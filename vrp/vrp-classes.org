#+TITLE: VRP solver environment
#+AUTHOR: Fernando Rodriguez Flores
#+AUTHOR: Yoel Medero Vargas
#+AUTHOR: Eduardo Núñez de Villavicencio Sánchez
#+DATE 2018-07-29
#+TODO: TODO BROKEN WIP | DONE


* TODO Description
  In this file we'll have all the classes involved in the VRP solving environment.


* Add the package to the file
  #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
  (in-package :vrp)
  #+END_SRC


* Very basic and abstract classes
** documentation
   In this section we'll add the classes that are so abstract that almost any class could inherit from them.
** has-id (abstract structural)
*** documentation
    A class with only an id
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class has-id ()
       ((id))
       :documentation "A basic class with only one id.")
    #+END_SRC
*** no tests because it is an abstract class

** has-name (abstract structural)
*** documentation
    A class with only a name
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class has-name ()
       ((name))
       :documentation "A basic class with only one name.")
    #+END_SRC
*** no tests because it is an abstract class

** has-coordinates (abstract structural)
*** documentation
    A class with geographical coordinates
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class has-coordinates ()
       ((x-coord) (y-coord))
       :documentation "A class that has geographic coordinates.")
    #+END_SRC
*** no tests because it is an abstract class
** has-cost (abstract structural)
*** documentation
    A class with a cost slot
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class has-cost ()
       ((cost))
       :documentation "A class with a cost.")
    #+END_SRC
*** no tests because it is an abstract class
** has-clients (abstract structural)
*** documentation
     A set of clients is something that has a set of clients.  For example, a =route= is a set of clients with a depot and a vehicle.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
  (def-vrp-class has-clients ()
    ((clients))
    :documentation "A set of clients.")
    #+END_SRC

  And now I have a question: should the modified clone be here or in the vehicles as it was originally conceived?  I believe that right now it should be in the clients.

  The problem is that now =basic-route= should inherit from this class.  But maybe there would be no problems because the clone constructor for the (/for the what?!/) does not use the clients.  And also there is another reason: the clients in the =basic-route= are created in an around method, that calls =call-next-method=, and that method is the one created automatically that does not clone the clients, so there should be no problem.

  In any case, let's test it using the macro =defset-of-clients=.
*** no tests because it is an abstract class
** has-vehicles (abstract structural)
*** documentation
     A class that inherits from this, will have a list of vehicles.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
  (def-vrp-class has-vehicles ()
    ((vehicles))
    :documentation "A class to represent things that have vehicles.")
    #+END_SRC

  And now I have a question: should the modified clone be here or in the vehicles as it was originally conceived?  I believe that right now it should be in the clients.

  The problem is that now =basic-route= should inherit from this class.  But maybe there would be no problems because the clone constructor for the (/for the what?!/) does not use the clients.  And also there is another reason: the clients in the =basic-route= are created in an around method, that calls =call-next-method=, and that method is the one created automatically that does not clone the clients, so there should be no problem.

  In any case, let's test it using the macro =defset-of-clients=.
*** no tests because it is an abstract class


* Classes that represent problem characteristics
** description
   In this section, I'll add classes that represent characteristics of the problems.
** has-infinite-fleet (functional, abstract)
   :PROPERTIES:
   :CUSTOM_ID: class:has-infinite-fleet
   :END:
*** documentation
    A class to represent that we have infinite-fleet. For instance, this is the type of solution we should use in the CVRP.

    Here we won't have any slots because this is a functional class.  It should provide some behavior in some methods.

    If after we apply some operations to a solution some routes are left without clients, this class makes sure that those empty-routes are removed from the solution.  That's one of the behaviors that this class adds.
    
*** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class has-infinite-fleet ()
       ()
       :documentation "Represents that we can have inifinitely many routes."
       ;; no constructor because it as an abstract class
       ;; no print-object because it as an abstract class
       ;; no obj= or clone because it as an abstract class
       )
     #+END_SRC
*** no tests because it is an abstract class
** has-one-depot (functional, abstract)
   :PROPERTIES:
   :CUSTOM_ID: class:has-one-depot
   :END:
*** documentation
    A class to represent that the route has one depot.  This is the "standard" case and most problems will inherit from here.  This is the class that has the slot =depot=.
*** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class has-one-depot ()
       ((depot))
       :documentation "Represents that routes have only one depot."
       ;; no constructor because it as an abstract class
       ;; no print-object because it as an abstract class
       ;; no obj= or clone because it as an abstract class
       )
     #+END_SRC
*** no tests because it is an abstract class
** has-multi-depots (functional, abstract)
   :PROPERTIES:
   :CUSTOM_ID: class:has-one-depot
   :END:
*** documentation
    A class to represent that the route has multiple depots.  This is the class that has the slot =depots=.
*** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class has-multi-depots ()
       ((depots))
       :documentation "Represents that routes have only one depot."
       ;; no constructor because it as an abstract class
       ;; no print-object because it as an abstract class
       ;; no obj= or clone because it as an abstract class
       )
     #+END_SRC
*** no tests because it is an abstract class
** has-an-end-depot (structural, functional, abstract)
   :PROPERTIES:
   :CUSTOM_ID: class:has-an-end-depot
   :END:
*** documentation
    A class to represent that the routes may have another depot where the vehicles should finish the route.  This class adds the slot =end-depot=.  It also inherits from has-one-depot, because it makes no sense to have an end depot and not a 'simple' depot.
*** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class has-an-end-depot (has-one-depot)
       ((end-depot))
       :documentation "Represents that routes have an end depot."
       ;; no constructor because it as an abstract class
       ;; no print-object because it as an abstract class
       ;; no obj= or clone because it as an abstract class
       )
     #+END_SRC
*** code to simulate the end-depot classes
**** description
     The idea is that when we call the method =end-depot= on a class that has only one depot, we can return the traditional depot.
**** generic function end-depot
     #+BEGIN_SRC lisp +n -r :results none :exports code
     (defgeneric end-depot (obj)
       (:documentation "Returns the end depot of the route."))
     #+END_SRC
     
**** method (has-one-depot)
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (defmethod end-depot ((obj has-one-depot))
       "If we ask a one-depot instance for it's end-depot, we just return 'the' ddepot."
       (depot obj))
     #+END_SRC
     
**** method (has-an-end-depot)
     #+BEGIN_SRC lisp +n -r :results none :exports code
     ;; (defmethod end-depot ((obj has-an-end-depot))
     ;;   "If we ask a one-depot instance for it's end-depot, we just return 'the' ddepot."
     ;;   (end-depot-slot obj))
     #+END_SRC
     
**** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (with-basic-clients (1 2 3)
      (let* ((d0 (basic-depot))
             (d1 (basic-depot 1))
             (obj1 (make-instance 'has-one-depot :depot d0))
             (obj2 (make-instance 'has-an-end-depot
                                  :depot d0
                                  :end-depot d1))
             )

        (bformat t "Testing end-depot...")


        (format t "Depot for obj1 (expect d0): ~a~%" (depot obj1))
        (format t "Depot for obj2 (expect d0): ~a~%" (depot obj2))
        (format t "End depot for obj1 (expect d0): ~a~%" (end-depot obj1))
        (format t "End depot for obj2 (expect d1): ~a~%" (end-depot obj2))))
    #+END_SRC


* Products
  In this section we'll add the classes related to the products.  This classes will be useful in problems where the clients demand more than one type of product.

** basic-product
*** documentation
    A basic client has an id and a name.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
 (def-vrp-class basic-product (has-id has-name)
   ()
   :documentation "A basic product with one id and a name."
   :constructor (basic-product (id name))
   :print-object-string ("<p~a: ~a>" id name)
   :slots-for-obj= (id name)
   :slots-for-clone (id name))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((c1 (basic-product 1 "oil"))
           (c2 (basic-product 2 "water"))
           (c3 (clone c1))
           (c4 (clone c2)))
      (bformat t "Testing basic-product...")

      (format t "Printing the objects:~%")
      (loop for e in (list c1 c2 c3 c4)
            doing (format t "   basic-product with id ~a: ~a~%"
                          (id e) e))

      (deftests "Testing obj="
        (check-t (obj= c1 c1))
        (check-t (obj= c2 c2))
        (check-t (obj= c1 c3))
        (check-t (obj= c2 c4))

        (check-nil (obj= c1 c2))
        (check-nil (obj= c2 c3))
        (check-nil (obj= c3 c4))))
    #+END_SRC


* Clients
   In this section we'll add the classes related to the clients.
** basic-client
*** documentation
    A basic client has only an id.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
 (def-vrp-class basic-client (has-id)
   ()
   :documentation "A basic client with only one id."
   :constructor (basic-client (id))
   :print-object-string ("<c:~a>" id)
   :slots-for-obj= (id)
   :slots-for-clone (id))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((c1 (basic-client 1))
           (c2 (basic-client 2))
           (c3 (clone c1))
           (c4 (clone c2)))
      (format t "~%=======================
    Testing basic-client...
    =======================~2%")

      (format t "Printing the objects:~%")
      (loop for e in (list c1 c2 c3 c4)
            doing (format t "   basic-client with id ~a: ~a~%"
                          (id e) e))

      (deftests "Testing obj="
        (check-t (obj= c1 c1))
        (check-t (obj= c2 c2))
        (check-t (obj= c1 c3))
        (check-t (obj= c2 c4))

        (check-nil (obj= c1 c2))
        (check-nil (obj= c2 c3))
        (check-nil (obj= c3 c4))))
    #+END_SRC
** demand-client (structural abstract)
*** documentation
    A client with a demand that should be satisfied.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class demand-client (basic-client)
      ((demand))
      :documentation "A client with a demand that must be satisfied.")
    #+END_SRC
*** no tests because it is an abstract class
** limited-client (structural abstract)
*** documentation
    TODO
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class limited-client (demand-client)
      ()
      :documentation "")
    #+END_SRC
*** no tests because it is an abstract class
** basic-cvrp-client (actual class)
*** documentation
    A client that can be used in the CVRP.  It has and id and a demand.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class basic-cvrp-client (demand-client)
      ()
      :documentation "A basic client for the CVRP with id and demand."
      :constructor (basic-cvrp-client (id demand))
      :print-object-string ("<c~a: ~a>" id demand)
      :slots-for-obj= (id demand)
      :slots-for-clone (id demand))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((c1 (basic-cvrp-client 1 10))
           (c2 (basic-cvrp-client 2 10))
           (c3 (basic-cvrp-client 1 20))
           (c4 (clone c1))
           (c5 (clone c2)))
      (format t "~%=======================
    Testing basic-cvrp-client...
    =======================~2%")

      (format t "Printing the objects:~%")
      (loop for e in (list c1 c2 c3 c4 c5)
            doing (format t "   basic-cvrp-client with id ~a: ~a~%"
                          (id e) e))

      (deftests "Testing obj="
        (check-t (obj= c1 c1))
        (check-t (obj= c1 c4))
        (check-t (obj= c2 c5))

        (check-nil (obj= c1 c2))
        (check-nil (obj= c1 c3))
        (check-nil (obj= c2 c4))
        (check-nil (obj= c3 c5))))
    #+END_SRC

    #+RESULTS:
    #+begin_example

    =======================
    Testing basic-cvrp-client...
    =======================

    Printing the objects:
       basic-cvrp-client with id 1: <c1: 10>
       basic-cvrp-client with id 2: <c2: 10>
       basic-cvrp-client with id 1: <c1: 20>
       basic-cvrp-client with id 1: <c1: 10>
       basic-cvrp-client with id 2: <c2: 10>

    Testing obj=:
       pass ... Check T:          (OBJ= C1 C1)
       pass ... Check T:          (OBJ= C1 C4)
       pass ... Check T:          (OBJ= C2 C5)
       pass ... Check NIL:        (OBJ= C1 C2)
       pass ... Check NIL:        (OBJ= C1 C3)
       pass ... Check NIL:        (OBJ= C2 C4)
       pass ... Check NIL:        (OBJ= C3 C5)
    #+end_example

    
** size-limited-cvrp-client (actual class)
*** documentation
    TODO
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class size-limited-cvrp-client (limited-client)
      ()
      :documentation "A size-limited client for the CVRP with id and demand and route-limit."
      :constructor (size-limited-cvrp-client (id demand))
      :print-object-string ("<c~a: ~a>" id demand)
      :slots-for-obj= (id demand)
      :slots-for-clone (id demand))
    #+END_SRC

** multi-product-demand-client (structural abstract)
*** documentation
    A client that demands several products. It has a list of demanded products and the demand for each of them.
*** class definition code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class multi-product-demand-client ()
      ((products
        :initform nil
        :documentation "A list with all the demanded products.")
       (products-demand :initform (make-hash-table)
        :documentation "A hash table with each product demand. In this implementation, the keys are the id of the products." ))
      :documentation "A client with a demand for several products.")
    #+END_SRC
*** no tests because it is an abstract class
** basic-cupet-client (actual class)
*** documentation
    A client that has id, and a demand of several products.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class basic-cupet-client (basic-client
                                       multi-product-demand-client)
      ()
      :documentation "A basic client for the CUPET problem."
      :constructor (basic-cupet-client (id &optional (products nil)))
      :print-object-string ("<cupet c~a>" id )
      :slots-for-obj= (id products products-demand)
      :slots-for-clone (id products products-demand))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((c1 (basic-cupet-client 1))
           (c2 (basic-cupet-client 2))
           (c3 (clone c1))
           (c4 (clone c2)))
      (format t "Testing basic-cvrp-client...")


      (deftests "Testing obj="
        (check-t (obj= c1 c1))
        (check-t (obj= c2 c2))
        (check-t (obj= c1 c3))
        (check-t (obj= c2 c4))

        (check-nil (obj= c1 c2))
        (check-nil (obj= c2 c3))
        (check-nil (obj= c3 c4)))
      ;; (format t "Printing the objects:~%")
      ;; (loop for e in (list c1 c2 c3 c4 )
      ;;       doing (format t "   basic-cupet-client with id ~a: ~a~%"
      ;;                     (id e) e))
      )
    #+END_SRC

    #+RESULTS:
    : Testing basic-cvrp-client...
    : Testing obj=:
    :    FAIL ... Check T:          (OBJ= C1 C1)
    :    FAIL ... Check T:          (OBJ= C2 C2)
    :    FAIL ... Check T:          (OBJ= C1 C3)
    :    FAIL ... Check T:          (OBJ= C2 C4)
    :    pass ... Check NIL:        (OBJ= C1 C2)
    :    pass ... Check NIL:        (OBJ= C2 C3)
    :    pass ... Check NIL:        (OBJ= C3 C4)


* Vehicles
   In this section we'll add the classes related to the vehicles.
** basic-vehicle
*** documentation
    A basic vehicle has only an id.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
 (def-vrp-class basic-vehicle (has-id)
   ()
   :documentation "A basic vehicle with only one id."
   :constructor (basic-vehicle (id))
   :print-object-string ("<v:~a>" id)
   :slots-for-obj= (id)
   :slots-for-clone (id))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((c1 (basic-vehicle 1))
           (c2 (basic-vehicle 2))
           (c3 (clone c1))
           (c4 (clone c2)))
      (format t "~%=======================
    Testing basic-vehicle...
    =======================~2%")

      (format t "Printing the objects:~%")
      (loop for e in (list c1 c2 c3 c4)
            doing (format t "   basic-vehicle with id ~a: ~a~%"
                          (id e) e))

      (deftests "Testing obj="
        (check-t (obj= c1 c1))
        (check-t (obj= c2 c2))
        (check-t (obj= c1 c3))
        (check-t (obj= c2 c4))

        (check-nil (obj= c1 c2))
        (check-nil (obj= c2 c3))
        (check-nil (obj= c3 c4))))
    #+END_SRC
** cargo-vehicle (structural abstract)
*** documentation
    This is a vehicle with a cargo.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
   (def-vrp-class cargo-vehicle ()
      ((cargo))
      :documentation "A vehicle with a current cargo slot.")
   #+END_SRC
*** no tests because it is an abstract class
** capacity-vehicle (structural abstract)
*** documentation
    This is a vehicle with a maximum capacity.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
   (def-vrp-class capacity-vehicle ()
      ((capacity))
      :documentation "A vehicle with a max capacity.")
   #+END_SRC
*** no tests because it is an abstract class
** multi-product-vehicle (structural abstract)
*** documentation
    This is a vehicle that can carry several products.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
   (def-vrp-class multi-product-vehicle ()
      ((products
        :documentation "The products that the vehicle can carry."))
      :documentation "A vehicle that can carry several products.")
   #+END_SRC
*** no tests because it is an abstract class
** multi-compartment-vehicle (structural abstract)
*** documentation
    This is a vehicle with several compartments, each with a maximum capacity.  This means that we can ask for (capacity compartment vehicle)
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
   (def-vrp-class multi-compartment-vehicle ()
      ((number-of-compartments
        :documentation "The number of compartments in the vehicle.")
       (compartments-capacity
        :initform (make-hash-table)
        :documentation "A hash table with the capacity of each compartment."))
      :documentation "A vehicle with several compartments.")
   #+END_SRC
*** no tests because it is an abstract class
** clients-constrained-vehicle (structural abstract)
*** documentation
    This is a vehicle that cannot visit all the clients, only a subset of them.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
   (def-vrp-class clients-constrained-vehicle ()
      ((compatible-clients
        :documentation "A list with the compatible clients."))
      :documentation "A vehicle that can only visit some of the clients.")
   #+END_SRC
*** no tests because it is an abstract class


** unload-vehicle (functional abstract)
*** documentation
    This is the standard vehicle that arrives at a client and download its cargo.  This is a "functional class", meaning it doesn't have any slots.

    This class provides the =unload= operation when it visits a client.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
   (def-vrp-class unload-vehicle ()
      ()
      :documentation "A vehicle with an unload operation.")
   #+END_SRC
*** no tests because it is an abstract class
** unconditionally-unload-vehicle (functional abstract)
*** documentation
    This is the standard vehicle, that arrives at a client and download its cargo.  This is a "functional class", meaning it doesn't have any slots.  It doesn't inherit from "basic-vehicle" either.

    This class provides the =unconditionally-unload= operation.  When an instance of this class unloads in a demand-client, it unconditionally unloads all the client's demand.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
   (def-vrp-class unconditionally-unload-vehicle ()
      ()
      :documentation "A vehicle that always unloads all the client's demand.")
   #+END_SRC
*** no tests because it is an abstract class
** cvrp-vehicle (actual class)
*** documentation
    These are the vehicles used in the CVRP.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class cvrp-vehicle (basic-vehicle
                                 cargo-vehicle
                                 unconditionally-unload-vehicle
                                 unload-vehicle
                                 capacity-vehicle)
       ()
       :documentation "A vehicle for the CVRP."
       :constructor (cvrp-vehicle (id capacity &optional (cargo 0)))
       :print-object-string ("<cv:~a. ~a/~a>" id cargo capacity)
       :slots-for-obj= (id capacity cargo)
       :slots-for-clone (id capacity cargo))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((v1 (cvrp-vehicle 1 20))
           (v2 (cvrp-vehicle 1 30))
           (v3 (cvrp-vehicle 1 20 5))
           (v4 (cvrp-vehicle 2 20))
           (v6 (clone v1))
           (v7 (clone v2)))
      (format t "~%=======================
    Testing cvrp-vehicle...
    =======================~2%")

      (format t "Printing the objects:~%")
      (loop for e in (list v1 v2 v3 v4 v6 v7)
            doing (format t "   cvrp-vehicle with id ~a: ~a~%"
                          (id e) e))

      (deftests "Testing obj="
        (check-t (obj= v1 v1))
        (check-t (obj= v1 v6))
        (check-t (obj= v2 v7))

        (check-nil (obj= v1 v2))
        (check-nil (obj= v1 v3))
        (check-nil (obj= v1 v4))
        (check-nil (obj= v1 v2))
        (check-nil (obj= v1 v7))
        (check-nil (obj= v2 v6))))
    #+END_SRC
** basic-cupet-vehicle (actual class)
*** documentation
    These are vehicles with id, constrained by clients, and with multiple compartments.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class basic-cupet-vehicle (basic-vehicle
                                        multi-compartment-vehicle
                                        multi-product-vehicle
                                        clients-constrained-vehicle)
       ()
       :documentation "A basic vehicle for CUPET's problem."
       :constructor (basic-cupet-vehicle (id
                                          number-of-compartments
                                          &key
                                          (products nil)
                                          (compatible-clients nil)
                                          ))
       :print-object-string ("<cupet_v~a: ~a>"
                             id
                             number-of-compartments)
       :slots-for-obj= (id
                        number-of-compartments
                        compatible-clients
                        products
                        compartments-capacity)
       :slots-for-clone (id
                        number-of-compartments
                        compatible-clients
                        products
                        compartments-capacity))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((v1 (cvrp-vehicle 1 20))
           (v2 (cvrp-vehicle 1 30))
           (v3 (cvrp-vehicle 1 20 5))
           (v4 (cvrp-vehicle 2 20))
           (v6 (clone v1))
           (v7 (clone v2)))
      (format t "~%=======================
    Testing cvrp-vehicle...
    =======================~2%")

      (format t "Printing the objects:~%")
      (loop for e in (list v1 v2 v3 v4 v6 v7)
            doing (format t "   cvrp-vehicle with id ~a: ~a~%"
                          (id e) e))

      (deftests "Testing obj="
        (check-t (obj= v1 v1))
        (check-t (obj= v1 v6))
        (check-t (obj= v2 v7))

        (check-nil (obj= v1 v2))
        (check-nil (obj= v1 v3))
        (check-nil (obj= v1 v4))
        (check-nil (obj= v1 v2))
        (check-nil (obj= v1 v7))
        (check-nil (obj= v2 v6))))
    #+END_SRC


* Depots
  In this section we'll add all the classes related to the depots
** basic-depot
*** documentation
    A basic depot has only an id and it defaults to 0.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class basic-depot (has-id)
      ((id :initform 0))
      :documentation "A basic depot with only one id."
      :constructor (basic-depot (&optional (id 0)))
      :print-object-string ("<d:~a>" id)
      :slots-for-obj= (id)
      :slots-for-clone (id))
     #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((c0 (basic-depot))
           (c1 (basic-depot 1))
           (c2 (basic-depot 2))
           (c3 (clone c0))
           (c4 (clone c1))
           (c5 (clone c2)))
      (format t "~%======================
    Testing basic-depot...
    ======================~2%")

      (format t "Printing the objects:~%")
      (loop for e in (list c0 c1 c2 c3 c4 c5)
            doing (format t "   basic-depot with id ~a: ~a~%"
                          (id e) e))

      (deftests "Testing obj="
        (check-t (obj= c0 c0))
        (check-t (obj= c1 c1))
        (check-t (obj= c2 c2))
        (check-t (obj= c1 c4))
        (check-t (obj= c2 c5))
        (check-t (obj= c3 c0))

        (check-nil (obj= c1 c2))
        (check-nil (obj= c2 c3))
        (check-nil (obj= c3 c4))
        (check-nil (obj= c0 c1))))
    #+END_SRC
** g-depot (depot with geographic coordinates)
*** documentation
    This is a basic depot with coordinates
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class geographic-depot (basic-depot has-coordinates)
      ()
      :documentation "A basic depot with coordinates."
      :constructor (g-depot (id x-coord y-coord))
      :print-object-string ("<gd:~a>" id)
      :slots-for-obj= (id x-coord y-coord)
      :slots-for-clone (id x-coord y-coord))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((c1 (g-depot 1 10 10))
           (c2 (g-depot 2 0 0))
           (c3 (g-depot 3 0 0))
           (c4 (clone c1))
           (c5 (clone c2))
           (c6 (clone c3)))
      (format t "~%======================
    Testing g-depot...
    ======================~2%")

      (format t "Printing the objects:~%")
      (loop for e in (list c1 c2 c3 c4 c5 c6)
            doing (format t "   g-depot with id ~a and coords (~a ~a): ~a~%"
                          (id e) (x-coord e) (y-coord e) e))

      (deftests "Testing obj="
        (check-t (obj= c1 c1))
        (check-t (obj= c2 c2))
        (check-t (obj= c1 c4))
        (check-t (obj= c2 c5))
        (check-t (obj= c3 c6))

        (check-nil (obj= c1 c2))
        (check-nil (obj= c1 c3))
        (check-nil (obj= c2 c3))
        (check-nil (obj= c6 c1))))
    #+END_SRC


* Routes
  In this section we define the routes.
** basic-route
*** documentation
    A basic route.  It has a set-of-clients, a vehicle and a depot.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class basic-route (has-id
                                has-clients
                                has-one-depot)
      ((vehicle))
      :documentation "A basic route with clients, vehicle and one depot."
      :constructor (basic-route (&key id vehicle depot clients))
      :print-object-string ("<r~a: ~a (~a: ~a)>"
                            id vehicle depot clients)
      :slots-for-obj= (id vehicle depot clients)
      :slots-for-clone (id vehicle depot clients))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (with-basic-clients (1 2 3 4 5 6)
      (let* ((v1 (basic-vehicle 1))
             (v2 (basic-vehicle 2))
             (d0 (basic-depot))
             (d1 (basic-depot 1))
             (r1 (basic-route :id 1 :vehicle v1 :depot d0
                              :clients (list c1 c2 c3)))
             (r2 (basic-route :id 2 :vehicle v2 :depot d0
                              :clients (list c4 c5 c6)))
             (r3 (basic-route :id 1 :vehicle v2 :depot d0
                              :clients (list c1 c2 c3)))
             (r4 (basic-route :id 1 :vehicle v1 :depot d1
                              :clients (list c1 c2 c3)))
             (r5 (basic-route :id 2 :vehicle v1 :depot d0
                              :clients (list c1 c2 c3)))
             (r6 (clone r1)))

        (bformat t "Testing basic-route")

        (format t "Printing the objects:~%")
        (loop for e in (list r1 r2 r3 r4 r5 r6)
              doing (format t "   basic-route with id ~a: ~a~%"
                            (id e) e))

        (deftests "Testing obj="
          (check-t (obj= r1 r1))
          (check-t (obj= r1 r6))

          (check-nil (obj= r1 r2))
          (check-nil (obj= r1 r2))
          (check-nil (obj= r1 r3))
          (check-nil (obj= r1 r4))
          (check-nil (obj= r2 r5)))))
    #+END_SRC
** route-for-simulation (structural class)
*** documentation
    This is a very simple route that has a =previous-client= slot.  This probably should be the base class for any route that implements the simulation.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class route-for-simulation (basic-route)
      ((previous-client))
      :documentation "A route with a previous-client slot.  Good for simulations."
      :constructor (route-for-simulation (&key id vehicle depot clients (previous-client nil)))
      :slots-for-obj= (id vehicle depot clients previous-client)
      :slots-for-clone (id vehicle depot clients previous-client))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (with-basic-clients (1 2 3 4 5 6)
      (let* ((v1 (basic-vehicle 1))
             (v2 (basic-vehicle 2))
             (d0 (basic-depot))
             (d1 (basic-depot 1))
             (r1 (route-for-simulation :id 1 :vehicle v1 :depot d0
                              :clients (list c1 c2 c3)))
             (r2 (route-for-simulation :id 2 :vehicle v2 :depot d0
                              :clients (list c4 c5 c6)))
             (r3 (route-for-simulation :id 1 :vehicle v2 :depot d0
                              :clients (list c1 c2 c3)))
             (r4 (route-for-simulation :id 1 :vehicle v1 :depot d1
                              :clients (list c1 c2 c3)))
             (r5 (route-for-simulation :id 2 :vehicle v1 :depot d0
                              :clients (list c1 c2 c3)))
             (r6 (clone r1)))

        (format t "~%===============================
    Testing route-for-simulation...
    ===============================~2%")

        (format t "Printing the objects:~%")
        (loop for e in (list r1 r2 r3 r4 r5 r6)
              doing (format t "   route-for-simulation with id ~a: ~a~%"
                            (id e) e))

        (deftests "Testing obj="
          (check-t (obj= r1 r1))
          (check-t (obj= r1 r6))

          (check-nil (obj= r1 r2))
          (check-nil (obj= r1 r2))
          (check-nil (obj= r1 r3))
          (check-nil (obj= r1 r4))
          (check-nil (obj= r2 r5)))))
    #+END_SRC
** route-for-simulation-with-end-depot (structural class)
*** documentation
    This is a simulation route that also has an end-depot.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class route-for-simulation-with-end-depot
        (route-for-simulation
         has-an-end-depot)
      ()
      :documentation "A route for simulation with an end-depot."
      :constructor (route-for-simulation-with-end-depot
                    (&key id vehicle depot end-depot clients))
      :print-object-string ("<r~a: ~a (~a: ~a) ~a>"
                            id vehicle depot clients end-depot)
      :slots-for-obj= (id vehicle depot end-depot clients previous-client)
      :slots-for-clone (id vehicle depot end-depot clients previous-client))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (with-basic-clients (1 2 3 4 5 6)
      (let* ((v1 (basic-vehicle 1))
             (v2 (basic-vehicle 2))
             (d0 (basic-depot))
             (d1 (basic-depot 7))
             (r1 (route-for-simulation-with-end-depot
                  :id 1
                  :vehicle v1
                  :depot d0
                  :end-depot d1
                  :clients (list c1 c2 c3)))
             (r2 (route-for-simulation-with-end-depot
                  :id 2
                  :vehicle v2
                  :depot d0
                  :end-depot d1
                  :clients (list c4 c5 c6)))
             (r3 (route-for-simulation-with-end-depot
                  :id 1
                  :vehicle v2
                  :depot d0
                  :end-depot d1
                  :clients (list c1 c2 c3)))
             (r4 (route-for-simulation-with-end-depot
                  :id 1
                  :vehicle v1
                  :depot d1
                  :end-depot d1
                  :clients (list c1 c2 c3)))
             (r5 (route-for-simulation-with-end-depot
                  :id 2
                  :vehicle v1
                  :depot d0
                  :end-depot d1
                  :clients (list c1 c2 c3)))
             (r6 (clone r1)))

        (bformat t "Testing route-for-simulation-with-end-depot...")

        (format t "Printing the objects:~%")
        (loop for e in (list r1 r2 r3 r4 r5 r6)
              doing (format t "   route-for-simulation with id ~a: ~a~%"
                            (id e) e))

        (deftests "Testing obj="
          (check-t (obj= r1 r1))
          (check-t (obj= r1 r6))

          (check-nil (obj= r1 r2))
          (check-nil (obj= r1 r2))
          (check-nil (obj= r1 r3))
          (check-nil (obj= r1 r4))
          (check-nil (obj= r2 r5)))

        (format t "end-depot of r1 (expect d7): ~a~%" (end-depot r1))
        (format t "depot of r1 (expect d0): ~a~%" (depot r1))))


    #+END_SRC


* Solutions
  In this section we add the classes for the solutions.

** basic-solution
*** documentation
    A basic solution.  It has a set of routes.
*** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class basic-solution (has-id
                                    has-cost)
       ((routes))
       :documentation "A basic solution with a cost and a set of routes."
       :constructor (basic-solution (&key id routes (cost 0)))
       :print-object-string ("S~a: (~a)~%routes:~%~{  ~a~%~}" id cost routes)
       :slots-for-obj= (id routes cost)
       :slots-for-clone (id routes cost))
     #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (with-basic-clients (1 2 3 4 5 6)
      (let* ((v1 (basic-vehicle 1))
             (v2 (basic-vehicle 2))
             (d0 (basic-depot))
             (r1 (basic-route :id 1 :vehicle v1 :depot d0
                              :clients (list c1 c2 c3)))
             (r2 (basic-route :id 2 :vehicle v2 :depot d0
                              :clients (list c4 c5 c6)))
             (s1 (basic-solution :id 1 :routes (list r1 r2)))
             (s2 (basic-solution :id 2 :routes (list r1 r2)))
             (s3 (basic-solution :id 1 :routes (list r2 r1)))
             (s4 (clone s1))
             (s5 (basic-solution :id 1 :routes (list r1 r2) :cost 1)))

        (bformat t "Testing basic-solution")

        (format t "Printing the objects:~%")
        (loop for e in (list s1 s2 s3 s4)
              doing (format t "   basic-solution with id ~a:~% ~a~%"
                            (id e) e))

        (deftests "Testing obj="
          (check-t (obj= s1 s1))
          (check-t (obj= s1 s4))

          (check-nil (obj= s1 s2))
          (check-nil (obj= s1 s3))
          (check-nil (obj= s1 s5))
          (check-nil (obj= s2 s3))
          (check-nil (obj= s2 s4)))))
    #+END_SRC
** basic-cvrp-solution (actual-class)
   :PROPERTIES:
   :CUSTOM_ID: class:basic-cvrp-solution
   :END:
*** documentation
    A basic solution where we can have as many routes as we want.  This is the type of solution we should use in the CVRP.

*** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class basic-cvrp-solution
         (basic-solution
          has-infinite-fleet)
       ()
       :documentation "The solution we should use in the CVRP."
       :constructor (basic-cvrp-solution (&key id routes (cost 0)))
       :print-object-string ("CVRP_S~a: (~a)~%~{  ~a~%~}" id cost routes)
       :slots-for-obj= (id routes cost)
       :slots-for-clone (id routes cost)
       )
     #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (with-basic-clients (1 2 3 4 5 6)
      (let* ((v1 (basic-vehicle 1))
             (v2 (basic-vehicle 2))
             (d0 (basic-depot))
             (r1 (basic-route :id 1 :vehicle v1 :depot d0
                              :clients (list c1 c2 c3)))
             (r2 (basic-route :id 2 :vehicle v2 :depot d0
                              :clients (list c4 c5 c6)))
             (s1 (basic-cvrp-solution :id 1 :routes (list r1 r2)))
             (s2 (basic-cvrp-solution :id 2 :routes (list r1 r2)))
             (s3 (basic-cvrp-solution :id 1 :routes (list r2 r1)))
             (s4 (clone s1))
             (s5 (basic-cvrp-solution :id 1 :routes (list r1 r2) :cost 1))
             (s6 (basic-solution :id 1 :routes (list r1 r2) :cost 1)))

        (bformat t "Testing basic-solution")

        (format t "Printing the objects:~%")
        (loop for e in (list s1 s2 s3 s4)
              doing (format t "   basic-solution with id ~a:~% ~a~%"
                            (id e) e))

        (deftests "Testing obj="
          (check-t (obj= s1 s1))
          (check-t (obj= s1 s4))

          (check-nil (obj= s1 s2))
          (check-nil (obj= s1 s3))
          (check-nil (obj= s1 s5))
          (check-nil (obj= s2 s3))
          (check-nil (obj= s2 s4))
          (check-nil (obj= s5 s6)))))
    #+END_SRC


* Problems
  In this section we'll add the classes for the problems.
** basic-problem
*** description
    A basic-problem is a class that has a set of clients and a depot.
*** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class basic-problem (has-id
                                   has-clients
                                   has-one-depot)
       ()
       :documentation "A basic problem with clients and a depot."
       :constructor (basic-problem (&key id clients depot))
       :print-object-string ("<P~a.~a, ~a>" id clients depot)
       :slots-for-obj= (id clients depot)
       :slots-for-clone (id clients depot))
     #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (with-basic-clients (1 2 3 4 5 6)
      (let* ((d0 (basic-depot))
             (d1 (basic-depot 1))
             (p1 (basic-problem :id 1 :depot d0
                                :clients (list c1 c2 c3 c4 c5 c6)))
             (p2 (basic-problem :id 2 :depot d0
                                :clients (list c1 c2 c3 c4 c5 c6)))
             (p3 (basic-problem :id 1 :depot d1
                                :clients (list c1 c2 c3 c4 c5 c6)))
             (p4 (basic-problem :id 1 :depot d1
                                :clients (list c1 c2 c3 c4 c5)))
             (p5 (clone p1)))

        (bformat t "Testing basic-problem...")

        (format t "Printing the objects:~%")
        (loop for e in (list p1 p2 p3 p4 p5)
              doing (format t "   basic-problem with id ~a:~% ~a~%"
                            (id e) e))

        (deftests "Testing obj="
          (check-t (obj= p1 p1))
          (check-t (obj= p1 p5))

          (check-nil (obj= p1 p2))
          (check-nil (obj= p1 p3))
          (check-nil (obj= p2 p4))
          (check-nil (obj= p2 p4)))))
    #+END_SRC
** distance-problem (structural abstract)
*** documentation
    This is a problem with a matrix distance.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class distance-problem ()
      ((distance-matrix))
      :documentation "A problem with a distance matrix.")
    #+END_SRC
*** no tests because it is an abstract class
** capacity-problem (structural abstract)
*** documentation
    This is a problem where all the vehicles in the routes have a maximum capacity, and all the vehicles are equal (they all have the same capacity).
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class capacity-problem ()
      ;; the slots
      ((capacity))
      :documentation "A problem with a capacity for all the vehicles.")
    #+END_SRC
*** no tests because it is an abstract class

** finite-fleet-problem (structural abstract)
*** documentation
    This is a problem where there is a finite set of vehicles.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class finite-fleet-problem ()
      ;; the slots
      ((fleet))
      :documentation "A problem with a finite fleet of vehicles.")
    #+END_SRC
*** no tests because it is an abstract class
** several-products-problem (structural abstract)
*** documentation
    This is a problem with several products that should be delivered to the clients.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class several-products-problem ()
      ;; the slots
      ((products))
      :documentation "A problem with several products that should be delivered to the clients.")
    #+END_SRC
*** no tests because it is an abstract class
** cupet-problem
*** documentation
    This is a distance-problem with several products that should be delivered to the clients.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class cupet-problem (basic-problem
                                  distance-problem
                                  several-products-problem
                                  has-vehicles)
      ()
      :documentation "A distance-problem with several products to be delivered to the clients."
      :constructor (cupet-problem (&key id clients depot distance-matrix products vehicles))
      :slots-for-obj= (id clients depot distance-matrix products vehicles)
      :slots-for-clone (id clients depot distance-matrix products vehicles))

     (defmethod print-object ((obj cupet-problem) stream)
       (format stream "<CUPET_problem ~a: ~a clients, ~a products, ~a vehicles>"
               (id obj)
               (length (clients obj))
               (length (products obj))
               (length (vehicles obj))))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (with-basic-clients (1 2 3)
      (let* ((d0 (basic-depot))
             (d1 (basic-depot 1))
             (c1 (basic-client 1))
             (c2 (basic-client 2))
             (c3 (basic-client 3))
             (p1 (basic-product 1 "p1"))
             (p2 (basic-product 2 "p2"))
             (p3 (basic-product 3 "p3"))
             (pr1 (cupet-problem :id 1 :depot d0
                                 :clients (list c1 c2 c3)
                                 :products (list p1 p2)
                                 :distance-matrix #2A((0 1 2 3)
                                                      (1 0 4 6)
                                                      (2 4 0 2)
                                                      (3 6 2 0))))
             (pr2 (cupet-problem :id 2 :depot d0
                                 :clients (list c1 c2 c3)
                                 :products (list p1 p2 p3)
                                 :distance-matrix #2A((0 1 2 3)
                                                      (1 0 4 6)
                                                      (2 4 0 2)
                                                      (3 6 2 0))))

             (pr3 (clone pr1)))

        (bformat t "Testing")

        (format t "Printing the objects:~%")
        (loop for e in (list pr1 pr2 pr3)
              doing (format t "   cupet-problem with id ~a:~%      ~a~%"
                            (id e) e))

        (deftests "Testing obj="
          (check-t (obj= pr1 pr1))
          (check-t (obj= pr1 pr3))

          (check-nil (obj= pr1 pr2))
          (check-nil (obj= pr2 pr3)))))
    #+END_SRC
** cvrp-problem
*** documentation
    This is a distance-problem with a number indicating the maximum capacity of the vehicles.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class cvrp-problem (basic-problem
                                 distance-problem
                                 capacity-problem)
      ()
      :documentation "A distance-problem with a capacity for all the vehicles."
      :constructor (cvrp-problem (&key id clients depot distance-matrix capacity))
      :slots-for-obj= (id clients depot distance-matrix capacity)
      :slots-for-clone (id clients depot distance-matrix capacity))

     (defmethod print-object ((obj cvrp-problem) stream)
       (format stream "<CVRP ~a: ~a clients, capacity ~a>"
               (id obj)
               (length (clients obj))
               (capacity obj)))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (with-basic-clients (1 2 3)
      (let* ((d0 (basic-depot))
             (d1 (basic-depot 1))
             (p1 (cvrp-problem :id 1 :depot d0
                               :clients (list c1 c2 c3)
                               :capacity 40
                               :distance-matrix #2A((0 1 2 3)
                                                    (1 0 4 6)
                                                    (2 4 0 2)
                                                    (3 6 2 0))))
             (p2 (cvrp-problem :id 2 :depot d0
                               :clients (list c1 c2 c3)
                               :capacity 40
                               :distance-matrix #2A((0 1 2 3)
                                                    (1 0 4 6)
                                                    (2 4 0 2)
                                                    (3 6 2 0))))
             (p3 (cvrp-problem :id 1 :depot d0
                               :clients (list c1 c3 c2)
                               :capacity 40
                               :distance-matrix #2A((0 1 2 3)
                                                    (1 0 4 6)
                                                    (2 4 0 2)
                                                    (3 6 2 0))))
             (p4 (cvrp-problem :id 1 :depot d0
                               :clients (list c1 c2 c3)
                               :capacity 10
                               :distance-matrix #2A((0 1 2 3)
                                                    (1 0 4 6)
                                                    (2 4 0 2)
                                                    (3 6 2 0))))
             (p5 (cvrp-problem :id 1 :depot d0
                               :clients (list c1 c2 c3)
                               :capacity 10
                               :distance-matrix #2A((0 1 2 3)
                                                    (1 0 4 6)
                                                    (2 4 0 2)
                                                    (3 6 2 8))))
             (p6 (clone p1)))

        (format t "~%=======================
        Testing cvrp-problem...
        =======================~2%")

        (format t "Printing the objects:~%")
        (loop for e in (list p1 p2 p3 p4 p5 p6)
              doing (format t "   cvrp-problem with id ~a:~% ~a~%"
                            (id e) e))

        (deftests "Testing obj="
          (check-t (obj= p1 p1))
          (check-t (obj= p1 p6))

          (check-nil (obj= p1 p2))
          (check-nil (obj= p1 p3))
          (check-nil (obj= p1 p4))
          (check-nil (obj= p1 p5)))))
    #+END_SRC
** finite-fleet-cvrp-problem
*** documentation
    This is a distance-problem with a finite fleet.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class finite-fleet-cvrp-problem
        ;; inherits from
        (basic-problem
         distance-problem
         finite-fleet-problem)
      ()
      :documentation "A distance-problem with a finite fleet of vehicles."
      :constructor (finite-fleet-cvrp-problem (&key id clients depot distance-matrix fleet))
      :slots-for-obj= (id clients depot distance-matrix fleet)
      :slots-for-clone (id clients depot distance-matrix fleet))

     (defmethod print-object ((obj finite-fleet-cvrp-problem) stream)
       (format stream "<FFCVRP ~a: ~a clients, fleet ~a>"
               (id obj)
               (length (clients obj))
               (fleet obj)))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (with-basic-clients (1 2 3)
      (let* ((d0 (basic-depot))
             (v1 (cvrp-vehicle 1 10))
             (v2 (cvrp-vehicle 2 20))
             (v3 (cvrp-vehicle 3 30))
             (v4 (cvrp-vehicle 4 40))
             (p1 (finite-fleet-cvrp-problem :id 1 :depot d0
                               :clients (list c1 c2 c3)
                               :distance-matrix #2A((0 1 2 3)
                                                    (1 0 4 6)
                                                    (2 4 0 2)
                                                    (3 6 2 0))
                               :fleet (list v1 v2 v3 v4)))
             (p2 (finite-fleet-cvrp-problem :id 2 :depot d0
                               :clients (list c1 c2 c3)
                               :distance-matrix #2A((0 1 2 3)
                                                    (1 0 4 6)
                                                    (2 4 0 2)
                                                    (3 6 2 0))
                               :fleet (list v1 v2 v3 v4)))
             (p3 (finite-fleet-cvrp-problem :id 1 :depot d0
                               :clients (list c1 c3 c2)
                               :distance-matrix #2A((0 1 2 3)
                                                    (1 0 4 6)
                                                    (2 4 0 2)
                                                    (3 6 2 0))
                               :fleet (list v1 v2 v3 v4)))
             (p4 (finite-fleet-cvrp-problem :id 1 :depot d0
                               :clients (list c1 c2 c3)
                               :distance-matrix #2A((0 1 2 3)
                                                    (1 0 4 6)
                                                    (2 4 0 2)
                                                    (3 6 2 0))
                               :fleet (list v1 v2 v3)))
             (p5 (finite-fleet-cvrp-problem :id 1 :depot d0
                               :clients (list c1 c2 c3)
                               :distance-matrix #2A((0 1 2 3)
                                                    (1 0 4 6)
                                                    (2 4 0 2)
                                                    (3 6 2 8))
                               :fleet (list v1 v2 v3 v4)))

             (p6 (clone p1)))

        (bformat t "Testing finite-fleet-cvrp-problem...")

        (format t "Printing the objects:~%")
        (loop for e in (list p1 p2 p3 p4 p5 p6)
              doing (format t "   finite-fleet-cvrp-problem with id ~a:~% ~a~%"
                            (id e) e))

        (deftests "Testing obj="
          (check-t (obj= p1 p1))
          (check-t (obj= p1 p6))

          (check-nil (obj= p1 p2))
          (check-nil (obj= p1 p3))
          (check-nil (obj= p1 p4))
          (check-nil (obj= p1 p5)))))
    #+END_SRC
** finite-fleet-end-depot-cvrp-problem
*** documentation
    This is a distance-problem with a finite fleet and an end depot for each route.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class finite-fleet-end-depot-cvrp-problem
        ;; inherits from
        (basic-problem
         distance-problem
         finite-fleet-problem
         has-an-end-depot)
      ()
      :documentation "A distance-problem with a finite fleet of vehicles and an end depot."
      :constructor (finite-fleet-end-depot-cvrp-problem
                    (&key id clients depot end-depot distance-matrix fleet))
      :slots-for-obj= (id clients depot end-depot distance-matrix fleet)
      :slots-for-clone (id clients depot end-depot distance-matrix fleet))

    (defmethod print-object ((obj finite-fleet-end-depot-cvrp-problem) stream)
       (format stream "<FFCVRP2D ~a: ~a clients, fleet ~a, depots ~a, ~a>"
               (id obj)
               (length (clients obj))
               (fleet obj)
               (depot obj)
               (end-depot obj)))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (with-basic-clients (1 2 3)
      (let* ((d0 (basic-depot))
             (d1 (basic-depot 5))
             (v1 (cvrp-vehicle 1 10))
             (v2 (cvrp-vehicle 2 20))
             (v3 (cvrp-vehicle 3 30))
             (v4 (cvrp-vehicle 4 40))
             (p1 (finite-fleet-end-depot-cvrp-problem
                  :id 1
                  :depot d0
                  :end-depot d1
                  :clients (list c1 c2 c3)
                  :distance-matrix #2A((0 1 2 3 4)
                                       (1 0 4 6 1)
                                       (2 4 0 2 3)
                                       (3 6 2 0 2)
                                       (8 2 1 4 0))
                  :fleet (list v1 v2 v3 v4)))
             (p2 (finite-fleet-end-depot-cvrp-problem
                  :id 2
                  :depot d0
                  :end-depot d1
                  :clients (list c1 c2 c3)
                  :distance-matrix #2A((0 1 2 3 4)
                                       (1 0 4 6 1)
                                       (2 4 0 2 3)
                                       (3 6 2 0 2)
                                       (8 2 1 4 0))
                  :fleet (list v1 v2 v3 v4)))
             (p3 (finite-fleet-end-depot-cvrp-problem
                  :id 1
                  :depot d0
                  :end-depot d1
                  :clients (list c1 c3 c2)
                  :distance-matrix #2A((0 1 2 3 4)
                                       (1 0 4 6 1)
                                       (2 4 0 2 3)
                                       (3 6 2 0 2)
                                       (8 2 1 4 0))
                  :fleet (list v1 v2 v3 v4)))
             (p4 (finite-fleet-end-depot-cvrp-problem
                  :id 1
                  :depot d0
                  :end-depot d1
                  :clients (list c1 c2 c3)
                  :distance-matrix #2A((0 1 2 3 4)
                                       (1 0 4 6 1)
                                       (2 4 0 2 3)
                                       (3 6 2 0 2)
                                       (8 2 1 4 0))
                  :fleet (list v1 v2 v3)))
             (p5 (finite-fleet-end-depot-cvrp-problem
                  :id 1
                  :depot d0
                  :end-depot d0
                  :clients (list c1 c2 c3)
                  :distance-matrix #2A((0 1 2 3 4)
                                       (1 0 4 6 1)
                                       (2 4 0 2 3)
                                       (3 6 2 0 2)
                                       (8 2 1 4 0))
                  :fleet (list v1 v2 v3 v4)))

             (p6 (clone p1)))

        (bformat t "Testing finite-fleet-with-cvrp-problem...")

        (format t "d0: ~a, d1: ~a~%" d0 d1 )
        (format t "p1: ~a, p5: ~a~%" (end-depot p1) (end-depot p5) )
        (format t "d1 == d0: ~a~%" (obj= (end-depot p1) (end-depot p5)))

        (format t "Printing the objects:~%")
        (loop for e in (list p1 p2 p3 p4 p5 p6)
              doing (format t "   finite-fleet-end-depot-cvrp-problem with id ~a:~% ~a~%"
                            (id e) e))

        (deftests "Testing obj="
          (check-t (obj= p1 p1))
          (check-t (obj= p1 p6))

          (check-nil (obj= p1 p2))
          (check-nil (obj= p1 p3))
          (check-nil (obj= p1 p4))
          (check-nil (obj= p1 p5)))))
    #+END_SRC


* Actions
  In this section we'll add the basic actions used in the suite.

  /It could be convenient to add a description here explaining what are these action and how they are used./

** actions for the simulation of a solution

*** description
    The actions in this section are used to compute the cost of a solution in a given CVRP.
*** route-distance-action
**** description
     This action computes the distance travelled by a vehicle in a route.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class route-distance-action (has-id)
       ((current-distance)
        (id :documentation "The id of the route this action is being used on."))
       :documentation "An action to compute the distance travelled by a vehicle in a route."
       :constructor (route-distance-action (id &optional (current-distance 0)))
       :print-object-string ("<a_rd: ~a ~a>" id current-distance)
       :slots-for-obj= (id current-distance)
       :slots-for-clone (id current-distance))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((c1 (route-distance-action 1 10))
            (c2 (route-distance-action 2 10))
            (c3 (route-distance-action 1 20))
            (c4 (clone c1))
            (c5 (clone c2)))
       (format t "~%===============================
     Testing route-distance-action...
     ================================~2%")

       (format t "Printing the objects:~%")
       (loop for e in (list c1 c2 c3 c4 c5)
             doing (format t "   route-distance-action with id ~a: ~a~%"
                           (id e) e))

       (deftests "Testing obj="
         (check-t (obj= c1 c1))
         (check-t (obj= c1 c4))
         (check-t (obj= c2 c5))

         (check-nil (obj= c1 c2))
         (check-nil (obj= c1 c3))
         (check-nil (obj= c2 c4))
         (check-nil (obj= c3 c5))))
     #+END_SRC
*** basic-vehicle-capacity-action
**** description
     This action checks the basic feasibility of a capacity vehicle.  The check is basic because it only checks it a the beginning of the route.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class basic-vehicle-capacity-action (has-id)
       ((capacity-violation)
        (id :documentation "The id of the route this action is being used on."))
       :documentation "An action to compute the capacity infeasibility in a route."
       :constructor (basic-vehicle-capacity-action (id &optional (capacity-violation 0)))
       :print-object-string ("<a_bvc: ~a ~a>" id capacity-violation)
       :slots-for-obj= (id capacity-violation)
       :slots-for-clone (id capacity-violation))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((c1 (basic-vehicle-capacity-action 1 0))
            (c2 (basic-vehicle-capacity-action 2 0))
            (c3 (basic-vehicle-capacity-action 1 20))
            (c4 (clone c1))
            (c5 (clone c2)))
       (format t "~%=======================================
     Testing basic-vehicle-capacity-action...
     ========================================~2%")

       (format t "Printing the objects:~%")
       (loop for e in (list c1 c2 c3 c4 c5)
             doing (format t "   basic-vehicle-capacity-action with id ~a: ~a~%"
                           (id e) e))

       (deftests "Testing obj="
         (check-t (obj= c1 c1))
         (check-t (obj= c1 c4))
         (check-t (obj= c2 c5))

         (check-nil (obj= c1 c2))
         (check-nil (obj= c1 c3))
         (check-nil (obj= c2 c4))
         (check-nil (obj= c3 c5))))
     #+END_SRC
*** simulate-load-action
**** description
     This action will allow the simulation of all the load/unload operations.  When this action is present, then these actions will be simulated, otherwise they won't.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class simulate-load-action ()
       ()
       :documentation "An action that will allow the simulation of the load operations."
       :constructor (simulate-load-action ())
       :print-object-string ("<a_sl>"))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((a (simulate-load-action)))

       (format t "===============================
     Testing simulate-load-action...
     ===============================~2%")

     (format t "A simulate-load-action: ~a~%" a))
     #+END_SRC
*** basic-solution-distance-action
**** description
     This action will be used to compute, in a very basic way, the distance travelled by the vehicles in the solution.  It will just be the sum of the distances on each route.  It is assumed that this action is always used in conjunction with a route-distance-action.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class basic-solution-distance-action (route-distance-action)
       ((total-distance))
       :documentation "An action that will be used to compute the distance travelled by all the vehicles in a solution."
       :constructor (basic-solution-distance-action
                     (&optional (total-distance 0) (id 1)))
       :print-object-string ("<a_bsd: ~a>" total-distance)
       :slots-for-obj= (id current-distance total-distance)
       :slots-for-clone (id current-distance total-distance))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((c1 (basic-solution-distance-action ))
            (c2 (basic-solution-distance-action 10))
            (c3 (clone c1))
            (c4 (clone c2)))
       (format t "~%=========================================
     Testing basic-solution-distance-action...
     =========================================~2%")

       (format t "Printing the objects:~%")
       (loop for e in (list c1 c2 c3 c4)
             doing (format t "   basic-solution-distance-action ~a:~%" e))

       (deftests "Testing obj="
         (check-t (obj= c1 c1))
         (check-t (obj= c1 c3))
         (check-t (obj= c2 c4))

         (check-nil (obj= c1 c2))
         (check-nil (obj= c2 c3))
         (check-nil (obj= c3 c4))))
     #+END_SRC
*** basic-penalty-action (abstract)
**** description
     This action is the base class for the actions that implement some kind of penalty.  It should have a factor, that we'll multiply by the infeasibility measure.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
         (def-vrp-class basic-penalty-action ()
           ((total-penalty
             :documentation "The total penalty due to this action.")
            (penalty-factor
             :documentation "The factor that we should multiply by the infeasibility measure."))
           :documentation "An base action to implement a basic penalty strategy.")
     #+END_SRC
**** no tests because it is an abstract class
*** basic-capacity-penalty-action
**** description
     A class to implement a basic penalty on the violation of the capacity in the clients.  The idea is that the basic-route-capacity action measures how capacity-infeasible is this route, and when we use this action we can panalize that infeasibility.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class basic-capacity-penalty-action
         (basic-vehicle-capacity-action
          basic-penalty-action)
       ()
       :constructor (basic-capacity-penalty-action
                     (&key (id 1)
                           (penalty-factor 1)
                           (total-penalty 0)
                           (capacity-violation 0)))
       :print-object-string ("<a_bcp~a: ~a>" id total-penalty)
       :slots-for-obj= (id capacity-violation penalty-factor total-penalty)
       :slots-for-clone (id capacity-violation penalty-factor total-penalty)
       :documentation "An action to implement a penalty strategy for the capacity violation.")
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((c1 (basic-capacity-penalty-action ))
            (c2 (basic-capacity-penalty-action :id 1 :penalty-factor 100))
            (c3 (basic-capacity-penalty-action :id 1 :capacity-violation 5))
            (c4 (basic-capacity-penalty-action :id 2))
            (c5 (clone c1)))
       (format t "~%=======================================
     Testing basic-capacity-penalty-action...
     ========================================~2%")

       (format t "Printing the objects:~%")
       (loop for e in (list c1 c2 c3 c4 c5)
             doing (format t "   basic-capacity-penalty-action with id ~a: ~a~%"
                           (id e) e))

       (deftests "Testing obj="
         (check-t (obj= c1 c1))
         (check-t (obj= c1 c5))

         (check-nil (obj= c1 c2))
         (check-nil (obj= c1 c3))
         (check-nil (obj= c1 c4))
         (check-nil (obj= c2 c3))
         (check-nil (obj= c3 c4))
         (check-nil (obj= c4 c5))
         ))
     #+END_SRC
*** basic-cvrp-action
**** description
     This is a class to implement an action for the CVRP penalizing the capacity violations.  If you want to simulate a solution for a CVRP you'll only need an instance of this action.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class basic-cvrp-action
         (basic-solution-distance-action
          simulate-load-action
          basic-capacity-penalty-action)
       ()
       :constructor (basic-cvrp-action
                     (&key (id 1)
                           (penalty-factor 1000)
                           (total-penalty 0)
                           (capacity-violation 0)
                           (current-distance 0)
                           (total-distance 0)))
       :print-object-string ("<a_cvrp~a. d: ~a, p: ~a>"
                             id total-distance total-penalty)
       :slots-for-obj= (id
                        penalty-factor
                        total-penalty
                        capacity-violation
                        current-distance
                        total-distance)
       :slots-for-clone (id
                        penalty-factor
                        total-penalty
                        capacity-violation
                        current-distance
                        total-distance)
       :documentation "An action to simulate a basic CVRP solution.")
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((c1 (basic-capacity-penalty-action ))
            (c2 (basic-capacity-penalty-action :id 1 :penalty-factor 100))
            (c3 (basic-capacity-penalty-action :id 1 :capacity-violation 5))
            (c4 (basic-capacity-penalty-action :id 2))
            (c5 (clone c1)))
       (format t "~%=======================================
     Testing basic-capacity-penalty-action...
     ========================================~2%")

       (format t "Printing the objects:~%")
       (loop for e in (list c1 c2 c3 c4 c5)
             doing (format t "   basic-capacity-penalty-action with id ~a: ~a~%"
                           (id e) e))

       (deftests "Testing obj="
         (check-t (obj= c1 c1))
         (check-t (obj= c1 c5))

         (check-nil (obj= c1 c2))
         (check-nil (obj= c1 c3))
         (check-nil (obj= c1 c4))
         (check-nil (obj= c2 c3))
         (check-nil (obj= c3 c4))
         (check-nil (obj= c4 c5))
         ))
     #+END_SRC

** actions for the delta-cost-computation
*** description
    The actions in this section are used to compute the delta-cost of a solution after some neighborhood operations have been applied.
*** compute-delta-distance-action
**** description
     An action to compute the distance difference after some operation (insertion or selection) has been made in the working copy.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class delta-distance-action (has-id)
       ((delta-distance :initform 0))
       :documentation "This actions computes the difference in the distances of a solution after a neighborhood operation  has been made."
       :constructor (delta-distance-action
                     (&key (delta-distance 0) (id 1)))
       :print-object-string ("<da_d ~a: ~a>"
                             id delta-distance)
       :slots-for-obj= (id delta-distance)
       :slots-for-clone (id delta-distance))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((c1 (delta-distance-action ))
            (c2 (delta-distance-action :id 1 :delta-distance 0))
            (c3 (delta-distance-action :id 2 ))
            (c4 (delta-distance-action :id 1 :delta-distance 10))
            (c5 (clone c1)))
       (format t "~%=======================================
     Testing delta-distance-action...
     ========================================~2%")

       (format t "Printing the objects:~%")
       (loop for e in (list c1 c2 c3 c4 c5)
             doing (format t "   delta-distance-action with id ~a: ~a~%"
                           (id e) e))

       (deftests "Testing obj="
         (check-t (obj= c1 c1))
         (check-t (obj= c1 c5))

         (check-nil (obj= c1 c2))
         (check-nil (obj= c1 c3))
         (check-nil (obj= c1 c4))
         (check-nil (obj= c2 c3))
         (check-nil (obj= c3 c4))
         (check-nil (obj= c4 c5))))
     #+END_SRC
*** compute-delta-basic-capacity-action
**** description
     An action to compute the difference in basic-capacity feasibility after some operation (insertion or selection) has been made in the working copy.  The basic-capacity of a route is the difference between the capacity of the client and the sum of the demands of the clients in the route.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class delta-basic-capacity-action (has-id)
       ((delta-routes-feasibility :initform nil
           :documentation "An array with the available basic-capacity in the vehicles on each route.  The available basic-capacity of a route is the capacity of the vehicle minus the sum of the demand of the clients.  In other words is how much cargo the vehicle could carry."))
       :documentation "A class to represent an action to compute the difference of vehicle-capacity in a solution after an operation (selection or insertion) has been made."
       ;; no constructor (I'll write it by hand)
       :print-object-string ("<da_bc: ~a: ~a>"
                             id delta-routes-feasibility)
       :slots-for-obj= (id delta-routes-feasibility)
       :slots-for-clone (id delta-routes-feasibility))

     ;; this is the code for the constructor
     (defun delta-basic-capacity-action (number-of-routes
                                         &key (id 1)
                                           routes-feasibility)
       (make-instance
        'delta-basic-capacity-action
        :id id
        :delta-routes-feasibility (aif routes-feasibility it
                                       (make-array (1+ number-of-routes)
                                                   :initial-element 0))))


     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((c1 (delta-basic-capacity-action 3))
            (c2 (delta-basic-capacity-action 3 :id 1))
            (c3 (delta-basic-capacity-action
                 3 :id 1 :routes-feasibility #(0 0 0 0) ))
            (c4 (delta-basic-capacity-action 4))
            (c5 (delta-basic-capacity-action 3 :id 2))
            (c6 (delta-basic-capacity-action
                 3 :id 1 :routes-feasibility #(0 1 0 0)))
            (c7 (clone c1)))
       (format t "~%=======================================
     Testing delta-basic-capacity-action...
     ========================================~2%")

       (format t "Printing the objects:~%")
       (loop for e in (list c1 c2 c3 c4 c5 c6 c7)
             doing (format t "   delta-basic-capacity-action with id ~a: ~a~%"
                           (id e) e))

       (deftests "Testing obj="
         (check-t (obj= c1 c1))
         (check-t (obj= c1 c2))
         (check-t (obj= c1 c3))
         (check-t (obj= c1 c7))

         (check-nil (obj= c1 c4))
         (check-nil (obj= c1 c5))
         (check-nil (obj= c1 c6))
         (check-nil (obj= c3 c5))))
     #+END_SRC
*** delta-basic-capacity-penalty-action (structural functional)
**** description
     An action that can be used to penalize the basic-capacity unfeasibility.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
       (def-vrp-class delta-basic-capacity-penalty-action
           (basic-penalty-action
            delta-basic-capacity-action)
         ;; slots
         ((original-routes-feasibility
           :documentation "A slot to record the original routes-feasibility in the solution."))
         :documentation "A class to represent an action that penalizes the basic-capacity unfeasibility."
         :constructor (delta-basic-capacity-penalty-action
                       (&key (penalty-factor 1000)
                             (total-penalty 0)
                             (original-routes-feasibility)
                             (delta-routes-feasibility)
                             (id 1)))
         :print-object-string ("<da_bcp ~a: total: ~a: ~a>"
                               id
                               total-penalty
                               delta-routes-feasibility)
         :slots-for-obj= (id
                          penalty-factor
                          total-penalty
                          delta-routes-feasibility
                          original-routes-feasibility)
         :slots-for-clone (id
                          penalty-factor
                          total-penalty
                          delta-routes-feasibility
                          original-routes-feasibility))
     #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((c1 (delta-basic-capacity-penalty-action))
            (c2 (delta-basic-capacity-penalty-action
                 :penalty-factor 200))
            (c3 (delta-basic-capacity-penalty-action
                 :delta-routes-feasibility #(0 3 0 0)))
            (c4 (delta-basic-capacity-penalty-action
                 :original-routes-feasibility #(1 3)))
            (c5 (delta-basic-capacity-penalty-action
                 :total-penalty 500))
            (c6 (delta-basic-capacity-penalty-action
                 :total-penalty 3
                 :id 2
                 :penalty-factor 4
                 :delta-routes-feasibility #(0 1 0 0)
                 :original-routes-feasibility #(0)))
            (c7 (clone c1)))
       (format t "~%=======================================
     Testing delta-basic-cvrp-action...
     ========================================~2%")

       (format t "Printing the objects:~%")
       (loop for e in (list c1 c2 c3 c4 c5 c6 c7)
             doing (format t "   delta-basic-cvrp-action with id ~a: ~a~%"
                           (id e) e))

       (deftests "Testing obj="
         (check-t (obj= c1 c1))
         (check-t (obj= c1 c7))

         (check-nil (obj= c1 c2))
         (check-nil (obj= c1 c3))
         (check-nil (obj= c1 c4))
         (check-nil (obj= c1 c5))
         (check-nil (obj= c1 c6))
         (check-nil (obj= c3 c5))))
     #+END_SRC
*** delta-basic-cvrp-action
**** description
     An action that can be used to solve a basic CVRP: homogeneous (and infinite) fleet, each client is visited only once, and when a vehicle visits a client, it downloads its demand.  This class inherit from delta-distance-action and delta-basic-capacity-action: the only two actions related to this problem.  The penalty is computed from delta-basic-capacity-penalty-action.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class delta-basic-cvrp-action
         (delta-distance-action
          delta-basic-capacity-penalty-action)
       ()
       :documentation "A class to represent an action to compute the difference of vehicle-capacity in a solution after an operation (selection or insertion) has been made."
       :constructor (delta-cvrp-action
                     (&key (delta-distance 0)
                           (delta-routes-feasibility)
                           (penalty-factor 1000)
                           (original-routes-feasibility nil)
                           (total-penalty 0)
                           (id 1)))
       :print-object-string ("<da_cvrp ~a: D: ~a. P: ~a>"
                             id
                             delta-distance
                             total-penalty)
       :slots-for-obj= (id
                        delta-distance
                        delta-routes-feasibility
                        original-routes-feasibility
                        penalty-factor
                        total-penalty)
       :slots-for-clone (id
                        delta-distance
                        delta-routes-feasibility
                        original-routes-feasibility
                        penalty-factor
                        total-penalty))
     #+END_SRC
**** tests
***** basic-test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((c1 (delta-cvrp-action))
             (c2 (delta-cvrp-action :delta-distance 1))
             (c3 (delta-cvrp-action :delta-routes-feasibility #(0 0 0 0) ))
             (c3 (delta-cvrp-action
                  :original-routes-feasibility #(0 0 0 0) ))
             (c4 (delta-cvrp-action :id 2))
             (c5 (delta-cvrp-action :total-penalty 2))
             (c6 (delta-cvrp-action :penalty-factor 2))
             (c7 (delta-cvrp-action
                  :delta-distance 3
                  :id 1
                  :delta-routes-feasibility #(0 1 0 0)))
             (c8 (clone c1)))
        (format t "~%=======================================
      Testing delta-basic-cvrp-action...
      ========================================~2%")

        (format t "Printing the objects:~%")
        (loop for e in (list c1 c2 c3 c4 c5 c6 c7)
              doing (format t "   delta-basic-cvrp-action with id ~a: ~a~%"
                            (id e) e))

        (deftests "Testing obj="
          (check-t (obj= c1 c1))
          (check-t (obj= c1 c8))

          (check-nil (obj= c1 c2))
          (check-nil (obj= c1 c3))
          (check-nil (obj= c1 c4))
          (check-nil (obj= c1 c5))
          (check-nil (obj= c1 c6))
          (check-nil (obj= c1 c7))
          (check-nil (obj= c3 c5))))
      #+END_SRC
***** testing-initialization
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (with-cvrp-problem (p1 :distances `((0 2 3 4 5)
                                          (5 0 6 7 2 )
                                          (1 8 0 3 9)
                                          (4 5 1 0 5)
                                          (4 5 1 5 0))
                             :demands '(20 10 15 40)
                             :capacity 40)
        (with-basic-cvrp-solution (s1 ((1 2) (3) (4)) p1)
          (let* ((wc1 (basic-working-copy s1))
                 (c1 (delta-cvrp-action
                      :delta-distance 3
                      :id 1
                      :total-penalty 400
                      :penalty-factor 300
                      :original-routes-feasibility nil
                      :delta-routes-feasibility #(0 1 0))))
            (bformat t "Testing delta-basic-cvrp-action initialization")
            (check-= 3 (delta-distance c1))
            (check-obj= #(0 1 0) (delta-routes-feasibility c1))
            (check-obj= #(0 1 2) (delta-routes-feasibility c1))
            (check-nil (original-routes-feasibility c1))
            (check-= 300 (penalty-factor c1))
            (check-= 400 (total-penalty c1))

            ;; let's initialize
            (initialize-action-for-delta-cost-computation wc1 p1 c1)

            ;; after initialization
            (check-= 0 (delta-distance c1))
            (check-obj= #(0 0 0 0) (delta-routes-feasibility c1))
            (check-obj= #(0 10 25 0) (original-routes-feasibility c1))
            (check-= 300 (penalty-factor c1))
            (check-= 0 (total-penalty c1)))))
      #+END_SRC

** actions for the delta-cost*
*** description
    The actions in this section are used to compute the delta-cost of a solution after some neighborhood operations have been applied, but in a way that will allow the undo-delta-cost-computation, by storing the values in a stack.

    I'll write the ones for the CVRP by hand, but I think that it can be abstracted in a macro.
*** compute-delta-distance-action*
**** description
     This is the same class as the compute-delta-distance-action, but with a stack.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class delta-distance-action* (delta-distance-action)
       ((delta-distance-stack :initform nil))
       :documentation "This action computes the difference in the distances of a solution after a neighborhood operation has been made, and adds the functionalities for an undo-delta-cost-computation. It does that by storing each previous result in the stack."
       :constructor (delta-distance-action*
                     (&key (delta-distance 0)
                           (id 1)
                           (delta-distance-stack nil)))
       :print-object-string ("<da_d* ~a: ~a>"
                             id delta-distance)
       :slots-for-obj= (id delta-distance delta-distance-stack)
       :slots-for-clone (id delta-distance delta-distance-stack))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((c1 (delta-distance-action* ))
            (c2 (delta-distance-action* :id 1 :delta-distance 0
                                        :delta-distance-stack nil))
            (c3 (delta-distance-action* :id 2))
            (c4 (delta-distance-action* :id 1 :delta-distance 10))
            (c5 (delta-distance-action* :id 1 :delta-distance 0
                                        :delta-distance-stack (list 0)))
            (c6 (clone c1)))
       (bformat t "Testing delta-distance-action")

       (format t "Printing the objects:~%")
       (loop for e in (list c1 c2 c3 c4 c5)
             doing (format t "   delta-distance-action with id ~a: ~a~%"
                           (id e) e))

       (deftests "Testing obj="
         (check-t (obj= c1 c1))
         (check-t (obj= c1 c2))
         (check-t (obj= c1 c6))

         (check-nil (obj= c1 c3))
         (check-nil (obj= c1 c4))
         (check-nil (obj= c1 c5))
         (check-nil (obj= c2 c3))
         (check-nil (obj= c3 c4))
         (check-nil (obj= c4 c5))))
     #+END_SRC
*** compute-delta-basic-capacity-action*
**** description
     An action to compute the difference in basic-capacity feasibility after some operation (insertion or selection) has been made in the working copy.  The basic-capacity of a route is the difference between the capacity of the client and the sum of the demands of the clients in the route.  It provides a stack for the undo-delta-cost-computation.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class delta-basic-capacity-action*
         (delta-basic-capacity-action)
       ((delta-routes-feasibility-stack :initform nil
           :documentation "A stack to store the arrays with the available basic-capacity in the vehicles on each route.  The available basic-capacity of a route is the capacity of the vehicle minus the sum of the demand of the clients.  In other words is how much cargo the vehicle could carry."))
       :documentation "A class to represent an action* to compute the difference of vehicle-capacity in a solution after an operation (selection or insertion) has been made."
       ;; no constructor (I'll write it by hand)
       :print-object-string ("<da_bc*: ~a: ~a>"
                             id delta-routes-feasibility)
       :slots-for-obj= (id
                        delta-routes-feasibility
                        delta-routes-feasibility-stack)
       :slots-for-clone (id
                        delta-routes-feasibility
                        delta-routes-feasibility-stack))

     ;; this is the code for the constructor
     (defun delta-basic-capacity-action* (number-of-routes
                                          &key (id 1)
                                            routes-feasibility
                                            delta-routes-feasibility-stack)
       (make-instance
        'delta-basic-capacity-action*
        :id id
        :delta-routes-feasibility (aif routes-feasibility it
                                       (make-array (1+ number-of-routes)
                                                   :initial-element 0))
        :delta-routes-feasibility-stack delta-routes-feasibility-stack))


     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((c1 (delta-basic-capacity-action* 3))
            (c2 (delta-basic-capacity-action* 3 :id 1))
            (c3 (delta-basic-capacity-action*
                 3 :id 1 :routes-feasibility #(0 0 0 0) ))
            (c4 (delta-basic-capacity-action*
                 3
                 :id 1
                 :routes-feasibility #(0 0 0 0)
                 :delta-routes-feasibility-stack nil))
            (c5 (delta-basic-capacity-action* 4))
            (c6 (delta-basic-capacity-action* 3 :id 2))
            (c7 (delta-basic-capacity-action*
                 3
                 :id 1
                 :routes-feasibility #(0 1 0 0)))
            (c8 (clone c1))
            )
       (format t "~%=======================================
     Testing delta-basic-capacity-action...
     ========================================~2%")

       (format t "Printing the objects:~%")
       (loop for e in (list c1 c2 c3 c4
                            c5 c6 c7 c8)
             doing (format t "   delta-basic-capacity-action* ~a: ~a~%"
                            (id e) e))

       (deftests "Testing obj="
         (check-t (obj= c1 c1))
         (check-t (obj= c1 c2))
         (check-t (obj= c1 c3))
         (check-t (obj= c1 c4))
         (check-t (obj= c1 c8))

         (check-nil (obj= c1 c5))
         (check-nil (obj= c1 c6))
         (check-nil (obj= c3 c5))))
     #+END_SRC
*** basic-penalty-action* (abstract)
**** description
     This action is the base class for the actions that implement some kind of penalty *and* undo-delta-cost-computation.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
         (def-vrp-class basic-penalty-action* (basic-penalty-action)
           ((total-penalty-stack
             :documentation "A stack with the previous total penalty due to this action."))
           :documentation "An base action to implement a basic penalty strategy with undo-delta-cost-computation.")
     #+END_SRC
**** no tests because it is an abstract class
*** delta-basic-capacity-penalty-action* (structural functional)
**** description
     An action that can be used to penalize the basic-capacity unfeasibility and to undo those calculations.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class delta-basic-capacity-penalty-action*
         (basic-penalty-action*
          delta-basic-capacity-action*)
       ;; slots
       ((original-routes-feasibility
         :documentation "A slot to record the original routes-feasibility in the solution."))
       :documentation "A class to represent an action that penalizes the basic-capacity unfeasibility."
       :constructor (delta-basic-capacity-penalty-action*
                     (&key (penalty-factor 1000)
                           (total-penalty 0)
                           (original-routes-feasibility)
                           (delta-routes-feasibility)
                           (delta-routes-feasibility-stack nil)
                           (total-penalty-stack nil)
                           (id 1)))
       :print-object-string ("<da_bcp* ~a: total: ~a: ~a>"
                             id
                             total-penalty
                             delta-routes-feasibility)
       :slots-for-obj= (id
                        penalty-factor
                        total-penalty
                        delta-routes-feasibility
                        original-routes-feasibility
                        delta-routes-feasibility-stack
                        total-penalty-stack)
       :slots-for-clone (id
                        penalty-factor
                        total-penalty
                        delta-routes-feasibility
                        original-routes-feasibility
                        delta-routes-feasibility-stack
                        total-penalty-stack))
     #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((c1 (delta-basic-capacity-penalty-action*))
            (c2 (delta-basic-capacity-penalty-action*
                 :penalty-factor 200))
            (c3 (delta-basic-capacity-penalty-action*
                 :delta-routes-feasibility #(0 3 0 0)))
            (c4 (delta-basic-capacity-penalty-action*
                 :original-routes-feasibility #(1 3)))
            (c5 (delta-basic-capacity-penalty-action*
                 :total-penalty 500))
            (c6 (delta-basic-capacity-penalty-action*
                 :total-penalty 3
                 :id 2
                 :penalty-factor 4
                 :delta-routes-feasibility #(0 1 0 0)
                 :original-routes-feasibility #(0)))
            (c7 (clone c1))
            (c8 (delta-basic-capacity-penalty-action*
                 :total-penalty 0
                 :id 1
                 :penalty-factor 1000
                 :delta-routes-feasibility nil
                 :original-routes-feasibility nil
                 :delta-routes-feasibility-stack nil
                 :total-penalty-stack nil))
            (c9 (delta-basic-capacity-penalty-action*
                 :total-penalty 0
                 :id 1
                 :penalty-factor 1000
                 :delta-routes-feasibility nil
                 :original-routes-feasibility nil
                 :delta-routes-feasibility-stack `((1 2 0))
                 :total-penalty-stack nil))
            (c10 (delta-basic-capacity-penalty-action*
                 :total-penalty 0
                 :id 1
                 :penalty-factor 1000
                 :delta-routes-feasibility nil
                 :original-routes-feasibility nil
                 :delta-routes-feasibility-stack `((1 ,(+ 1 1) 0))
                 :total-penalty-stack nil)))
       (bformat t "Testing delta-basic-cvrp-action")

       (format t "Printing the objects:~%")
       (loop for e in (list c1 c2 c3 c4 c5 c6 c7)
             doing (format t "   delta-basic-cvrp-action with id ~a: ~a~%"
                           (id e) e))

       (deftests "Testing obj="
         (check-t (obj= c1 c1))
         (check-t (obj= c1 c7))
         (check-t (obj= c1 c8))
         (check-t (obj= c9 c10))

         (check-nil (obj= c1 c2))
         (check-nil (obj= c1 c3))
         (check-nil (obj= c1 c4))
         (check-nil (obj= c1 c5))
         (check-nil (obj= c1 c6))
         (check-nil (obj= c3 c5))
         (check-nil (obj= c1 c9))))
     #+END_SRC
*** delta-basic-cvrp-action*
**** description
     An action that can be used to solve a basic CVRP: homogeneous (and infinite) fleet, each client is visited only once, and when a vehicle visits a client, it downloads its demand, by undoing the =compute-delta-cost-after= and =finish-delta-cost-computation=.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class delta-basic-cvrp-action*
         (delta-distance-action*
          delta-basic-capacity-penalty-action*)
       ()
       :documentation "A class to represent an action to compute the difference of vehicle-capacity in a solution after an operation (selection or insertion) has been made and can undo all those computations."
       :constructor (delta-cvrp-action*
                     (&key (delta-distance 0)
                           (delta-routes-feasibility)
                           (penalty-factor 1000)
                           (original-routes-feasibility nil)
                           (total-penalty 0)
                           (delta-distance-stack nil)
                           (delta-routes-feasibility-stack nil)
                           (total-penalty-stack nil)
                           (id 1)))
       :print-object-string ("<da_cvrp* ~a: D: ~a. P: ~a>"
                             id
                             delta-distance
                             total-penalty)
       :slots-for-obj= (id
                        delta-distance
                        delta-routes-feasibility
                        original-routes-feasibility
                        penalty-factor
                        total-penalty
                        delta-distance-stack
                        delta-routes-feasibility-stack
                        total-penalty-stack)

       :slots-for-clone (id
                        delta-distance
                        delta-routes-feasibility
                        original-routes-feasibility
                        penalty-factor
                        total-penalty
                        delta-distance-stack
                        delta-routes-feasibility-stack
                        total-penalty-stack))
     #+END_SRC
**** WIP tests
***** basic-test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((c1 (delta-cvrp-action*))
             (c2 (delta-cvrp-action* :delta-distance 1))
             (c3 (delta-cvrp-action* :delta-routes-feasibility #(0 0 0 0) ))
             (c3 (delta-cvrp-action*
                  :original-routes-feasibility #(0 0 0 0) ))
             (c4 (delta-cvrp-action* :id 2))
             (c5 (delta-cvrp-action* :total-penalty 2))
             (c6 (delta-cvrp-action* :penalty-factor 2))
             (c7 (delta-cvrp-action*
                  :delta-distance 3
                  :id 1
                  :delta-routes-feasibility #(0 1 0 0)))
             (c8 (clone c1)))
        (format t "~%=======================================
      Testing delta-basic-cvrp-action...
      ========================================~2%")

        (format t "Printing the objects:~%")
        (loop for e in (list c1 c2 c3 c4 c5 c6 c7)
              doing (format t "   delta-basic-cvrp-action with id ~a: ~a~%"
                            (id e) e))

        (deftests "Testing obj="
          (check-t (obj= c1 c1))
          (check-t (obj= c1 c8))

          (check-nil (obj= c1 c2))
          (check-nil (obj= c1 c3))
          (check-nil (obj= c1 c4))
          (check-nil (obj= c1 c5))
          (check-nil (obj= c1 c6))
          (check-nil (obj= c1 c7))
          (check-nil (obj= c3 c5))))
      #+END_SRC
***** testing-initialization
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (with-cvrp-problem (p1 :distances `((0 2 3 4 5)
                                          (5 0 6 7 2 )
                                          (1 8 0 3 9)
                                          (4 5 1 0 5)
                                          (4 5 1 5 0))
                             :demands '(20 10 15 40)
                             :capacity 40)
        (with-basic-cvrp-solution (s1 ((1 2) (3) (4)) p1)
          (let* ((wc1 (basic-working-copy s1))
                 (c1 (delta-cvrp-action
                      :delta-distance 3
                      :id 1
                      :total-penalty 400
                      :penalty-factor 300
                      :original-routes-feasibility nil
                      :delta-routes-feasibility #(0 1 0))))
            (bformat t "Testing delta-basic-cvrp-action initialization")
            (check-= 3 (delta-distance c1))
            (check-obj= #(0 1 0) (delta-routes-feasibility c1))
            (check-obj= #(0 1 2) (delta-routes-feasibility c1))
            (check-nil (original-routes-feasibility c1))
            (check-= 300 (penalty-factor c1))
            (check-= 400 (total-penalty c1))

            ;; let's initialize
            (initialize-action-for-delta-cost-computation wc1 p1 c1)

            ;; after initialization
            (check-= 0 (delta-distance c1))
            (check-obj= #(0 0 0 0) (delta-routes-feasibility c1))
            (check-obj= #(0 10 25 0) (original-routes-feasibility c1))
            (check-= 300 (penalty-factor c1))
            (check-= 0 (total-penalty c1)))))
      #+END_SRC


* Neighborhood operations
  :PROPERTIES:
  :CUSTOM_ID: sec:neighborhood-operations
  :END:
  
  In this section I'll add the classes needed to explore a neighborhood.
** description
   In this section we'll define the classes that will allow us to represent all the possible changes.  The most elementary classes are:

    - operation-select-client
    - operation-insert-client

    These classes will have the route and the position inside that route where the operation should take place.  It will also have a number.  In the case of the selections, it indicates how many selections have been made before this one.  In the case of the insertions it points to the client that should be inserted (and that client is the one that was selected at this operation number).

    I will create a base class for all the operations in the neighborhood.  This base class will have the slots for where to store the results/arguments, the op-number, the pos and the route where the operation is to be executed.
** neigborhood-operation (abstract)
*** description
    This is a base class for the operations in a neighborhood.  It has a route and a position (this pair is called a coordinate) and an number identifying the client that should be operated.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class neighborhood-operation ()
      (;; the slots
       (route
        :documentation "The route where the operation will take place.")
       (pos
        :documentation "The position in the route where the operation will take place.")
       (operand
        :documentation "The result of the operation: a client or a set of clients that was selected or that should be inserted.  Actually I think that it is the index in the *selected-clients-array* where the selected client was stored or the position in the array of the client that should be inserted."))
      ;; the rest of the class elements
      :documentation "A base class for a neighborhood operation."
      ;; we don't want a constructor because this is an abstract class
      ;; we don't want either a print-object method
      ;; we leave slots for obj= and clone because maybe they are
      ;; used to polymorphically compute something
      :slots-for-obj= (route pos operand)
      :slots-for-clone (route pos operand))
    #+END_SRC
** operation-on-route (abstract)
*** description
    This is a base class for the operations that have a route in their definition.  It has a route and an operand
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class operation-on-route ()
      (;; the slots
       (route
        :documentation "The route where the operation will take place.")
       (operand
        :documentation "It is the index in the *selected-clients-array* where the selected client was stored or the position in the array of the client that should be inserted."))
      ;; the rest of the class elements
      :documentation "A base class for all operations on a route."
      ;; we don't want a constructor because this is an abstract class
      ;; we don't want either a print-object method
      ;; we leave slots for obj= and clone because maybe they are
      ;; used to polymorphically compute something
      :slots-for-obj= (route operand)
      :slots-for-clone (route operand))
    #+END_SRC
** operation-with-operand (abstract)
*** description
    This is a base class for the operations that have an operand slot.  In the case of the selections the operand indicates the order in which the operation was done.  In the case of the insertions it works as a pointer to the object that should be inserted.
    
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (def-vrp-class operation-with-operand ()
      (;; the slots
       (operand
        :documentation "It is the index to identify the operation."))
      ;; the rest of the class elements
      :documentation "A base class for all operations that have one operand."
      ;; we don't want a constructor because this is an abstract class
      ;; we don't want either a print-object method
      ;; we leave slots for obj= and clone because maybe they are
      ;; used to polymorphically compute something
      :slots-for-obj= (operand)
      :slots-for-clone (operand))
    #+END_SRC
** operation-select-client (actual class)
*** description
    This class represent a client selection in a neighborhood function.  It inherits from the neighborhood-operation class, so in this case there are not too many things to add, just the print-object-string and the constructor name and arguments.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    ;; A class for the select-client operation
    (def-vrp-class operation-select-client (neighborhood-operation)
      ;; the slots are inherited from neighborhood-operation
      ()
      ;; the rest of the class elements
      :documentation "A class to represent the select-client operation in a neighborhood criterion."
      :constructor (op-select-client (route pos &optional operand))
      :print-object-string ("<op:a ~a ~a ~a>" route pos operand)
      ;; the slots-for-clone and for obj are
      ;; inherited from the neighborhood-operation class
      )
   #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((c1 (op-select-client 1 1 0))
           (c2 (op-select-client 1 1 1))
           (c3 (op-select-client 1 2 0))
           (c4 (op-select-client 2 1 0))
           (c5 (clone c1)))
      (format t "~%===========================
    Testing op-select-client...
    ===========================~2%")

      (format t "Printing the objects:~%")
      (loop for e in (list c1 c2 c3 c4 c5)
            doing (format t "   op-select-client: ~a~%" e))

      (deftests "Testing obj="
        (check-t (obj= c1 c1))
        (check-t (obj= c1 c5))

        (check-nil (obj= c1 c2))
        (check-nil (obj= c1 c3))
        (check-nil (obj= c1 c4))
        (check-nil (obj= c2 c3))
        (check-nil (obj= c3 c4))
        (check-nil (obj= c4 c5))))
    #+END_SRC
** operation-insert-client (actual class)
*** description
    This class represent a client insertion in a neighborhood function.  It has a route, a position and the client that should be inserted (in the slot operand).
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    ;; A class for the insert-client operation
    (def-vrp-class operation-insert-client (neighborhood-operation)
      ;; the slots are inherited from neighborhood-operation
      ()
      ;; the rest of the class elements
      :documentation "A class to represent the insert-client operation in a neighborhood criterion."
      :constructor (op-insert-client (route pos operand))
      :print-object-string ("<op:b ~a ~a ~a>" route pos operand)
      ;; the slots-for-clone and for obj are
      ;; inherited from the neighborhood-operation class
      )
   #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((c1 (op-insert-client 1 1 0))
           (c2 (op-insert-client 1 1 1))
           (c3 (op-insert-client 1 2 0))
           (c4 (op-insert-client 2 1 0))
           (c5 (clone c1)))
      (format t "~%===========================
    Testing op-insert-client...
    ===========================~2%")

      (format t "Printing the objects:~%")
      (loop for e in (list c1 c2 c3 c4 c5)
            doing (format t "   op-insert-client: ~a~%" e))

      (deftests "Testing obj="
        (check-t (obj= c1 c1))
        (check-t (obj= c1 c5))

        (check-nil (obj= c1 c2))
        (check-nil (obj= c1 c3))
        (check-nil (obj= c1 c4))
        (check-nil (obj= c2 c3))
        (check-nil (obj= c3 c4))
        (check-nil (obj= c4 c5))))
    #+END_SRC


* Working-copy
  In this section I'll add the classes to implement the working-copies.

** basic-working-copy (actual class)
*** description
    A class that includes all the variables needed in the functions and macros to simulate a neighborhood-operation without actually making the changes.  This is useful to calculate the costs and feasibilities of neighbor solutions.

    This class has the following slots:

      - solution
        the solution from which this is the working copy.
      - actual-position-functions-stack
        A stack with all the actual-position functions.
      - initial-route-lengths
        An array with the lengths of the routes in the solution.
      - number-of-routes
        The number of routes this working-copy has.
      - routes-lengths
        The current length of the routes.
      - insertions-made
        a list with info about the insertions made.
      - selections-count
        A variable to indicate how many select-client operations we have done.
      - selected-clients
        an array with info about the selected clients.
      - original-positions
        An array with the coords of every client in the original solution.  In the position `n' it has the coords of the client with id `n'.
      - selected-subroutes
        A data structure to store info about the selected suborutes in a neighborhood search.  So far it is an array where in the position `n' we have a client, a size and a boolean to indicate whether or not that subroute has been reversed.  The size is the number of select-clients that also are part of the subroute.
      - selected-clients-during-apply
        An array with the selected clients during the application of an operation to a solution.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    ;; A class for the insert-client operation
    (def-vrp-class basic-working-copy ()
      ;; slots
      ((solution
        :documentation "A solution with the routes of clients and depot, the demands and the vehicles capacity.")
       (actual-position-functions-stack :initform nil
        :documentation  "A stack with all the previously used actual-positions functions.")
       (number-of-routes :initform 0
        :documentation "The number of routes this working-copy has.")
       (initial-routes-lengths :initform nil
        :documentation "An array with the initial route lengths in the working copy of the solution.")
       (routes-lengths :initform nil
        :documentation "An array with the current route lengths in the working copy.")
       (insertions-made :initform nil
        :documentation "A list with all the insertions made in the neighborhood process.  Each element is a list of the form (r,p,c) where r and p are the route and the position where the insertion was made and c is the client that was inserted.")
       (selections-count :initform -1
        :documentation "A variable to count how many select-client operations have been made.  This count is zero based.")
       (selected-clients
        :initform (make-array 20 :adjustable t :fill-pointer t :initial-element nil)
        :documentation "A data structure to store the clients that were selected during a neighborhood simulation.")
       (original-positions
        :initform (make-array 20 :adjustable t :fill-pointer t :initial-element nil)
        :documentation "A data structure to store the order of the clients in the original solution.")
       (selected-subroutes
        :initform nil
        :documentation "A data structure to store info about the selected suborutes in a neighborhood search.")
       (selected-clients-during-apply
        :initform nil
        :documentation "An array with the selected clients during the application of an operation to a solution.")
       )


      ;; the rest of the class elements
      :documentation "A class to represent a data structure for the simulation of operations in a neighborhood exploration."
      :constructor (basic-working-copy (solution))
      :slots-for-obj= (solution
                       initial-routes-lengths
                       number-of-routes
                       routes-lengths
                       insertions-made
                       selections-count
                       selected-clients
                       original-positions
                       selected-subroutes
                       selected-clients-during-apply)
      :slots-for-clone (solution
                        initial-routes-lengths
                        routes-lengths
                        number-of-routes
                        insertions-made
                        selections-count
                        selected-clients
                        original-positions
                        selected-subroutes
                        selected-clients-during-apply))
   #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (with-basic-solution (s1 ((1 2 3) (4 5)))
      (with-basic-solution (s2 ((1 2 3) (5 4)))
        (let* ((wc1 (basic-working-copy s1))
               (wc2 (basic-working-copy s2))
               (wc3 (clone wc1))
               (wc4 (clone wc2)))
          (format t "~%==========================
    Testing basic-working-copy
    ==========================~2%")

          (format t "Printing the objects:~%")
          (loop for e in (list wc1 wc2 wc3 wc4)
                doing (format t "   basic-working-copy: ~a~%" e))

          (deftests "Testing obj="
            (check-t (obj= wc1 wc1))
            (check-t (obj= wc1 wc3))
            (check-t (obj= wc2 wc4))

            (check-nil (obj= wc1 wc2))
            (check-nil (obj= wc1 wc4))
            (check-nil (obj= wc2 wc3))))))
    #+END_SRC
** specialize the =routes= function for basic-working-copy
*** description
    In this section we especialize the generic function =routes= in the basic-working-copy class.  This is to make easier to access the routes of the working-copy.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
   ;;; A function to access the route of the working-copy
   (defmethod routes ((working-copy basic-working-copy))
     "This function returns the routes of the solution in the given instance."
     (routes (solution working-copy)))
   #+END_SRC
** specialize the =cost= function for basic-working-copy
*** description
    In this section we especialize the generic function =cost= in the basic-working-copy class.  This is to not duplicate the slot in both cases, so we just access the cost of the basic-solution.
*** code (cost)
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
   ;;; A function to access the route of the working-copy
   (defmethod cost ((working-copy basic-working-copy))
     "This function returns the cost of the solution in the given working-copy."
     (cost (solution working-copy)))
   #+END_SRC
*** code (setf cost)
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
   ;;; A function to access the route of the working-copy
   (defmethod (setf cost) (new-cost (working-copy basic-working-copy))
     "This function setfs the cost of the solution in the given working-copy."
     (setf (cost (solution working-copy)) new-cost))
   #+END_SRC
*** test
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (with-basic-solution (s1 ((1 2 3) (4 5)))
      (let* ((wc (basic-working-copy s1)))

        (bformat t "Checking cost in the working-copy")
        (check-= 0 (cost s1))
        (check-= 0 (cost wc))
        (setf (cost s1) 100)
        (check-= 100 (cost wc))
        (setf (cost wc) 200)
        (check-= 200 (cost wc))
        (check-= 200 (cost (solution wc)))))
    #+END_SRC
** specialize the =depot= function for basic-working-copy
*** description
    In this section we especialize the generic function =depot= for the basic-working-copy class.  In this case (the basic-working-copy) the depot is always an instance of a =basic-depot= with id 0.
*** code (depot)
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
   ;;; A function to access the route of the working-copy
   (defmethod depot ((working-copy basic-working-copy))
     "This function returns a basic-depot with id 0."
     (basic-depot 0))
   #+END_SRC
*** test
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (with-basic-solution (s1 ((1 2 3) (4 5)))
      (let* ((wc (basic-working-copy s1)))

        (bformat t "Checking depot in the working-copy")
        (check-obj= (basic-depot) (depot wc))))
    #+END_SRC
** specialize the =end-depot= function for basic-working-copy
*** description
    In this section we especialize the generic function =end-depot= for the basic-working-copy class.  In this case (the basic-working-copy) the end-depot is always the =depot=.
*** code (depot)
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
   ;;; A function to access the route of the working-copy
   (defmethod end-depot ((working-copy basic-working-copy))
     "This function returns a basic-depot with id 0."
     (depot working-copy))
   #+END_SRC
*** test
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (with-basic-solution (s1 ((1 2 3) (4 5)))
      (let* ((wc (basic-working-copy s1)))

        (bformat t "Checking depot in the working-copy")
        (check-obj= (basic-depot) (depot wc))))
    #+END_SRC
** working-copy-with-infinite-fleet (actual class)
*** description
    This is a working class where the solution can have potentially inifitely many routes.  That is, it has an infinite fleet.  This is the working-copy that we should use in the CVRP.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    ;; A class for the insert-client operation
    (def-vrp-class working-copy-with-inifinite-fleet
        (basic-working-copy
         has-infinite-fleet)
      ;; no slots
      ()
      ;; the rest of the class elements
      :documentation "A working copy with potentially inifinitely many routes."
      :constructor (working-copy-with-infinite-fleet (solution))
      :slots-for-obj= (solution
                       initial-routes-lengths
                       number-of-routes
                       routes-lengths
                       insertions-made
                       selections-count
                       selected-clients
                       original-positions
                       selected-subroutes
                       selected-clients-during-apply)
      :slots-for-clone (solution
                        initial-routes-lengths
                        routes-lengths
                        number-of-routes
                        insertions-made
                        selections-count
                        selected-clients
                        original-positions
                        selected-subroutes
                        selected-clients-during-apply))
   #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (with-basic-solution (s1 ((1 2 3) (4 5)))
      (with-basic-solution (s2 ((1 2 3) (5 4)))
        (let* ((wc1 (working-copy-with-infinite-fleet s1))
               (wc2 (working-copy-with-infinite-fleet s2))
               (wc3 (clone wc1))
               (wc4 (clone wc2)))
          (format t "Testing working-copy-with-infinite-fleet")

          (format t "Printing the objects:~%")
          (loop for e in (list wc1 wc2 wc3 wc4)
                doing (format t "   working-copy-with-infinite-fleet: ~a~%" e))

          (deftests "Testing obj="
            (check-t (obj= wc1 wc1))
            (check-t (obj= wc1 wc3))
            (check-t (obj= wc2 wc4))

            (check-nil (obj= wc1 wc2))
            (check-nil (obj= wc1 wc4))
            (check-nil (obj= wc2 wc3))))))
    #+END_SRC


** function make-working-copy
*** description
    This is going to be a generic function that returns the appropriate working-copy according to the solution that is passed as argument.  For instance, if it is a basic solution, return a basic-working-copy, if it is a solution-with-inifite-fleet, it returns a working-copy-with-infinite-fleet, and so on.
*** generic function
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
   (defgeneric make-working-copy (solution)
     (:documentation "This function returns the appropriate working-copy according to the  solution passed as argument."))
   #+END_SRC
*** make-working-copy (basic-solution)
**** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (defmethod make-working-copy ((solution basic-solution))
      "Return an instance of basic-working-copy."
      (basic-working-copy solution))
    #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-solution (s1 ((1 2 3) (4 5 6)))
       (let* ((wc (make-working-copy s1)))
         (format t "Expect basic-working-copy: ~a~%"
                 (type-of wc))))
     #+END_SRC
*** make-working-copy (has-infinite-fleet)
**** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (defmethod make-working-copy ((solution basic-cvrp-solution))
      "Return an instance of working-copy-with-infinite-fleet."
      (working-copy-with-infinite-fleet solution))
    #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-cvrp-solution (s1 ((1 2 3) (4 5 6)) a-n33-k6-problem )
       (let* ((wc (make-working-copy s1)))
         (format t "What is s1: ~a~%"
                 (subtypep (type-of s1) 'has-infinite-fleet))
         (format t "Expect working-copy-with-inifinite-fleet: ~a~%"
                 (type-of wc))))
     #+END_SRC
    

* API to manipulate some of the basic classes
** get-client-with-id
*** description
    This function receives a problem and an id and returns the client with the given id in that problem.  It will be an ordinary function.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (defun get-client-with-id (id problem)
      "Returns the client with the given id in the given problem"
      (loop for c in (clients problem)
            when (= (id c) id) do (return c)))
    #+END_SRC
*** tests
  #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
  (with-basic-clients (1 2 3 4 5 6)

    (format t "===========================
  Testing get-client-with-id:
  ===========================~2%")
    (let* ((d1 (basic-depot 1))
           (p1 (basic-problem
                :id 1 :clients (list c1 c2 c3 c4 c5 c6) :depot d1)))
      (loop for i from 1 to 6
            doing (format t "With id ~a: ~a~%" i
                          (get-client-with-id i p1)))

      (format t "~%A client that is not there (7): ~a~%"
              (get-client-with-id 7 p1))))
  #+END_SRC

  #+RESULTS:
  : With id 1: <c:1>
  : With id 2: <c:2>
  : With id 3: <c:3>
  : With id 4: <c:4>
  : With id 5: <c:5>
  : With id 6: <c:6>
  :
  : A client that is not there (7): NIL
** get-vehicle-with-id
*** description
    This function receives a problem and an id and returns the vehicle with the given id in that problem.  It will be an ordinary function.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (defun get-vehicle-with-id (id problem)
      "Returns the vehicle with the given id in the given problem"
      (loop for v in (fleet problem)
            when (= (id v) id) do (return v)))
    #+END_SRC
*** tests
  #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
  (with-basic-clients (1 2 3 4 5 6)

    (bformat t "Testing get-vehicle-with-id:")
    (let* ((d1 (basic-depot 1))
           (v1 (basic-vehicle 1))
           (v2 (basic-vehicle 2))
           (v3 (basic-vehicle 3))
           (p1 (finite-fleet-cvrp-problem 
                :id 1
                :clients (list c1 c2 c3 c4 c5 c6)
                :depot d1
                :fleet (list v1 v2 v3))))
      (loop for i from 1 to 3
            doing (format t "With id ~a: ~a~%" i
                          (get-vehicle-with-id i p1)))

      (format t "~%A vehicle that is not there (4): ~a~%"
              (get-vehicle-with-id 7 p1))))
  #+END_SRC

** get-distance-from-to
*** description
    This function receives two has-id instances and a distance-problem and an id and returns the distance from the first instance to the second in that problem.  It will be a generic-function because I want it to be as flexible as possible.
*** code
**** generic-function
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defgeneric get-distance-from-to (from to problem)
        (:documentation "Returns the distance from the first point to the second in the given problem."))
      #+END_SRC
**** method (has-id has-id distance-problem)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defmethod get-distance-from-to ((from has-id)
                                       (to has-id)
                                       (problem distance-problem))
        "Returns the distance from the first point to the second in the given distance-problem."
        (aref (distance-matrix problem) (id from) (id to)))
      #+END_SRC

***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((distance #2A ((0 1 2 3)
                            (1 0 4 5)
                            (2 4 0 6)
                            (3 5 6 0)))
             (dp (make-instance 'distance-problem
                                :distance-matrix distance))
             (d0 (basic-depot))
             (c1 (basic-client 1))
             (c2 (basic-client 2))
             (c3 (basic-client 3)))
        (format t "=============================
      Testing get-distance-from-to:
      =============================~2%")
        (check-= 0 (get-distance-from-to d0 d0 dp))
        (check-= 1 (get-distance-from-to d0 c1 dp))
        (check-= 2 (get-distance-from-to d0 c2 dp))
        (check-= 3 (get-distance-from-to d0 c3 dp))

        (check-= 1 (get-distance-from-to c1 d0 dp))
        (check-= 0 (get-distance-from-to c1 c1 dp))
        (check-= 4 (get-distance-from-to c1 c2 dp))
        (check-= 5 (get-distance-from-to c1 c3 dp)))
      #+END_SRC
** product-demand (for multi-product-demand-clients)
*** description
    This function receives a product and a multi-product-demand-client and returns the demand of that client for that product.
*** code
**** generic-function
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defgeneric product-demand (product client)
        (:documentation "Returns the demand of the given product in the client."))
      #+END_SRC
**** method (basic-product multi-product-demand-client)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defmethod product-demand ((product basic-product)
                                 (client multi-product-demand-client))
        "Returns the demand of the product in the given multi-product-demand client."
        (gethash (id product) (products-demand client)))
      #+END_SRC

***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((p1 (basic-product 1 "oil"))
             (p2 (basic-product 2 "gas"))
             (p3 (basic-product 3 "bread"))
             (p4 (basic-product 4 "meat"))
             (plist (list p1 p2 p3 p4))
             (c1 (make-instance 'multi-product-demand-client
                                :products (list p1 p2 p3 p4))))
        ;; let's initialize the demands
        (loop for p in plist
              for i from 1
              doing (setf (gethash (id p) (products-demand c1)) (* 10 i)))

        (bformat t "Testing products-demand")

        (loop for p in plist
              for i from 1
              doing (check-= (* 10 i) (product-demand p c1))))
      #+END_SRC

      #+RESULTS:
      : =========================
      :  Testing products-demand
      : =========================
      :
** setf product-demand (for multi-product-demand-clients)
*** description
    This function sets the demand for a given product in a multi-product-demand-client.  It receives the product, the demand and the vehicle.
*** code
**** generic-function
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defgeneric set-product-demand (product client demand)
        (:documentation "Sets the demand for a given product in a multi-product-demand-client."))
      #+END_SRC
**** method (basic-product multi-product-demand-client number)
***** code (generic-function and method)
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defgeneric (setf product-demand)
          (new-value product client)
        (:documentation "Sets the demand for a given product in a multi-product-demand-client."))

      (defmethod (setf product-demand)
          ((new-value number)
           (product basic-product)
           (client multi-product-demand-client))
        "Sets the demand for a given product in a multi-product-demand-client."
        (setf (gethash (id product) (products-demand client)) new-value))
      #+END_SRC

***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((p1 (basic-product 1 "oil"))
             (p2 (basic-product 2 "gas"))
             (p3 (basic-product 3 "bread"))
             (p4 (basic-product 4 "meat"))
             (plist (list p1 p2 p3 p4))
             (c1 (make-instance 'multi-product-demand-client
                                :products (list p1 p2 p3 p4))))
        ;; let's initialize the demands
        (loop for p in plist
              for i from 1 to 3
              doing (set-product-demand p c1 (* 10 i)))

        (bformat t "Testing set-products-demand")

        (loop for p in plist
              for i from 1 to 3
              doing (check-= (* 10 i) (product-demand p c1)))

        (check-nil (product-demand p4 c1)))
      #+END_SRC
** compartment-capacity (for multi-compartment-vehicles)
*** description
    This function receives a product and a multi-compartment-vehicle and returns the capacity of that vehicle for that product.  This is because of some abstraction someone made when solving one specific problem.
*** code
**** generic-function
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defgeneric compartment-capacity (product vehicle)
        (:documentation "Returns the capacity of the given compartment in the vehicle."))
      #+END_SRC
**** method (basic-product multi-compartment-vehicle)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defmethod compartment-capacity ((compartment basic-product)
                                       (vehicle multi-compartment-vehicle))
        "Returns the demand of the product in the given multi-product-demand client."
        (gethash (id compartment) (compartments-capacity vehicle)))
      #+END_SRC

***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((p1 (basic-product 1 "oil"))
             (p2 (basic-product 2 "gas"))
             (p3 (basic-product 3 "bread"))
             (p4 (basic-product 4 "meat"))
             (plist (list p1 p2 p3 p4))
             (v1 (make-instance 'multi-compartment-vehicle
                                :number-of-compartments 4)))
        ;; let's initialize the demands
        (loop for p in plist
              for i from 1 to 3
              doing (setf (gethash (id p) (compartments-capacity v1)) (* 10 i)))

        (bformat t "Testing compartment-capacity")

        (loop for p in plist
              for i from 1 to 3
              doing (check-= (* 10 i) (compartment-capacity p v1)))

        (check-nil (compartment-capacity p4 v1)))
      #+END_SRC

      #+RESULTS:
      : =========================
      :  Testing products-demand
      : =========================
      :
**** method (number multi-compartment-vehicle)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defmethod compartment-capacity ((compartment number)
                                       (vehicle multi-compartment-vehicle))
        "Returns the demand of the given compartment in the given multi-product-demand client."
        (gethash compartment (compartments-capacity vehicle)))
      #+END_SRC

***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((p1 1)
             (p2 2)
             (p3 3)
             (p4 4)
             (plist (list p1 p2 p3 p4))
             (v1 (make-instance 'multi-compartment-vehicle
                                :number-of-compartments 4)))
        ;; let's initialize the demands
        (loop for p in plist
              for i from 1 to 3
              doing (setf (gethash p (compartments-capacity v1)) (* 10 i)))

        (bformat t "Testing compartment-capacity with numbers")

        (loop for p in plist
              for i from 1 to 3
              doing (check-= (* 10 i) (compartment-capacity p v1)))

        (check-nil (compartment-capacity p4 v1)))
      #+END_SRC
**** generic function setf (number multi-compartment-vehicle)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defgeneric (setf compartment-capacity)
          (new-value compartment vehicle)
        (:documentation "Sets the demand of the given compartment in the given multi-product-demand client to the new-value."))
      #+END_SRC

**** method setf (number multi-compartment-vehicle)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defmethod (setf compartment-capacity)
          ((new-value number)
           (compartment number)
           (vehicle multi-compartment-vehicle))
        "Sets the demand of the given compartment in the given multi-product-demand client to the new-value."
        (setf (gethash compartment (compartments-capacity vehicle)) new-value))
      #+END_SRC

***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((p1 1)
             (p2 2)
             (p3 3)
             (p4 4)
             (plist (list p1 p2 p3 p4))
             (v1 (make-instance 'multi-compartment-vehicle
                                :number-of-compartments 4)))
        ;; let's initialize the demands
        (loop for p in plist
              for i from 1 to 3
              doing (setf (gethash p (compartments-capacity v1)) (* 10 i)))

        (bformat t "Testing compartment-capacity with numbers")

        (loop for p in plist
              for i from 1 to 3
              doing (check-= (* 10 i) (compartment-capacity p v1)))

        (check-nil (compartment-capacity p4 v1)))
      #+END_SRC
**** method setf (product multi-compartment-vehicle)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defmethod (setf compartment-capacity)
          ((new-value number)
           (compartment basic-product)
           (vehicle multi-compartment-vehicle))
        "Sets the demand of the given compartment in the given multi-product-demand client to the new-value."
        (setf (gethash (id compartment)
                       (compartments-capacity vehicle))
              new-value))
      #+END_SRC

***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((p1 1)
             (p2 2)
             (p3 3)
             (p4 4)
             (plist (list p1 p2 p3 p4))
             (v1 (make-instance 'multi-compartment-vehicle
                                :number-of-compartments 4)))
        ;; let's initialize the demands
        (loop for p in plist
              for i from 1 to 3
              doing (setf (gethash p (compartments-capacity v1)) (* 10 i)))

        (bformat t "Testing compartment-capacity with numbers")

        (loop for p in plist
              for i from 1 to 3
              doing (check-= (* 10 i) (compartment-capacity p v1)))

        (check-nil (compartment-capacity p4 v1)))
      #+END_SRC
** set-compartment-capacity (for multi-compartment-vehicles)
*** description
    This function receives a product and a multi-compartment-vehicle and a value and sets the capacity of that vehicle for that product.  This is because of some abstraction that someone did when solving one specific problem.
*** code
**** generic-function
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defgeneric set-compartment-capacity (product vehicle value)
        (:documentation "Sets the capacity of the given compartment in the vehicle to the given value."))
      #+END_SRC
**** method (basic-product multi-compartment-vehicle)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defmethod set-compartment-capacity
          ((compartment basic-product)
           (vehicle multi-compartment-vehicle)
           (value number))
        "Sets the capacity of the compartment (identified by product) in the given multiple compartment vehicle to the given value."
        (setf (gethash (id compartment) (compartments-capacity vehicle))
              value))
      #+END_SRC

***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((p1 (basic-product 1 "oil"))
             (p2 (basic-product 2 "gas"))
             (p3 (basic-product 3 "bread"))
             (p4 (basic-product 4 "meat"))
             (plist (list p1 p2 p3 p4))
             (v1 (make-instance 'multi-compartment-vehicle
                                :number-of-compartments 4)))
        ;; let's initialize the demands
        (loop for p in plist
              for i from 1 to 3
              doing (set-compartment-capacity p v1  (* 10 i)))

        (bformat t "Testing set-compartment-capacity")

        (loop for p in plist
              for i from 1 to 3
              doing (check-= (* 10 i) (compartment-capacity p v1)))

        (check-nil (compartment-capacity p4 v1)))
      #+END_SRC

      #+RESULTS:
      : =========================
      :  Testing products-demand
      : =========================
      :
**** method (number multi-compartment-vehicle)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defmethod compartment-capacity ((compartment number)
                                       (vehicle multi-compartment-vehicle))
        "Returns the demand of the given compartment in the given multi-product-demand client."
        (gethash compartment (compartments-capacity vehicle)))
      #+END_SRC

***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((p1 1)
             (p2 2)
             (p3 3)
             (p4 4)
             (plist (list p1 p2 p3 p4))
             (v1 (make-instance 'multi-compartment-vehicle
                                :number-of-compartments 4)))
        ;; let's initialize the demands
        (loop for p in plist
              for i from 1 to 3
              doing (setf (gethash p (compartments-capacity v1)) (* 10 i)))

        (bformat t "Testing compartment-capacity with numbers")

        (loop for p in plist
              for i from 1 to 3
              doing (check-= (* 10 i) (compartment-capacity p v1)))

        (check-nil (compartment-capacity p4 v1)))
      #+END_SRC
** client-is-compatible-with-vehicle (for clients-constrained-vehicle)
*** description
    This function receives a client and clients-constrained-vehicle, and returns non nil if the vehicle can visit that client.
*** code
**** generic-function
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defgeneric client-is-compatible-with-vehicle (client vehicle)
        (:documentation "Returns non nil if the vehicle can visit that client."))
      #+END_SRC
**** method (basic-client clients-constrained-vehicle)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      (defmethod client-is-compatible-with-vehicle
          ((client basic-client)
           (vehicle clients-constrained-vehicle))
        "Returns non nil if the vehicle can visit that client."
        (member client (compatible-clients vehicle) :test #'obj=))
      #+END_SRC

***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((c1 (basic-client 1))
             (c2 (basic-client 2))
             (c3 (basic-client 3))
             (c4 (basic-client 4))
             (v1 (make-instance 'clients-constrained-vehicle
                                :compatible-clients (list c1 c3)))
             (v2 (make-instance 'clients-constrained-vehicle
                                :compatible-clients (list c1 c2 c3))))
        ;; let's initialize the demands


        (bformat t "Testing client-is-compatible-with-vehicle")

        (check-non-nil (client-is-compatible-with-vehicle c1 v1))
        (check-non-nil (client-is-compatible-with-vehicle c3 v1))
        (check-non-nil (client-is-compatible-with-vehicle c1 v2))
        (check-non-nil (client-is-compatible-with-vehicle c2 v2))
        (check-non-nil (client-is-compatible-with-vehicle c3 v2))
        (check-nil     (client-is-compatible-with-vehicle c2 v1)))
      #+END_SRC

      #+RESULTS:
      : =========================
      :  Testing products-demand
      : =========================
      :
** get-simpler-operations-from
*** description
    Some neighborhood operations can be decomposed into several simpler operations.  For instance, a swap can be decomposed into two insertions, and a select-subroute can be decomposed into several client-selections.

    This function does this.  For a given neighborhood-operation it returns a list with all the simpler operations into which the operation can be decomposed.  It the case of operations than can't be decomposed any further, this function should return a one-element list with the operation.  That's the case of the operation-select-client and operation-insert-client.
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (defgeneric get-simpler-operations-from (operation working-copy)
       (:documentation "Returns a list with all the (simpler) operations into which the given operation can be decomposed.  The elements in this list are the ones that should be passed to simulate-neighborhood-operation and to the delta-cost-computation methods."))
     #+END_SRC
*** method (t basic-working-copy)
**** description
     We are going to assume that, by default, a neighborhood-operation is simple enough and does not decompose into simpler operations.  We are going to do that by specializing the generic-function into t as the first arg.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (defmethod get-simpler-operations-from
         (op (wc basic-working-copy))
       "By default, a neighborhood-operation does not decompose into simpler operations, so this method returns a list with the operation."
       (list op))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-solution (s1 ((1 2 3)))
       (let* ((wc (basic-working-copy s1))
              (op1 (op-select-client 1 1 0))
              (op2 (op-insert-client 1 1 1)))
         (check-obj= (list op1) (get-simpler-operations-from op1 wc))
         (check-obj= (list op2) (get-simpler-operations-from op2 wc))))
     #+END_SRC


* Macros to deal with disposable instances
** macro with-basic-clients
*** documentation
    This macro will receive a list with integers and create symbols of the form cn bounds to a basic client with id n.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
    (defmacro with-basic-clients ((&rest ids) &body body)
      (let* ((symbols (mapcar (lambda (n) (symb "c" n))
                                      ids))
              (instances (mapcar (lambda (n) `(basic-client ,n))
                                      ids)))
         `(let* (,@(loop for s in symbols
                         for c in instances
                         collecting (list s c)))
            ,@body)))
    #+END_SRC
*** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (progn
       (bformat t "Testing with-basic-clients")
       (with-basic-clients (1 2 3 4 5)
         (format t "  ~a~%" c1)
         (format t "  ~a~%" c2)
         (format t "  ~a~%" c3)
         (format t "  ~a~%" c4)
         (format t "  ~a~%" c5)))
     #+END_SRC
** macro with-basic-solution
*** documentation
    The idea is to have a macro such as:

    #+BEGIN_EXAMPLE
    (with-basic-solution ((s1 ((1 2 3) (4 5) (6))))
      ...  some code here)
    #+END_EXAMPLE

    That should expand into

    #+BEGIN_EXAMPLE
    (let* ((s1 (make-basic-solution-from-list 1 '((1 2 3) (4 5) (6)))))
      ...  some code here)
    #+END_EXAMPLE

    Another example could be

    #+BEGIN_EXAMPLE
    (with-basic-solution ((s1 ((1 2 3) (4 5) (6)) 2))
      ...  some code here)
    #+END_EXAMPLE

    That should expand into

    #+BEGIN_EXAMPLE
    (let* ((s1 (make-basic-solution-from-list 2 '((1 2 3) (4 5) (6)))))
      ...some code here)
    #+END_EXAMPLE


    The number after the clients list is an optional parameter with the id for the solution.  It defaults to 1.

    And it creates a basic-solution =s1= with the given routes.  The numbers in the lists are =clients-id=.

    To do that I'll create a function to create a basic solution from a list and then use it to write the macro.
*** help functions
**** make-route-from-list
***** documentation
      The name of the section should be self explanatory.  It also receives the route-id and the vehicle-id.

      Maybe I should check if the depot should be passed as argument.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      ;;; make-basic-route-from-list function
      (defun make-basic-route-from-list (route-id clients-id vehicle-id
                                         &optional (depot-id 0))
        "This functions receives a list with the id of the clients in the route and a number with the vehicle-id.
        For example:
         (make-basic-route-from-list 3 (1 2 3) 2)
       returns the route:
         r3: c1, c2, c3, v2."
        ;; first we create the clients
        (let* ((clients (loop for c in clients-id
                              collecting (basic-client c)))
               ;; the vehicle
               (vehicle (basic-vehicle vehicle-id))
               (depot (basic-depot depot-id)))
          ;; return the route
          (basic-route :id route-id
                       :clients clients
                       :depot depot
                       :vehicle vehicle)))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (print (make-basic-route-from-list 1 '(1 2 3) 1))
      (print (make-basic-route-from-list 2 '(4 5) 2))
      (print (make-basic-route-from-list 3 '(6) 3))
      (print (make-basic-route-from-list 3 '(6) 3 2))
      #+END_SRC
**** make-basic-solution-from-list
***** description
      The idea is to receive a list with the routes as in

      #+BEGIN_EXAMPLE
      ((1 2 3) (4 5) (6 7 8))
      #+END_EXAMPLE

      and return a basic solution with three routes, each with clients with those ids, a global depot and a vehicle for each of them.

      It should be easy to implement, but I'm going to use some help functions to make the code shorter.

***** code
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-classes.lisp
      ;;; make-basic-solution-from-list function
      (defun make-basic-solution-from-list (sol-id routes)
        "This functions receives a list that represent a basic solution.  The elements of the list are list with numbers.  The numbers represent the id of the clients in the route.  For example:
         ((1 2 3) (4 5) (6 7 8))
       represents the solution:
         S1:
           r1: c1, c2, c3
           r2: c4, c5
           r3: c6, c7, c8
      For each route we create a basic vehicle, and for the solution we also create a depot."
        (let* ((depot-id 0)
               (actual-routes (loop for element in routes
                                    for id from 1
                                    collecting (make-basic-route-from-list
                                                id element id depot-id))))
          ;; return the solution
          (basic-solution :id sol-id :routes actual-routes)))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (print (make-basic-solution-from-list 1 '((1 2 3) (4 5) (6))))
      (print (make-basic-solution-from-list 2 '((1 3) (2 4 5) (6))))
      #+END_SRC
*** code for the macro
**** description
     The idea for the macro is simple is just a let that calls the make-basic-solution-from-list function.

     Something important to take into account is that this macro quotes the argument =routes=, so it cannot be used to create the solutions from a list in a variable.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-classes.lisp
     ;;; with-basic-solution
     (defmacro with-basic-solution ((solution-name
                                     routes
                                     &optional (id 1))
                                    &body body)

       `(let* ((,solution-name (make-basic-solution-from-list
                                ,id ',routes)))
          ,@body))
     #+END_SRC

**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-solution (s1 ((1 2 3) (4 5) (6)))
       (format t "~%Id of the solution: ~a" (id s1))
       (print s1))

     (with-basic-solution (s3 ((1 2 3) (4 5) (6)) 2)
       (format t "~%Id of the solution: ~a" (id s3))
       (print s3))
     #+END_SRC
** macro with-basic-cvrp-solution
   :PROPERTIES:
   :CUSTOM_ID: macro:with-basic-cvrp-solution
   :END:

*** documentation
    The idea is to have a macro such as:

    #+BEGIN_EXAMPLE
    (with-basic-cvrp-solution ((s1 ((1 2 3) (4 5) (6)) p1))
      ...  some code here)
    #+END_EXAMPLE

    That should expand into

    #+BEGIN_EXAMPLE
    (let* ((s1 (make-basic-cvrp-solution-from-list
                  1 '((1 2 3) (4 5) (6)) p1)))
      ...  some code here)
    #+END_EXAMPLE

    Another example could be

    #+BEGIN_EXAMPLE
    (with-basic-solution ((s1 ((1 2 3) (4 5) (6)) p2 2))
      ...  some code here)
    #+END_EXAMPLE

    That should expand into

    #+BEGIN_EXAMPLE
    (let* ((s1 (make-basic-solution-from-list
                2 '((1 2 3) (4 5) (6)) p2)))
      ...some code here)
    #+END_EXAMPLE


    The number after the problem is an optional parameter with the id for the solution.  It defaults to 1.

    This macro creates a basic-cvrp-solution =s1= with the given routes.  The numbers in the lists are =clients-id=.  The clients are taken from the problem passed as arguments.  In the examples, this problem is p1 and p2.

    To do that I'll create a function to create a basic-cvrp-solution from a list and then use it to write the macro.
*** help functions
**** make-route-from-list
***** documentation
      The name of the section should be self explanatory.  It also receives the route-id and the vehicle-id.  The class of the vehicle will be cvrp-vehicle.  The class of the route will be route-for-simulation.

***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      ;;; make-basic-route-from-list function
      (defun make-basic-cvrp-route-from-list
          (route-id clients-id v-id problem)
        "This functions receives a list with the id of the clients in the route and a number with the vehicle-id.  It also receives a cvrp-problem.
        For example:
         (make-basic-route-from-list 3 (1 2 3) 2 p1)
       returns a simulation-route:
         r3: c1, c2, c3, v2.
       where c1, c2, and c3 are taken from the clients in the problem."
        ;; first we create the clients
        (let* ((clients (loop for c in clients-id
                              collect (get-client-with-id c problem)))
               ;; the vehicle
               (vehicle (cvrp-vehicle v-id (capacity problem)))
               (depot (depot problem)))
          ;; return the route
          (route-for-simulation :id route-id
                                :vehicle vehicle
                                :depot depot
                                :clients clients)))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (c1 (basic-cvrp-client 1 30))
             (c2 (basic-cvrp-client 2 20))
             (c3 (basic-cvrp-client 3 40))
             (c4 (basic-cvrp-client 4 50))
             (d0 (basic-depot))
             (v1 (cvrp-vehicle 1 50))
             (v2 (cvrp-vehicle 2 50))
             (r1 (route-for-simulation :id 1 :vehicle v1
                                       :depot d0 :clients (list c1 c2)))
             (r2 (route-for-simulation :id 2 :vehicle v2
                                       :depot d0 :clients (list c3 c4)))
             ;; (s1 (basic-solution :id 1 :routes (list r1 r2)))

             (distance #2A ((0 1 2 3 5)
                            (1 0 4 5 6)
                            (2 4 0 6 7)
                            (3 5 6 0 8)
                            (5 6 7 8 0)))
             (p1 (make-instance 'cvrp-problem
                                :depot d0
                                :id 1
                                :clients (list c1 c2 c3 c4)
                                :capacity 50
                                :distance-matrix distance))
             (action (basic-cvrp-action))
             (*vrp-logging* 0))
        (format t "=======================================
      Testing make-basic-cvrp-route-from-list
      =======================================~2%")
        (format t "Basic route from (1 2 3):~%  ~a~%"
                (make-basic-cvrp-route-from-list 1 '(1 2 3) 1 p1))
        (check-obj= r1 (make-basic-cvrp-route-from-list 1 '(1 2) 1 p1))
        (check-obj= r2 (make-basic-cvrp-route-from-list 2 '(3 4) 2 p1))
        (check-= 1 1)
        ;; (simulate-solution s1 dp action)
        ;; (check-= 23 (total-distance action))
        ;; (check-= 20 (capacity-violation action))
        ;; (check-= 20000 (total-penalty action))
        )
      #+END_SRC
**** make-basic-cvrp-solution-from-list
***** description
      The idea is to receive a list with the routes and a cvrp-problem as in

      #+BEGIN_EXAMPLE
      ((1 2 3) (4 5) (6 7 8) p1)
      #+END_EXAMPLE

      and return a basic-cvrp-solution with three routes, each with clients with those ids, the depot is the one in p1, and each vehicle is a cvrp-vehicle with the appropriate id.

***** code
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-classes.lisp
      ;;; make-basic-cvrp-solution-from-list function
      (defun make-basic-cvrp-solution-from-list (sol-id routes problem)
        "This functions receives a list that represent a basic solution.  The elements of the list are list with numbers.  The numbers represent the id of the clients in the route.  For example:
         (1 ((1 2 3) (4 5) (6 7 8)) p1)
       represents the solution:
         S1:
           r1: c1, c2, c3
           r2: c4, c5
           r3: c6, c7, c8
      For each route we create a cvrp-vehicle, and for the solution we use the depot specified in the problem."
        (let* ((actual-routes
                (loop for element in routes
                      for id from 1
                      collect (make-basic-cvrp-route-from-list
                               id element id problem))))
          ;; return the solution
          (basic-cvrp-solution :id sol-id :routes actual-routes)))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (c1 (basic-cvrp-client 1 30))
             (c2 (basic-cvrp-client 2 20))
             (c3 (basic-cvrp-client 3 40))
             (c4 (basic-cvrp-client 4 50))
             (d0 (basic-depot))
             (v1 (cvrp-vehicle 1 50))
             (v2 (cvrp-vehicle 2 50))
             (r1 (route-for-simulation :id 1 :vehicle v1
                                       :depot d0 :clients (list c1 c2)))
             (r2 (route-for-simulation :id 2 :vehicle v2
                                       :depot d0 :clients (list c3 c4)))
             (s1 (basic-cvrp-solution :id 1 :routes (list r1 r2)))

             (distance #2A ((0 1 2 3 5)
                            (1 0 4 5 6)
                            (2 4 0 6 7)
                            (3 5 6 0 8)
                            (5 6 7 8 0)))
             (p1 (make-instance 'cvrp-problem
                                :depot d0
                                :id 1
                                :clients (list c1 c2 c3 c4)
                                :capacity 50
                                :distance-matrix distance))
             (s2 (make-basic-cvrp-solution-from-list 1 '((1 2) (4 3)) p1))
             (action (basic-cvrp-action))
             (*vrp-logging* 0))

        (bformat t "Testing make-basic-cvrp-solution-from-list")

        (format t "Basic solution from ((1 2) (4 3)):~%~a~%"
                (make-basic-cvrp-solution-from-list 1 '((1 2) (4 3)) p1))

        (check-obj= s1 (make-basic-cvrp-solution-from-list 1 '((1 2) (3 4)) p1))

        (format t "Testing the simulation with the original solution:~%")
        (simulate-solution s1 p1 action)
        (check-= 23 (total-distance action))
        (check-= 40 (capacity-violation action))
        (check-= 40000 (total-penalty action))

        (format t "Testing the simulation with the automatic solution:~%")
        (simulate-solution s2 p1 action)
        (check-= 23 (total-distance action))
        (check-= 40 (capacity-violation action))
        (check-= 40000 (total-penalty action))
        )
      #+END_SRC
*** code for the macro
**** description
     The idea for the macro is simple is just a let* that calls the make-basic-cvrp-solution-from-list function.

     Something important to take into account is that this macro quotes the argument =routes=, so it cannot be used to create the solutions from a list in a variable.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-classes.lisp
     ;;; with-basic-cvrp-solution
     (defmacro with-basic-cvrp-solution ((solution-name
                                     routes
                                     problem
                                     &optional (id 1))
                                    &body body)

       `(let* ((,solution-name (make-basic-cvrp-solution-from-list
                                ,id ',routes ,problem)))
          ,@body))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (c1 (basic-cvrp-client 1 30))
            (c2 (basic-cvrp-client 2 20))
            (c3 (basic-cvrp-client 3 40))
            (c4 (basic-cvrp-client 4 50))
            (d0 (basic-depot))
            (v1 (cvrp-vehicle 1 50))
            (v2 (cvrp-vehicle 2 50))
            (r1 (route-for-simulation :id 1 :vehicle v1
                                      :depot d0 :clients (list c1 c2)))
            (r2 (route-for-simulation :id 2 :vehicle v2
                                      :depot d0 :clients (list c3 c4)))
            (s1 (basic-solution :id 1 :routes (list r1 r2)))

            (distance #2A ((0 1 2 3 5)
                           (1 0 4 5 6)
                           (2 4 0 6 7)
                           (3 5 6 0 8)
                           (5 6 7 8 0)))
            (p1 (make-instance 'cvrp-problem
                               :depot d0
                               :id 1
                               :clients (list c1 c2 c3 c4)
                               :capacity 50
                               :distance-matrix distance))
            (action (basic-cvrp-action))
            (*vrp-logging* 0))

       (bformat t "Testing make-basic-cvrp-solution-from-list")

       (with-basic-cvrp-solution (s2 ((1 2) (3 4)) p1)
         (format t "Basic solution from ((1 2) (4 3)):~%~a~%"
                 s2)

         (format t "type-of S1: ~a~%" (type-of S1))
         (check-obj= s1 s2)

         (format t "Testing the simulation with the original solution:~%")
         (simulate-solution s1 p1 action)
         (check-= 23 (total-distance action))
         (check-= 40 (capacity-violation action))
         (check-= 40000 (total-penalty action))

         (format t "Testing the simulation with the automatic solution:~%")
         (simulate-solution s2 p1 action)
         (check-= 23 (total-distance action))
         (check-= 40 (capacity-violation action))
         (check-= 40000 (total-penalty action))))
     #+END_SRC

** macro with-finite-fleet-cvrp-solution
   :PROPERTIES:
   :CUSTOM_ID: macro:with-finite-fleet-cvrp-solution
   :END:
*** documentation
    The idea is to have a macro such as:

    #+BEGIN_EXAMPLE
    (with-finite-fleet-cvrp-solution ((s1 ((1 1 2 3) (2 4 5) (6)) p1))
      ...  some code here)
    #+END_EXAMPLE

    That should expand into

    #+BEGIN_EXAMPLE
    (let* ((s1 (make-finite-fleet-cvrp-solution-from-list
                  1 '((1 2 3) (4 5) (6)) p1)))
      ...  some code here)
    #+END_EXAMPLE

    The number after the problem is an optional parameter with the id for the solution.  It defaults to 1.

    This macro creates a basic-solution =s1= where the routes are instances of route for simulation.  The numbers in the lists are =clients-id=.  The clients are taken from the problem passed as arguments.  The first element in the route is the id of the vehicle in the problem.

    To do that I'll create a function to create a basic-solution from a list and then use it to write the macro.
*** help functions
**** make-finite-fleet-route-from-list
***** documentation
      The name of the section should be self explanatory.  It also receives the route-id and the vehicle-id.  We'll use the vehicle with that vehicle-id in the problem fleet.

***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      ;;; make-basic-route-from-list function
      (defun make-finite-fleet-cvrp-route-from-list
          (route-id clients-id v-id problem)
        "This functions receives a list with the id of the clients in the route and a number with the vehicle-id.  It also receives a cvrp-problem.
        For example:
         (make-finite-fleet-route-from-list 3 (1 2 3) 2 p1)
       returns a simulation-route:
         r3: c1, c2, c3, v2.
       where c1, c2, and c3 are taken from the clients in the problem, and v2 should be a vehicle in the problem's fleet with id 2."
        ;; first we create the clients
        (let* ((clients (loop for c in clients-id
                              collect (get-client-with-id c problem)))
               ;; the vehicles
               (vehicle (get-vehicle-with-id v-id problem))
               (depot (depot problem)))
          ;; return the route
          (route-for-simulation :id route-id
                                :vehicle vehicle
                                :depot depot
                                :clients clients)))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (c1 (basic-cvrp-client 1 30))
             (c2 (basic-cvrp-client 2 20))
             (c3 (basic-cvrp-client 3 40))
             (c4 (basic-cvrp-client 4 50))
             (d0 (basic-depot))
             (v1 (cvrp-vehicle 1 50))
             (v2 (cvrp-vehicle 2 10))
             (r1 (route-for-simulation :id 1 :vehicle v1
                                       :depot d0 :clients (list c1 c2)))
             (r2 (route-for-simulation :id 2 :vehicle v2
                                       :depot d0 :clients (list c3 c4)))
             ;; (s1 (basic-solution :id 1 :routes (list r1 r2)))

             (distance #2A ((0 1 2 3 5)
                            (1 0 4 5 6)
                            (2 4 0 6 7)
                            (3 5 6 0 8)
                            (5 6 7 8 0)))
             (p1 (make-instance 'finite-fleet-cvrp-problem
                                :depot d0
                                :id 1
                                :clients (list c1 c2 c3 c4)
                                :fleet (list v1 v2)
                                :distance-matrix distance))
             (*vrp-logging* 0))
        (bformat t "Testing make-basic-cvrp-route-from-list")
        (format t "Basic route from (1 2 3):~%  ~a~%"
                (make-basic-cvrp-route-from-list 1 '(1 2 3) 2 p1))
        (check-obj= r1 (make-finite-fleet-cvrp-route-from-list 1 '(1 2) 1 p1))
        (check-obj= r2 (make-finite-fleet-cvrp-route-from-list 2 '(3 4) 2 p1))
        )
      #+END_SRC
**** make-finite-fleet-cvrp-solution-from-list
***** description
      The idea is to receive a list with the routes and a cvrp-problem as in

      #+BEGIN_EXAMPLE
      ((1 1 2 3) (2 4 5) (2 6 7 8) p1)
      #+END_EXAMPLE

      and return a finite-fleet-cvrp-solution with three routes, each with clients with those ids, the depot is the one in p1, and each vehicle is the vehicle in the problem with id equal to the first element in the route.

***** code
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-classes.lisp
      ;;; make-basic-cvrp-solution-from-list function
      (defun make-finite-fleet-cvrp-solution-from-list
          (sol-id routes problem)
        "This functions receives a list that represent a basic solution.  The elements of the list are list with numbers.  The numbers represent the id of the clients in the route, except the first number on each 'route', that represents the id of the vehicle in that route.  For example:
         (1 ((1 1 2 3) (3 4 5) (2 6 7 8)) p1)
       represents the solution:
         S1:
           r1: c1, c2, c3, v1
           r2: c4, c5,     v3
           r3: c6, c7, c8, v2
      For the solution we use the depot specified in the problem."
        (let* ((actual-routes
                (loop for element in routes
                      for id from 1
                      collect (make-finite-fleet-cvrp-route-from-list
                               id (cdr element) (car element) problem))))
          ;; return the solution
          (basic-solution :id sol-id :routes actual-routes)))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (c1 (basic-cvrp-client 1 30))
             (c2 (basic-cvrp-client 2 20))
             (c3 (basic-cvrp-client 3 40))
             (c4 (basic-cvrp-client 4 50))
             (d0 (basic-depot))
             (v1 (cvrp-vehicle 1 50))
             (v2 (cvrp-vehicle 2 50))
             (r1 (route-for-simulation :id 1 :vehicle v2
                                       :depot d0 :clients (list c1 c2)))
             (r2 (route-for-simulation :id 2 :vehicle v1
                                       :depot d0 :clients (list c3 c4)))
             (s1 (basic-solution :id 1 :routes (list r1 r2)))

             (distance #2A ((0 1 2 3 5)
                            (1 0 4 5 6)
                            (2 4 0 6 7)
                            (3 5 6 0 8)
                            (5 6 7 8 0)))
             (p1 (make-instance 'finite-fleet-cvrp-problem
                                :depot d0
                                :id 1
                                :clients (list c1 c2 c3 c4)
                                :fleet (list v1 v2)
                                :distance-matrix distance))
             (s2 (make-finite-fleet-cvrp-solution-from-list
                  1 '((2 1 2) (1 4 3)) p1))
             (action (basic-cvrp-action))
             (*vrp-logging* 0))

        (bformat t "Testing make-basic-cvrp-solution-from-list")

        (format t "Basic solution from ((1 2) (4 3)):~%~a~%"
                (make-finite-fleet-cvrp-solution-from-list
                 1 '((2 1 2) (1 3 4)) p1))

        (check-obj= s1 (make-finite-fleet-cvrp-solution-from-list
                        1 '((2 1 2) (1 3 4)) p1))

        (format t "Testing the simulation with the original solution:~%")
        (simulate-solution s1 p1 action)
        (check-= 23 (total-distance action))
        (check-= 40 (capacity-violation action))
        (check-= 40000 (total-penalty action))

        ;; (format t "Testing the simulation with the automatic solution:~%")
        ;; (simulate-solution s2 p1 action)
        ;; (check-= 23 (total-distance action))
        ;; (check-= 40 (capacity-violation action))
        ;; (check-= 40000 (total-penalty action))
        )
      #+END_SRC
*** code for the macro
**** description
     The idea for the macro is simple is just a let* that calls the make-finite-fleet-cvrp-solution-from-list function.

     Something important to take into account is that this macro quotes the argument =routes=, so it cannot be used to create the solutions from a list in a variable.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-classes.lisp
     ;;; with-basic-cvrp-solution
     (defmacro with-finite-fleet-cvrp-solution
         ((solution-name
           routes
           problem
           &optional (id 1))
          &body body)

       `(let* ((,solution-name (make-finite-fleet-cvrp-solution-from-list
                                ,id ',routes ,problem)))
          ,@body))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (c1 (basic-cvrp-client 1 30))
            (c2 (basic-cvrp-client 2 20))
            (c3 (basic-cvrp-client 3 40))
            (c4 (basic-cvrp-client 4 50))
            (d0 (basic-depot))
            (v1 (cvrp-vehicle 1 50))
            (v2 (cvrp-vehicle 2 50))
            (r1 (route-for-simulation :id 1 :vehicle v1
                                      :depot d0 :clients (list c1 c2)))
            (r2 (route-for-simulation :id 2 :vehicle v2
                                      :depot d0 :clients (list c3 c4)))
            (s1 (basic-solution :id 1 :routes (list r1 r2)))

            (distance #2A ((0 1 2 3 5)
                           (1 0 4 5 6)
                           (2 4 0 6 7)
                           (3 5 6 0 8)
                           (5 6 7 8 0)))
            (p1 (make-instance 'finite-fleet-cvrp-problem
                               :depot d0
                               :id 1
                               :clients (list c1 c2 c3 c4)
                               :fleet (list v1 v2)
                               :distance-matrix distance))
            (action (basic-cvrp-action))
            (*vrp-logging* 0))

       (bformat t "Testing make-basic-cvrp-solution-from-list")

       (with-finite-fleet-cvrp-solution (s2 ((1 1 2) (2 3 4)) p1)
         (format t "Basic solution from ((1 1 2) (2 3 4)):~%~a~%"
                 s2)

         (format t "type-of S1: ~a~%" (type-of S1))
         (format t "type-of p1: ~a~%" (type-of p1))
         (check-obj= s1 s2)

         (format t "Testing the simulation with the original solution:~%")
         (simulate-solution s1 p1 action)
         (check-= 23 (total-distance action))
         (check-= 40 (capacity-violation action))
         (check-= 40000 (total-penalty action))

         (format t "Testing the simulation with the automatic solution:~%")
         (simulate-solution s2 p1 action)
         (check-= 23 (total-distance action))
         (check-= 40 (capacity-violation action))
         (check-= 40000 (total-penalty action))
         ))
     #+END_SRC
** macro with-finite-fleet-end-depot-cvrp-solution
   :PROPERTIES:
   :CUSTOM_ID: macro:with-finite-fleet-end-depot-cvrp-solution
   :END:
*** documentation
    The idea is to have a macro such as:

    #+BEGIN_EXAMPLE
    (with-finite-fleet-cvrp-solution ((s1 ((1 1 2 3) (2 4 5) (6)) p1 2))
      ...  some code here)
    #+END_EXAMPLE

    where p1 is a finite-fleet-end-depot-cvrp-problem, and it should expand into

    #+BEGIN_EXAMPLE
    (let* ((s1 (make-finite-fleet-cvrp-solution-from-list
                  2 '((1 2 3) (4 5) (6)) p1)))
      ...  some code here)
    #+END_EXAMPLE

    The number after the problem is an optional parameter with the id for the solution.  It defaults to 1.

    This macro creates a =basic-cvrp-solution= s1 where the routes are instances of =route-for-simulation-with-end-depot=.  The numbers in the lists are =clients-id=.  The clients are taken from the problem passed as arguments.  The first element in the route is the id of the vehicle in the problem, and the =depot= and =end-depot= for each route are taken from the problem.

    To do that I'll create a function to create a basic-cvrp-solution from a list and then use it to write the macro.
*** help functions
**** make-finite-fleet-with-end-depot-route-cvrp-from-list
***** documentation
      The list has the id of the clients in the route.  It also receives the route-id and the vehicle-id.  We'll use the vehicle with that vehicle-id in the problem fleet, and the depot and end-depot will also be taken from the problem.

***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
      ;;; make-basic-route-from-list function
      (defun make-finite-fleet-with-end-depot-route-cvrp-from-list
          (route-id clients-id v-id problem)
        "This functions receives a list with the id of the clients in the route and a number with the vehicle-id.  It also receives a cvrp-problem.
        For example:
         (make-finite-fleet-route-from-list 3 (1 2 3) 2 p1)
       returns a simulation-route:
         r3: c1, c2, c3, v2, d0, d1.
       where c1, c2, and c3 are taken from the clients in the problem, v2 should be a vehicle in the problem's fleet with id 2, and d0 and d1 are the problem's depot and end-depot, respectively."
        ;; first we create the clients
        (let* ((clients (loop for c in clients-id
                              collect (get-client-with-id c problem)))
               ;; the vehicles
               (vehicle (get-vehicle-with-id v-id problem))
               (depot (depot problem))
               (end-depot (end-depot problem)))
          ;; return the route
          (route-for-simulation-with-end-depot
           :id route-id
           :vehicle vehicle
           :depot depot
           :end-depot end-depot
           :clients clients)))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (c1 (basic-cvrp-client 1 30))
             (c2 (basic-cvrp-client 2 20))
             (c3 (basic-cvrp-client 3 40))
             (c4 (basic-cvrp-client 4 50))
             (d0 (basic-depot))
             (d1 (basic-depot 5))
             (v1 (cvrp-vehicle 1 50))
             (v2 (cvrp-vehicle 2 10))
             (r1 (route-for-simulation-with-end-depot
                  :id 1
                  :vehicle v1
                  :depot d0
                  :end-depot d1
                  :clients (list c1 c2)))
             (r2 (route-for-simulation-with-end-depot
                  :id 2
                  :vehicle v2
                  :depot d0
                  :end-depot d1
                  :clients (list c3 c4)))

             (distance #2A ((0 1 2 3 5 6)
                            (1 0 4 5 6 7)
                            (2 4 0 6 7 9)
                            (3 5 6 0 8 9)
                            (5 6 7 8 0 1)
                            (3 5 6 4 8 0)))
             (p1 (make-instance 'finite-fleet-end-depot-cvrp-problem
                                :depot d0
                                :end-depot d1
                                :id 1
                                :clients (list c1 c2 c3 c4)
                                :fleet (list v1 v2)
                                :distance-matrix distance))
             (*vrp-logging* 0))
        (bformat t "Testing make-basic-cvrp-")
        (format t "Basic route with end-depot from (1 2 3):~%  ~a~%"
                (make-finite-fleet-with-end-depot-route-cvrp-from-list
                 1 '(1 2 3) 2 p1))
  
        (check-obj= r1 (make-finite-fleet-with-end-depot-route-cvrp-from-list
                        1 '(1 2) 1 p1))
        (check-obj= r2 (make-finite-fleet-with-end-depot-route-cvrp-from-list
                        2 '(3 4) 2 p1)))
      #+END_SRC
**** make-finite-fleet-with-end-depot-cvrp-solutions-from-list
***** description
      The idea is to receive a list with the routes and a finite-fleet-end-depot-cvrp-problem as in:

      #+BEGIN_EXAMPLE
      ((1 1 2 3) (2 4 5) (2 6 7 8) p1)
      #+END_EXAMPLE

      and return a =finite-fleet-cvrp-solution= with three routes, each with clients with those ids, the depots and end-depot are the ones in p1, and each vehicle is the vehicle in the problem with id equal to the first element in the route.

***** code
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-classes.lisp
      ;;; make-basic-cvrp-solution-from-list function
      (defun make-finite-fleet-with-end-depot-cvrp-solution-from-list
          (sol-id routes problem)
        "This functions receives a list that represent a cvrp solution.  The elements of the list are list with numbers.  The numbers represent the id of the clients in the route, except the first number on each 'route', that represents the id of the vehicle in that route.  For example:
         (1 ((1 1 2 3) (3 4 5) (2 6 7 8)) p1)
       represents the solution:
         S1:
           r1: c1, c2, c3, v1, d0, d1
           r2: c4, c5,     v3, d0, d1
           r3: c6, c7, c8, v2, d0, d1
      For each route we use the depot and end-depot specified in the problem."
        (let* ((actual-routes
                (loop for element in routes
                      for id from 1
                      collect
                      (make-finite-fleet-with-end-depot-route-cvrp-from-list
                       id (cdr element) (car element) problem))))
          ;; return the solution
          (basic-solution :id sol-id :routes actual-routes)))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (c1 (basic-cvrp-client 1 30))
             (c2 (basic-cvrp-client 2 20))
             (c3 (basic-cvrp-client 3 40))
             (c4 (basic-cvrp-client 4 50))
             (d0 (basic-depot))
             (d1 (basic-depot 5))
             (v1 (cvrp-vehicle 1 50))
             (v2 (cvrp-vehicle 2 10))
             (r1 (route-for-simulation-with-end-depot
                  :id 1
                  :vehicle v1
                  :depot d0
                  :end-depot d1
                  :clients (list c1 c2)))
             (r2 (route-for-simulation-with-end-depot
                  :id 2
                  :vehicle v2
                  :depot d0
                  :end-depot d1
                  :clients (list c3 c4)))

             (distance #2A ((0 1 2 3 5 6)
                            (1 0 4 5 6 7)
                            (2 4 0 6 7 9)
                            (3 5 6 0 8 9)
                            (5 6 7 8 0 1)
                            (3 5 6 4 8 0)))
             (p1 (make-instance 'finite-fleet-end-depot-cvrp-problem
                                :depot d0
                                :end-depot d1
                                :id 1
                                :clients (list c1 c2 c3 c4)
                                :fleet (list v1 v2)
                                :distance-matrix distance))
             (s1 (basic-solution :id 1 :routes (list r1 r2)))

             (*vrp-logging* 0))
        (bformat t "Testing make-finite-fleet-with-end-depot-route-cvrp-from-list")
        (format t "Basic solution with end-depot from ((1 1 2) (2 3 4)):~%  ~a~%"
                (make-finite-fleet-with-end-depot-cvrp-solution-from-list
                 1 '((1 1 2) (2 3 4)) p1))

        (check-obj= s1 (make-finite-fleet-with-end-depot-cvrp-solution-from-list
                         1 '((1 1 2) (2 3 4)) p1)))
      #+END_SRC
*** code for the macro
**** description
     The idea for the macro is simple is just a let* that calls the make-finite-fleet-with-end-depot-cvrp-solution-from-list function.

     Something important to take into account is that this macro quotes the argument =routes=, so it cannot be used to create the solutions from a list in a variable.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-classes.lisp
     ;;; with-basic-cvrp-solution
     (defmacro with-finite-fleet-end-depot-cvrp-solution
         ((solution-name
           routes
           problem
           &optional (id 1))
          &body body)

       `(let* ((,solution-name
                (make-finite-fleet-with-end-depot-cvrp-solution-from-list
                 ,id ',routes ,problem)))
          ,@body))
     #+END_SRC
**** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (c1 (basic-cvrp-client 1 30))
             (c2 (basic-cvrp-client 2 20))
             (c3 (basic-cvrp-client 3 40))
             (c4 (basic-cvrp-client 4 50))
             (d0 (basic-depot))
             (d1 (basic-depot 5))
             (v1 (cvrp-vehicle 1 50))
             (v2 (cvrp-vehicle 2 10))
             (r1 (route-for-simulation-with-end-depot
                  :id 1
                  :vehicle v1
                  :depot d0
                  :end-depot d1
                  :clients (list c1 c2)))
             (r2 (route-for-simulation-with-end-depot
                  :id 2
                  :vehicle v2
                  :depot d0
                  :end-depot d1
                  :clients (list c3 c4)))

             (distance #2A ((0 1 2 3 5 6)
                            (1 0 4 5 6 7)
                            (2 4 0 6 7 9)
                            (3 5 6 0 8 9)
                            (5 6 7 8 0 1)
                            (3 5 6 4 8 0)))
             (p1 (make-instance 'finite-fleet-end-depot-cvrp-problem
                                :depot d0
                                :end-depot d1
                                :id 1
                                :clients (list c1 c2 c3 c4)
                                :fleet (list v1 v2)
                                :distance-matrix distance))
             (s1 (basic-solution :id 1 :routes (list r1 r2)))

             (action (basic-cvrp-action))

             (*vrp-logging* 0))
        (bformat t "Testing with-finite-fleet-with-end-depot-solution")

        (with-finite-fleet-end-depot-cvrp-solution (s2 ((1 1 2) (2 3 4)) p1)

          (format t "Basic solution with the macro:~%  ~a~%" s2)

          (check-t (obj= s1 s2))

          (format t "Checking the evaluation of the solution s1:~%")
          (simulate-solution s1 p1 action)
          (format t "distance: ~a~%" (total-distance action))
          (format t "penalty: ~a~%" (total-penalty action))


          (format t "~%Checking the evaluation of the solution s2:~%")
          (setf action (basic-cvrp-action))
          (simulate-solution s2 p1 action)
          (format t "distance: ~a~%" (total-distance action))
          (format t "penalty: ~a~%" (total-penalty action))
    
          ))
      #+END_SRC




** macro with-cvrp-problem
*** description

    This macro receives a matrix (made up of lists) with the distances, and a list with the demands of the clients and returns an instance of a CVRP.

    The code should be something like:

    #+BEGIN_EXAMPLE
    (with-cvrp-problem (p1 :distances ((0 2 3 4)
                                       (5 0 6 7)
                                       (1 8 0 9)
                                       (4 5 1 0))
                           :demands (1 3 5 2)
                           :capacity 6)
       ...  do some things here with p1)
    #+END_EXAMPLE
*** help functions
**** make-clients-list-from-demands
***** description
      This function receives a list with the demands of the clients and returns a list with instances of demand-clients where the demand of each client is the one specified in the list.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-classes.lisp
      (defun make-demand-clients-from-demands (list-with-demands)
        "This function receives a list with demands and returns a list with instances of demand-client where the demand of the i-th client is the demand in the i-th position in the list."
        (loop for demand in list-with-demands
              for id from 1
              collecting (basic-cvrp-client id demand)))
       #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (progn

        (bformat t "Testing make-demand-clients-from-demands")

        (format t "Clients: ~a~%"
                (make-demand-clients-from-demands '(1 2 3 4 5 6)))
        (format t "Clients: ~a~%"
                (make-demand-clients-from-demands '(10 20 30 40 50 60)))
        (format t "Clients: ~a~%"
                (make-demand-clients-from-demands '(10 30 20 50 40 60))))
      #+END_SRC

      #+RESULTS:
      :
      : (<c1: 1> <c2: 2> <c3: 3> <c4: 4> <c5: 5> <c6: 6>)
      : (<c1: 10> <c2: 20> <c3: 30> <c4: 40> <c5: 50> <c6: 60>)
      : (<c1: 10> <c2: 30> <c3: 20> <c4: 50> <c5: 40> <c6: 60>)
**** make-cvrp-from-lists
***** description
      This function receives a list with the distances, a list with the demands and a number with the capacity and returns an instance of a cvrp.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-classes.lisp
      (defun make-cvrp-from-lists (distances demands capacity
                                   &optional (id 1))
        "This function receives a list with the distances, a list with the demands and a number with the capacity and returns an instance of a cvrp."
        (let* ((depot (basic-depot 0))
               (n (length demands))
               (clients (make-demand-clients-from-demands demands))
               ;; the dimension is 1+ because of the depot
               (matrix-dimensions (list (1+ n) (1+ n)))
               (d-matrix (make-array matrix-dimensions
                                     :initial-contents distances)))
          ;; return the problem with the new data
          (cvrp-problem :id id :clients clients :depot depot
                        :distance-matrix d-matrix :capacity capacity)))
       #+END_SRC
***** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((p1 (make-cvrp-from-lists `((0 2 3 4 5)
                                       (5 0 6 7 6)
                                       (1 8 0 9 8)
                                       (4 5 1 0 6)
                                       (1 2 3 4 0))
                                      `(1 3 5 2)
                                      6)))
      (print p1)
      (print (distance-matrix p1))
      (print (id p1))
      (print (clients p1)))
    #+END_SRC

*** code for the macro
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-classes.lisp
      (defmacro with-cvrp-problem ((pname
                                    &key distances demands capacity
                                    (id 1)) &body body)
        `(let ((,pname (make-cvrp-from-lists ,distances
                                             ,demands
                                             ,capacity
                                             ,id)))
           ,@body))
      #+END_SRC

**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5)
                                          (5 0 6 7 2 )
                                          (1 8 0 3 9)
                                          (4 5 1 0 5)
                                          (4 5 1 5 0))
                             :demands '(1 3 5 2)
                             :capacity 6)
      (print p1)
      (print (distance-matrix p1))
      (print (id p1))
      (print (clients p1)))
     #+END_SRC

     #+RESULTS:
     :
     : <CVRP 1: 4 clients, capacity 6.>
     : #2A((0 2 3 4 5) (5 0 6 7 2) (1 8 0 3 9) (4 5 1 0 5) (4 5 1 5 0))
     : 1
     : (<c1: 1> <c2: 3> <c3: 5> <c4: 2>)
** macro with-finite-fleet-cvrp-problem
*** description

    This macro receives a matrix (made up of lists) with the distances, a list with the demands of the clients, a list with the capacities of the vehicles in the fleet and returns an instance of a finite-fleet-cvrp-problem.

    The code should be something like:

    #+BEGIN_EXAMPLE
    (with-finite-fleet-cvrp-problem (p1 :distances ((0 2 3 4)
                                                    (5 0 6 7)
                                                    (1 8 0 9)
                                                    (4 5 1 0))
                                         :demands (1 3 5 2)
                                         :fleet (2 5 8))
       ...  do some things here with p1)
    #+END_EXAMPLE
*** help functions
**** make-cvrp-vehicles-list-from-capacities
***** description
      This function receives a list with the capacities of the vehicles and returns a list with instances of cvrp-clients where the capacity of each vehicle is the one specified in the list.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-classes.lisp
      (defun make-cvrp-vehicles-list-from-capacities (list-with-capacities)
        "This function receives a list with capacities and returns a list with instances of cvrp-vehicles where the capacity of the i-th vehicle is the number in the i-th position in the list."
        (loop for capacity in list-with-capacities
              for id from 1
              collecting (cvrp-vehicle id capacity)))
       #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (progn

        (bformat t "Testing make-demand-clients-from-demands")

        (format t "Vehicles: ~a~%"
                (make-cvrp-vehicles-list-from-capacities
                 '(1 2 3 4 5 6)))
        (format t "Vehicles: ~a~%"
                (make-cvrp-vehicles-list-from-capacities
                 '(10 20 30 40 50 60)))
        (format t "Vehicles: ~a~%"
                (make-cvrp-vehicles-list-from-capacities
                 '(10 30 20 50 40 60))))
      #+END_SRC

**** make-finite-fleet-cvrp-from-lists
***** description
      This function receives a list with the distances, a list with the demands and a list with the capacities of the fleet and returns an instance of a finite-fleet-cvrp-problem.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-classes.lisp
      (defun make-finite-fleet-cvrp-from-lists (distances demands capacities
                                   &optional (id 1))
        "This function receives a list with the distances, a list with the demands and a number with the capacity and returns an instance of a finite-fleet-cvrp."
        (let* ((depot (basic-depot 0))
               (n (length demands))
               (clients (make-demand-clients-from-demands demands))
               (vehicles (make-cvrp-vehicles-list-from-capacities capacities))
               ;; the dimension is 1+ because of the depot
               (matrix-dimensions (list (1+ n) (1+ n)))
               (d-matrix (make-array matrix-dimensions
                                     :initial-contents distances)))
          ;; return the problem with the new data
          (finite-fleet-cvrp-problem :id id
                                     :clients clients
                                     :depot depot
                                     :distance-matrix d-matrix
                                     :fleet vehicles)))
       #+END_SRC
***** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((p1 (make-finite-fleet-cvrp-from-lists `((0 2 3 4 5)
                                                    (5 0 6 7 6)
                                                    (1 8 0 9 8)
                                                    (4 5 1 0 6)
                                                    (1 2 3 4 0))
                                                  `(1 3 5 2)
                                                  `(1 2 5 4))))
      (format t "Finite-Fleet-Problem: ~a~%" p1)
      (format t "distance matrix: ~a~%" (distance-matrix p1))
      (format t "id: ~a~%" (id p1))
      (format t "clients: ~a~%" (clients p1))
      (format t "vehicles: ~a~%" (fleet p1)))
    #+END_SRC

*** code for the macro
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-classes.lisp
      (defmacro with-finite-fleet-cvrp-problem
          ((pname
            &key distances demands capacities
            (id 1)) &body body)
        `(let ((,pname (make-finite-fleet-cvrp-from-lists
                        ,distances
                        ,demands
                        ,capacities
                        ,id)))
           ,@body))
      #+END_SRC

**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-finite-fleet-cvrp-problem (p1 :distances `((0 2 3 4 5)
                                                      (5 0 6 7 2 )
                                                      (1 8 0 3 9)
                                                      (4 5 1 0 5)
                                                      (4 5 1 5 0))
                                         :demands '(1 3 5 2)
                                         :capacities '(4 5 3))
  
       (bformat t "Testing with-finite-fleet-cvrp-problem...")
  
       (format t "Finite-Fleet-Problem: ~a~%" p1)
       (format t "distance matrix: ~a~%" (distance-matrix p1))
       (format t "id: ~a~%" (id p1))
       (format t "clients: ~a~%" (clients p1))
       (format t "vehicles: ~a~%" (fleet p1)))
     #+END_SRC

     #+RESULTS:
     :
     : <CVRP 1: 4 clients, capacity 6.>
     : #2A((0 2 3 4 5) (5 0 6 7 2) (1 8 0 3 9) (4 5 1 0 5) (4 5 1 5 0))
     : 1
     : (<c1: 1> <c2: 3> <c3: 5> <c4: 2>)
** macro with-finite-fleet-end-depot-cvrp-problem
*** description

    This macro receives:
     - a matrix (made up of lists) with the distances,
     - a list with the demands of the clients,
     - a list with the capacities of the vehicles in the fleet

     and returns an instance of a finite-fleet-with-end-depot-cvrp-problem.

     The interesting thing here is that, in the end-depot slot we are going to store a depot whose =id= is n+1 where n is the number of clients.

    The code should be something like:

    #+BEGIN_EXAMPLE
    (with-finite-fleet-cvrp-problem (p1 :distances ((0 2 3 4 5 6)
                                                    (5 0 6 7 8 9)
                                                    (1 8 0 9 1 2)
                                                    (4 5 1 0 3 4)
                                                    (4 3 9 2 0 2)
                                                    (8 1 2 5 2 0))
                                         :demands (1 3 5 2)
                                         :fleet (2 5 8))
       ...  do some things here with p1)
    #+END_EXAMPLE

    Check in the previous example that the matrix has dimension 6 while there are only 4 clients.  That's because of the two depots.
    
*** help functions
**** make-finite-fleet-with-end-depot-cvrp-from-lists
***** description
      This function receives a list with the distances, a list with the demands and a list with the capacities of the fleet and returns an instance of a finite-fleet-end-depot-cvrp-problem.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-classes.lisp
      (defun make-finite-fleet-end-depot-cvrp-from-lists
          (distances demands capacities &optional (id 1))
        "This function receives a list with the distances, a list with the demands and a number with the capacity and returns an instance of a finite-fleet-cvrp."
        (let* ((n (length demands))
               (depot     (basic-depot 0))
               (end-depot (basic-depot (1+ n)))
               (clients (make-demand-clients-from-demands demands))
               (vehicles (make-cvrp-vehicles-list-from-capacities capacities))
               ;; the dimension is +2 because of the depot
               (matrix-dimensions (list (+ n 2) (+ n 2)))
               (d-matrix (make-array matrix-dimensions
                                     :initial-contents distances)))
          ;; return the problem with the new data
          (finite-fleet-end-depot-cvrp-problem :id id
                                               :clients clients
                                               :depot depot
                                               :end-depot end-depot
                                               :distance-matrix d-matrix
                                               :fleet vehicles)))
       #+END_SRC
***** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((p1 (make-finite-fleet-end-cvrp-from-lists `((0 2 3 4 5 6)
                                                        (5 0 6 7 8 9)
                                                        (1 8 0 9 1 2)
                                                        (4 5 1 0 3 4)
                                                        (4 3 9 2 0 2)
                                                        (8 1 2 5 2 0))
                                                      `(1 3 5 2)
                                                      `(2 5 8))))
      (format t "finite-fleet-end-depot-cvrp-problem: ~a~%" p1)

      (format t "distance matrix: ~a~3%" (distance-matrix p1))
      (format t "id:        ~a~%" (id p1))
      (format t "clients:   ~a~%" (clients p1))
      (format t "vehicles:  ~a~%" (fleet p1))
      (format t "depot:     ~a~%" (depot p1))
      (format t "end-depot: ~a~%" (end-depot p1)))
    #+END_SRC

*** code for the macro
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-classes.lisp
      (defmacro with-finite-fleet-end-depot-cvrp-problem
          ((pname
            &key distances demands capacities
            (id 1)) &body body)
        `(let ((,pname (make-finite-fleet-end-depot-cvrp-from-lists
                        ,distances
                        ,demands
                        ,capacities
                        ,id)))
           ,@body))
      #+END_SRC

**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-finite-fleet-end-depot-cvrp-problem
         (p1 :distances `((0 2 3 4 5)
                          (5 0 6 7 8)
                          (1 8 0 9 1)
                          (4 5 1 0 3)
                          (8 1 2 5 2))
              :demands '(1 3 2)
              :capacities '(4 5 3))

       (format t "finite-fleet-end-depot-cvrp-problem: ~a~%" p1)

       (format t "distance matrix: ~a~3%" (distance-matrix p1))
       (format t "id:        ~a~%" (id p1))
       (format t "clients:   ~a~%" (clients p1))
       (format t "vehicles:  ~a~%" (fleet p1))
       (format t "depot:     ~a~%" (depot p1))
       (format t "end-depot: ~a~%" (end-depot p1)))
     #+END_SRC

     #+RESULTS:
     :
     : <CVRP 1: 4 clients, capacity 6.>
     : #2A((0 2 3 4 5) (5 0 6 7 2) (1 8 0 3 9) (4 5 1 0 5) (4 5 1 5 0))
     : 1
     : (<c1: 1> <c2: 3> <c3: 5> <c4: 2>)
