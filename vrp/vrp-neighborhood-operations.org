#+TITLE: VRP solver environment
#+AUTHOR: Fernando Rodriguez Flores
#+AUTHOR: Eduardo Núñez de Villavicencio Sánchez
#+DATE 2018-08-19
#+TODO: TODO WIP BROKEN | DONE


* Description

  In this file I'm going to add the code for the new operations that are added to the suite.  Hopefully, this file can also be used as a source of tutorials on how to add operations to the suite.

  The src blocks in this file should be tangled to vrp-neighborhood-operations.lisp.

  
* add the package to the tangled file
  #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp 
  (in-package :vrp)
  #+END_SRC
  
  
* operation swap-clients (tutorial)
** description
   In this section I'm going to add the swap operation.

   The steps required to add a new operation are the following:

   1. create a new vrp-class for this operation
   2. write the methods to update the working-copy after this operation
   3. write the simulate-neighborhood-operation for this operation
   4. write the method get-simpler-operations-from
   5. write the methods to undo each of the actions
   6. write the undo-neighborhood-operation for this operation
   7. write the do-operation macro
   8. test it all.

   In some cases, some of these steps can be avoided, because we can express the new operation as a secuence of simpler operations.  That's what we are going to do with the swap that can be expressed as two insertions (in the appropriate positions.)

   In this case, to add the swap operation we only need to create the class, implement the method =get-simpler-operations-from= and write the doswap method.  We'll do that in the next sections.
** add the class for the swap-clients operation
*** description
   The class for the swap operation only requires the "indices" of the two selected clients.  In this context "index" refer to the select operation where the client was selected.  This is the =operand= of the select-client instance where the client was selected.  It is only the index of the client in the selected-clients array.

   The swap operation does not inherits from neighborhood-operation because we doesn't need a =route= or a =pos=.  Instead we need the indexes of the two clients that should be swapped.

*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp 
    (def-vrp-class operation-swap-clients ()
      ;; slots
      (;; the ids of the clients that should be swapped
       (client1)
       (client2))
      ;; the rest of the class elements
      :documentation "A class to represent the swap-clients operation in a neighborhood criterion."
      :constructor (op-swap-clients (client1 client2))
      :print-object-string ("<op:s ~a ~a>" client1 client2)
      :slots-for-obj= (client1 client2)
      :slots-for-clone (client1 client2))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((c1 (op-swap-clients 1 1))
           (c2 (op-swap-clients 2 1))
           (c3 (op-swap-clients 1 2))
           (c4 (clone c1))
           (c5 (clone c2)))
      (bformat t "Testing op-swap-clients...")

      (format t "Printing the objects:~%")
      (loop for e in (list c1 c2 c3 c4 c5)
            doing (format t "   op-swap-clients: ~a~%" e))

      (deftests "Testing obj="
        (check-t (obj= c1 c1))
        (check-t (obj= c1 c4))

        (check-nil (obj= c1 c2))
        (check-nil (obj= c1 c3))
        (check-nil (obj= c2 c3))
        (check-nil (obj= c3 c4))))
    #+END_SRC
** write the method get-simpler-operations-from
*** description
    With this method we return a list with the two insertions that are the result of this swap.  As the swap reduces to these two operations there is no need to implement any other method.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp 
    (defmethod  get-simpler-operations-from ((op operation-swap-clients)
                                             (wc basic-working-copy))
       "Here we return a list with the two insertions that should be made because of the swap operation."

       (let* ((c1 (client1 op))  ;; the selected-clients id of c1
              (c2 (client2 op)) ;; the selected-clients id of c2
              (c1-id (id (client-selected-at-operation c1 wc)))
              (c2-id (id (client-selected-at-operation c2 wc)))) 
         (symbol-macrolet
             ((c1-route (route-of-client-selected-at-operation c1 wc))
              (c1-pos (pos-of-client-selected-at-operation c1 wc))
              (c2-route (route-of-client-selected-at-operation c2 wc))
              (c2-pos (pos-of-client-selected-at-operation c2 wc)))

           (cond
             ((not (= c1-route c2-route)) ;; they were in different routes
              ;; so the orden doesn't matter.
              ;; Return the list in any order
              (list
               (op-insert-client c1-route c1-pos c2)
               (op-insert-client c2-route c2-pos c1)))
             ;; from here on they are on the same route
             ((< c1-pos c2-pos)
              ;; c1 was in a position before c2
              ;; so we need to insert first c2 were c1 was
              ;; and then c1 into 1+ from where c2 was
              ;; because they are in the same route, c1 was
              ;; selected first, and from a position smaller
              ;; than c2. When we insert c2 into c1's position
              ;; the 'original' position of c2 should be increased,
              ;; otherwise we get the insertions wrong
              (list
               (op-insert-client c1-route c1-pos c2)
               (op-insert-client c2-route (1+ c2-pos) c1)))
             ((< c2-pos c1-pos)
              ;; c2 was in a position before c1
              (list
               ;; so we need to insert first c1 were c2 was
               (op-insert-client c2-route c2-pos c1)
               ;; and now insert c1 into 1+ where c2 was.
               ;; We need to 1+ the position of c1 because now
               ;; we are "compiling" the position for the
               ;; second insertion and we need to take into
               ;; account that the first insertion will 1+ to the
               ;; position of all the clients after it.
               (op-insert-client c1-route (1+ c1-pos) c2)))
             ;; from here on they were on the same route and 
             ;; in the same position :-o
             ;; (they were one after the other)
             ((= c2-pos c1-pos)
              ;; We are assuming that there are not
              ;; selections after the first insertion is made,
              ;; so if we want to know which one should we insert first
              ;; we just need to check the new function
              ;; client-c1-was-before-client-c2
              ;; and insert first the one that was behind
              (if (client-c1-was-before-client-c2 c1-id c2-id wc) 
                  (then ;; c1 was before c2 so
         
                    (list
                     ;; first insert c2 into c1 position
                     (op-insert-client c1-route c1-pos c2)
                     ;; and then c1 into 1+ of c2's position
                     ;; because we are "compiling" the position
                     ;; of the second insertion, and the
                     ;; first one will add 1+ to all the positions
                     ;; after it, including the one we want to insert
                     (op-insert-client c2-route (1+ c2-pos) c1)))

                  (else ;; c2 was before c1
                    (list
                     ;; so we should first insert c1 into c2's pos
                     (op-insert-client c2-route c2-pos c1)
                     ;; and then insert c2 into 1+ c1's pos because
                     ;; of the explanation in the then's part
                     (op-insert-client c1-route (1+ c1-pos) c2)))))))))
    #+END_SRC

*** tests
**** swapping from different routes
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3) (4 5 6) (7)))
       (let* ((wc1 (basic-working-copy s1))
              (c1 0) (c2 1)
              (op1 (op-select-client 1 1 c1))
              (op2 (op-select-client 2 1 c2))
              (op3 (op-swap-clients c1 c2))
              ops1 ops2
              )

         (prepare-solution-for-neighborhood-exploration wc1)

         (bformat t "Testing swap from different routes.")
         (format t "Before doing anything: ~%")
         (pp-solution wc1 t)(terpri)

         (simulate-neighborhood-operation op1 wc1)
         (format t "After operation ~a~%" op1)
         (pp-solution wc1 t)(terpri)

         (simulate-neighborhood-operation op2 wc1)
         (format t "After operation ~a~%" op2)
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)

         (format t "Let's see the insertions from the swap ~a.~%" op3)
         (format t "operations from ~a: ~{~a ~}~%"
                 op3 (get-simpler-operations-from op3 wc1))
    
    
         (format t "Now let's simulate and check the final solution:")

         (dolist (op (get-simpler-operations-from op3 wc1))
           (simulate-neighborhood-operation op wc1))

         (format t "After operation ~a~%" op3)
         (pp-solution wc1 t)(terpri)

         ))
     #+END_SRC
**** swapping from different routes with extra selections
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3) (4 5 6) (7)))
       (let* ((wc1 (basic-working-copy s1))
              (c1 0) (c2 1) (c3 2)
              (op1 (op-select-client 1 1 c1))
              (op2 (op-select-client 2 1 c2))
              (op3 (op-select-client 2 1 c3))
              (op4 (op-swap-clients c1 c3))
              ops1 ops2
              )

         (prepare-solution-for-neighborhood-exploration wc1)

         (bformat t "Testing swap from different routes.")
         (format t "Before doing anything: ~%")
         (pp-solution wc1 t)(terpri)

         (dolist (op (list op1 op2 op3))
           (simulate-neighborhood-operation op wc1)
           (format t "After operation ~a~%" op)
           (pp-solution wc1 t) (terpri)
           (pp-selected-clients-array wc1) (terpri))

         (format t "Let's see the swap in action:")
         (dolist (op (get-simpler-operations-from op4 wc1))
           (simulate-neighborhood-operation op wc1))

         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri))

    
    

         ;; (format t "Let's see the insertions from the swap ~a.~%" op3)
         ;; (format t "operations from ~a: ~{~a ~}~%"
         ;;         op3 (get-simpler-operations-from op3 wc1))


         ;; (format t "Now let's simulate and check the final solution:")

         ;; (dolist (op (get-simpler-operations-from op3 wc1))
         ;;   (simulate-neighborhood-operation op wc1))

         ;; (format t "After operation ~a~%" op3)
         ;; (pp-solution wc1 t)(terpri)

         ))
     #+END_SRC
**** swapping from the same route c1 < c2
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3) (4 5 6) (7)))
       (let* ((wc1 (basic-working-copy s1))
              (c1 0) (c2 1)
              (op1 (op-select-client 1 1 c1))
              (op2 (op-select-client 1 2 c2))
              (op3 (op-swap-clients c1 c2))
              )

         (prepare-solution-for-neighborhood-exploration wc1)

         (bformat t "Testing swap from different routes.")
         (format t "Before doing anything: ~%")
         (pp-solution wc1 t)(terpri)

         (simulate-neighborhood-operation op1 wc1)
         (format t "After operation ~a~%" op1)
         (pp-solution wc1 t)(terpri)

         (simulate-neighborhood-operation op2 wc1)
         (format t "After operation ~a~%" op2)
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)

         (format t "Let's see the insertions from the swap ~a.~%" op3)
         (format t "operations from ~a: ~{~a ~}~%"
                 op3 (get-simpler-operations-from op3 wc1))


         (format t "Now let's simulate and check the final solution:")

         (dolist (op (get-simpler-operations-from op3 wc1))
           (simulate-neighborhood-operation op wc1))

         (format t "After operation ~a~%" op3)
         (pp-solution wc1 t)(terpri)

         ))
     #+END_SRC

**** swapping from the same route c1 < c2 with extra selection
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6) (7)))
       (let* ((wc1 (basic-working-copy s1))
              (c1 0) (c2 1) (c3 2)
              (op1 (op-select-client 1 1 c1))
              (op2 (op-select-client 1 3 c2))
              (op3 (op-select-client 1 2 c3))
              (op4 (op-swap-clients c1 c2)))

         (prepare-solution-for-neighborhood-exploration wc1)

         (bformat t "Testing swap from the same route.")
         (format t "Before doing anything: ~%")
         (pp-solution wc1 t)(terpri)

         (dolist (op (list op1 op2 op3))
           (simulate-neighborhood-operation op wc1))

         (format t "After selecting c1, c4 and then c3~%")
         (pp-solution wc1 t)(terpri)

         (dolist (op (get-simpler-operations-from op4 wc1))
           (simulate-neighborhood-operation op wc1))

         (format t "After swapping c1 and c4~%")
         (pp-solution wc1 t)(terpri)

         ))
     #+END_SRC

**** swapping from the same route c2 < c1
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3) (4 5 6) (7)))
       (let* ((wc1 (basic-working-copy s1))
              (c1 0) (c2 1)
              (op1 (op-select-client 1 3 c1))
              (op2 (op-select-client 1 1 c2))
              (op3 (op-swap-clients c1 c2))
              )

         (prepare-solution-for-neighborhood-exploration wc1)

         (bformat t "Testing swap from different routes.")
         (format t "Before doing anything: ~%")
         (pp-solution wc1 t)(terpri)

         (simulate-neighborhood-operation op1 wc1)
         (format t "After operation ~a~%" op1)
         (pp-solution wc1 t)(terpri)

         (simulate-neighborhood-operation op2 wc1)
         (format t "After operation ~a~%" op2)
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)

         (format t "Let's see the insertions from the swap ~a.~%" op3)
         (format t "operations from ~a: ~{~a ~}~%"
                 op3 (get-simpler-operations-from op3 wc1))


         (format t "Now let's simulate and check the final solution:")

         (dolist (op (get-simpler-operations-from op3 wc1))
           (simulate-neighborhood-operation op wc1))

         (format t "After operation ~a~%" op3)
         (pp-solution wc1 t)(terpri)

         ))
     #+END_SRC


**** swapping same route, c1 = c2, c1 first
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6)))
       (let* ((wc1 (basic-working-copy s1))
              (c1 0) (c2 1)
              (op1 (op-select-client 1 2 c1))
              (op2 (op-select-client 1 2 c2))
              (op3 (op-swap-clients c1 c2))
              )

         (prepare-solution-for-neighborhood-exploration wc1)

         (bformat t "Testing swap from the same route.")
         (format t "Before doing anything: ~%")
         (pp-solution wc1 t)(terpri)


         (dolist (op (list op1 op2))
           (simulate-neighborhood-operation op wc1))

         (format t "After selecting c2 and c3:~%")
         (pp-solution wc1 t) (terpri)


         ;; (format t "c1 before c2: ~a~%"
         ;;         (client-c1-was-before-client-c2
         ;;          (id (client-selected-at-operation c1 wc1))
         ;;          (id (client-selected-at-operation c2 wc1)) wc1))
    
         (dolist (op (get-simpler-operations-from op3 wc1))
           (simulate-neighborhood-operation op wc1))

         (format t "After operation ~a~%" op3)
         (pp-solution wc1 t)    (terpri)

         ))
     #+END_SRC

     
**** swapping same route, c1 = c2, c1 first extra selection
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6)))
       (let* ((wc1 (basic-working-copy s1))
              (c1 0) (c2 1) (c3 2)
              (op1 (op-select-client 1 2 c1))
              (op2 (op-select-client 1 3 c2))
              (op3 (op-select-client 1 2 c3))
              (op4 (op-swap-clients c1 c2))
              (op5 (op-insert-client 1 3 c3))
              )

         (prepare-solution-for-neighborhood-exploration wc1)

         (bformat t "Testing swap from the same route.")
         (format t "Before doing anything: ~%")
         (pp-solution wc1 t)(terpri)


         (dolist (op (list op1 op2 op3))
           (simulate-neighborhood-operation op wc1))

         (format t "After selecting c2, c4, and then c3:~%")
         (pp-solution wc1 t) (terpri)


         ;; (format t "c1 before c2: ~a~%"
         ;;         (client-c1-was-before-client-c2
         ;;          (id (client-selected-at-operation c1 wc1))
         ;;          (id (client-selected-at-operation c2 wc1)) wc1))

         (dolist (op (get-simpler-operations-from op4 wc1))
           (simulate-neighborhood-operation op wc1))

         (format t "After swapping ~a~%" op3)
         (pp-solution wc1 t)    (terpri)

         (simulate-neighborhood-operation op5 wc1)
         (pp-solution wc1 t)    (terpri)

         ))
     #+END_SRC

     

**** +swapping same route, c1 = c2, c2 first+
***** description
      I believe that this situation is not possible because the only way I can think of achieving this state is selecting after an insertion :-(
** add the doswap-clients macro
*** description
    In the doswap-clients macro we don't need to do many things because we only need to create the instance of the operation, get the simpler-operations, simulate them, do the user's action, and undo them.

    In the firs approach we'll write the macro from scratch because this macro is easy to write.  This is done in the section [[code (hand written)]].

    However, the doswap macro is a static-macro, in the sense that it does not traverse a route (or anything to make an exhaustive search of the neighborhood).  Because of this, we can create the code for this macro with very little code using the macro =make-do-neighborhood-static-macro=.  This is done in the section [[code (using make-do-neighborhood-static-macro)]].

*** +code (hand written)+
    #+BEGIN_SRC lisp +n -r :results none :exports code 
    (defmacro doswap-clients ((client1 client2 working-copy) &body body)
      "Pushes into ops-lists the insertions that should be made because of this swap, do whatever the users wants to do, and restores everything to the previous state.

    client1  is the index of the first client that we want to swap
        (it should be the selections-count corresponding
         to its selection, or in other words the index of the client
         in the (selected-clients working-copy).
    client2  is the index of the second client that we want to swap
        (it should be the selections-count corresponding
         to its selection, or in other words the index of the client
         in the (selected-clients working-copy).
    working-copy is the working-copy where we are working.
    Example:
        (doswap (c1 c2 wc1)
           (format t \"Swapping clients ~a and ~a~%\"
            (aref *selected-clients-array* c1)
            (aref *selected-clients-array* c2)))"
      (with-gensyms (op simple-op simpler-ops)
         ;; create the instance of the swap operation
        `(unless *vrp-stop-neighborhood-search*
           (let* ((,op (op-swap-clients ,client1 ,client2))
                  (,simpler-ops (get-simpler-operations-from
                                 ,op ,working-copy)))

              ;; do the automatic stuff
              ;; with the simpler-operations
              (progn
                (dolist (,simple-op ,simpler-ops)
                  ;; push the operations into the ops-list
                  (push ,simple-op ops-list)
                  ;; simulate the operations
                  (simulate-neighborhood-operation
                   ,simple-op ,working-copy)))

              ;; here I want to add some code to execute it
              ;; before the simulation of the operation
              ;; but now I'm not sure how to do it right :-/
              ;; I'm thinking about something like
              ;;  (:before-simulation
              ;;     user-code here)

              ;; let's do what the user wants
              (progn ,@body)

              ;; now the clean up
              (progn
                ;; traverse the list popping from the ops-list
                ;; and undoing the operation
                (loop for ,simple-op in (reverse ,simpler-ops)
                      do (pop ops-list)
                      do (undo-neighborhood-operation
                          ,simple-op ,working-copy))

                ;; (format t "Debug doswap after undo:~%")
                ;; (pp-working-copy ,working-copy t)
                ;; (pp-selected-clients-array 2)
                ;; (format t "END Debug doswap after undo:~%")
                )))))    
    #+END_SRC
*** code (using make-do-neighborhood-static-macro)
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (make-do-neighborhood-static-macro doswap-clients 
       (client1 client2 working-copy)
       op-swap-clients (client1 client2)
       "Pushes into ops-lists the insertions that should be made because of this swap, do whatever the users wants to do, and restores everything to the previous state.

        client1  is the index of the first client that we want to swap
            (it should be the selections-count corresponding
             to its selection, or in other words the index of the client
             in the (selected-clients working-copy).
        client2  is the index of the second client that we want to swap
            (it should be the selections-count corresponding
             to its selection, or in other words the index of the client
             in the (selected-clients working-copy).
        working-copy is the working-copy where we are working.
        Example:
            (doswap (c1 c2 wc1)
               (format t \"Swapping clients ~a and ~a~%\"
                (aref *selected-clients-array* c1)
                (aref *selected-clients-array* c2)))")    
    #+END_SRC
*** tests
**** simple tests (no iterations)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6 7)))
       (let* ((wc1 (basic-working-copy s1))
              (ops-list nil)
              (c1 0) (c2 1)
              (op1 (op-select-client 1 2 c1))
              (op2 (op-select-client 1 3 c2))
              (*vrp-stop-neighborhood-search* nil))

         (prepare-solution-for-neighborhood-exploration wc1)

         (bformat t "Testing the doswap-clients macro")

         (format t "The original solution:~%")
         (pp-solution wc1 t) (terpri)

         (dolist (op (list op1 op2))
           (simulate-neighborhood-operation op wc1))

         (format t "After the selections:~%")
         (pp-solution wc1 t) (terpri)

         (doswap-clients (c1 c2 wc1)
           (format t "Swapped!~%")
           (format t "After the swap the solution is:~%")
           (pp-solution wc1 t) (terpri))))
     #+END_SRC
     
**** tests (iterating through a route)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6 7)))
       (let* ((wc1 (basic-working-copy s1))
              (ops-list nil)
              (*vrp-stop-neighborhood-search* nil))

         (prepare-solution-for-neighborhood-exploration wc1)

         (bformat t "Testing doswap macro with 2 doselect-clients")

         (format t "The original solution:~%")
         (pp-solution wc1 t) (terpri)



         (doselect-client (c1 1 wc1)
           (doselect-client (c2 1 wc1)
             (doswap-clients (c1 c2 wc1)
               (format t "Swapping ~a and ~a:~%"
                       (id (client-selected-at-operation c1 wc1))
                       (id (client-selected-at-operation c2 wc1)))
               (pp-solution wc1 t) (terpri))))))
     #+END_SRC
** macro doswap-clients* 
*** description
    This is smart version of the doswap-clients macro: everytime it simulates an operation, it also computes the delta-cost due to that operation.  We can do that using the macros simulate-simpler-ops-macro* and undo-simpler-ops-macro*.
*** code (using make-do-neighborhood-static-macro)
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (make-do-neighborhood-static-macro
     doswap-clients*
     (client1 client2 working-copy)
     op-swap-clients (client1 client2)
     "Pushes into ops-lists the insertions that should be made because of this swap, do whatever the users wants to do, and restores everything to the previous state.

        client1  is the index of the first client that we want to swap
            (it should be the selections-count corresponding
             to its selection, or in other words the index of the client
             in the (selected-clients working-copy).
        client2  is the index of the second client that we want to swap
            (it should be the selections-count corresponding
             to its selection, or in other words the index of the client
             in the (selected-clients working-copy).
        working-copy is the working-copy where we are working.
        Example:
            (doswap* (c1 c2 wc1)
               (format t \"Swapping clients ~a and ~a~%\"
                (aref *selected-clients-array* c1)
                (aref *selected-clients-array* c2)))"
     :simpler-ops-macro simulate-simpler-ops-macro*
     :undo-simpler-ops-macro undo-simpler-ops-macro*)    
    #+END_SRC
*** tests
**** simple test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                              (5 0 6 7 2 4 2 3 4)  ;1
                                              (1 8 0 3 9 1 2 4 5)  ;2
                                              (4 5 1 0 5 7 1 9 5)  ;3
                                              (4 5 1 5 0 6 2 8 2)  ;4
                                              (1 5 7 6 9 0 1 6 7)  ;5
                                              (4 5 1 3 5 7 0 9 5)  ;6
                                              (4 6 2 8 2 3 8 0 1)  ;7
                                              (4 5 3 4 1 6 2 8 0)  ;8
                                              )
                                              ;0 1 2 3 4 5 6 7 8
                                :demands '(20 10 15 40 30 20 10 30)
                                :capacity 30)
           (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6 7 8)) problem)
             (let* ((wc (basic-working-copy s1))
                    (c1 0) (c2 1)
                    (op1 (op-select-client 1 1 c1))
                    (op2 (op-select-client 2 1 c2))
                    (ops-list nil)
                    (action (delta-cvrp-action*)))

               (bformat t "Testing doswap-clients*")

               (prepare-solution-for-neighborhood-exploration wc)
               (initialize-action-for-delta-cost-computation wc problem action)


               ;; let's simulate compute the cost of these operations
               (dolist (op (list op1 op2))
                 (compute-delta-cost-after op wc problem action)
                 (simulate-neighborhood-operation op wc))


               (format t "Delta distance after ops: ~a~%"
                       (delta-distance action))
               (format t "Route feasibility after ops: ~a~%"
                       (delta-routes-feasibility action))

               (format t "Selected clients: ~a, ~a~%"
                       (client-selected-at-operation c1 wc)
                       (client-selected-at-operation c2 wc))

               (bformat t "Testing dosawp-clients*")
               (doswap-clients* (c1 c2 wc)
                  (pp-solution wc t) (terpri)
                  (format t "Delta distance after op: ~a~%"
                          (delta-distance action))
                  (format t "Route feasibility after op: ~a~%"
                          (delta-routes-feasibility action))
                  (format t "delta-distance-stack: ~a~%"
                          (delta-distance-stack action)))

               (format t "Outside the doswap*~%")

               (format t "Delta distance after op: ~a~%"
                       (delta-distance action))
               (format t "Route feasibility after op: ~a~%"
                       (delta-routes-feasibility action))
               (format t "delta-distance-stack: ~a~%"
                       (delta-distance-stack action)))))
     #+END_SRC
**** test with a doselect-client*
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                              (5 0 6 7 2 4 2 3 4)  ;1
                                              (1 8 0 3 9 1 2 4 5)  ;2
                                              (4 5 1 0 5 7 1 9 5)  ;3
                                              (4 5 1 5 0 6 2 8 2)  ;4
                                              (1 5 7 6 9 0 1 6 7)  ;5
                                              (4 5 1 3 5 7 0 9 5)  ;6
                                              (4 6 2 8 2 3 8 0 1)  ;7
                                              (4 5 3 4 1 6 2 8 0)  ;8
                                              )
                                              ;0 1 2 3 4 5 6 7 8
                                :demands '(20 10 15 40 30 20 10 30)
                                :capacity 30)
           (with-basic-cvrp-solution (s1 ((1 2 3) (4 5)) problem)
             (let* ((wc (basic-working-copy s1))
                    ;; (c1 0) (c2 1)
                    ;; (op1 (op-select-client 1 1 c1))
                    ;; (op2 (op-select-client 2 1 c2))
                    (ops-list nil)
                    (action (delta-cvrp-action*)))

               (prepare-solution-for-neighborhood-exploration wc)
               (initialize-action-for-delta-cost-computation wc problem action)


               (bformat t "Testing dosawp-clients*")
               (doselect-client* (c1 1 wc)
                 (doselect-client* (c2 2 wc)
                  (doswap* (c1 c2 wc)
                    (pp-solution wc t) (terpri)
                    (format t "Delta distance after op: ~a~%"
                            (delta-distance action))
                    (format t "Route feasibility after op: ~a~%"
                            (delta-routes-feasibility action))
                    (format t "delta-distance-stack: ~a~%"
                            (delta-distance-stack action)))))

               (format t "Outside the doswap*~%")

               (format t "Delta distance after op: ~a~%"
                       (delta-distance action))
               (format t "Route feasibility after op: ~a~%"
                       (delta-routes-feasibility action))
               (format t "delta-distance-stack: ~a~%"
                       (delta-distance-stack action)))))
     #+END_SRC


* subroute related operations
** description
   In this section I'll add all the functions required to deal with the subroute-related operations.

   To avoid runtime overhead, and because the subroutes operations are really basic operations in the solution of the VRP, I'll add the elements related to the subroutes to the basic-working-copy class.  If it were a more exotic operation, we could create a new class to deal with the new operations.

   Anyway, in this section I'm going to add a tutorial on how to add a somewhat more complex operation (at least more complex than the swap-clients)
** tutorial
*** general introduction
    Here we are going to add the subroute related functions.  To do that we need todefine what operations we are going to add and for each of them
     - write the class,
     - write the code for the simulate-neighborhood-operation,
     - write the code for the functions get-simpler-operations-from,
     - write the code for the undo-neighborhood-operation,
     - write the code for the corresponding do-neighborhood-operation macro.
     - write the code for the apply-neighborhood-operation (when required)

    The operations we are interested in are:

      - select-subroute
      - insert-subroute
      - swap-subroutes
      - reverse-subroute

    The most interesting one is the select-subroute operation, because we also need to add code for the subroute management.  In the next section I'm going to describe the process for this operation.

*** adding the operation select-subroute

    1. Create the class
       
       The first step is to create the class.  This is simple, because this is a very simple class: it has a route, a position, a size (how many clients are in the suborute) and the operand.  route, position and operand can be inherited from the basic neighborhood-operation class.  That's what we did.

    2. Add the functions to manage the subroutes

       As we want to simulate a full exploration of the neighborhood, we want to simulate all the possible operations without actually doing them.  To do that as easy as possible we are going to use the fact that a subroute selection can be described as a sequence of clients selections.  This means that we won't need to write code for the simulation of a subroute-selection, instead, we'll transform the select-subroute operation into the corresponding sequence of select-clients.  However, we need to keep track of which client-selections correspond to a subroute-selections and which don't.  We also need to know, in the select-clients slot, where each subroute-selection begins and where it ends.  We'll need this when we want to insert a subroute.

       To do this, we added an extra slot to the basic-working-copy class.  This slot is named selected-subroutes and it is a list where each element has three elements: the selected-client id of the first selection in the subroute, the size of the subroute, and whether or not the subroute is reversed.

       For instance, one element of that slot could be:

       =(2 5 nil)=

       That means that the select-client that was made at selected-clients id 2, is the first selection of a subroute-selection.  As the second element is 5, this means that size of the suborute is 5, meaning that the clients selected with operand 3, 4, 5 and 6, also belong to this subroute.  Finally, as the third element is nil, this subroute has not been reversed.  That information is relevant when we want to insert that subroute.

       To keep things ordered, everytime we select a subroute, we need to update this selected-subroutes slot.  We decided to write several functions to manipulate this info.  These functions are:

       - add-subroute-info
       - get-subroute-info
       - get-subroute-size
       - mark-subroute-as-reversed
       - subroute-reversed-p

       Each of this functions does what its name says.  (Besides, they are documented in its own section)

       After these functions work the way they were intended, we can add the rest of the methods to simulate the subroute-selection.

    3. Add the method simulate-neighborhood-operation

       In the case of the selected-subroute operation, the only thing we need to do is to update the selected-subroutes info by adding the info.

       This is easy to do.  I is done in the corresponding section below.

    4. Add the method get-simpler-operations-from

       The next step is to write the function =get-simpler-operations-from=.  In the case of the select-subroute, this function should return all the select-client operations related to the subroute, but it also should return itself.  This is because, unlike the swap operation, with this one we have to update the selected-subroutes and we do this in the simulate-neighborhood-operation.

       We have to take into account that if we simulate-neighborhood-operation for a select-subroute, the selections are not simulated.  Maybe we should change some name around here.

    5. Add the undo-neighborhood-operation

       Now we need to create the method undo-neighborhood-operation.  In this case we only need to remove the subroute-info.

    6. Add the doselect-subroute macro

       The next step is to create the macro, but in this case, we need an auxiliary macro, one that receives a fixed length subroute, and extracts all the subroutes with that fixed length, and then the actual doselect-subroute macro that iterates through all the possible subroute-lengths.

       First we add the macro with the fixed length.

       Once the help macro is added, we add a macro to iterate through all the possible lengths in the route.

    7. Add the code for the apply-neighborhood-operation

       As we added the operation to the simpler-operations list, now we need to implement how to apply this op to a working copy.  But we are not going to modify the solution because of this operation, so we just define an empty method that does nothing.

*** adding the operation insert-subroute

    This operation should be easier to implement, because we don't need to do any management.  We just have to create the class, the =get-simpler-operations-from=, and write the macro.  As the method =get-simpler-operations-from= an insert-subroute operation won't return an instance of this class, we don't need to implement the =simulate-neighborhood-operation= or =undo-neighborhood-operation= methods.

    Let's follow these steps.

    1. Create the class

       This class just inherits from =neighborhood-operation= and doesn't need to add any slot.

    2. Write the method =get-simpler-operations-from=

       In this case we just return the clients insertions that result from this subroute-insertion.  We need to take into account whether or not the subroute was reversed because that would influence in the the order of the insertions.

    3. Add the macro doinsert-subroute

       This macro should very similar to the doinsert-client.  We just need to iterate through all the possible positions in the route, create the op-insert-subroute at that postion and simulate all the simpler operations.

*** adding the operation reverse-subroute

    This operation should be the simplest of all, because the only thing we need to do here is to change the `reversed-status' of the subroute.  In this case, the simpler-operations is a list only with itself, and we don't need to specialize that method because that's precisely what this method does for the base class t.

    In this case, as this is a static operation, to create the macro doreverse-subroute we can use the macro make-do-neighborhood-static-macro.

    So, the steps are:

    1. Create the class
    2. Write the simulate-neighborhood-operation
    3. Write the undo-neighborhood-operation
    4. Write the macro
    5. Write the apply-neighborhood-operation
       
*** adding the operation swap-subroutes

    In this case we want to swap two previously selected subroutes.  In this case we don't need to return a copy of this operation in the =get-simpler-operations-from=, but we must take into account that the two operations into which this swap decomposes also decompose into simpler operations.  And so, in this case, we need to do both decompositions.

    As the macro for this operation does not traverse any route, we should be able to use the =make-do-neighborhood-static-macro=.

    1. Create the class
    2. Write the get-simpler-operations-from
    3. Write the macro
** subroute-operations
*** select-subroute
**** description
     As this class has a route and a position, it can inherit from the neighborhood-operation class.  It also has a size to indicate the length of the subroute.
**** class defintion
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp 
      ;;The select-subroute class definition.
      (def-vrp-class operation-select-subroute (neighborhood-operation)
        ((size :documentation "The size of the subroute that should be selected."))
        :documentation "A class to represent the select subroute operation in a neighborhood criterion"
        :constructor (op-select-subroute (route pos size operand))
        :print-object-string
        ("<op:ss ~a ~a ~a ~a>" route pos size operand)
        :slots-for-obj= (route pos size operand)
        :slots-for-clone (route pos size operand))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((c1 (op-select-subroute 1 1 2 0))
             (c2 (op-select-subroute 1 1 2 1))
             (c3 (op-select-subroute 1 2 2 0))
             (c4 (op-select-subroute 2 1 2 0))
             (c5 (clone c1)))
        (bformat t "Testing op-select-subroute...")

        (format t "Printing the objects:~%")
        (loop for e in (list c1 c2 c3 c4 c5)
              doing (format t "   op-select-subroute: ~a~%" e))

        (deftests "Testing obj="
          (check-t (obj= c1 c1))
          (check-t (obj= c1 c5))

          (check-nil (obj= c1 c2))
          (check-nil (obj= c1 c3))
          (check-nil (obj= c2 c3))
          (check-nil (obj= c3 c4))))
      #+END_SRC
    
**** API for selected-subroutes manipulation
***** description
      In this section I'll add the functions needed to manage the subroutes operations.
****** suborute info

        To use the subroutes operations we need to store information about the suboroutes that we have already selected.  This info will be stored in the slot selected-subroutes in the basic-working-copy class.

        This slot will be a list where each element is a list of the form:

        =(id size reversed?)=

        - id is the `selected-clients-id' of the first client in the selected subroute.

        - size is the length of the suborutes.  This number indicates how many of the clients selected the id-th selection belong to this subroute.

        - reversed?  is a boolean indicating if the selected subroute was reversed or not.

****** functions to manage the subroute info

       We can access and update the subroute info using the following functions:

       - add-subroute-info
       - get-subroute-info
       - get-subroute-size
       - mark-subroute-as-reversed
       - subroute-reversed-p
***** add-subroute-info
****** description
       Adds the info related to a new subroute selected. Receives a select-subroute operation.  Each subroute info is an array with 3 elements.
****** generic-function
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
       (defgeneric add-subroute-info (op working-copy)
         (:documentation "Adds the info of the selected-subroute to the working-copy."))
        #+END_SRC
****** method (op-select-subroute basic-working-copy)
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
       (defmethod add-subroute-info ((op operation-select-subroute)
                                     (wc basic-working-copy))
         (let* ((id (operand op))
                (size (size op)))
           (push (make-array
                  3 :initial-contents (list id size nil))
                 (selected-subroutes wc))))
        #+END_SRC
****** tests
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8 9 10)))
            (let* ((wc1 (basic-working-copy s1))
                   (op1 (op-select-subroute 1 2 2 0))
                   (op2 (op-select-subroute 2 1 3 1)))

              (prepare-solution-for-neighborhood-exploration wc1)


              (bformat t "Testing add-subroute-info")
              (add-subroute-info op1 wc1)
              (format t "selected-subroutes after op1: ~a~%"
                      (selected-subroutes wc1))
              (add-subroute-info op2 wc1)
              (format t "selected-subroutes after op2: ~a~%"
                      (selected-subroutes wc1))))
        #+END_SRC

***** get-subroute-info
****** description
       Returns the info related to the subroute selected with the given id.
       The info of a subroute is triplet (id size reversed?)
         - The first element (id) is the id of the first client of the subroute in the selected-clients-array.
         - The second element (length) is the length of the subroute.  This number means how many selections in selected-clients-array belong to this subroute.
         - the third element (reversed?) is a boolean indicating whether or not the subroute has been reversed.
****** generic-function
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
       (defgeneric get-subroute-info (id working-copy)
         (:documentation "Returns the info of subroute with the given id.  This id is the selections-count of the first client in the subroute."))
        #+END_SRC
****** method (id basic-working-copy)
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp 
       (defmethod get-subroute-info (id (wc basic-working-copy))
         (let* ((result)
                (subroute-found nil))
           (loop for subr in (selected-subroutes wc)
                 while (not subroute-found)
                 do (if (= id (aref subr 0))
                        (progn
                          (setf result subr)
                          (setf subroute-found t))))
           ;; return result
           result))
        #+END_SRC
****** tests
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8 9 10)))
            (let* ((wc1 (basic-working-copy s1))
                   (op1 (op-select-subroute 1 2 2 0))
                   (op2 (op-select-subroute 2 1 3 1)))

              (prepare-solution-for-neighborhood-exploration wc1)


              (bformat t "Testing get-subroute-info")
              (add-subroute-info op1 wc1)
              (add-subroute-info op2 wc1)
              (format t "selected-subroutes after op2: ~a~%"
                      (selected-subroutes wc1))

              (format t "subroute-info related to 0: ~a~%"
                      (get-subroute-info 0 wc1))

              (format t "subroute-info related to 1: ~a~%"
                      (get-subroute-info 1 wc1))

              (check-non-nil (get-subroute-info 0 wc1))
              (check-non-nil (get-subroute-info 1 wc1))
              (check-nil (get-subroute-info 2 wc1))

              ))
        #+END_SRC
***** get-subroute-size
****** description
       This function returns the size of the selected subroute with the given id.
****** generic-function
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp 
       (defgeneric get-subroute-size (id working-copy)
         (:documentation "Returns the size of the selected-subroute with the given id."))
        #+END_SRC
****** method (id basic-working-copy)
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp 
       (defmethod get-subroute-size (subroute-id
                                     (working-copy basic-working-copy))
         (aif (get-subroute-info subroute-id working-copy)
              (aref it 1)))
       #+END_SRC
****** tests
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8 9 10)))
            (let* ((wc1 (basic-working-copy s1))
                   (op1 (op-select-subroute 1 2 2 0))
                   (op2 (op-select-subroute 2 1 3 1)))

              (prepare-solution-for-neighborhood-exploration wc1)


           (add-subroute-info op1 wc1)
           (add-subroute-info op2 wc1)

           (loop for i in `(0 1 2 3 4 5)
                 do (format t "subroute size ~a: ~a~%"
                            i (get-subroute-size i wc1)))

           (check-= 2 (get-subroute-size 0 wc1))
           (check-= 3 (get-subroute-size 1 wc1))
           (check-nil (get-subroute-size 2 wc1))
           ))
        #+END_SRC

***** subroute-reversed-p
****** description
       This function returns the reversed status of the given subroute.  The reversed status of a subroute is a boolean indicating whether the subroute is reversed or not.
****** generic-function
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
       (defgeneric subroute-reversed-p (id working-copy)
         (:documentation "Returns the reversed status of the given subroutev"))
        #+END_SRC
****** method (id basic-working-copy)
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp 
       (defmethod subroute-reversed-p (subroute-id
                                       (working-copy basic-working-copy))
                (aif (get-subroute-info subroute-id working-copy)
                     (aref it 2)))
       #+END_SRC

****** tests
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8 9 10)))
            (let* ((wc1 (basic-working-copy s1))
                   (op1 (op-select-subroute 1 2 2 0))
                   (op2 (op-select-subroute 2 1 3 1)))

              (prepare-solution-for-neighborhood-exploration wc1)


              (bformat t "Testing subroute-reversed-p")

              (add-subroute-info op1 wc1)
              (add-subroute-info op2 wc1)

              (push #(2 3 t) (selected-subroutes wc1))

              (check-nil     (subroute-reversed-p 0 wc1))
              (check-nil     (subroute-reversed-p 1 wc1))
              (check-non-nil (subroute-reversed-p 2 wc1))


           ))
        #+END_SRC

***** mark-subroute-as-reversed
****** description
       This function updates the info about the "reversed" status of the subroute.
****** generic-function
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp 
       (defgeneric mark-subroute-as-reversed (id working-copy)
         (:documentation "Toggle the reversed status of the given subroute."))
        #+END_SRC
****** method (id basic-working-copy)
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp 
       (defmethod mark-subroute-as-reversed
           (subroute-id (working-copy basic-working-copy))
         (let* ((subroute-info (get-subroute-info
                                subroute-id working-copy)))
           (setf (aref subroute-info 2)
                 (not (aref subroute-info 2)))))
       #+END_SRC
****** tests
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8 9 10)))
          (let* ((wc1 (basic-working-copy s1))
                 (op1 (op-select-subroute 1 2 2 0))
                 (op2 (op-select-subroute 2 1 3 1)))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing mark-subroute-as-reversed")

            (add-subroute-info op1 wc1)
            (add-subroute-info op2 wc1)

            (check-nil (subroute-reversed-p 0 wc1))
            (check-nil (subroute-reversed-p 1 wc1))
            (mark-subroute-as-reversed 0 wc1)
            (check-non-nil (subroute-reversed-p 0 wc1))
            (mark-subroute-as-reversed 0 wc1)
            (check-nil (subroute-reversed-p 0 wc1))
            (mark-subroute-as-reversed 1 wc1)
            (check-non-nil (subroute-reversed-p 1 wc1))


            ))
        #+END_SRC
***** subroute-selected-at-operation
****** description
       This function returns a list with the subroute selected at the given operation.
****** generic-function
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp 
       (defgeneric subroute-selected-at-operation (id working-copy)
         (:documentation "Returns the subroute whose first element was selected at the operation id."))
        #+END_SRC
****** method (id basic-working-copy)
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp 
       (defmethod subroute-selected-at-operation
           (id (wc basic-working-copy))
         (loop for i from 0 to (1- (get-subroute-size id wc))
               collecting (client-selected-at-operation (+ id i) wc)))
       #+END_SRC
****** tests
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8 9 10)))
          (let* ((wc (basic-working-copy s1))
                 (op1 (op-select-subroute 1 2 2 0))
                 (op2 (op-select-subroute 2 1 3 2)))

            (bformat t "Testing subroute-selected-at-operation")

            (prepare-solution-for-neighborhood-exploration wc)

            (loop for op in (get-simpler-operations-from op1 wc)
                  doing (simulate-neighborhood-operation op wc))

            (loop for op in (get-simpler-operations-from op2 wc)
                  doing (simulate-neighborhood-operation op wc))

            (format t "subroute 1: ~a~%" (subroute-selected-at-operation 0 wc))))
        #+END_SRC

**** simulate-neighborhood-operation
***** description
      In this section we implement the simulate-neighborhood-operation for the select-subroute operation.  The only thing we need to do there is to add the subroute-info.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
      (defmethod simulate-neighborhood-operation
           ((op operation-select-subroute)
            (wc basic-working-copy))
         (add-subroute-info op wc))
      #+END_SRC

***** tests
****** simple tests
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9 10)))
         (let* ((wc1 (basic-working-copy s1))
                (sr1 0) (sr2 1)
                (op1 (op-select-subroute 1 2 3 sr1))
                (op2 (op-select-subroute 2 1 4 sr2)))

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing simulate-neighborhood-operation for select-subroute")

           (check-nil (selected-subroutes wc1))
           (simulate-neighborhood-operation op1 wc1)

           (format t "selected-subroutes after operation: ~a~%"
                   (selected-subroutes wc1))

           (check-non-nil (selected-subroutes wc1))
           (check-= 3 (get-subroute-size sr1 wc1))
           (check-nil (subroute-reversed-p sr1 wc1))

           (simulate-neighborhood-operation op2 wc1)
           (check-= 2 (length (selected-subroutes wc1)))
           (check-= 4 (get-subroute-size sr2 wc1))
           (check-nil (subroute-reversed-p sr2 wc1))

           ))
       #+END_SRC
**** get-simpler-operations-from
***** description
      This function returns all the operations involved in the select-subroute operation.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
      (defmethod get-simpler-operations-from
          ((op operation-select-subroute)
           (wc basic-working-copy))
        "We return a list with all the client selections that will be made because of this select-subroute, and we also return the operation itself, because we need to add the subroute info and that is done in the simulate-neighborhood-operation for the select-subroute."
        (let* ((route (route op))
               (pos (pos op))
               (size (size op))
               (first-index (1- (operand op))))
          ;; append the op
          `(,op
            ;; with all the client selections
            ,@(loop for i from 1 to size
                 collect (op-select-client
                          route pos (+ i first-index))))))
      #+END_SRC

***** tests
****** simple test
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9 10)))
         (let* ((wc1 (basic-working-copy s1))
                (sr1 0) (sr2 3)
                (op1 (op-select-subroute 1 2 3 sr1))
                (op2 (op-select-subroute 2 1 4 sr2))
                list1 list2)

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing get-simpler-operations-from select-subroute")

           (check-nil (selected-subroutes wc1))
           (setf list1 (get-simpler-operations-from op1 wc1))


           (format t "selected-clients from ~a:~%   ~a~%" op1
                   list1)

           (check-obj= op1 (first list1))
           (check-= 4 (length list1))

           (setf list2 (get-simpler-operations-from op2 wc1))
           (format t "selected-clients from ~a:~%   ~a~%" op2
                   list2)

           ;; (check-non-nil (selected-subroutes wc1))
           ;; (check-= 3 (get-subroute-size sr1 wc1))
           ;; (check-nil (subroute-reversed-p sr1 wc1))

           ;; (simulate-neighborhood-operation op2 wc1)
           ;; (check-= 2 (length (selected-subroutes wc1)))
           ;; (check-= 4 (get-subroute-size sr2 wc1))
           ;; (check-nil (subroute-reversed-p sr2 wc1))

           ))
       #+END_SRC
****** test changing the solution
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9 10)))
         (let* ((wc1 (basic-working-copy s1))
                (sr1 0) (sr2 3)
                (op1 (op-select-subroute 1 2 3 sr1))
                (op2 (op-select-subroute 2 1 4 sr2))
                list1)

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing get-simpler-operations-from select-subroute")

           (setf list1 (get-simpler-operations-from op1 wc1))

           (format t "Solution after first selection:~%")
           (dolist (op list1) (simulate-neighborhood-operation op wc1))
           (pp-solution wc1 t)

           (format t "Solution after second selection:~%")
           (dolist (op (get-simpler-operations-from op2 wc1))
             (simulate-neighborhood-operation op wc1))
           (pp-solution wc1 t)

           ))
       #+END_SRC
**** undo-neighborhood-operation
***** description
      In this section we implement the undo-neighborhood-operation for the select-subroute operation.  As the only thing we did in the simulate-neighborhood-operation was to add the subroute-info, here we only need to remove that info.  As we assume a LIFO order in way operations are simulated and undone, we just need to pop the slot `selected-subroutes'.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
      (defmethod undo-neighborhood-operation
           ((op operation-select-subroute)
            (wc basic-working-copy))
         (pop (selected-subroutes wc)))
      #+END_SRC

***** tests
****** simple tests
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9 10)))
         (let* ((wc1 (basic-working-copy s1))
                (sr1 0) (sr2 1)
                (op1 (op-select-subroute 1 2 3 sr1))
                (op2 (op-select-subroute 2 1 4 sr2)))

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing undo-neighborhood-operation for select-subroute")

           (check-nil (selected-subroutes wc1))
           (simulate-neighborhood-operation op1 wc1)

           (format t "selected-subroutes after operation: ~a~%"
                   (selected-subroutes wc1))

           (check-non-nil (selected-subroutes wc1))
           (check-= 3 (get-subroute-size sr1 wc1))
           (check-nil (subroute-reversed-p sr1 wc1))

           (simulate-neighborhood-operation op2 wc1)
           (check-= 2 (length (selected-subroutes wc1)))
           (check-= 4 (get-subroute-size sr2 wc1))
           (check-nil (subroute-reversed-p sr2 wc1))

           (undo-neighborhood-operation op2 wc1)
           (check-= 1 (length (selected-subroutes wc1)))
           (undo-neighborhood-operation op1 wc1)
           (check-nil (selected-subroutes wc1))
    
           ))
       #+END_SRC
**** *macro* for the creation of fixed length doselect-subroutes
***** description
      As I want to add the doselect-subroute* macro, and it will be very similar to doselect-subroute, I want to add a macro here, so the difference will only be the simpler-ops-macro* and undo-simpler-ops-macro*.
***** code
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
       (defmacro make-doselect-subroute-with-length
           (name
            &key
              (simpler-ops-macro
               'simulate-simpler-ops-macro)
              (undo-simpler-ops-macro
               'undo-simpler-ops-macro))
           `(defmacro ,name
                ((cname route length working-copy
                        &key ge gt le lt dt ex ex-cond)
                 &body body)

              "Iterates through each position in the given route, creates an instance of op-select-subroute, pushes it int ops-lists, simulates it, do whatever the users wants to do, and finally restores everything to the previous state.
       Example:
          (doselect-subroute-with-length (z1 r1 3 wc1)
                        (format t \"Selecting length 3 subroute stariting with
       ~a  form route ~a~%\"
                         (client-selected-at-operation c1)
                         (get-route-with-id r1 wc1)))"

              (with-gensyms (op
                             simpler-ops
                             initial-pos
                             final-pos
                             initial-target-route
                             final-target-route
                             exclude-target-route
                             exclude-pos
                             ;; last-pos
                             default-final-position
                             )

                ;; here we create the names of the
                ;; variables we create on the fly
                (let* ((cname.position (symb cname ".select.position"))
                       (static-pos (symb cname ".position"))
                       (subroute-length (symb cname ".subroute.length"))
                       (cname.coord (symb cname ".select.coord"))
                       (cname.route (symb cname ".select.route")))

                  ;; here we assign the value to the variables
                  ;; created on the fly
                  ;; some on the symbol-macrolet and
                  ;; and some others on the let
                  `(symbol-macrolet ((,cname.position
                                      (pos-of-client-selected-at-operation
                                       ,cname ,working-copy))
                                     (,cname.coord
                                      (info-of-client-selected-at-operation
                                       ,cname ,working-copy))
                                     (,cname.route
                                      (route-of-client-selected-at-operation
                                       ,cname ,working-copy)))
                     (let* ((,default-final-position
                             (1+ (- (route-length ,route ,working-copy) ,length)))
                            (,subroute-length ,length))

                       (declare (ignorable ,subroute-length))

                       (with-variables-for-constraints-for-subroute-selection
                           (,initial-pos
                            ,ge ,gt
                            ,final-pos ,le ,lt
                            ,initial-target-route
                            ,final-target-route
                            ,exclude-target-route
                            ,exclude-pos
                            ,dt
                            ,default-final-position)

                         (loop for ,static-pos from
                               ;; here we use the macro
                               ;; for the initialization of the values
                               (initial-for-value-in-all-macros
                                ,initial-target-route
                                ,route
                                ,initial-pos)

                               to (final-value-for-loop-in-route-operation-macro
                                   ,final-target-route
                                   ,route
                                   ,final-pos
                                   ,default-final-position)

                               ;; the next line allows the user to
                               ;; stop the search
                               while (not *vrp-stop-neighborhood-search*)


                               do ;; let's execute the body if
                               ;; we are not in a forbidden coord
                               (unless-forbidden-coord
                                   (,ex
                                    ,route
                                    ,static-pos
                                    ,dt
                                    ,exclude-target-route
                                    ,exclude-pos
                                    ,ex-cond)
                                 (let* (;; here we increase the index
                                        ;; of the operation
                                        (,cname
                                         (1+ (selections-count ,working-copy)))
                                        ;; we create the op and keep going
                                        ;; with the rest
                                        (,op (op-select-subroute
                                              ,route ,static-pos ,length ,cname))

                                        (,simpler-ops
                                         (get-simpler-operations-from
                                          ,op ,working-copy)))

                                   ;; here I want to add some code to execute it
                                   ;; before the simulation of the operation
                                   ;; but I'm not yet sure about how
                                   ;; to do it right :-/

                                   ;; now the simulation
                                   (,',simpler-ops-macro
                                    ,simpler-ops ,working-copy)

                                   ;; let's do what the user wants
                                   (progn ,@body)

                                   ;; now the clean up
                                   (,',undo-simpler-ops-macro
                                    ,simpler-ops
                                    ,working-copy)))))))))))
       #+END_SRC
***** tests
****** testing macroexpansion
       #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-tests.lisp 
       (make-doselect-subroute-with-length doselect-subroute-with-length%)       
       #+END_SRC
****** testing original tests for doselect-suborute
******* very simple test
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5 6 )))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing select-subroute-with-length")

             (format t "Original solution:~%")
             (pp-solution wc1 t) (terpri)

           (doselect-subroute-with-length% (z1 1 3 wc1)
             (format t "After one select-subroute:~%")
             (pp-solution wc1 t) (terpri)
             (format t "subroute-coords: ~a, length ~a~%"
                     z1.select.coord
                     z1.subroute.length))))
        #+END_SRC
**** doselect-subroute-with-length
***** description
      This macros receives a route, and id for the name of the subroute, a length and a working-copy, and it selects all the possible subroutes of the given length inside that route.  This should be easy to implement.
***** code
****** version 3 (with the maker)
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
       (make-doselect-subroute-with-length
        doselect-subroute-with-length)
       #+END_SRC
       
****** +version 2 (with macros)+
       #+BEGIN_SRC lisp +n -r :results none :exports code
       (defmacro doselect-subroute-with-length
           ((cname route length working-copy
             &key ge gt le lt dt ex ex-cond)
            &body body)

         "Iterates through each position in the given route, creates an instance of op-select-subroute, pushes it int ops-lists, simulates it, do whatever the users wants to do, and finally restores everything to the previous state.
       Example:
          (doselect-subroute-with-length (z1 r1 3 wc1)
                        (format t \"Selecting length 3 subroute stariting with
       ~a  form route ~a~%\"
                         (client-selected-at-operation c1)
                         (get-route-with-id r1 wc1)))"

         (with-gensyms (op
                        simpler-ops
                        initial-pos
                        final-pos
                        initial-target-route
                        final-target-route
                        exclude-target-route
                        exclude-pos
                        ;; last-pos
                        default-final-position
                        )

           ;; here we create the names of the
           ;; variables we create on the fly
           (let* ((cname.position (symb cname ".select.position"))
                  (static-pos (symb cname ".position"))
                  (subroute-length (symb cname ".subroute.length"))
                  (cname.coord (symb cname ".select.coord"))
                  (cname.route (symb cname ".select.route")))

             ;; here we assign the value to the variables
             ;; created on the fly
             ;; some on the symbol-macrolet and
             ;; and some others on the let
             `(symbol-macrolet ((,cname.position
                                 (pos-of-client-selected-at-operation
                                  ,cname ,working-copy))
                                (,cname.coord
                                 (info-of-client-selected-at-operation
                                  ,cname ,working-copy))
                                (,cname.route
                                 (route-of-client-selected-at-operation
                                  ,cname ,working-copy)))
                (let* ((,default-final-position
                        (1+ (- (route-length ,route ,working-copy) ,length)))
                       (,subroute-length ,length))

                  (declare (ignorable ,subroute-length))

                  (with-variables-for-constraints-for-subroute-selection
                      (,initial-pos
                       ,ge ,gt
                       ,final-pos ,le ,lt
                       ,initial-target-route
                       ,final-target-route
                       ,exclude-target-route
                       ,exclude-pos
                       ,dt
                       ,default-final-position)

                    (loop for ,static-pos from
                          ;; here we use the macro
                          ;; for the initialization of the values
                          (initial-for-value-in-all-macros
                           ,initial-target-route
                           ,route
                           ,initial-pos)

                          to (final-value-for-loop-in-route-operation-macro
                                ,final-target-route
                                ,route
                                ,final-pos
                                ,default-final-position)

                          ;; the next line allows the user to
                          ;; stop the search
                          while (not *vrp-stop-neighborhood-search*)


                          do ;; let's execute the body if
                          ;; we are not in a forbidden coord
                          (unless-forbidden-coord
                             (,ex
                               ,route
                               ,static-pos
                               ,dt
                               ,exclude-target-route
                               ,exclude-pos
                               ,ex-cond)
                            (let* (;; here we increase the index
                                   ;; of the operation
                                   (,cname
                                    (1+ (selections-count ,working-copy)))
                                   ;; we create the op and keep going
                                   ;; with the rest
                                   (,op (op-select-subroute
                                         ,route ,static-pos ,length ,cname))

                                   (,simpler-ops
                                         (get-simpler-operations-from
                                          ,op ,working-copy)))

                                   ;; here I want to add some code to execute it
                                   ;; before the simulation of the operation
                                   ;; but I'm not yet sure about how
                                   ;; to do it right :-/

                                   ;; now the simulation
                                   (simulate-simpler-ops-macro
                                    ,simpler-ops ,working-copy)

                                   ;; let's do what the user wants
                                   (progn ,@body)

                                   ;; now the clean up
                                   (undo-simpler-ops-macro
                                    ,simpler-ops ,working-copy))))))))))
       #+END_SRC
****** +version 1+
       #+BEGIN_SRC lisp +n -r :results none :exports code
       (defmacro doselect-subroute-with-length
           ((cname route length working-copy
             &key ge gt le lt dt ex)
            &body body)

         "Iterates through each position in the given route, creates an instance of op-select-subroute, pushes it int ops-lists, simulates it, do whatever the users wants to do, and finally restores everything to the previous state.
       Example:
          (doselect-subroute-with-length (z1 r1 3 wc1)
                        (format t \"Selecting length 3 subroute stariting with
       ~a  form route ~a~%\"
                         (client-selected-at-operation c1)
                         (get-route-with-id r1 wc1)))"

         (with-gensyms (op
                        simpler-ops
                        initial-pos
                        final-pos
                        initial-target-route
                        final-target-route
                        exclude-target-route
                        exclude-pos
                        last-pos
                        )

           (let* ((pos (symb cname ".select.position"))
                  (subroute-length (symb cname ".subroute.length"))
                  (cname.coord (symb cname ".select.coord")))

             `(symbol-macrolet ((,cname.coord
                                 (info-of-client-selected-at-operation
                                  ,cname ,working-copy)))
                (let* ((,last-pos
                        (1+ (- (route-length ,route ,working-copy) ,length)))
                       (,subroute-length ,length))

                  (declare (ignorable ,subroute-length))

                  (with-variables-for-constraints-for-subroute-selection
                      (,initial-pos
                       ,ge ,gt
                       ,final-pos ,le ,lt
                       ,initial-target-route
                       ,final-target-route
                       ,exclude-target-route
                       ,exclude-pos
                       ,dt
                       ,last-pos)

                    (loop for ,pos from
                          ;; here we use the macro
                          ;; for the initialization of the values
                          (initial-for-value-in-all-macros
                           ,initial-target-route
                           ,route
                           ,initial-pos)

                          to ,last-pos

                          ;; the next line allows the user to
                          ;; stop the search
                          while (not *vrp-stop-neighborhood-search*)


                          do ;; let's execute the body if
                          ;; we are not in a forbidden coord
                          (unless-forbidden-coord
                             (,ex
                               ,route
                               ,pos
                               ,dt
                               ,exclude-target-route ,exclude-pos)
                            (let* (;; here we increase the index
                                   ;; of the operation
                                   (,cname
                                    (1+ (selections-count ,working-copy)))
                                   ;; we create the op and keep going
                                   ;; with the rest
                                   (,op (op-select-subroute
                                         ,route ,pos ,length ,cname))

                                   (,simpler-ops
                                         (get-simpler-operations-from
                                          ,op ,working-copy)))

                                   ;; here I want to add some code to execute it
                                   ;; before the simulation of the operation
                                   ;; but I'm not yet sure about how
                                   ;; to do it right :-/

                                   ;; now the simulation
                                   (simulate-simpler-ops-macro
                                    ,simpler-ops ,working-copy)

                                   ;; let's do what the user wants
                                   (progn ,@body)

                                   ;; now the clean up
                                   (undo-simpler-ops-macro
                                    ,simpler-ops ,working-copy))))))))))
       #+END_SRC
***** tests
****** very simple test
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5 6 )))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil))

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing select-subroute-with-length")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

          (doselect-subroute-with-length (z1 1 3 wc1)
            (format t "After one select-subroute:~%")
            (pp-solution wc1 t) (terpri)
            (format t "subroute-coords: ~a, length ~a~%"
                    z1.select.coord
                    z1.subroute.length))))
       #+END_SRC
****** very simple test with constraint
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5 6 7)))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil))

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing select-subroute-with-length with constraints")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

          (doselect-subroute-with-length (z1 1 3 wc1
                                             :ge (list 1 3)
                                             :dt (list 1 4))
            (format t "After one select-subroute:~%")
            (pp-solution wc1 t) (terpri)
            (format t "subroute-coords: ~a, length ~a~%"
                    z1.select.coord
                    z1.subroute.length))





          ))
       #+END_SRC
****** testing ex-cond
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5 6 7 8 9 10)))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil))

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing select-subroute-with-length with ex-cond")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

          (doselect-subroute-with-length (z1 1 3 wc1
                                             :ex-cond (oddp z1.position))
            (format t "Selecting from pos: ~a~%" z1.position)
            (pp-solution wc1 t) (terpri)
            ;; (format t "subroute-coords: ~a~%"
            ;;         z1.select.coord)
            )))
       #+END_SRC
****** testing z1.select.position
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5 6 )))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil))

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing select-subroute-with-length testing z1.select.position")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

          (doselect-subroute-with-length (z1 1 3 wc1)
            (format t "Selecting subroute with length ~a from pos ~a:~%"
                    z1.subroute.length z1.select.position)
            (pp-solution wc1 t) (terpri))))
       #+END_SRC
****** with two select-subroutes
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5 6 7 8 9)))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil)
                (r1 1))

           (prepare-solution-for-neighborhood-exploration wc1)
           (format t "Original solution:~%")
           (pp-solution wc1 t) (terpri)

           (doselect-subroute-with-length (ss2 r1 3 wc1)
             (doselect-subroute-with-length (ss1 r1 3 wc1)
               (format t "After 2 select-subroutes:~%")
               (pp-solution wc1 t)
               ;; (doselect-client (c1 r1 wc1)
               ;;   (format t "After select-subroute and after selection:~%")
               ;;   (pp-solution wc1 t) (terpri))
               ))))
       #+END_SRC
****** with two select-subroutes and a selection
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5 6 7 8 9)))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil)
                (r1 1))

           (bformat t "Testing select-subroutes-with-lengths")

           (prepare-solution-for-neighborhood-exploration wc1)
           (format t "Original solution:~%")
           (pp-solution wc1 t) (terpri)

           (doselect-subroute-with-length (ss2 r1 3 wc1)
             (doselect-subroute-with-length (ss1 r1 3 wc1)
               (format t "After 2 select-subroutes:~%")
               (pp-solution wc1 t)
               (doselect-client (c1 r1 wc1)
                 (format t "After select-subroute and after selection:~%")
                 (pp-solution wc1 t) (terpri))))))
       #+END_SRC
**** *macro* for the creation of fixed length doselect-subroutes
***** description
      As I want to add the doselect-subroute* macro, and it will be very similar to doselect-subroute, I want to add a macro here, so the difference will only be the simpler-ops-macro* and undo-simpler-ops-macro*.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
      (defmacro make-variable-length-doselect-subroute
          (name &key
                  (fixed-length-macro 'doselect-subroute-with-length))
        `(defmacro ,name
                 ((cname route working-copy
                         &key ge gt le lt dt ex ex-cond ldt lex lex-cond)
                  &body body)

               (with-gensyms (route-length)
                 (let* ((current-length-name (symb cname ".length")))
                   `(let ((,route-length (route-length ,route ,working-copy)))
                      (loop for ,current-length-name from 1 to ,route-length
                            doing (unless (or
                                           (and
                                            (numberp ,ldt)
                                            (= ,current-length-name ,ldt))
                                           (and
                                            ,lex
                                            (member ,current-length-name ,lex)))
                                    (unless-forbidden-length-code (,lex-cond)

                                      (,',fixed-length-macro
                                          (,cname
                                           ,route
                                           ,current-length-name
                                           ,working-copy
                                           :ge ,ge :gt ,gt :le ,le
                                           :lt ,lt :dt ,dt :ex ,ex
                                           :ex-cond ,ex-cond)
                                        ,@body)))))))))
      #+END_SRC
***** tests
****** testing macroexpansion
       #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-tests.lisp 
       (make-variable-length-doselect-subroute
         doselect-subroute%) 
       #+END_SRC
****** testing code
******* simple test
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing doselect-subroute (variable-length)")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (doselect-subroute% (ss1 1 wc1)
              (format t "After one select-subroute:~%")
              (pp-solution wc1 t) (terpri))))
        #+END_SRC
******* testing cname.subroute.length
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing doselect-subroute (variable-length)")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (doselect-subroute% (ss1 1 wc1)
              (format t "After selecting subroute with length ~a from pos ~a:~%"
               ss1.subroute.length ss1.select.position)
              (pp-solution wc1 t) (terpri))))
        #+END_SRC
**** doselect-subroute (variable-length)
***** description
      Iterates through all the possible lengths in the given subroute.

      The constaints allows the user to specify lengths that should not be iterated through.

      The ldt arg indicates to exclude subroutes with the given length.
      The lex arg indicates to exclude subroutes if its length is one of the elements in this list (lex)

***** version 3 (with the maker)
****** code v3
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
       (make-variable-length-doselect-subroute
        doselect-subroute)
       #+END_SRC
****** tests v3
******* simple test
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing doselect-subroute (variable-length)")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (doselect-subroute (ss1 1 wc1)
              (format t "After one select-subroute:~%")
              (pp-solution wc1 t) (terpri))))
        #+END_SRC
      
******* testing cname.subroute.length
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing doselect-subroute (variable-length)")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (doselect-subroute (ss1 1 wc1)
              (format t "After selecting subroute with length ~a from pos ~a:~%"
               ss1.subroute.length ss1.select.position)
              (pp-solution wc1 t) (terpri))))
        #+END_SRC
      
******* testing lex-cond
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5 6 7)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing doselect-subroute (variable-length)")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (doselect-subroute (ss1 1 wc1
                                    :lex-cond (and (> ss1.length 3)
                                                   (evenp ss1.length))
                                    :ex-cond (oddp ss1.position))
              (format t "Selecting subroute with length ~a from pos ~a:~%"
               ss1.subroute.length ss1.select.position)
              ;; (pp-solution wc1 t) (terpri)
              )))
        #+END_SRC
      
******* testing lex-cond
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5 6 7)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing doselect-subroute (variable-length)")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (doselect-subroute (ss1 1 wc1
                                    :lex-cond (and (> ss1.length 3)
                                                   (evenp ss1.length)))
              (format t "Selecting subroute with length ~a from pos ~a:~%"
               ss1.subroute.length ss1.select.position)
              ;; (pp-solution wc1 t) (terpri)
              )))
        #+END_SRC
      
******* testing ldt
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing doselect-subroute (variable-length)")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (doselect-subroute (ss1 1 wc1
                                    :ldt 3)
              (format t "Selecting subroute with length ~a from pos ~a:~%"
               ss1.subroute.length ss1.select.position)
              ;; (pp-solution wc1 t) (terpri)
              )))
        #+END_SRC
      
******* testing lex
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing doselect-subroute (variable-length)")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (doselect-subroute (ss1 1 wc1
                                    :lex (list 2 4))
              (format t "Selecting subroute with length ~a from pos ~a:~%"
               ss1.subroute.length ss1.select.position)
              ;; (pp-solution wc1 t) (terpri)
              )))
        #+END_SRC
      
***** +version 2+
****** +code v2 (with constraints on the route's length)+
       #+BEGIN_SRC lisp +n -r :results none :exports code
       (defmacro doselect-subroute
            ((cname route working-copy
              &key ge gt le lt dt ex ex-cond ldt lex lex-cond)
             &body body)

         (with-gensyms (route-length)
           (let* ((current-length-name (symb cname ".length")))
            `(let ((,route-length (route-length ,route ,working-copy)))
               (loop for ,current-length-name from 1 to ,route-length
                     doing (unless (or
                                    (and
                                     (numberp ,ldt)
                                     (= ,current-length-name ,ldt))
                                    (and
                                     ,lex
                                     (member ,current-length-name ,lex)))
                             (unless-forbidden-length-code (,lex-cond)

                               (doselect-subroute-with-length
                                   (,cname
                                    ,route
                                    ,current-length-name
                                    ,working-copy
                                    :ge ,ge :gt ,gt :le ,le
                                    :lt ,lt :dt ,dt :ex ,ex
                                    :ex-cond ,ex-cond)
                                 ,@body))))))))
       #+END_SRC
****** tests v2
******* simple test
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing doselect-subroute (variable-length)")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (doselect-subroute (ss1 1 wc1)
              (format t "After one select-subroute:~%")
              (pp-solution wc1 t) (terpri))))
        #+END_SRC
      
******* testing cname.subroute.length
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing doselect-subroute (variable-length)")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (doselect-subroute (ss1 1 wc1)
              (format t "After selecting subroute with length ~a from pos ~a:~%"
               ss1.subroute.length ss1.select.position)
              (pp-solution wc1 t) (terpri))))
        #+END_SRC
      
******* testing lex-cond
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5 6 7)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing doselect-subroute (variable-length)")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (doselect-subroute (ss1 1 wc1
                                    :lex-cond (and (> ss1.length 3)
                                                   (evenp ss1.length))
                                    :ex-cond (oddp ss1.position))
              (format t "Selecting subroute with length ~a from pos ~a:~%"
               ss1.subroute.length ss1.select.position)
              ;; (pp-solution wc1 t) (terpri)
              )))
        #+END_SRC
      
******* testing lex-cond
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5 6 7)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing doselect-subroute (variable-length)")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (doselect-subroute (ss1 1 wc1
                                    :lex-cond (and (> ss1.length 3)
                                                   (evenp ss1.length)))
              (format t "Selecting subroute with length ~a from pos ~a:~%"
               ss1.subroute.length ss1.select.position)
              ;; (pp-solution wc1 t) (terpri)
              )))
        #+END_SRC
      
******* testing ldt
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing doselect-subroute (variable-length)")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (doselect-subroute (ss1 1 wc1
                                    :ldt 3)
              (format t "Selecting subroute with length ~a from pos ~a:~%"
               ss1.subroute.length ss1.select.position)
              ;; (pp-solution wc1 t) (terpri)
              )))
        #+END_SRC
      
******* testing lex
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing doselect-subroute (variable-length)")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (doselect-subroute (ss1 1 wc1
                                    :lex (list 2 4))
              (format t "Selecting subroute with length ~a from pos ~a:~%"
               ss1.subroute.length ss1.select.position)
              ;; (pp-solution wc1 t) (terpri)
              )))
        #+END_SRC
      
***** +version 1+
****** +code v1 (without macros or constraints)+
       #+BEGIN_SRC lisp +n -r :results none :exports code
       (defmacro doselect-subroute
            ((cname route working-copy
              &key ge gt le lt dt ex)
             &body body)

          (with-gensyms (current-length route-length)
            `(let ((,route-length (route-length ,route ,working-copy)))
               (loop for ,current-length from 2 to ,route-length
                     doing (doselect-subroute-with-length
                               (,cname ,route ,current-length ,working-copy
                                       :ge ,ge :gt ,gt :le ,le
                                       :lt ,lt :dt ,dt :ex ,ex)
                             ,@body)))))
       #+END_SRC
****** +tests v1+
******* simple test
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing doselect-subroute (variable-length)")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (doselect-subroute (ss1 1 wc1)
              (format t "After one select-subroute:~%")
              (pp-solution wc1 t) (terpri))))
        #+END_SRC
      
******* testing cname.subroute.length
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3 4 5)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)

            (bformat t "Testing doselect-subroute (variable-length)")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (doselect-subroute (ss1 1 wc1)
              (format t "After selecting subroute with length ~a from pos ~a:~%"
               ss1.subroute.length ss1.select.position)
              (pp-solution wc1 t) (terpri))))
        #+END_SRC
      
**** doselect-subroute-with-length*
***** description
      This is the * version of the doselect-subroute-with-length*.  Here we assume that in the expansion place there is a variable =problem=, and a variable =action=.
***** code (using the maker)
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
       (make-doselect-subroute-with-length
        doselect-subroute-with-length*
        :simpler-ops-macro simulate-simpler-ops-macro*
        :undo-simpler-ops-macro undo-simpler-ops-macro*)
       #+END_SRC

***** tests
****** simple test
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                                (5 0 6 7 2 4 2 3 4)  ;1
                                                (1 8 0 3 9 1 2 4 5)  ;2
                                                (4 5 1 0 5 7 1 9 5)  ;3
                                                (4 5 1 5 0 6 2 8 2)  ;4
                                                (1 5 7 6 9 0 1 6 7)  ;5
                                                (4 5 1 3 5 7 0 9 5)  ;6
                                                (4 6 2 8 2 3 8 0 1)  ;7
                                                (4 5 3 4 1 6 2 8 0)  ;8
                                                )
                                                ;0 1 2 3 4 5 6 7 8
                                  :demands '(20 10 15 40 30 20 10 30)
                                  :capacity 30)
         (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6 7 8)) problem)
           (let* ((wc (basic-working-copy s1))
                  (ops-list nil)
                  (action (delta-cvrp-action*)))

             (prepare-solution-for-neighborhood-exploration wc)
             (initialize-action-for-delta-cost-computation wc problem action)

             (bformat t "Testing doselect-route")
             (doselect-subroute-with-length* (c1 1 2 wc
                                                 :ex-cond (/= c1.position 1))
                 (format t "Selected subroute: ~a~%"
                         (subroute-selected-at-operation c1 wc))
                 (pp-solution wc t) (terpri)
                 (format t "Delta distance after op: ~a~%"
                         (delta-distance action))
                 (format t "Route feasibility after op: ~a~%"
                         (delta-routes-feasibility action))
                 (format t "distance-stack: ~a, feasibility: ~a~2%"
                         (delta-distance-stack action)
                         (delta-routes-feasibility-stack action))))))
       #+END_SRC
****** test with constraints
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                                (5 0 6 7 2 4 2 3 4)  ;1
                                                (1 8 0 3 9 1 2 4 5)  ;2
                                                (4 5 1 0 5 7 1 9 5)  ;3
                                                (4 5 1 5 0 6 2 8 2)  ;4
                                                (1 5 7 6 9 0 1 6 7)  ;5
                                                (4 5 1 3 5 7 0 9 5)  ;6
                                                (4 6 2 8 2 3 8 0 1)  ;7
                                                (4 5 3 4 1 6 2 8 0)  ;8
                                                )
                                                ;0 1 2 3 4 5 6 7 8
                                  :demands '(20 10 15 40 30 20 10 30)
                                  :capacity 30)
         (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6 7 8)) problem)
           (let* ((wc (basic-working-copy s1))
                  (ops-list nil)
                  (action (delta-cvrp-action*)))

             (prepare-solution-for-neighborhood-exploration wc)
             (initialize-action-for-delta-cost-computation wc problem action)

             (bformat t "Testing doselect-route")
             (doselect-subroute-with-length* (c1 1 2 wc
                                                 :ex-cond (< c1.position 3))
                 (format t "Selected subroute: ~a~%"
                         (subroute-selected-at-operation c1 wc))
                 (pp-solution wc t) (terpri)
                 (format t "Delta distance after op: ~a~%"
                         (delta-distance action))
                 (format t "Route feasibility after op: ~a~%"
                         (delta-routes-feasibility action))
                 (format t "distance-stack: ~a, feasibility: ~a~2%"
                         (delta-distance-stack action)
                         (delta-routes-feasibility-stack action))))))
       #+END_SRC

**** doselect-subroute* (variable-length)
***** description
      This is the * version of the doselect-subroute-with-length*.  Here we assume that in the expansion place there is a variable =problem=, and a variable =action=.
***** code (with the maker)
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
      (make-variable-length-doselect-subroute
       doselect-subroute*
       :fixed-length-macro doselect-subroute-with-length*)
      #+END_SRC
***** tests
****** simple test
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                                (5 0 6 7 2 4 2 3 4)  ;1
                                                (1 8 0 3 9 1 2 4 5)  ;2
                                                (4 5 1 0 5 7 1 9 5)  ;3
                                                (4 5 1 5 0 6 2 8 2)  ;4
                                                (1 5 7 6 9 0 1 6 7)  ;5
                                                (4 5 1 3 5 7 0 9 5)  ;6
                                                (4 6 2 8 2 3 8 0 1)  ;7
                                                (4 5 3 4 1 6 2 8 0)  ;8
                                                )
                                                ;0 1 2 3 4 5 6 7 8
                                  :demands '(20 10 15 40 30 20 10 30)
                                  :capacity 30)
         (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6 7 8)) problem)
           (let* ((wc (basic-working-copy s1))
                  (ops-list nil)
                  (action (delta-cvrp-action*)))

             (prepare-solution-for-neighborhood-exploration wc)
             (initialize-action-for-delta-cost-computation wc problem action)

             (bformat t "Testing doselect-route")
             (doselect-subroute* (c1 1 wc
                                     :ex-cond (/= c1.position 1))
                 (format t "Selected subroute: ~a~%"
                         (subroute-selected-at-operation c1 wc))
                 (pp-solution wc t) (terpri)
                 (format t "Delta distance after op: ~a~%"
                         (delta-distance action))
                 (format t "Route feasibility after op: ~a~%"
                         (delta-routes-feasibility action))
                 (format t "distance-stack: ~a, feasibility: ~a~2%"
                         (delta-distance-stack action)
                         (delta-routes-feasibility-stack action))))))
       #+END_SRC
****** test with constraints
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                                (5 0 6 7 2 4 2 3 4)  ;1
                                                (1 8 0 3 9 1 2 4 5)  ;2
                                                (4 5 1 0 5 7 1 9 5)  ;3
                                                (4 5 1 5 0 6 2 8 2)  ;4
                                                (1 5 7 6 9 0 1 6 7)  ;5
                                                (4 5 1 3 5 7 0 9 5)  ;6
                                                (4 6 2 8 2 3 8 0 1)  ;7
                                                (4 5 3 4 1 6 2 8 0)  ;8
                                                )
                                                ;0 1 2 3 4 5 6 7 8
                                  :demands '(20 10 15 40 30 20 10 30)
                                  :capacity 30)
         (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6 7 8)) problem)
           (let* ((wc (basic-working-copy s1))
                  (ops-list nil)
                  (action (delta-cvrp-action*)))

             (prepare-solution-for-neighborhood-exploration wc)
             (initialize-action-for-delta-cost-computation wc problem action)

             (bformat t "Testing doselect-route")
             (doselect-subroute* (c1 1 wc
                                     :ex-cond (< c1.position 3))
                 (format t "Selected subroute: ~a~%"
                         (subroute-selected-at-operation c1 wc))
                 (pp-solution wc t) (terpri)
                 (format t "Delta distance after op: ~a~%"
                         (delta-distance action))
                 (format t "Route feasibility after op: ~a~%"
                         (delta-routes-feasibility action))
                 (format t "distance-stack: ~a, feasibility: ~a~2%"
                         (delta-distance-stack action)
                         (delta-routes-feasibility-stack action))))))
       #+END_SRC

**** apply-neighborhood-operation
***** description
      In this method we won't do anything.  We are just creating it to avoid an error when applying the operations to a working copy.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
      (defbehavior apply-neighborhood-operation
        ((operation operation-select-subroute)
         (wc basic-working-copy))
      :log-str "(Not) Applying op select-subroute"

      "Don't do anything.  This is here to avoid errors when applying a set of operations.  The actual changes will be made by the simpler-operations."
      nil)
      #+END_SRC
***** simple test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3 4 5)))
        (let* ((wc1 (basic-working-copy s1))
               (ops-list nil))

          (prepare-solution-for-neighborhood-exploration wc1)

          (bformat t "Testing doselect-subroute (variable-length)")

          (format t "Original solution:~%")
          (pp-solution wc1 t) (terpri)

          (doselect-subroute (ss1 1 wc1)
            (format t "After one select-subroute:~%")
            (pp-solution wc1 t) (terpri))))
      #+END_SRC
      
*** insert-subroute
**** description
     In a given solution insert a previously selected subroute in one route at a given position.
**** class definition
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp 
      ;;The insert-subroute class definition.
      (def-vrp-class operation-insert-subroute (neighborhood-operation)
         ()
         :documentation "A class to represent the insert-subroute operation in a neighborhood criterion."
         :constructor (op-insert-subroute (route pos operand))
         :print-object-string ("<op:is ~a ~a ~a>" route pos operand)
         :slots-for-obj= (route pos operand)
         :slots-for-clone (route pos operand))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((c1 (op-insert-subroute 1 1 0))
             (c2 (op-insert-subroute 1 1 1))
             (c3 (op-insert-subroute 1 2 0))
             (c4 (op-insert-subroute 2 1 0))
             (c5 (clone c1)))
        (bformat t "Testing op-insert-subroute...")

        (format t "Printing the objects:~%")
        (loop for e in (list c1 c2 c3 c4 c5)
              doing (format t "   op-insert-subroute: ~a~%" e))

        (deftests "Testing obj="
          (check-t (obj= c1 c1))
          (check-t (obj= c1 c5))

          (check-nil (obj= c1 c2))
          (check-nil (obj= c1 c3))
          (check-nil (obj= c2 c3))
          (check-nil (obj= c3 c4))))
      #+END_SRC
**** get-simpler-operations-from
***** description
      This function returns all the operations involved in the insert-subroute operation.  We have to take into account whether or not the subroute has been reversed.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
      (defmethod get-simpler-operations-from
          ((op operation-insert-subroute)
           (wc basic-working-copy))
        "We return a list with all the insertions that will be made because of this insert-subroute operation. We need to check whether or not the subroute has been reversed."
        (let* ((route-for-insertion (route op))
               (pos-for-insertion (pos op))
               (subroute-id (operand op))
               ;; let's get the size of the subroute
               (subroute-size (get-subroute-size subroute-id wc)))


          (if (not (subroute-reversed-p subroute-id wc))
              (then
                (loop for i from 1 to subroute-size
                      for current-id from subroute-id
                      for current-position from pos-for-insertion

                      collect (op-insert-client
                               route-for-insertion
                               current-position
                               current-id)))
              (else ;; insert in the opposite order
                ;; This can be achieved by inserting
                ;; in the same order but always in
                ;; the same position, because we
                ;; always insert before the previous
                ;; element
                (loop for i from 1 to subroute-size
                      for current-insert-id from subroute-id
                      collect (op-insert-client
                               route-for-insertion
                               pos-for-insertion
                               current-insert-id))))))
      #+END_SRC

***** tests
****** simple test
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9 10)))
         (let* ((wc (basic-working-copy s1))
                (z1 0) (z2 3)
                (op1 (op-select-subroute 1 2 3 z1))
                (op2 (op-insert-subroute 2 1 z1))
                (op3 (op-insert-subroute 2 6 z1)))

           (prepare-solution-for-neighborhood-exploration wc)

           (bformat t "Testing get-simpler-operations-from insert-subroute")

           (dolist (op (get-simpler-operations-from op1 wc))
             (simulate-neighborhood-operation op wc))

           (format t "get-simpler-operations-from op2:~%  ~a~%"
                   (get-simpler-operations-from op2 wc))

           (dolist (op (get-simpler-operations-from op2 wc))
             (simulate-neighborhood-operation op wc))

           (format t "After subroute-insertion:~%")
           (pp-solution wc t) (terpri)

           (dolist (op (get-simpler-operations-from op2 wc))
             (undo-neighborhood-operation op wc))

           (format t "After undo the subroute-insertion:~%")
           (pp-solution wc t) (terpri)

           (dolist (op (get-simpler-operations-from op3 wc))
             (simulate-neighborhood-operation op wc))

           (format t "After another subroute-insertion:~%")
           (pp-solution wc t) (terpri)

           ;; (check-non-nil (selected-subroutes wc1))
           ;; (check-= 3 (get-subroute-size sr1 wc1))
           ;; (check-nil (subroute-reversed-p sr1 wc1))

           ;; (simulate-neighborhood-operation op2 wc1)
           ;; (check-= 2 (length (selected-subroutes wc1)))
           ;; (check-= 4 (get-subroute-size sr2 wc1))
           ;; (check-nil (subroute-reversed-p sr2 wc1))

           ))
       #+END_SRC
****** test changing the solution
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9 10)))
         (let* ((wc1 (basic-working-copy s1))
                (sr1 0) (sr2 3)
                (op1 (op-select-subroute 1 2 3 sr1))
                (op2 (op-select-subroute 2 1 4 sr2))
                list1)

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing get-simpler-operations-from select-subroute")

           (setf list1 (get-simpler-operations-from op1 wc1))

           (format t "Solution after first selection:~%")
           (dolist (op list1) (simulate-neighborhood-operation op wc1))
           (pp-solution wc1 t)

           (format t "Solution after second selection:~%")
           (dolist (op (get-simpler-operations-from op2 wc1))
             (simulate-neighborhood-operation op wc1))
           (pp-solution wc1 t)

           ))
       #+END_SRC
**** *macro* for the creation of doinsert-subroutes
***** description
      As I want to add the doinsert-subroute* macro, and it will be very similar to doselect-subroute, I want to add a macro here, so the difference will only be the simpler-ops-macro* and undo-simpler-ops-macro*.
***** code
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
       (defmacro make-doinsert-subroute
           (name
            &key
              (simpler-ops-macro
               'simulate-simpler-ops-macro)
              (undo-simpler-ops-macro
               'undo-simpler-ops-macro))
           `(defmacro ,name
                ((cname route working-copy
                        &key ge gt le lt dt ex ex-cond)
                 &body body)
              "Iterates through all the positions in the given route, creates an instance of op-insert-subroute, pushes all its simpler-operations into ops-lists, simulates them, do whatever the users wants to do, and finally restores everything to the previous state.
       Example:
          (doinsert-subroute (z1 r1 wc1)
            (format t \"Inserting subroute ~a.~%\"
               (client-selected-at-operation c1 wc1)))
                 z1   is the index of the subroute that we want to insert
                      (actually it should be the selections-count corresponding
                      to its selection)
                 r1  is the id of the route we want to make the insertion in.
                 wc1 is the working-copy where we are working."
              (with-gensyms (op
                             simpler-ops
                             initial-pos
                             final-pos
                             initial-target-route
                             final-target-route
                             exclude-target-route
                             exclude-pos
                             last-pos)

                ;; here we create the names of the
                ;; variables we create on the fly
                (let* ((pos (symb cname ".ins.pos"))
                       (cname.ins.pos (symb cname ".insert.position"))
                       (cname.ins.coord (symb cname ".insert.coord"))
                       (cname.ins.route (symb cname ".insert.route")))

                  ;; here we assign values to cname.insert.route
                  `(symbol-macrolet ((,cname.ins.pos
                                      (pos-of-client-selected-at-operation
                                       ,cname ,working-copy))
                                     (,cname.ins.route
                                      (get-inserted-client-route
                                       ,cname ,working-copy))
                                     (,cname.ins.coord
                                      (get-inserted-client-info
                                       ,cname ,working-copy)))
                     ;; here we need to set the value of the last pos
                     ;; to 1+ than the route-length because we can
                     ;; insert at the end of the route
                     (let* ((,last-pos (1+ (route-length ,route ,working-copy))))

                       (with-variables-for-constraints-in-exhaustive-macro
                           (,initial-pos
                            ,ge ,gt
                            ,final-pos ,le ,lt
                            ,initial-target-route
                            ,final-target-route
                            ,exclude-target-route
                            ,exclude-pos
                            ,dt
                            ,last-pos)
                         (loop for ,pos from
                               ;; here we use the macro
                               ;; for the initialization of
                               ;; the values
                               (initial-for-value-in-all-macros
                                ,initial-target-route
                                ,route
                                ,initial-pos)
                               ;; here we also use the macro
                               ;; for the initialization of
                               ;; the macro
                               to (final-value-for-loop-in-route-operation-macro
                                   ,final-target-route
                                   ,route
                                   ,final-pos
                                   ,last-pos)
                               ;; the next line allows the user
                               ;; to stop the search
                               while (not *vrp-stop-neighborhood-search*)

                               do ;; let's execute the code if
                               ;; we are not in a forbidden coord
                               (unless-forbidden-coord
                                   (,ex
                                    ,route
                                    ,pos
                                    ,dt
                                    ,exclude-target-route
                                    ,exclude-pos
                                    ,ex-cond)
                                 (let* ( ;; we create the op and keep going
                                        ;; with the rest
                                        (,op (op-insert-subroute
                                              ,route ,pos ,cname))
                                        ;; we get the simpler ops
                                        (,simpler-ops
                                         (get-simpler-operations-from
                                          ,op ,working-copy)))

                                   ;; here I want to add some code to execute it
                                   ;; before the simulation of the operation
                                   ;; but I'm not yet sure about how
                                   ;; to do it right :-/

                                   ;; now the simulation
                                   (,',simpler-ops-macro
                                    ,simpler-ops ,working-copy)

                                   ;; let's do what the user wants
                                   (progn ,@body)

                                   ;; now the clean up
                                   (,',undo-simpler-ops-macro
                                    ,simpler-ops
                                    ,working-copy)))))))))))
       #+END_SRC
***** tests
****** testing macroexpansion
       #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-tests.lisp 
       (make-doinsert-subroute doinsert-subroute%)       
       #+END_SRC
****** testing original tests for doinsert-suborute
******* very simple test
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3) (4 5)))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil))

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing doinsert-subroute")

           (format t "Original solution:~%")
           (pp-solution wc1 t) (terpri)

           (doselect-subroute (ss1 1 wc1)
             (doinsert-subroute% (ss1 2 wc1)
               (format t "Length ~a, inserting in route ~a~%"
                       ss1.subroute.length
                       ss1.insert.route)
              (pp-solution wc1 t) (terpri)))))
        #+END_SRC
**** doinsert-subroute
***** description
      Iterates through all the possitions in the given route and inserts the subroute at that postion.
***** code
****** version 2 (using the maker)
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
       (make-doinsert-subroute doinsert-subroute)
       #+END_SRC
****** +version 2 (with macros)+
       #+BEGIN_SRC lisp +n -r :results none :exports code
       (defmacro doinsert-subroute
           ((cname route working-copy
             &key ge gt le lt dt ex ex-cond)
            &body body)
         "Iterates through all the positions in the given route, creates an instance of op-insert-subroute, pushes all its simpler-operations into ops-lists, simulates them, do whatever the users wants to do, and finally restores everything to the previous state.
       Example:
          (doinsert-subroute (z1 r1 wc1)
            (format t \"Inserting subroute ~a.~%\"
               (client-selected-at-operation c1 wc1)))
                 z1   is the index of the subroute that we want to insert
                      (actually it should be the selections-count corresponding
                      to its selection)
                 r1  is the id of the route we want to make the insertion in.
                 wc1 is the working-copy where we are working."
         (with-gensyms (op
                        simpler-ops
                        initial-pos
                        final-pos
                        initial-target-route
                        final-target-route
                        exclude-target-route
                        exclude-pos
                        last-pos)

           ;; here we create the names of the
           ;; variables we create on the fly
           (let* ((pos (symb cname ".ins.pos"))
                  (cname.ins.pos (symb cname ".insert.position"))
                  (cname.ins.coord (symb cname ".insert.coord"))
                  (cname.ins.route (symb cname ".insert.route")))

             ;; here we assign values to cname.insert.route
             `(symbol-macrolet ((,cname.ins.pos
                                 (pos-of-client-selected-at-operation
                                  ,cname ,working-copy))
                                (,cname.ins.route
                                 (get-inserted-client-route
                                  ,cname ,working-copy))
                                (,cname.ins.coord
                                 (get-inserted-client-info
                                  ,cname ,working-copy)))
                ;; here we need to set the value of the last pos
                ;; to 1+ than the route-length because we can
                ;; insert at the end of the route
                (let* ((,last-pos (1+ (route-length ,route ,working-copy))))

                  (with-variables-for-constraints-in-exhaustive-macro
                      (,initial-pos
                       ,ge ,gt
                       ,final-pos ,le ,lt
                       ,initial-target-route
                       ,final-target-route
                       ,exclude-target-route
                       ,exclude-pos
                       ,dt
                       ,last-pos)
                    (loop for ,pos from
                          ;; here we use the macro
                          ;; for the initialization of
                          ;; the values
                          (initial-for-value-in-all-macros
                           ,initial-target-route
                           ,route
                           ,initial-pos)
                          ;; here we also use the macro
                          ;; for the initialization of
                          ;; the macro
                          to (final-value-for-loop-in-route-operation-macro
                              ,final-target-route
                              ,route
                              ,final-pos
                              ,last-pos)
                          ;; the next line allows the user
                          ;; to stop the search
                          while (not *vrp-stop-neighborhood-search*)

                          do ;; let's execute the code if
                          ;; we are not in a forbidden coord
                          (unless-forbidden-coord
                             (,ex
                               ,route
                               ,pos
                               ,dt
                               ,exclude-target-route
                               ,exclude-pos
                               ,ex-cond)
                            (let* (;; we create the op and keep going
                                   ;; with the rest
                                   (,op (op-insert-subroute
                                         ,route ,pos ,cname))
                                   ;; we get the simpler ops
                                   (,simpler-ops
                                         (get-simpler-operations-from
                                          ,op ,working-copy)))

                                   ;; here I want to add some code to execute it
                                   ;; before the simulation of the operation
                                   ;; but I'm not yet sure about how
                                   ;; to do it right :-/

                                   ;; now the simulation of the ops
                                   (simulate-simpler-ops-macro
                                    ,simpler-ops ,working-copy)

                                   ;; let's do what the user wants
                                   (progn ,@body)

                                   ;; undo the operations
                                   (undo-simpler-ops-macro
                                    ,simpler-ops ,working-copy))))))))))
       #+END_SRC
****** +version 1 (original code)+
       #+BEGIN_SRC lisp +n -r :results none :exports code
       (defmacro doinsert-subroute ((cname route working-copy) &body body)
         "Iterates through all the positions in the given route, creates an instance of op-insert-subroute, pushes all its simpler-operations into ops-lists, simulates them, do whatever the users wants to do, and finally restores everything to the previous state.
       Example:
          (doinsert-subroute (z1 r1 wc1)
            (format t \"Inserting subroute ~a.~%\"
               (client-selected-at-operation c1 wc1)))
                 z1   is the index of the subroute that we want to insert
                      (actually it should be the selections-count corresponding
                      to its selection)
                 r1  is the id of the route we want to make the insertion in.
                 wc1 is the working-copy where we are working."
         (with-gensyms (op simpler-ops)
           (let* ((pos (symb cname ".insert.position"))
                  (cname.ins.route (symb cname ".insert.route")))

             ;; here we assign values to cname.insert.route
             `(symbol-macrolet ((,cname.ins.route
                                 (get-inserted-client-route
                                  ,cname ,working-copy)))         
                 (loop for ,pos from 1 to (1+ (route-length ,route ,working-copy))
                    for ,op = (,'op-insert-subroute ,route ,pos ,cname)
                    for ,simpler-ops = (get-simpler-operations-from
                                        ,op ,working-copy)
                    while (not *vrp-stop-neighborhood-search*)

                    ;; simulate the simpler ops
                    do (simulate-simpler-ops-macro
                        ,simpler-ops ,working-copy)

                    ;; execute the user's actions
                    do (progn ,@body)

                    ;; undo the operations
                    do (undo-simpler-ops-macro
                        ,simpler-ops ,working-copy))))))
       #+END_SRC
***** tests
****** simple test
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3) (4 5)))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil))

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing doinsert-subroute")

           (format t "Original solution:~%")
           (pp-solution wc1 t) (terpri)

           (doselect-subroute (ss1 1 wc1)
             (doinsert-subroute (ss1 2 wc1)
               (format t "Length ~a, inserting in route ~a~%"
                       ss1.subroute.length
                       ss1.insert.route)
              (pp-solution wc1 t) (terpri)))))
       #+END_SRC
      
****** testing cname.insert.position
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3) (4 5)))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil))

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing doinsert-subroute")

           (format t "Original solution:~%")
           (pp-solution wc1 t) (terpri)

           (doselect-subroute (ss1 1 wc1)
             (doinsert-subroute (ss1 2 wc1)
              (format t "Subroute with length ~a selected from (1 ~a) inserted at (2 ~a)~%"
                      ss1.subroute.length
                      ss1.select.position
                      ss1.insert.position)
              (pp-solution wc1 t) (terpri)))))
       #+END_SRC
      
****** simple test with constraints
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5) (6 7)))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil))

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing doinsert-subroute")

           (format t "Original solution:~%")
           (pp-solution wc1 t) (terpri)

           (doselect-subroute-with-length (ss1 2 2 wc1)
             (doinsert-subroute (ss1 1 wc1
                                     :ex-cond (oddp ss1.ins.pos))
               (format t "Length ~a, inserting in pos ~a~%"
                       ss1.subroute.length
                       ss1.insert.coord)
              (pp-solution wc1 t) (terpri)))))
       #+END_SRC
      
**** doinsert-subroute*
***** description
      This is the * version of the doinsert-subroute*.  Here we assume that in the expansion place there is a variable =problem=, and a variable =action=.
***** code (using the maker)
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
       (make-doinsert-subroute
        doinsert-subroute*
        :simpler-ops-macro simulate-simpler-ops-macro*
        :undo-simpler-ops-macro undo-simpler-ops-macro*)
       #+END_SRC

***** tests
****** simple test
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                                (5 0 6 7 2 4 2 3 4)  ;1
                                                (1 8 0 3 9 1 2 4 5)  ;2
                                                (4 5 1 0 5 7 1 9 5)  ;3
                                                (4 5 1 5 0 6 2 8 2)  ;4
                                                (1 5 7 6 9 0 1 6 7)  ;5
                                                (4 5 1 3 5 7 0 9 5)  ;6
                                                (4 6 2 8 2 3 8 0 1)  ;7
                                                (4 5 3 4 1 6 2 8 0)  ;8
                                                )
                                                ;0 1 2 3 4 5 6 7 8
                                  :demands '(20 10 15 40 30 20 10 30)
                                  :capacity 30)
         (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6)) problem)
           (let* ((wc (basic-working-copy s1))
                  (ops-list nil)
                  (action (delta-cvrp-action*)))

             (prepare-solution-for-neighborhood-exploration wc)
             (initialize-action-for-delta-cost-computation wc problem action)

             (bformat t "Testing doinsert-route*")
             (doselect-subroute-with-length* (c1 1 3 wc
                                                 :ex-cond (/= c1.position 1))
               (doinsert-subroute* (c1 2 wc
                                       :ex-cond (/= c1.ins.pos 1))
                   (format t "Selected subroute: ~a~%"
                          (subroute-selected-at-operation c1 wc))
                  (pp-solution wc t) (terpri)
                  (format t "Delta distance after op: ~a~%"
                          (delta-distance action))
                  (format t "Route feasibility after op: ~a~%"
                          (delta-routes-feasibility action))
                  (format t "distance-stack: ~a~%feasibility-stack: ~a~2%"
                          (delta-distance-stack action)
                          (delta-routes-feasibility-stack action)))))))
       #+END_SRC

****** test with constraints
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                                (5 0 6 7 2 4 2 3 4)  ;1
                                                (1 8 0 3 9 1 2 4 5)  ;2
                                                (4 5 1 0 5 7 1 9 5)  ;3
                                                (4 5 1 5 0 6 2 8 2)  ;4
                                                (1 5 7 6 9 0 1 6 7)  ;5
                                                (4 5 1 3 5 7 0 9 5)  ;6
                                                (4 6 2 8 2 3 8 0 1)  ;7
                                                (4 5 3 4 1 6 2 8 0)  ;8
                                                )
                                                ;0 1 2 3 4 5 6 7 8
                                  :demands '(20 10 15 40 30 20 10 30)
                                  :capacity 30)
         (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6 7 8)) problem)
           (let* ((wc (basic-working-copy s1))
                  (ops-list nil)
                  (action (delta-cvrp-action*)))

             (prepare-solution-for-neighborhood-exploration wc)
             (initialize-action-for-delta-cost-computation wc problem action)

             (bformat t "Testing doselect-route")
             (doselect-subroute-with-length* (c1 1 2 wc
                                                 :ex-cond (< c1.position 3))
                 (format t "Selected subroute: ~a~%"
                         (subroute-selected-at-operation c1 wc))
                 (pp-solution wc t) (terpri)
                 (format t "Delta distance after op: ~a~%"
                         (delta-distance action))
                 (format t "Route feasibility after op: ~a~%"
                         (delta-routes-feasibility action))
                 (format t "distance-stack: ~a, feasibility: ~a~2%"
                         (delta-distance-stack action)
                         (delta-routes-feasibility-stack action))))))
       #+END_SRC

*** reverse-subroute
**** description
     Reverse the order of the clients in a selected-subroute.
**** class definition
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp 
      ;;The reverse-subroute class definition.
      (def-vrp-class operation-reverse-subroute ()
        ((subroute-id
          :documentation "The id of the subroute that should be reversed."))
        ;; the rest of the class options
        :documentation "A class to represent the reverse-subroute operation in a neighborhood criterion."
        :constructor (op-reverse-subroute (subroute-id))
        :print-object-string ("<op:rs ~a>" subroute-id)
        :slots-for-obj= (subroute-id)
        :slots-for-clone (subroute-id))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((c1 (op-reverse-subroute 1))
             (c2 (op-reverse-subroute 2))
             (c3 (clone c1)))
        (bformat t "Testing op-reverse-subroute...")

        (format t "Printing the objects:~%")
        (loop for e in (list c1 c2 c3)
              doing (format t "   op-reverse-subroute: ~a~%" e))

        (deftests "Testing obj="
          (check-t (obj= c1 c1))
          (check-t (obj= c1 c3))

          (check-nil (obj= c1 c2))
          (check-nil (obj= c2 c3))))
      #+END_SRC
**** simulate-neighborhood-operation
***** description
      In the simulate-neighborhood-operation for the reverse-subroute operation we only need to toggle the reversed-status of the subroute.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
      (defmethod simulate-neighborhood-operation
          ((op operation-reverse-subroute)
            (wc basic-working-copy))
        (mark-subroute-as-reversed (subroute-id op) wc))
      #+END_SRC

***** tests
****** simple tests
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9 10)))
         (let* ((wc1 (basic-working-copy s1))
                (sr1 0) (sr2 1)
                (op1 (op-select-subroute 1 2 3 sr1))
                (op2 (op-reverse-subroute sr1))
                (op3 (op-insert-subroute 1 2 sr1)))

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing simulate-neighborhood-operation for reverse-subroute")

           (format t "Original solution:~%")
           (pp-solution wc1 t) (terpri)

           (dolist (op (get-simpler-operations-from op1 wc1))
             (simulate-neighborhood-operation op wc1))

           (dolist (op (get-simpler-operations-from op2 wc1))
             (simulate-neighborhood-operation op wc1))

           (dolist (op (get-simpler-operations-from op3 wc1))
             (simulate-neighborhood-operation op wc1))


           (format t "Solution after reversal and insertion:~%")
           (pp-solution wc1 t) (terpri)

           ))
       #+END_SRC
**** undo-neighborhood-operation
***** description
      In the undo-neighborhood-operation for the reverse-subroute operation we only need to toggle the reversed-status of the subroute.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
      (defmethod undo-neighborhood-operation
          ((op operation-reverse-subroute)
            (wc basic-working-copy))
        (mark-subroute-as-reversed (subroute-id op) wc))
      #+END_SRC

***** tests
****** simple tests
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9 10)))
         (let* ((wc1 (basic-working-copy s1))
                (sr1 0) (sr2 1)
                (op1 (op-select-subroute 1 2 3 sr1))
                (op2 (op-reverse-subroute sr1))
                (op3 (op-insert-subroute 1 2 sr1)))

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing undo-neighborhood-operation for reverse-subroute")

           (format t "Original solution:~%")
           (pp-solution wc1 t) (terpri)

           (dolist (op (get-simpler-operations-from op1 wc1))
             (simulate-neighborhood-operation op wc1))

           (dolist (op (get-simpler-operations-from op2 wc1))
             (simulate-neighborhood-operation op wc1))

           (dolist (op (get-simpler-operations-from op3 wc1))
             (simulate-neighborhood-operation op wc1))

           (format t "Solution after reversal and insertion:~%")
           (pp-solution wc1 t) (terpri)

           ;; undoing 
           (dolist (op (get-simpler-operations-from op3 wc1))
             (undo-neighborhood-operation op wc1))

           (dolist (op (get-simpler-operations-from op2 wc1))
             (undo-neighborhood-operation op wc1))

           ;; now lets insert again

           (dolist (op (get-simpler-operations-from op3 wc1))
             (simulate-neighborhood-operation op wc1))
    
           (format t "Solution after undoing reversal and insertion:~%")
           (pp-solution wc1 t) (terpri)


           ))
       #+END_SRC
**** doreverse-subroute
***** description
      Here we can use the make-do-neighborhood-static-macro.  
***** code (using make-do-neighborhood-static-macro)
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
      (make-do-neighborhood-static-macro
         doreverse-subroute  (subroute-id working-copy)
         op-reverse-subroute
         (subroute-id)
         "Reverses the given selected subroute. If the subroute has not been previously selected things will break.")    
      #+END_SRC
***** tests
****** simple tests (no iterations)
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5 6 7) ()))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil)

                (*vrp-stop-neighborhood-search* nil))

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing the doreverse-subroute macro")

           (format t "The original solution:~%")
           (pp-solution wc1 t) (terpri)



           (doselect-subroute (z1 1 wc1)
             (doreverse-subroute (z1 wc1)
               (doinsert-subroute (z1 2 wc1)
                (format t "After the subroute-reverse:~%")
                (pp-solution wc1 t) (terpri))))))
       #+END_SRC
     
**** apply-neighborhood-operation
***** description
      In this method we won't do anything.  We are just creating it to avoid an error when applying the operations to a working copy.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
      (defbehavior apply-neighborhood-operation
          ((operation operation-reverse-subroute)
           (wc basic-working-copy))
        :log-str "(Not) Applying op select-subroute"

      "Don't do anything.  This is here to avoid errors when applying a set of operations.  The actual changes will be made by the simpler-operations."
      nil)
      #+END_SRC
***** simple test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3 4 5)))
        (let* ((wc1 (basic-working-copy s1))
               (ops-list nil))

          (prepare-solution-for-neighborhood-exploration wc1)

          (bformat t "Testing doselect-subroute (variable-length)")

          (format t "Original solution:~%")
          (pp-solution wc1 t) (terpri)

          (doselect-subroute (ss1 1 wc1)
            (format t "After one select-subroute:~%")
            (pp-solution wc1 t) (terpri))))
      #+END_SRC
**** doreverse-subroute*
***** description
      This is the * version of the reverse-subroute operation.
***** code (using make-do-neighborhood-static-macro)
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
      (make-do-neighborhood-static-macro
        doreverse-subroute*
        (subroute-id working-copy)
        op-reverse-subroute
        (subroute-id)
        "Reverses the given selected subroute. If the subroute has not been previously selected things will break."
        :simpler-ops-macro simulate-simpler-ops-macro*
        :undo-simpler-ops-macro undo-simpler-ops-macro*)    
      #+END_SRC
***** tests
****** simple test
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                                (5 0 6 7 2 4 2 3 4)  ;1
                                                (1 8 0 3 9 1 2 4 5)  ;2
                                                (4 5 1 0 5 7 1 9 5)  ;3
                                                (4 5 1 5 0 6 2 8 2)  ;4
                                                (1 5 7 6 9 0 1 6 7)  ;5
                                                (4 5 1 3 5 7 0 9 5)  ;6
                                                (4 6 2 8 2 3 8 0 1)  ;7
                                                (4 5 3 4 1 6 2 8 0)  ;8
                                                )
                                                ;0 1 2 3 4 5 6 7 8
                                  :demands '(20 10 15 40 30 20 10 30)
                                  :capacity 30)
         (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6)) problem)
           (let* ((wc (basic-working-copy s1))
                  (ops-list nil)
                  (action (delta-cvrp-action*)))

             (prepare-solution-for-neighborhood-exploration wc)
             (initialize-action-for-delta-cost-computation wc problem action)

             (bformat t "Testing doinsert-route*")
             (doselect-subroute-with-length* (c1 1 2 wc
                                                 :ex-cond (/= c1.position 1))
               (doreverse-subroute* (c1 wc)
                (doinsert-subroute* (c1 2 wc
                                        :ex-cond (/= c1.ins.pos 1))
                  (format t "Selected subroute: ~a~%"
                          (subroute-selected-at-operation c1 wc))
                  (pp-solution wc t) (terpri)
                  (format t "Delta distance after op: ~a~%"
                          (delta-distance action))
                  (format t "Route feasibility after op: ~a~%"
                          (delta-routes-feasibility action))
                  (format t "distance-stack: ~a~%feasibility-stack: ~a~2%"
                          (delta-distance-stack action)
                          (delta-routes-feasibility-stack action))))))))
       #+END_SRC

*** swap-subroutes
**** description
     Swaps two subroutes.
**** class definition
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp 
      ;;The swap-subroutes class definition.
      (def-vrp-class operation-swap-subroutes ()
        ((subroute1
          :documentation "The id of the first subroute that should be swapped.")
         (subroute2
          :documentation "The id of the second subroute that should be swapped."))
  
        :documentation "A class to represent the swap-subroute operation in a neighborhood criterion."
        :constructor (op-swap-subroutes (subroute1 subroute2))
        :print-object-string ("<op:sz ~a ~a>" subroute1 subroute2)
        :slots-for-obj= (subroute1 subroute2)
        :slots-for-clone (subroute1 subroute2))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((c1 (op-swap-subroutes 1 1))
             (c2 (op-swap-subroutes 1 2))
             (c3 (op-swap-subroutes 2 1))
             (c4 (clone c1)))

        (bformat t "Testing op-swap-subroutes")

        (format t "Printing the objects:~%")
        (loop for e in (list c1 c2 c3 c4)
              doing (format t "   op-swap-subroutes: ~a~%" e))

        (deftests "Testing obj="
          (check-t (obj= c1 c1))
          (check-t (obj= c1 c4))

          (check-nil (obj= c1 c2))
          (check-nil (obj= c1 c3))
          (check-nil (obj= c2 c3))
          (check-nil (obj= c3 c4))))
      #+END_SRC
    
**** get-simpler-operations-from
***** description
      This function returns all the operations involved in the swap-subroutes operation.  This function should return all the insert-client operations, not only the two insert-subroute :-o.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
      (defmethod get-simpler-operations-from
          ((op operation-swap-subroutes)
           (wc basic-working-copy))
        "Returns all the insert-clients related to a swap subroutes operation."


        (let* ((s1 (subroute1 op))
               (s2 (subroute2 op))
               (s1-id (id (client-selected-at-operation s1 wc)))
               (s2-id (id (client-selected-at-operation s2 wc)))
               first-subroute-insertion
               second-subroute-insertion)

          (symbol-macrolet
              ((s1-route (route-of-client-selected-at-operation s1 wc))
               (s1-pos (pos-of-client-selected-at-operation s1 wc))
               (s2-route (route-of-client-selected-at-operation s2 wc))
               (s2-pos (pos-of-client-selected-at-operation s2 wc)))

            ;; first we create the two subroute-insertions
            ;; and then we'll create the insertions from them
            ;; we'll store the two subroute insertions in the
            ;; variables first-subroute-insertion and
            ;; second-subroute-insertion

            (cond
              ;; they are in different routes
              ((/= s1-route s2-route)
               ;; they are in different routes
               ;; so the order doesn't matter
               ;; return the list in any order
               ;; let's create the first insertion (s2 in s1 coordinates)
               (setf first-subroute-insertion
                     (op-insert-subroute s2-route s2-pos s1))
               ;; and then the insertion (s1 in s2 coordinates)
               (setf second-subroute-insertion
                     (op-insert-subroute s1-route s1-pos s2)))

              ;; from here on they are on the same route
              ((< s1-pos s2-pos) ;; s1 is clearly before s2

               ;; s1 was in a position before s2
               ;; so we need to insert first s2 were s1 was
               ;; and then, s1 where s2 was
               ;; but to do that, I'm going to add first s1 where s2 was
               ;; and then s2 in s1 position.
               ;; This way, the insertion of s1 does non affect the insertions
               ;; made by s2
               (setf first-subroute-insertion  (op-insert-subroute s2-route s2-pos s1))
               (setf second-subroute-insertion (op-insert-subroute s1-route s1-pos s2)))

              ((< s2-pos s1-pos) ;; s2 is evidently before s1 and no overlap

               ;; s2 was in a position before s1 so,
               ;; after the swap s1 should be before s2
               ;; To do that, I'm going to insert first s2 to where s1 was
               ;; and then s1 into s2 position.
               ;; This way, the insertions of s2 do not affect the insertions
               ;; made by s1
               (setf first-subroute-insertion
                     (op-insert-subroute s1-route s1-pos s2))
               (setf second-subroute-insertion
                     (op-insert-subroute s2-route s2-pos s1)))

              ;; from here on they are on the same route and same pos :-o
              ;; (they were right one after another or there was an overlap)
              ((= s1-pos s2-pos)
               ;; to know which one we should insert first,
               ;; we need to know which one was before the other
               ;; in the original solution.
               ;; we are assumming that there are not selections
               ;; after insertions, so we can use the fuction
               ;; client-c1-was-before-client-c2 to find out
               (if (client-c1-was-before-client-c2 s1-id s2-id wc)
                   (then ;; s1 was before s2
                     ;; so first insert s1 in the same place
                     (setf first-subroute-insertion
                           (op-insert-subroute s1-route s1-pos s1))
                     ;; and now insert s2 in the same place
                     (setf second-subroute-insertion
                           (op-insert-subroute s2-route s2-pos s2)))
                   (else ;; s2 was before s1
                     ;; so first insert s2 in the same place
                     (setf first-subroute-insertion
                           (op-insert-subroute s2-route s2-pos s2))
                     ;; and now insert s1 in the same place
                     (setf second-subroute-insertion
                           (op-insert-subroute s1-route s1-pos s1))))))
            ;; now create and return the list with all the insertions
            (append (get-simpler-operations-from
                     first-subroute-insertion wc)
                    (get-simpler-operations-from
                     second-subroute-insertion wc)))))
      #+END_SRC

***** tests
****** simple tests (in different routes)
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9)))
         (let* ((wc1 (basic-working-copy s1))
                (op1 (op-select-subroute 1 1 4 0))
                (op2 (op-select-subroute 2 1 2 4))
                (op3 (op-swap-subroutes 0 4)))

           (bformat t "Testing get-simpler-operations-from swap-subroutes")


           (prepare-solution-for-neighborhood-exploration wc1)

           (format t "Original solution:~%")
           (pp-solution wc1 t) (terpri)

           (dolist (op (get-simpler-operations-from op1 wc1))
             (simulate-neighborhood-operation op wc1))
           (format t "After the first subroute-selection~%")
           (pp-solution wc1 t) (terpri)

           (dolist (op (get-simpler-operations-from op2 wc1))
             (simulate-neighborhood-operation op wc1))
           (format t "After the second subroute-selection~%")
           (pp-solution wc1 t) (terpri)

           (dolist (op (get-simpler-operations-from op3 wc1))
             (simulate-neighborhood-operation op wc1))
           (format t "After the swap-subroutes~%")
           (pp-solution wc1 t) (terpri)

         ))
       #+END_SRC
****** simple tests (in the same route s1 < s2)
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5 6 7 8 9 10 11 12)))
         (let* ((wc1 (basic-working-copy s1))
                (s1-length 2)
                (op1 (op-select-subroute 1 1 s1-length 0))
                (op2 (op-select-subroute 1 3 3 s1-length))
                (op3 (op-swap-subroutes 0 s1-length)))

           (bformat t "Testing get-simpler-operations-from swap-subroutes")
       
           (prepare-solution-for-neighborhood-exploration wc1)

           (format t "Original solution:~%")
           (pp-solution wc1 t)

           (dolist (op (get-simpler-operations-from op1 wc1))
             (simulate-neighborhood-operation op wc1))
       
           (format t "After the first subroute-selection~%")
           (pp-solution wc1 t) (terpri)

           (dolist (op (get-simpler-operations-from op2 wc1))
             (simulate-neighborhood-operation op wc1))
       
           (format t "After the second subroute-selection~%")
           (pp-solution wc1 t) (terpri)


           (dolist (op (get-simpler-operations-from op3 wc1))
             (simulate-neighborhood-operation op wc1))
       
           (format t "After the swap-subroutes~%")
           (pp-solution wc1 t) (terpri)

           ))
       #+END_SRC
****** simple tests (in the same route s2 < s1 without overlap)
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5 6 7 8 9 10 11 12)))
         (let* ((wc1 (basic-working-copy s1))
                (s1-length 3)
                (op1 (op-select-subroute 1 9 s1-length 0))
                (op2 (op-select-subroute 1 4 3 s1-length))
                (op3 (op-swap-subroutes 0 s1-length)))

           (bformat t "Testing get-simpler-operations-from swap-subroutes")


           (prepare-solution-for-neighborhood-exploration wc1)
           (format t "Original solution:~%")
           (pp-solution wc1 t) (terpri)

           (dolist (op (get-simpler-operations-from op1 wc1))
             (simulate-neighborhood-operation op wc1))
           (format t "After the first subroute-selection~%")
           (pp-solution wc1 t) (terpri)

           (dolist (op (get-simpler-operations-from op2 wc1))
             (simulate-neighborhood-operation op wc1))
           (format t "After the second subroute-selection~%")
           (pp-solution wc1 t) (terpri)

           (dolist (op (get-simpler-operations-from op3 wc1))
             (simulate-neighborhood-operation op wc1))
           (format t "After the swap-subroutes~%")
           (pp-solution wc1 t) (terpri)


         ))
       #+END_SRC
****** simple tests (in the same route s2 < s1 with overlap)
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5 6 7 8 9 10 11 12)))
         (let* ((wc1 (basic-working-copy s1))
                (s1-length 4)
                (op1 (op-select-subroute 1 5 s1-length 0))
                (op2 (op-select-subroute 1 3 4 s1-length))
                (op3 (op-swap-subroutes 0 s1-length)))

           (bformat t "Testing get-simpler-operations-from swap-subroutes")


           (prepare-solution-for-neighborhood-exploration wc1)
           (format t "Original solution:~%")
           (pp-solution wc1 t) (terpri)

           (dolist (op (get-simpler-operations-from op1 wc1))
             (simulate-neighborhood-operation op wc1))
           (format t "After the first subroute-selection~%")
           (pp-solution wc1 t) (terpri)

           (dolist (op (get-simpler-operations-from op2 wc1))
             (simulate-neighborhood-operation op wc1))
           (format t "After the second subroute-selection~%")
           (pp-solution wc1 t) (terpri)

           (dolist (op (get-simpler-operations-from op3 wc1))
             (simulate-neighborhood-operation op wc1))
           (format t "After the swap-subroutes~%")
           (pp-solution wc1 t) (terpri)


         ))
       #+END_SRC
****** simple tests (in the same route s1 = s2 s1 was first)
       "Overlap" means that the first subroute is selected from "inside" the first one.
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5 6 7 8 9 10 11 12)))
         (let* ((wc1 (basic-working-copy s1))
                (s1-length 4)
                (op1 (op-select-subroute 1 2 s1-length 0))
                (op2 (op-select-subroute 1 2 3 s1-length))
                (op3 (op-swap-subroutes 0 s1-length)))

           (bformat t "Testing get-simpler-operations-from swap-subroutes")


           (prepare-solution-for-neighborhood-exploration wc1)

           (format t "Original solution:~%")
           (pp-solution wc1 t) (terpri)

           (dolist (op (get-simpler-operations-from op1 wc1))
             (simulate-neighborhood-operation op wc1))
           (format t "After the first subroute-selection~%")
           (pp-solution wc1 t) (terpri)

           (dolist (op (get-simpler-operations-from op2 wc1))
             (simulate-neighborhood-operation op wc1))
           (format t "After the second subroute-selection~%")
           (pp-solution wc1 t) (terpri)

           (dolist (op (get-simpler-operations-from op3 wc1))
             (simulate-neighborhood-operation op wc1))
           (format t "After the swap-subroutes~%")
           (pp-solution wc1 t) (terpri)


           ))
       #+END_SRC
**** doswap-subroutes
***** description
      Here we can use the make-do-neighborhood-static-macro.  
***** code (using make-do-neighborhood-static-macro)
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
      (make-do-neighborhood-static-macro
         doswap-subroutes  (subroute1 subroute2 working-copy)
         op-swap-subroutes 
         (subroute1 subroute2)
         "Swaps the selected-subroutes passed as arguments.")    
      #+END_SRC
***** tests
****** very simple test (from different routes)
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1  2  3  4  5  6  7 8)
                                 (9 10 11 12 13 14 15 16)))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil)
                (r1 1) (r2 2)
                (s1-length 3)
                (op1 (op-select-subroute r1 2 s1-length 0))
                (op2 (op-select-subroute r2 3 4 s1-length))
                )

           (prepare-solution-for-neighborhood-exploration wc1)

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (dolist (op (get-simpler-operations-from op1 wc1))
              (simulate-neighborhood-operation op wc1))

            (dolist (op (get-simpler-operations-from op2 wc1))
              (simulate-neighborhood-operation op wc1))

            (format t "Solution before swap:~%")
            (pp-solution wc1 t) (terpri)

            (doswap-subroutes (0 s1-length wc1)
              (format t "Inside doswap-subroutes:~%")
              (pp-solution wc1 t) (terpri))

            (format t "Solution after doswap:~%")
            (pp-solution wc1 t) (terpri)

          ))
       #+END_SRC
****** simple test with doselect-subroute (different routes sized)
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1  2  3  4  5)
                                 (6  7  8  9 10)))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil)
                (s1-length 2)
                (r1 1) (r2 2)
                (op1 (op-select-subroute 2 2 3 s1-length))
                (counter 0)
                )

           (bformat t "Testing doswap-subroutes")

           (prepare-solution-for-neighborhood-exploration wc1)

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)


            (doselect-subroute-with-length (s1 r1 s1-length wc1)
              (dolist (op (get-simpler-operations-from op1 wc1))
                (simulate-neighborhood-operation op wc1))
              (doswap-subroutes (s1 s1-length wc1)
                  (incf counter)
                  (format t "Inside doswap-subroutes ~a...~%"
                          counter)
                  (pp-solution wc1 t) (terpri))
              (dolist (op (get-simpler-operations-from op1 wc1))
                (undo-neighborhood-operation op wc1)))

            ;; (doselect-subroute-with-length (s1 r1 2 wc1)
            ;;   (doselect-subroute-with-length (s2 r2 4 wc1)
            ;;     (doswap-subroutes (s1 s2 wc1)
            ;;       (incf counter))))

            (format t "Neighborhood size: ~a~%" counter)
            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)))
       #+END_SRC
****** simple test with doselect-subroute (from different all sizes)
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1  2  3  4)
                                 (5  6  7  8)))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil)
                (r1 1) (r2 2)
                (counter 0)
                )

           (bformat t "Testing doswap-subroutes")

           (prepare-solution-for-neighborhood-exploration wc1)

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)


            (doselect-subroute (s1 r1 wc1)
              (doselect-subroute (s2 r2 wc1)
                (doswap-subroutes (s1 s2 wc1)
                  (incf counter)
                  (format t "Inside doswap-subroutes...~%")
                  (pp-solution wc1 t) (terpri))))

            ;; (doselect-subroute (s1 r1 wc1)
            ;;   (doselect-subroute (s2 r2 wc1)
            ;;     (doswap-subroutes (s1 s2 wc1)
            ;;       (incf counter))))

            (format t "Neighborhood size: ~a~%" counter)
            ;; (format t "Original solution:~%")
            ;; (pp-solution wc1 t)
            ;; (terpri)


          ))
       #+END_SRC
****** test with doselect-subroute (from the same route)
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1  2  3  4 5)))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil)
                (r1 1)
                (counter 0)
                )

           (bformat t "Testing doswap-subroutes")

           (prepare-solution-for-neighborhood-exploration wc1)

           (format t "Original solution:~%")
           (pp-solution wc1 t) (terpri)


           (doselect-subroute (s1 r1 wc1)
             (doselect-subroute (s2 r1 wc1)
               (doswap-subroutes (s1 s2 wc1)
                 (incf counter)
                 (format t "Inside doswap-subroutes...~%")
                 (pp-solution wc1 t) (terpri))))

           ;; (doselect-subroute (s1 r1 wc1)
           ;;   (doselect-subroute (s2 r2 wc1)
           ;;     (doswap-subroutes (s1 s2 wc1)
           ;;       (incf counter))))

           (format t "Neighborhood size: ~a~%" counter)
           ;; (format t "Original solution:~%")
           ;; (pp-solution wc1 t)
           ;; (terpri)


           ))
       #+END_SRC
**** doswap-subroutes*
***** description
      This is the * version of the swap-subroutes operations.  
***** code (using make-do-neighborhood-static-macro)
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
      (make-do-neighborhood-static-macro
         doswap-subroutes*
         (subroute1 subroute2 working-copy)
         op-swap-subroutes 
         (subroute1 subroute2)
         "Swaps the selected-subroutes passed as arguments."
         :simpler-ops-macro simulate-simpler-ops-macro*
         :undo-simpler-ops-macro undo-simpler-ops-macro*)    
      #+END_SRC
***** tests
****** simple test
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                                (5 0 6 7 2 4 2 3 4)  ;1
                                                (1 8 0 3 9 1 2 4 5)  ;2
                                                (4 5 1 0 5 7 1 9 5)  ;3
                                                (4 5 1 5 0 6 2 8 2)  ;4
                                                (1 5 7 6 9 0 1 6 7)  ;5
                                                (4 5 1 3 5 7 0 9 5)  ;6
                                                (4 6 2 8 2 3 8 0 1)  ;7
                                                (4 5 3 4 1 6 2 8 0)  ;8
                                                )
                                                ;0 1 2 3 4 5 6 7 8
                                  :demands '(20 10 15 40 30 20 10 30)
                                  :capacity 30)
         (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6)) problem)
           (let* ((wc (basic-working-copy s1))
                  (ops-list nil)
                  (action (delta-cvrp-action*)))

             (prepare-solution-for-neighborhood-exploration wc)
             (initialize-action-for-delta-cost-computation wc problem action)

             (bformat t "Testing doinsert-route*")
             (doselect-subroute-with-length* (c1 1 2 wc
                                                 :ex-cond (/= c1.position 1))
               (doselect-subroute-with-length* (c2 2 2 wc
                                       :ex-cond (/= c2.position 1))
                 (doswap-subroutes* (c1 c2 wc)
                   (format t "Selected subroute: ~a~%"
                           (subroute-selected-at-operation c1 wc))
                   (pp-solution wc t) (terpri)
                   (format t "Delta distance after op: ~a~%"
                           (delta-distance action))
                   (format t "Route feasibility after op: ~a~%"
                           (delta-routes-feasibility action))
                   (format t "distance-stack: ~a~%feasibility-stack: ~a~2%"
                           (delta-distance-stack action)
                           (delta-routes-feasibility-stack action))))))))
       #+END_SRC



* WIP operation add-route (from client)
** description
   In this section I'm going to add the operation add-route.  This operation can be done when we have already selected a client.

   The steps required to add a new operation are the following:

   1. [X] create a new vrp-class for this operation
   2. [X] +write the methods to update the working-copy after this operation+
      In this case we don't need to do anything at this point, because we can do that in the method simulate-neighborhood-operation, that is to increase the =number-of-routes= and extend the =routes-lengths= vector
   3. [X] write the simulate-neighborhood-operation for this operation
      Increase the =number-of-routes= and extend the =routes-lengths= vector.
   4. [X] write the method get-simpler-operations-from
      The simpler operations for the add-route are an add-route instance (to update the working-copy) and an insertion (to actually insert the client and create the route.)
   5. [X] write the methods to undo the neighborhood-operation
   6. [X] write the neighborhood-operation macros (do, and random)
   7. [X] write the apply-neighborhood-operation (if necessary)
   8. [X] +write the delta-cost methods (if necessary)+
      In this case we don't need to add anything to the delta cost, because everything should be handled by the insertion of the client in the route.  The creation of the route itself does not contribute to the cost.

      However, we need to add an empty method to avoid errors when processing the ops-list.  Actually we don't, because the method =compute-delta-cost-after= specialized in =t=, takes care of that  =\o/=.
   9. [X] Add the operation to the automatic generation
      To add the operation to the automatic neighborhood criteria generation we need to define how are we going to call it, and add it to the variable *exhaustive-search-macro-heading-mapping*.
      In thi case, we'll use it as (add-route c1)
   10. [X] test it all.


   In this case, to add the add-route operation we only need to create the class, implement the methods to update the working-copy and the undo operations function.  We'll do that in the next sections.
** add the class for the add-route operation
*** description
   The class for the add-route operation  requires the "index" of the selected client that will be inserted in the new route.  

   The add-route operation does not inherit from the class neighborhood-operation because we doesn't need a =route= or a =pos=.

*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp 
    (def-vrp-class operation-add-route ()
      ;; slots
      (;; the id of the client that should be inserted in the new route
       (client))
      ;; the rest of the class elements
      :documentation "A class to represent the operation add-route in a neighborhood criterion."
      :constructor (op-add-route (client))
      :print-object-string ("<op:add-r ~a>" client)
      :slots-for-obj= (client)
      :slots-for-clone (client))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((c1 (op-add-route 1))
           (c2 (op-add-route 2))
           (c3 (clone c1)))
      (bformat t "Testing op-add-route...")

      (format t "Printing the objects:~%")
      (loop for e in (list c1 c2 c3)
            doing (format t "   op-add-route: ~a~%" e))

      (deftests "Testing obj="
        (check-t (obj= c1 c1))
        (check-t (obj= c1 c3))

        (check-nil (obj= c1 c2))
        (check-nil (obj= c2 c3))))
    #+END_SRC
** simulate-neighborhood-operation
*** description
    In this case, we just increase the =number-of-routes= and add the info with the new route.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (defmethod simulate-neighborhood-operation
        ((op operation-add-route)
          (wc basic-working-copy))
      (incf (number-of-routes wc))
      ;; we need to set the length of the new route
      ;; to 0 because right after simulating this op
      ;; we'll simulate an insertion
      ;; and that insertion adds 1+ to that route-length.
      (vector-push-extend 0 (routes-lengths wc)))
    #+END_SRC

*** test
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
    (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9 10)))
      (let* ((wc (basic-working-copy s1))
             (c1 0) 
             (op1 (op-select-client 1 1 c1))
             (op2 (op-add-route c1)))

        (prepare-solution-for-neighborhood-exploration wc)

        (bformat t "Testing simulate-neighborhood-operation for add-route")

        (format t "Original solution:~%")
        (pp-solution wc t) (terpri)

        (dolist (op (get-simpler-operations-from op1 wc))
          (simulate-neighborhood-operation op wc))

        (format t "After selection:~%")
        (pp-solution wc t) (terpri)

        (format t "Before add-route:
       number-of-routes: ~a
       routes-lengths: ~a~%"
                (number-of-routes wc)
                (routes-lengths wc))

        (simulate-neighborhood-operation op2 wc)

        (format t "After add-route:
       number-of-routes: ~a
       routes-lengths: ~a~%"
                (number-of-routes wc)
                (routes-lengths wc))

        ))
    #+END_SRC
** get-simpler-operations-from
*** description
    When we have an add-route operation, we have two simpler operations: the add-route (to update the routes-lengths) and an insert-client in the new route.  That's what we return in this code.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (defmethod get-simpler-operations-from
        ((op operation-add-route)
         (wc basic-working-copy))
      "We return a list with the actual add-route operation (to update the routes-lengths) and the client insertion."
      (let* (;; we need to add in the route 1+ number-of-routes
             ;; because when we create this insertion
             ;; we haven't simulated the add-route yet
             ;; and so, the number-of-routes is the
             ;; actual number of routes.
             (route (1+ (number-of-routes wc)))
             (pos 1)
             (client (client op)))


        ;; return a list
        (list
         ;; with the add-route operation
         op
         ;; and the insertion
         (op-insert-client route pos client))))
    #+END_SRC

*** test
**** simple test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9 10)))
       (let* ((wc (basic-working-copy s1))
              (c1 0) 
              (op1 (op-select-client 1 1 c1))
              (op2 (op-add-route c1)))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing get-simpler-operations-from add-route")

         (format t "Original solution:~%")
         (pp-solution wc t) (terpri)

         (dolist (op (get-simpler-operations-from op1 wc))
           (simulate-neighborhood-operation op wc))

         (format t "After selection:~%")
         (pp-solution wc t) (terpri)

         (format t "Before add-route:
        number-of-routes: ~a
        routes-lengths: ~a~%"
                 (number-of-routes wc)
                 (routes-lengths wc))

         (format t "Operations from add-route: ~a~%"
                 (get-simpler-operations-from op2 wc))

         ))
     #+END_SRC
**** test simulating the ops
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9 10)))
       (let* ((wc (basic-working-copy s1))
              (c1 0) 
              (op1 (op-select-client 1 1 c1))
              (op2 (op-add-route c1)))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing get-simpler-operations-from add-route")

         (format t "Original solution:~%")
         (pp-solution wc t) (terpri)

         (dolist (op (get-simpler-operations-from op1 wc))
           (simulate-neighborhood-operation op wc))

         (format t "After selection:~%")
         (pp-solution wc t) (terpri)

         (format t "Before add-route:
        number-of-routes: ~a
        routes-lengths: ~a~%"
                 (number-of-routes wc)
                 (routes-lengths wc))

         (dolist (op (get-simpler-operations-from op2 wc))
           (simulate-neighborhood-operation op wc))

         (format t "After add-route:
        number-of-routes: ~a
        routes-lengths: ~a~%"
                 (number-of-routes wc)
                 (routes-lengths wc))

         (pp-solution wc t) (terpri)
    

         ))
     #+END_SRC
**** test with several additions and simulating
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9 10)))
       (let* ((wc (basic-working-copy s1))
              (c1 0) (c2 1) (c3 2)
              (op1 (op-select-client 1 1 c1))
              (op2 (op-select-client 1 1 c2))
              (op3 (op-select-client 1 1 c3))
              (op4 (op-add-route c1))
              (op5 (op-add-route c2))
              (op6 (op-add-route c3)))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing simulate-neighborhood-operation for add-route")

         (format t "Original solution:~%")
         (pp-solution wc t) (terpri)

         (dolist (opselect (list op1 op2 op3))
           (dolist (op (get-simpler-operations-from opselect wc))
             (simulate-neighborhood-operation op wc)))

         (format t "After selection:~%")
         (pp-solution wc t) (terpri)

         (format t "Before add-route:
        number-of-routes: ~a
        routes-lengths: ~a~%"
                 (number-of-routes wc)
                 (routes-lengths wc))

         (dolist (opadd-route (list op4 op5 op6))
           (dolist (op (get-simpler-operations-from opadd-route wc))
             (simulate-neighborhood-operation op wc))

          (format t "After add-route with client ~a:
        number-of-routes: ~a
        routes-lengths: ~a~%"
                  (client-selected-at-operation c1 wc)
                  (number-of-routes wc)
                  (routes-lengths wc))
    
          (pp-solution wc t) (terpri))

         ))
     #+END_SRC
** undo-neighborhood-operation
*** description
    To undo an add-route operation we need to decrease the =number-of-routes=, and pop the vector =routes-lengths=. 
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (defmethod undo-neighborhood-operation
        ((op operation-add-route)
         (wc basic-working-copy))
      "We undo the effects of adding a new route."
      ;; decrease the number-of-routes
      (decf (number-of-routes wc))
      ;; and pop the routes-lengths vector
      (vector-pop (routes-lengths wc)))
    #+END_SRC

*** test
**** simple test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9 10)))
       (let* ((wc (basic-working-copy s1))
              (c1 0) 
              (op1 (op-select-client 1 1 c1))
              (op2 (op-add-route c1)))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing get-simpler-operations-from add-route")

         (format t "Original solution:~%")
         (pp-solution wc t) (terpri)

         (dolist (op (get-simpler-operations-from op1 wc))
           (simulate-neighborhood-operation op wc))

         (format t "After selection:~%")
         (pp-solution wc t) (terpri)

         (format t "Before add-route:
        number-of-routes: ~a
        routes-lengths: ~a~%"
                 (number-of-routes wc)
                 (routes-lengths wc))

         (simulate-neighborhood-operation op2 wc)

         (format t "After add-route:
        number-of-routes: ~a
        routes-lengths: ~a~%"
                 (number-of-routes wc)
                 (routes-lengths wc))

         (undo-neighborhood-operation op2 wc)

         (format t "After undoing add-route:
        number-of-routes: ~a
        routes-lengths: ~a~%"
                 (number-of-routes wc)
                 (routes-lengths wc))

         ))
     #+END_SRC
**** test simulating the ops
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9 10)))
       (let* ((wc (basic-working-copy s1))
              (c1 0) 
              (op1 (op-select-client 1 1 c1))
              (op2 (op-add-route c1)))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing get-simpler-operations-from add-route")

         (format t "Original solution:~%")
         (pp-solution wc t) (terpri)

         (dolist (op (get-simpler-operations-from op1 wc))
           (simulate-neighborhood-operation op wc))

         (format t "After selection:~%")
         (pp-solution wc t) (terpri)

         (format t "Before add-route:
        number-of-routes: ~a
        routes-lengths: ~a~%"
                 (number-of-routes wc)
                 (routes-lengths wc))

         (dolist (op (get-simpler-operations-from op2 wc))
           (simulate-neighborhood-operation op wc))

         (format t "After add-route:
        number-of-routes: ~a
        routes-lengths: ~a~%"
                 (number-of-routes wc)
                 (routes-lengths wc))

         (pp-solution wc t) (terpri)

         ;; now let's undo the operations
         (dolist (op (reverse (get-simpler-operations-from op2 wc)))
           (undo-neighborhood-operation op wc))

         (format t "After undoing add-route:
        number-of-routes: ~a
        routes-lengths: ~a~%"
                 (number-of-routes wc)
                 (routes-lengths wc))

         (pp-solution wc t) (terpri)



         ))
     #+END_SRC
**** test with several additions and simulating
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9 10)))
       (let* ((wc (basic-working-copy s1))
              (c1 0) (c2 1) (c3 2)
              (op1 (op-select-client 1 1 c1))
              (op2 (op-select-client 1 1 c2))
              (op3 (op-select-client 1 1 c3))
              (op4 (op-add-route c1))
              (op5 (op-add-route c2))
              (op6 (op-add-route c3)))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing simulate-neighborhood-operation for add-route")

         (format t "Original solution:~%")
         (pp-solution wc t) (terpri)

         (dolist (opselect (list op1 op2 op3))
           (dolist (op (get-simpler-operations-from opselect wc))
             (simulate-neighborhood-operation op wc)))

         (format t "After selection:~%")
         (pp-solution wc t) (terpri)

         (format t "Before add-route:
        number-of-routes: ~a
        routes-lengths: ~a~%"
                 (number-of-routes wc)
                 (routes-lengths wc))

         (dolist (opadd-route (list op4 op5 op6))
           (dolist (op (get-simpler-operations-from opadd-route wc))
             (simulate-neighborhood-operation op wc))

          (format t "After add-route with client ~a:
        number-of-routes: ~a
        routes-lengths: ~a~%"
                  (client-selected-at-operation c1 wc)
                  (number-of-routes wc)
                  (routes-lengths wc))
    
          (pp-solution wc t) (terpri))

         ))
     #+END_SRC
** doadd-route macro
*** description
    Here we can use the make-do-neighborhood-static-macro because this operation does not iterates through any route.
*** code (using make-do-neighborhood-static-macro)
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (make-do-neighborhood-static-macro
       doadd-route  (client-id working-copy)
       op-add-route
       (client-id)
       "Adds a new route by adding to it the client selected at operation client-id.")    
    #+END_SRC
*** tests
**** simple tests (no iterations)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6 7) ()))
       (let* ((wc (basic-working-copy s1))
              (op1 (op-select-client 1 1 0))
              (ops-list nil)

              (*vrp-stop-neighborhood-search* nil))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing the doreverse-subroute macro")

         (format t "The original solution:~%")
         (pp-solution wc t) (terpri)

         (dolist (op (get-simpler-operations-from op1 wc))
           (simulate-neighborhood-operation op wc))

         (doadd-route (0 wc)
           (format t "After the add-route:~%")
           (pp-solution wc t) (terpri))))
     #+END_SRC
**** with a select-client
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6 7)))
       (let* ((wc (basic-working-copy s1))
              (op1 (op-select-client 1 1 0))
              (ops-list nil)

              (*vrp-stop-neighborhood-search* nil))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing the doreverse-subroute macro")

         (format t "The original solution:~%")
         (pp-solution wc t) (terpri)

         (doselect-client (c1 1 wc)
           (doadd-route (0 wc)
             (format t "After the add-route:~%")
             (pp-solution wc t) (terpri)))))
     #+END_SRC
**** with two select-client
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6 7)))
       (let* ((wc (basic-working-copy s1))
              (op1 (op-select-client 1 1 0))
              (ops-list nil)

              (*vrp-stop-neighborhood-search* nil))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing the doreverse-subroute macro")

         (format t "The original solution:~%")
         (pp-solution wc t) (terpri)

         (doselect-client (c1 1 wc)
           (doselect-client (c2 1 wc)
             (doadd-route (c1 wc)
               (doadd-route (c2 wc)
                 (format t "After the add-route:~%")
                 (pp-solution wc t) (terpri)))))))
     #+END_SRC
** apply-neighborhood-operation
*** description
    In this method we will create the new empty route with the approppriate id.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (defbehavior apply-neighborhood-operation
        ((operation operation-add-route)
         (wc basic-working-copy))
      :log-str "Creating a new empty route"

      "Creates a new empty route with the appropriate id."
      (if (null (routes (solution wc)))
          (error "Trying to add a new route to an empty solution :-(, check apply-neighborhood-operation for add-route and basic-working-copy."))
  
      (let* ((solution (solution wc))
             (routes (routes solution))
             (max-route-id (loop for route in routes
                                 maximizing (id route)))
             (vehicle (vehicle (first routes)))
             (depot (depot (first routes)))
             (new-route (route-for-simulation
                         :id (1+ max-route-id)
                         :vehicle vehicle
                         :depot depot
                         :clients nil)))
        ;; now let's add the new route
        (setf (routes solution)
              (append (routes solution)
                      (list new-route)))))
    #+END_SRC
*** tests
**** simple tests (no iterations)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6 7)))
       (let* ((wc (basic-working-copy s1))
              (op1 (op-select-client 1 1 0))
              (op2 (op-add-route 0))
              ;; (ops-list nil)

              (*vrp-stop-neighborhood-search* nil))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing the apply-neighborhood-operation doadd-route")

         (format t "The original solution:~%")
         (pp-solution wc t) (terpri)

         (dolist (op (get-simpler-operations-from op1 wc))
           (simulate-neighborhood-operation op wc))

         (dolist (op (get-simpler-operations-from op2 wc))
           (simulate-neighborhood-operation op wc))

         (format t "After simulating the add-route:~%")
         (pp-solution wc t) (terpri)

         (format t "Solution after the add-route:~%")
         (pp-solution (solution wc) t) (terpri)

         ;; let's apply some operations
         (initialize-selected-clients-during-apply 7 wc)
    
         (apply-neighborhood-operation op1 wc)
         (apply-neighborhood-operation op2 wc)

         (format t "Solution after applying the ops:~%")
         (pp-solution (solution wc) t) (terpri)

    

         ))


     #+END_SRC
**** with a select-client
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6 7) ()))
       (let* ((wc (basic-working-copy s1))
              (op1 (op-select-client 1 1 0))
              (op2 (op-add-route 0))

              (*vrp-stop-neighborhood-search* nil))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing the doreverse-subroute macro")

         (bformat t "Testing the apply-neighborhood-operation doadd-route")

         (format t "The original solution:~%")
         (pp-solution wc t) (terpri)

         (initialize-selected-clients-during-apply 7 wc)

         (dolist (op (get-simpler-operations-from op1 wc))
           (apply-neighborhood-operation op wc))

         (dolist (op (get-simpler-operations-from op2 wc))
           (apply-neighborhood-operation op wc))

         (finish-apply-neighborhood-operations wc)

         (format t "After applying the operations to the solution:~%")
         (pp-solution (solution wc) t) (terpri)
         
         ))
     #+END_SRC
**** with two select-client
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6 7)))
       (let* ((wc (basic-working-copy s1))
              (op1 (op-select-client 1 1 0))
              (ops-list nil)

              (*vrp-stop-neighborhood-search* nil))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing the doreverse-subroute macro")

         (format t "The original solution:~%")
         (pp-solution wc t) (terpri)

         (doselect-client (c1 1 wc)
           (doselect-client (c2 1 wc)
             (doadd-route (c1 wc)
               (doadd-route (c2 wc)
                 (format t "After the add-route:~%")
                 (pp-solution wc t) (terpri)))))))
     #+END_SRC
** testing delta-cost-after
*** description
    In this section I'm going to test the compute-delta-cost-after for this operations.
*** tests
**** simple test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                            :demands '(10 10 15 40 20)
                            :capacity 40)
       (with-basic-cvrp-solution (s1 ((1 2 3 4 5)) p1)
         (let* ((wc (basic-working-copy s1))
                (op1 (op-select-client 1 1 0))
                (op2 (op-add-route 0))
                (op3 (op-insert-client 2 1 0))
                (action (delta-cvrp-action)))

           (bformat t "Testing compute-delta-cost-after for add-route")

           (prepare-solution-for-neighborhood-exploration wc)
           (initialize-action-for-delta-cost-computation wc p1 action)

           (compute-delta-cost-after op1 wc p1 action)
           (simulate-neighborhood-operation op1 wc)
           (format t "wc after op1:~%")
           (pp-solution wc t) (terpri)

           (compute-delta-cost-after op2 wc p1 action)
           (simulate-neighborhood-operation op2 wc)
           (format t "wc after op2:~%")
           (format t "routes-lengths ~a~%" (routes-lengths wc))
           (format t "number-of-routes: ~a~%" (number-of-routes wc))
           (pp-solution wc t) (terpri)


           (compute-delta-cost-after op3 wc p1 action)
           (simulate-neighborhood-operation op3 wc)
           (format t "wc after op2:~%")
           (pp-solution wc t) (terpri)

           (finish-delta-cost-computation wc p1 action)

           (format t "delta-cost: ~a~%"
                   (get-delta-cost-from-action action))


           )
          ))
     #+END_SRC
**** test with select client
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                              (5 0 6 7 2 4)  ;1
                                              (1 8 0 3 9 1)  ;2
                                              (4 5 1 0 5 7)  ;3
                                              (4 5 1 5 0 6)  ;4
                                              (1 5 7 6 9 0)) ;5
                                              ;0 1 2 3 4 5 
                                              :demands '(10 10 15 40 20)
                                              :capacity 40)
       (with-basic-cvrp-solution (s1 ((1 2 3 4 5)) p1)
         (let* ((wc (basic-working-copy s1))
                (ops-list nil)
                (action (delta-cvrp-action)))

           (bformat t "Testing compute-delta-cost-after for add-route")

           (prepare-solution-for-neighborhood-exploration wc)
      

           (doselect-client (c1 1 wc)
             (doadd-route (c1 wc)
               (format t "delta-cost after adding-route with ~a: ~a~%"
                       (client-selected-at-operation c1 wc)
                       (delta-cost (reverse ops-list) wc p1 action))
               (pp-solution wc t) (terpri)))

      

           )
          ))
     #+END_SRC
** doadd-route* macro
*** description
    This is the * version of this operation.
*** code (using make-do-neighborhood-static-macro)
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (make-do-neighborhood-static-macro
       doadd-route*
       (client-id working-copy)
       op-add-route
       (client-id)
       "Adds a new route by adding to it the client selected at operation client-id."
       :simpler-ops-macro simulate-simpler-ops-macro*
       :undo-simpler-ops-macro undo-simpler-ops-macro*)    
    #+END_SRC
*** tests
**** simple test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9) ;0
                                              (5 0 6 7 2 4 2 3 4) ;1
                                              (1 8 0 3 9 1 2 4 5) ;2
                                              (4 5 1 0 5 7 1 9 5) ;3
                                              (4 5 1 5 0 6 2 8 2) ;4
                                              (1 5 7 6 9 0 1 6 7) ;5
                                              (4 5 1 3 5 7 0 9 5) ;6
                                              (4 6 2 8 2 3 8 0 1) ;7
                                              (4 5 3 4 1 6 2 8 0) ;8
                                              )
                                              ;0 1 2 3 4 5 6 7 8
                                 :demands '(20 10 15 40 30 20 10 30)
                                 :capacity 30)
       (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6 7 8)) problem)
         (let* ((wc (basic-working-copy s1))
                (c1 0)
                (op (op-select-client 1 1 c1))
                (ops-list nil)
                (action (delta-cvrp-action*)))

           (prepare-solution-for-neighborhood-exploration wc)
           (initialize-action-for-delta-cost-computation wc problem action)


           (compute-delta-cost-after op wc problem action)
           (format t "Delta distance after op: ~a~%"
                   (delta-distance action))
           (format t "Route feasibility after op: ~a~%"
                   (delta-routes-feasibility action))

           (simulate-neighborhood-operation op wc)
           (format t "Selected client: ~a~%"
                   (client-selected-at-operation c1 wc))


           (bformat t "Testing doinsert-client2")
           (doadd-route* (c1 wc)
             (pp-solution wc t) (terpri)
             (format t "Delta distance after op: ~a~%"
                     (delta-distance action))
             (format t "Route feasibility after op: ~a~%"
                     (delta-routes-feasibility action))
             (format t "delta-distance-stack: ~a~%"
                     (delta-distance-stack action))
             )
           )))
     #+END_SRC
    

* macros for a random-search of a neighborhood
** description
   In this section I'm going to add macros to behave in a random way instead than an exhaustive way.  The do-neighborhood macros explore the neighborhood exhaustively, visiting all the neighbors.  The idea with these random-macros is to access a random element according to the operation.

   For instance, if the operation is (select-client c1 from r1) the =doselect-client= selects all the possible clients in the route.  The =random-select-client= would select only one.

   (Maybe we could have a parameter to indicate how many times to repeat the operation :-/.)

   The usage would be something like:

   #+BEGIN_EXAMPLE
   (random-select-route (r1 wc)
     (random-select-client (c1 r1 wc)
        (random-insert-client (c1 r1 wc)
           code here)))
   #+END_EXAMPLE
** random-select-route
*** description
    Like doselect-route, but just select one route.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (defmacro random-select-route ((route-name
                                    working-copy 
                                    &key gt ge lt le dt ex ex-cond)
                                   &body body)
      "Selects a random route from the working-copy passed as argument.  The symbol route-name is bound to the id of the current route.
         Example:
             (random-select-route (r1 wc1)
                (format t \"Route ~a is ~a\"
                        r1 (get-route-with-id r1 wc1)))"
      (declare (ignorable gt ge lt le dt ex ex-cond))
      (with-gensyms (g!length)
      `(when (not *vrp-stop-neighborhood-search*)
         (let* ((,g!length (number-of-routes ,working-copy))
                (,route-name (1+ (random ,g!length))))

           (progn
             ,@body)))))
    #+END_SRC
*** tests
**** basic test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3) (4) (5 6 7 8)))
       (let* ((wc (basic-working-copy s1)))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing random-select-route")

         (dotimes (i 10)
           (random-select-route (r1 wc)
             (format t "current route: ~a: " r1)
             (pp-route r1 wc t) (terpri)))))
     #+END_SRC



     OK.  It works.  Let's write the others macros.
    
**** basic test with stop-neighborhood-search
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3) (4) (5 6 7 8)))
       (let* ((wc (basic-working-copy s1))
              (*vrp-stop-neighborhood-search* nil))

         (bformat t "Testing random-select-route")
         (prepare-solution-for-neighborhood-exploration wc)

         (pp-solution wc t) (terpri)

         (dotimes (c 10)
           (random-select-route (r1 wc)
             (pp-route r1 wc t) (terpri)))))
     #+END_SRC
**** basic testing constraints
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3) (4) (5 6 7 8)))
       (let* ((wc (basic-working-copy s1)))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing random-select-route")

         (dotimes (i 10)
           (random-select-route (r1 wc :ge 2)
             (format t "current route: ~a: " r1)
             (pp-route r1 wc t) (terpri)))))
     #+END_SRC



     OK.  It works.  Let's write the others macros.
    
** random-select-client
*** description
    Like doselect-client, but just select one random client.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (defmacro random-select-client
        ((cname route working-copy
          &key gt ge lt le dt ex ex-cond)
         &body body)
      "Selects a random route from the working-copy passed as argument.  The symbol route is bound to the id of the current route.
         Example:
             (random-select-client (c1 r1 wc1)
               (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))"
      (declare (ignorable gt ge lt le dt ex ex-cond))
      (with-gensyms (g!length op simpler-ops)

        (let* ((pos (symb cname ".select.position"))
               (cname.route (symb cname ".route"))
               (cname.client (symb cname ".client"))
               (cname.position (symb cname ".select.position"))
               (cname.coord (symb cname ".select.coord"))
               (cname.prev.coord (symb cname ".prev.insert.coord")))

         `(symbol-macrolet ((,cname.position
                             (pos-of-client-selected-at-operation
                              ,cname ,working-copy))
                            (,cname.route
                             (route-of-client-selected-at-operation
                              ,cname ,working-copy))
                            (,cname.client
                             (client-selected-at-operation
                              ,cname ,working-copy))
                            (,cname.coord
                             (info-of-client-selected-at-operation
                              ,cname ,working-copy))
                            (,cname.prev.coord
                             (let* ()
                               (cond
                                 ((> ,cname.position 1)
                                  (list ,cname.route
                                        (1- ,cname.position)))
                                 ;; we are in (1 1)
                                 ;; so there is not previous
                                 ((= ,route 1)
                                  (list 1 -1))
                                 ;; otherwise the previous
                                 ;; is the last of the
                                 ;; previous route
                                 (t
                                  (list (1- ,route)
                                        (1+
                                         (route-length
                                          (1- ,route)
                                          ,working-copy)))))))
                            )
            (when (and (not *vrp-stop-neighborhood-search*)
                       (> (route-length ,route ,working-copy) 0))
              (let* ((,g!length (route-length ,route ,working-copy))
                     (,pos (1+ (random ,g!length)))
                     (,cname (1+ (selections-count ,working-copy)))
                     (,op (op-select-client ,route ,pos ,cname))
                     (,simpler-ops (get-simpler-operations-from
                                    ,op ,working-copy))
                     )
                ;; the automatic-stuff
                (simulate-simpler-ops-macro ,simpler-ops ,working-copy)
                ;; the user's code
                (progn
                  ,@body)
                ;; let's clean up
                (undo-simpler-ops-macro ,simpler-ops ,working-copy)))))))
    #+END_SRC
*** tests
**** basic test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6 7 8)))
       (let* ((wc (basic-working-copy s1))
              (ops-list nil))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing random-select-route")

         (dotimes (i 10)
           (random-select-client (c1 1 wc)
             (format t "selected-client: ~a from pos ~a~%"
                     (id (client-selected-at-operation c1 wc))
                     c1.select.position)
             ;; (pp-route 1 wc t) (terpri) (terpri)
             ))))
     #+END_SRC

**** basic test with stop-neighborhood-search
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3) (4) (5 6 7 8)))
       (let* ((wc (basic-working-copy s1))
              (*vrp-stop-neighborhood-search* nil)
              (ops-list nil)
              )

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing random-select-client with stop")

         (dotimes (i 10)
           (random-select-client (c1 1 wc)
             (format t "~a: selected-client: ~a from pos ~a~%"
                     i
                     (id (client-selected-at-operation c1 wc))
                     c1.select.position
                     )
             (when (= i 5) (stop-neighborhood-search))
             ;; (pp-route 1 wc t) (terpri) (terpri)
             ))))
     #+END_SRC

**** basic test with 0 length routes
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6 7 8) ()))
       (let* ((wc (basic-working-copy s1))
              (ops-list nil))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing random-select-client")

         (format t "With solution:~%")
         (pp-solution wc t) (terpri)

         (dotimes (i 10)
           (random-select-client (c1 2 wc)
             (format t "selected-client: ~a from pos ~a~%"
                     (id (client-selected-at-operation c1 wc))
                     c1.select.position)
             ;; (pp-route 1 wc t) (terpri) (terpri)
             ))))
     #+END_SRC

**** testing constraint
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6 7 8)))
       (let* ((wc (basic-working-copy s1))
              (ops-list nil))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing random-select-route")

         (dotimes (i 10)
           (random-select-client (c1 1 wc
                                     :ge 2)
             (format t "selected-client: ~a from pos ~a~%"
                     (id (client-selected-at-operation c1 wc))
                     c1.select.position)
             ;; (pp-route 1 wc t) (terpri) (terpri)
             ))))
     #+END_SRC

** random-insert-client
*** description
    Like doinsert-client, but just insert in one random position.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (defmacro random-insert-client
        ((cname route-name working-copy
          &key gt ge lt le dt ex ex-cond)
         &body body)
      "Inserts a random client in the given route in the working-copy passed as argument.
         Example:
             (random-insert-client (c1 r1 wc1)
               (format t \"Inserting client ~a in position ~a~%\"
                   (client-selected-at-operation c1)
                   c1.insert.pos))"
      (declare (ignorable gt ge lt le dt ex ex-cond))

      (with-gensyms (g!length op simpler-ops)

        (let* ((pos (symb cname ".insert.position"))
               (cname.ins.route (symb cname ".insert.route"))
               (cname.ins.position (symb cname ".insert.position")))

          `(symbol-macrolet ((,cname.ins.position
                                     (get-inserted-client-pos
                                      ,cname ,working-copy))
                             (,cname.ins.route
                                     (get-inserted-client-route
                                      ,cname ,working-copy)))

             (when (not *vrp-stop-neighborhood-search*)

               (let* ((,g!length (route-length ,route-name ,working-copy))
                     ;; we have two +1 because we can insert
                     ;; beyond the last client in the route
                     ;; and that would the position:
                     ;; (+ 2 route-length)
                     (,pos (1+ (random (1+ ,g!length))))
                     (,op (op-insert-client ,route-name ,pos ,cname))
                     (,simpler-ops (get-simpler-operations-from
                                    ,op ,working-copy))
                     )
                ;; the automatic-stuff
                (simulate-simpler-ops-macro ,simpler-ops ,working-copy)
                ;; the user's code
                (progn
                  ,@body)
                ;; let's clean up
                (undo-simpler-ops-macro ,simpler-ops ,working-copy)))))))
    #+END_SRC
*** tests
**** simple test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
       (let* ((wc (basic-working-copy s1))
              (op1 (op-select-client 2 1 0))
              (c1 0)
              (ops-list nil))

         (prepare-solution-for-neighborhood-exploration wc)

         ;; simulate the first selection
         (simulate-neighborhood-operation op1 wc)

         (bformat t "Testing random-insert-client")
         (dotimes (i 10)
           (random-insert-client (0 1 wc)
             (format t "Inserting client: ~a at pos: ~a~%"
                     (client-selected-at-operation 0 wc)
                     0.insert.position)
             (pp-route 1 wc t) (terpri)))))
     #+END_SRC
** random-swap-clients
*** description
    Exactly doswap-clients but with a different name =:-/=.  In fact, we just copy the =macro-function= of the =doswap-clients= symbol.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (setf (macro-function 'random-swap-clients) 
           (macro-function 'doswap-clients))
    #+END_SRC
*** tests
**** simple tests (no iterations)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6 7)))
       (let* ((wc1 (basic-working-copy s1))
              (ops-list nil)
              (c1 0) (c2 1)
              (op1 (op-select-client 1 2 c1))
              (op2 (op-select-client 1 3 c2))
              (*vrp-stop-neighborhood-search* nil))

         (prepare-solution-for-neighborhood-exploration wc1)

         (bformat t "Testing the random-swap-clients macro")

         (format t "The original solution:~%")
         (pp-solution wc1 t) (terpri)

         (dolist (op (list op1 op2))
           (simulate-neighborhood-operation op wc1))

         (format t "After the selections:~%")
         (pp-solution wc1 t) (terpri)

         (random-swap-clients (c1 c2 wc1)
           (format t "Swapped!~%")
           (format t "After the swap the solution is:~%")
           (pp-solution wc1 t) (terpri))))
     #+END_SRC
     
**** tests (iterating through a route)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6 7)))
       (let* ((wc1 (basic-working-copy s1))
              (ops-list nil)
              (*vrp-stop-neighborhood-search* nil))

         (prepare-solution-for-neighborhood-exploration wc1)

         (bformat t "Testing random-swap-clients with 2 doselect-clients")

         (format t "The original solution:~%")
         (pp-solution wc1 t) (terpri)



         (doselect-client (c1 1 wc1)
           (doselect-client (c2 1 wc1)
             (random-swap-clients (c1 c2 wc1)
               (format t "Swapping ~a and ~a:~%"
                       (id (client-selected-at-operation c1 wc1))
                       (id (client-selected-at-operation c2 wc1)))
               (pp-solution wc1 t) (terpri))))))
     #+END_SRC
** random-select-subroute-with-length
*** description
    This macro receives a route, and an id for the name of the subroute, a length and a working-copy, and it selects one random subroute of the given length inside that route. 
*** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
     (defmacro random-select-subroute-with-length
         ((cname route-name length working-copy
                 &key ge gt le lt dt ex ex-cond)
          &body body)

       "Iterates through each position in the given route, creates an instance of op-select-subroute, pushes it int ops-lists, simulates it, do whatever the users wants to do, and finally restores everything to the previous state.
     Example:
        (doselect-subroute-with-length (z1 r1 3 wc1)
                      (format t \"Selecting length 3 subroute stariting with
     ~a  form route ~a~%\"
                       (client-selected-at-operation c1)
                       (get-route-with-id r1 wc1)))"
      
       (declare (ignorable ge gt le lt dt ex ex-cond))

       (with-gensyms (g!length op simpler-ops last-pos)
         (let* ((pos (symb cname ".select.position"))
                (subroute-length (symb cname ".subroute.length")))

         `(when (and (not *vrp-stop-neighborhood-search*)
                     (> (route-length ,route-name ,working-copy)
                        ,length))
            (let* ((,g!length (route-length ,route-name ,working-copy))
                   (,last-pos ;; the last pos is the length
                    ;; minus the subroute length.
                    (1+ (- ,g!length ,length)))
                   (,pos (1+ (random ,last-pos)))
                   (,cname (1+ (selections-count ,working-copy)))
                   (,op (op-select-subroute
                         ,route-name ,pos ,length ,cname))
                   (,simpler-ops (get-simpler-operations-from
                                  ,op ,working-copy))
                   (,subroute-length ,length))

              (declare (ignorable ,subroute-length))

              ;; the automatic-stuff
              (simulate-simpler-ops-macro ,simpler-ops ,working-copy)
              ;; the user's code
              (progn
                ,@body)
              ;; let's clean up
              (undo-simpler-ops-macro ,simpler-ops ,working-copy))))))
     #+END_SRC
*** tests
****** very simple test
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5 6 )))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil))

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing random-select-subroute-with-length")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (dotimes (i 5)
              (random-select-subroute-with-length (z1 1 3 wc1)
                (format t "After one select-subroute from pos ~a:~%"
                        z1.select.position)
                (pp-solution wc1 t) (terpri)
                ))))
       #+END_SRC
****** with two select-subroutes
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5 6 7 8 9)))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil)
                (r1 1))

           (prepare-solution-for-neighborhood-exploration wc1)
           (format t "Original solution:~%")
           (pp-solution wc1 t) (terpri)

           (random-select-subroute-with-length (z2 r1 3 wc1)
             (random-select-subroute-with-length (z1 r1 3 wc1)
               (format
                t "After 2 select-subroutes, one from ~a and the second from ~a:~%"
                       z2.select.position z1.select.position)
               (pp-solution wc1 t)
               ))))
       #+END_SRC
****** test with inappropriate lengths
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8 9)))
         (let* ((wc1 (basic-working-copy s1))
                (ops-list nil))

           (prepare-solution-for-neighborhood-exploration wc1)

           (bformat t "Testing random-select-subroute-with-length")

            (format t "Original solution:~%")
            (pp-solution wc1 t) (terpri)

            (dotimes (i 3)
              (random-select-subroute-with-length (z1 2 4 wc1)
                (format t "After one select-subroute from pos ~a:~%"
                        z1.select.position)
                (pp-solution wc1 t) (terpri)
                ))))
       #+END_SRC

** random-select-subroute (variable-length)
*** description
    Randomly selects one of the possible lengths in the given subroute and randomly selects a subroute with that length.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (defmacro random-select-subroute
        ((cname route-name working-copy
                &key ge gt le lt dt ex ex-cond ldt lex lex-cond)
         &body body)

      (declare (ignorable ge gt le lt dt ex ex-cond ldt lex lex-cond))


      (with-gensyms (current-length route-length)

        `(let* ((,route-length (route-length ,route-name ,working-copy))
                (,current-length (+ 2 (random (1- ,route-length)))))

           ;; the following conditional is to avoid
           ;; getting subroutes from routes without enough
           ;; elements
           (when (> ,route-length 1)
             (random-select-subroute-with-length
                 (,cname ,route-name ,current-length ,working-copy)
               ,@body)))))
    #+END_SRC
*** simple test
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
    (with-basic-solution (s1 ((1 2 3 4 5)))
      (let* ((wc1 (basic-working-copy s1))
             (ops-list nil))

        (prepare-solution-for-neighborhood-exploration wc1)

        (bformat t "Testing random-select-subroute (variable-length)")

        (format t "Original solution:~%")
        (pp-solution wc1 t) (terpri)

        (random-select-subroute (z1 1 wc1)
          (format t "Selected subroute with length ~a from pos ~a.~%"
                  z1.subroute.length z1.select.position)
          (pp-solution wc1 t) (terpri))))
    #+END_SRC
** random-insert-subroute
*** description
    Selects a random position from all the possitions in the given route and inserts the subroute at that postion.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (defmacro random-insert-subroute
        ((cname route-name working-copy
          &key ge gt le lt dt ex ex-cond)
         &body body)
      "Selects a random position from all the possitions in the given route and inserts the subroute at that postion.
        Example:
           (random-insert-subroute (z1 r1 wc1)
             (format t \"Inserting subroute ~a at pos ~a.~%\"
                (client-selected-at-operation c1 wc1)
                z1.insert.position))
                  z1   is the index of the subroute that we want to insert
                       (actually it should be the selections-count corresponding
                       to its selection)
                  r1  is the id of the route we want to make the insertion in.
                  wc1 is the working-copy where we are working."

      (declare (ignorable ge gt le lt dt ex ex-cond))

      (with-gensyms (g!length op simpler-ops)
        (let* ((pos (symb cname ".insert.position")))

          `(when (not *vrp-stop-neighborhood-search*)
             (let* ((,g!length (route-length ,route-name ,working-copy))
                    ;; we have two +1 because we can insert
                    ;; beyond the last client in the route.
                    (,pos (1+ (random (1+ ,g!length))))
                    (,op (op-insert-subroute ,route-name ,pos ,cname))
                    (,simpler-ops (get-simpler-operations-from
                                   ,op ,working-copy)))


               ;; the automatic-stuff
               (simulate-simpler-ops-macro ,simpler-ops ,working-copy)
               ;; the user's code
               (progn
                 ,@body)
               ;; let's clean up
               (undo-simpler-ops-macro ,simpler-ops ,working-copy))))))

    #+END_SRC
*** simple test
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
    (with-basic-solution (s1 ((1 2 3 4 5 6 7 8)))
      (let* ((wc1 (basic-working-copy s1))
             (ops-list nil) (z1 0)
             (op1 (op-select-subroute 1 3 4 z1)))

        (prepare-solution-for-neighborhood-exploration wc1)

        (bformat t "Testing random-insert-subroute")

        (format t "Original solution:~%")
        (pp-solution wc1 t) (terpri)

        (dolist (op (get-simpler-operations-from op1 wc1))
          (simulate-neighborhood-operation op wc1))

        (format t "after the selection:~%")
        (pp-solution wc1 t) (terpri)

        (random-insert-subroute (z1 1 wc1)
          (format t "Inserting the subroute at pos ~a.~%"
                  z1.insert.position)
           (pp-solution wc1 t) (terpri))))
    #+END_SRC
** random-reverse-subroute
*** description
    Exactly doreverse-subroute but with a different name =:-/=.  In fact, we just copy the =macro-function= of the =doreverse-subroute= symbol.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (setf (macro-function 'random-reverse-subroute) 
          (macro-function 'doreverse-subroute))
    #+END_SRC
*** tests
**** simple tests (no iterations)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4) ()))
       (let* ((wc1 (basic-working-copy s1))
              (ops-list nil)

              (*vrp-stop-neighborhood-search* nil))

         (prepare-solution-for-neighborhood-exploration wc1)

         (bformat t "Testing the doreverse-subroute macro")

         (format t "The original solution:~%")
         (pp-solution wc1 t) (terpri)



         (doselect-subroute (z1 1 wc1)
           (random-reverse-subroutes (z1 wc1)
             (doinsert-subroute (z1 2 wc1)
              (format t "After the subroute-reverse:~%")
              (pp-solution wc1 t) (terpri))))))
     #+END_SRC
** random-swap-subroutes
*** description
    Exactly doswap-subroutes but with a different name =:-/=.  In fact, we just copy the =macro-function= of the =doswap-subroutes= symbol.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (setf (macro-function 'random-swap-subroutes) 
          (macro-function 'doswap-subroutes))
    #+END_SRC
*** tests
**** very simple test (from different routes)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1  2  3  4  5  6  7 8)
                               (9 10 11 12 13 14 15 16)))
       (let* ((wc1 (basic-working-copy s1))
              (ops-list nil)
              (r1 1) (r2 2)
              (s1-length 3)
              (op1 (op-select-subroute r1 2 s1-length 0))
              (op2 (op-select-subroute r2 3 4 s1-length))
              )

         (prepare-solution-for-neighborhood-exploration wc1)

         (bformat t "Testing random-swap-subroutes")

          (format t "Original solution:~%")
          (pp-solution wc1 t) (terpri)

          (dolist (op (get-simpler-operations-from op1 wc1))
            (simulate-neighborhood-operation op wc1))

          (dolist (op (get-simpler-operations-from op2 wc1))
            (simulate-neighborhood-operation op wc1))

          (format t "Solution before swap:~%")
          (pp-solution wc1 t) (terpri)

          (random-swap-subroutes (0 s1-length wc1)
            (format t "Inside doswap-subroutes:~%")
            (pp-solution wc1 t) (terpri))

          (format t "Solution after random-swap-subroutes:~%")
          (pp-solution wc1 t) (terpri)))
     #+END_SRC
**** simple test with doselect-subroute (different routes sized)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1  2  3  4  5)
                               (6  7  8  9 10)))
       (let* ((wc1 (basic-working-copy s1))
              (ops-list nil)
              (s1-length 2)
              (r1 1) (r2 2)
              (op1 (op-select-subroute 2 2 3 s1-length))
              (counter 0)
              )

         (bformat t "Testing doswap-subroutes")

         (prepare-solution-for-neighborhood-exploration wc1)

          (format t "Original solution:~%")
          (pp-solution wc1 t) (terpri)


          (doselect-subroute-with-length (s1 r1 s1-length wc1)
            (dolist (op (get-simpler-operations-from op1 wc1))
              (simulate-neighborhood-operation op wc1))
            (doswap-subroutes (s1 s1-length wc1)
                (incf counter)
                (format t "Inside doswap-subroutes ~a...~%"
                        counter)
                (pp-solution wc1 t) (terpri))
            (dolist (op (get-simpler-operations-from op1 wc1))
              (undo-neighborhood-operation op wc1)))

          ;; (doselect-subroute-with-length (s1 r1 2 wc1)
          ;;   (doselect-subroute-with-length (s2 r2 4 wc1)
          ;;     (doswap-subroutes (s1 s2 wc1)
          ;;       (incf counter))))

          (format t "Neighborhood size: ~a~%" counter)
          (format t "Original solution:~%")
          (pp-solution wc1 t) (terpri)))
     #+END_SRC
**** simple test with doselect-subroute (from different all sizes)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1  2  3  4)
                               (5  6  7  8)))
       (let* ((wc1 (basic-working-copy s1))
              (ops-list nil)
              (r1 1) (r2 2)
              (counter 0)
              )

         (bformat t "Testing doswap-subroutes")

         (prepare-solution-for-neighborhood-exploration wc1)

          (format t "Original solution:~%")
          (pp-solution wc1 t) (terpri)


          (doselect-subroute (s1 r1 wc1)
            (doselect-subroute (s2 r2 wc1)
              (doswap-subroutes (s1 s2 wc1)
                (incf counter)
                (format t "Inside doswap-subroutes...~%")
                (pp-solution wc1 t) (terpri))))

          ;; (doselect-subroute (s1 r1 wc1)
          ;;   (doselect-subroute (s2 r2 wc1)
          ;;     (doswap-subroutes (s1 s2 wc1)
          ;;       (incf counter))))

          (format t "Neighborhood size: ~a~%" counter)
          ;; (format t "Original solution:~%")
          ;; (pp-solution wc1 t)
          ;; (terpri)


        ))
     #+END_SRC
**** test with doselect-subroute (from the same route)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1  2  3  4 5)))
       (let* ((wc1 (basic-working-copy s1))
              (ops-list nil)
              (r1 1)
              (counter 0)
              )

         (bformat t "Testing doswap-subroutes")

         (prepare-solution-for-neighborhood-exploration wc1)

         (format t "Original solution:~%")
         (pp-solution wc1 t) (terpri)


         (doselect-subroute (s1 r1 wc1)
           (doselect-subroute (s2 r1 wc1)
             (doswap-subroutes (s1 s2 wc1)
               (incf counter)
               (format t "Inside doswap-subroutes...~%")
               (pp-solution wc1 t) (terpri))))

         ;; (doselect-subroute (s1 r1 wc1)
         ;;   (doselect-subroute (s2 r2 wc1)
         ;;     (doswap-subroutes (s1 s2 wc1)
         ;;       (incf counter))))

         (format t "Neighborhood size: ~a~%" counter)
         ;; (format t "Original solution:~%")
         ;; (pp-solution wc1 t)
         ;; (terpri)


         ))
     #+END_SRC
** random-add-route
*** description
    Exactly doadd-route but with a different name =:-/=.  In fact, we just copy the =macro-function= of the =doadd-route= symbol.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-operations.lisp
    (setf (macro-function 'random-add-route) 
          (macro-function 'doadd-route))
    #+END_SRC
*** tests
**** simple tests (no iterations)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6 7) ()))
       (let* ((wc (basic-working-copy s1))
              (op1 (op-select-client 1 1 0))
              (ops-list nil)

              (*vrp-stop-neighborhood-search* nil))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing the doreverse-subroute macro")

         (format t "The original solution:~%")
         (pp-solution wc t) (terpri)

         (dolist (op (get-simpler-operations-from op1 wc))
           (simulate-neighborhood-operation op wc))

         (random-add-route (0 wc)
           (format t "After the add-route:~%")
           (pp-solution wc t) (terpri))))
     #+END_SRC
**** with a select-client
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6 7)))
       (let* ((wc (basic-working-copy s1))
              (op1 (op-select-client 1 1 0))
              (ops-list nil)

              (*vrp-stop-neighborhood-search* nil))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing the doreverse-subroute macro")

         (format t "The original solution:~%")
         (pp-solution wc t) (terpri)

         (doselect-client (c1 1 wc)
           (random-add-route (c1 wc)
             (format t "After the add-route:~%")
             (pp-solution wc t) (terpri)))))
     #+END_SRC
**** with two select-client
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5 6 7)))
       (let* ((wc (basic-working-copy s1))
              (op1 (op-select-client 1 1 0))
              (ops-list nil)

              (*vrp-stop-neighborhood-search* nil))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing the doreverse-subroute macro")

         (format t "The original solution:~%")
         (pp-solution wc t) (terpri)

         (doselect-client (c1 1 wc)
           (doselect-client (c2 1 wc)
             (random-add-route (c1 wc)
               (random-add-route (c2 wc)
                 (format t "After the add-route:~%")
                 (pp-solution wc t) (terpri)))))))
     #+END_SRC


* macros for a *random-search* of a neighborhood
** description
   In this section I'm going to add the * version of the macros that explore the neighborhood in a random way (as opposed to an exhaustive search).

   The usage would be something like:

   #+BEGIN_EXAMPLE
   (random-select-route* (r1 wc)
     (random-select-client* (c1 r1 wc)
        (random-insert-client* (c1 r1 wc)
           code here)))
   #+END_EXAMPLE

   Actually, I think that right now, the * version of these macros can be same random version, because (so far) in a random search we just select one value from each step in the neighborhood search, and there would be no advantage in the use of the * version.  So I think that rigth now, there is nothing to do here, and just specialize the appropriate strategy to return tho same random version of the macro.
