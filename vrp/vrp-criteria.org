#+TITLE: VRP solver environment
#+AUTHOR: Fernando Rodriguez Flores
#+AUTHOR: Heidy Abreu Fumero
#+DATE 2019-01-24
#+TODO: TODO WIP BROKEN | DONE

* Description
  In this file we are going to add the criteria related stuff.

  The src blocks in this file should be tangled to src/vrp-criteria.lisp.

  
* add the package to the tangled file
  #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
  (in-package :vrp)
  #+END_SRC


  
* some classical neighboorhood criteria

** description
   In this section I'll add some classical criteria, that can be used again, and again, and again.

   The smart version of a criterion is the same criterion avoiding the repetition of 

** macro for the creation of criteria
*** description
    Everytime we want to create a criterion we have to repeat the same steps.  This macro abstracts that process.  We'll use a variable to store all the possible search-strategies for the criteria.
*** variable with the strategies
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
    (defparameter *search-strategies-for-classical-criteria*
      `((best +best-improvement+)
        (first +first-improvement+)
        (random +random-improvement+))
      "A list with the search strategies that can be used to automatically create classical neighboorhood criteria.  The first element is a symbol to append to the name of the criterion, and the second is a symbol whose symbol-value should be an instance of a select-strategy class.")
    #+END_SRC
       
*** code for the macro
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
    (defmacro make-classical-criterion
        (name description
         &key
           (strategies *search-strategies-for-classical-criteria*))
      ;; (declare (ignore strategies))
      (let* ((criterion-description name))
        ;; let's create the description
        `(progn
           (defparameter ,criterion-description ',description)
           ;; now we add one criterion for each strategy
           ,@(loop for (strat instance) in strategies
                   collecting `
                   (defparameter ,(symb name "-" strat)
                     (make-neighborhood-criterion
                      ,criterion-description
                      +exhaustive-search-strategy+
                      ,instance)))
           )))
    #+END_SRC
    
*** tests
**** testing macro expansion
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (make-classical-criterion rab ((select-route r1)
                                    (select-client c1 from r1)
                                    (insert-client c1 into r1)))
     #+END_SRC
** generic function clone working-copy-as-solution
*** description
    This method receives a working-copy and returns a basic-solution that represents the current state of the working-copy.
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp
     (defgeneric clone-working-copy-as-solution (working-copy)
       (:documentation "Receives a working-copy and returns a new basic-solution that represents the current state of the working-copy."))
     #+END_SRC   
    
*** method (basic-working-copy)
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp
     (defmethod clone-working-copy-as-solution ((wc basic-working-copy))
       (let* ((solution (solution wc))
              (new-solution (basic-solution :id (id solution)))
              (r1 (first (routes solution)))
              (d1 (depot r1))
              (number-of-routes (number-of-routes wc)))

         ;; let's create the routes
         (loop for r-id from 1 to number-of-routes
               do (progn
                    (push
                     (basic-route :id r-id
                                  :vehicle (vehicle
                                            (nth (1- r-id)
                                                 (routes solution)))
                                  :depot d1
                                  :clients
                                  (loop for c from 1 to (route-length r-id wc)
                                        collect (clone (client-at
                                                        (list r-id c)
                                                        wc))))
                     (routes new-solution))))

         ;; let's reverse the routes
         (setf (routes new-solution) (reverse (routes new-solution)))

         ;; let's set the cost
         (setf (cost new-solution) (cost solution))

         ;; return the new-solution
         new-solution))
     #+END_SRC   

*** tests
**** basic test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3) (4 5)))
       (let* ((wc (basic-working-copy s1))
              (cloned-solution nil))

         (bformat t "Testing clone-working-copy-as-solution")
         (prepare-solution-for-neighborhood-exploration wc)

         (format t "Original solution:~%")
         (pp-solution wc t) (terpri)


         (setf cloned-solution (clone-working-copy-as-solution wc))

         (format t "Cloned solution:~%")
         (pp-solution cloned-solution t) (terpri)

         (check-obj= (solution wc) cloned-solution)

         (format t "id: ~a~%routes: ~a~%cost: ~a~%"
                 (obj= (id (solution wc)) (id cloned-solution))
                 (obj= (routes (solution wc)) (routes cloned-solution))
                 (obj= (cost (solution wc)) (cost cloned-solution)))

         (format t "routes 1: ~a~%routes2: ~a~%"
                 (routes (solution wc))
                 (routes cloned-solution))

         ))
     #+END_SRC
** macro to detect repeated elements in the criteria
*** description
    In this section we'll write a macro to count the number of repeated elements in a neighboorhood, and to explore other properties of the supposedly smart version of the neighboorhood.
*** code for the macro v3 (criteria vs set of criteria)
**** description
     In this section I'll write a macro to compare the elements in a neighboorhood with the neighbors in a set of criteria.  The idea is to use this macro te make sure the smart* version of the macros work as they should.

     The idea is that I could compare rerehgs* with the union of rarac* and rereg.
**** handmade code for the rehregs* vs rarac + rereg version
     #+BEGIN_SRC lisp +n -r :results none :exports code  :tangle ../src/vrp-tests.lisp  
     (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8 9 10)))
       (bformat t "Testing rehregs* vs rarac")
       (let* ( ;; (criteria-union nil)
              (smart*-neighborhood nil)
              (original-criterion-neighborhood nil)
              (criterion-minus-union nil)
              ;; (criterion-intersertion-union nil)
              ;; (original-criterion-format "[~a, ~a]")

              (ops-list nil)
              (wc (basic-working-copy s1))
              (current-solution nil))

         (prepare-solution-for-neighborhood-exploration wc)
         ;; let's create the original criterion
         ;; and populate the original-criterion-neighborhood
         (doselect-route (r1 wc)
           (doselect-subroute (c1 r1 wc
              ;; if c1.length is 1 then we don't
              ;; reverse anything and all those
              ;; neighboors are explored in rereg                             
              :ldt 1)
             (doselect-route (r2 wc)
               (doselect-subroute (c2 r2 wc
                  :ex-cond               
                  (or
                   (and ;; both routes with length 1 and r1 < r2
                    (= c1.length c2.length 1)
                    (< r1 r2)
                    )
                   (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
                    (= c1.length c2.length 1)
                    (= r1 r2)
                    (< c2.position c1.position))
                   ;; we'll only apply the constraints
                   ;; if we are in the same route
                   (and
                    (= r1 r2)
                    (or
                     ;; we'll split the analysis in several cases
                     ;; that I'll write in the comments
                     ;; |c1| = 1 and |c2| = 1
                     (and ;; these are the case where both length are 1
                      (= c1.length 1)
                      (= c2.length 1)
                      (or ;; pivoting effect
                       ;; the first two remove the "pivoting effect"
                       ;; this is the case where c2.pos > c1.pos
                       (= c2.position
                          (+ c1.position 1))
                       ;; this is the case where c2.pos > c1.pos
                       (= c2.position
                          (- c1.position 2))))

                     ;; |c1| = 1 and |c2| > 1 
                     (and
                      (= c1.length 1)
                      (> c2.length 1)
                      (or
                       (and ;; don't go pass me
                        (< c2.position c1.position)
                        (>= (1-
                             (+ c2.position c2.length))
                            c1.position))
                       (or ;; pivoting effect
                        ;; the first two remove the "pivoting effect"
                        ;; this is the case where c2.pos < c1.pos
                        (= c2.position
                           (- c1.position c2.length 1))
                        ;; this is the case where c2.pos > c1.pos
                        (= c2.position
                           (+ c1.position 1)))))
                     ;; TODO |c1| > 1 and |c2| = 1
                     (and
                      (> c1.length 1)
                      (= c2.length 1)
                      (or ;; pivot and symmetry
                       ;; the first two remove the "pivoting effect"
                       ;; this is the case where c2.pos > c1.pos
                       (= c2.position
                          (+ c1.position 1))
                       ;; this is the case where c2.pos > c1.pos
                       (= c2.position
                          (- c1.position 2))
                       ;; and this one removes the
                       ;; symmetry effect
                       (= c2.position
                          (- c1.position 1))))
                     ;; |c1| > 1 and |c2| > 1
                     (and
                      (> c1.length 1)
                      (> c2.length 1)
                      (or
                       (and ;; don't go beyond me!
                        (< c2.position c1.position)
                        (>= (1- (+ c2.position c2.length))
                            c1.position))
                       (or ;; pivoting effect  
                        ;; this is the case where c2.pos < c1.pos
                        (= c2.position
                           (- c1.position c2.length 1))
                        ;; this is the case where c2.pos > c1.pos
                        (= c2.position
                           (+ c1.position 1)))))
                     )))) 
                 (doreverse-subroute (c1 wc)
                   (doswap-subroutes (c1 c2 wc)
                     ;; here we collect the elements
                     ;; in this neighboorhood
                     (setf current-solution
                           (clone-working-copy-as-solution wc))
                     ;; (if (member current-solution
                     ;;             original-criterion-neighborhood
                     ;;             :test (lambda (x y) (obj= x (first y))))
                     ;;     (error "WTF!!!!"))
                     (push (list (clone current-solution)
                                 (format nil "[~a | ~a]"
                                         (subroute-selected-at-operation c1 wc)
                                         (subroute-selected-at-operation c2 wc)))
                           original-criterion-neighborhood)))

                 ))))

         ;; now let's create the criteria union
         ;; to gather all the neighbors from all
         ;; the other criteria, in this case
         ;; the rarac, and rereg.

         ;; here comes rarac
         (doselect-route (r1 wc)
           (doselect-client (c1 r1 wc)
             (doselect-route (r2 wc :ge r1)
               (doselect-client (c2 r2 wc
                                    :ge (list r1 c1.select.position))
                 (doswap-clients (c1 c2 wc)
                   ;; let's add the neighbors
                   (setf current-solution
                         (clone-working-copy-as-solution wc))
                   (push (list current-solution
                               (format nil "rarac: [~a, ~a]"
                                       (client-selected-at-operation c1 wc)
                                       (client-selected-at-operation c2 wc)))
                         smart*-neighborhood))))))

         ;; here comes rereg
         (doselect-route (r1 wc)
           (doselect-subroute (z1 r1 wc)
             (doselect-route (r2 wc :ge r1)
               (doselect-subroute (z2 r2 wc
                                      :ge z1.select.coord)
                 (doswap-subroutes (z1 z2 wc)
                   ;; let's add the neighbors
                   (setf current-solution
                         (clone-working-copy-as-solution wc))
                   (push (list current-solution
                               (format nil "rereg: [~a | ~a]."
                                       (subroute-selected-at-operation z1 wc)
                                       (subroute-selected-at-operation z2 wc)))
                         smart*-neighborhood))))))


         ;; here comes the smart* version of rerehg
         (doselect-route (r1 wc)
           (doselect-subroute (c1 r1 wc
              :ldt 1)
             (doselect-route (r2 wc)
               (doselect-subroute (c2 r2 wc
                  ;; to avoid collisions with rarac
                  ;; don't select both subroutes with length 1
                  :lex-cond (= c1.length c2.length 1)
                  :ex-cond               
                  (or
                   (and ;; avoid other collisions with rarac
                    ;; we should avoid the case
                    ;; when c1.length is 2, c2.length is 1
                    ;; and we are in the same route, and c2 is
                    ;; selected from the same place as c1
                    ;; this can also be obtained in rarac
                    (= r1 r2)
                    (= c1.length 2)
                    (= c2.length 1)
                    (= c2.position c1.position))

                   (and ;; r1 = r2
                    (= r1 r2)
                    (or ;; each case in isolation
                     ;; we'll split the analysis in several cases
                     ;; that I'll write in the comments

                     ;; |c1| = 1 and |c2| = 1
                     ;; we don't need this because we have already
                     ;; forbidden r1 = r2
                     ;; to avoid collisions with rarac

                     ;; |c1| = 1 and |c2| > 1
                     ;; no need to analyze this because
                     ;; we have already ruled out this case
                     ;; to avoid collisions with rereg


                     (and ;; |c1| > 1 and |c2| = 1
                      (> c1.length 1)
                      (= c2.length 1)
                      (or ;; pivot and symmetry
                       ;; the first two remove the "pivoting effect"
                       ;; this is the case where c2.pos > c1.pos
                       (= c2.position
                          (+ c1.position 1))
                       ;; this is the case where c2.pos > c1.pos
                       (= c2.position
                          (- c1.position 2))
                       ;; and this one removes the
                       ;; symmetry effect
                       (= c2.position
                          (- c1.position 1))))

                     ;; |c1| > 1 and |c2| > 1
                     (and
                      (> c1.length 1)
                      (> c2.length 1)
                      (or
                       (and
                        (< c2.position c1.position)
                        (>= (1- (+ c2.position c2.length))
                            c1.position))
                       (or ;; pivoting effect  
                        ;; this is the case where c2.pos < c1.pos
                        (= c2.position
                           (- c1.position c2.length 1))
                        ;; this is the case where c2.pos > c1.pos
                        (= c2.position
                           (+ c1.position 1)))))))))
                 (doreverse-subroute (c1 wc)
                   (doswap-subroutes (c1 c2 wc)
                     ;; let's add the neighbors
                     (setf current-solution
                           (clone-working-copy-as-solution wc))
                     (push (list current-solution
                                 (format nil "rerehgs*: [~a | ~a]."
                                         (subroute-selected-at-operation c1 wc)
                                         (subroute-selected-at-operation c2 wc)))
                           smart*-neighborhood)))))))

         ;; let's compute the difference
         (setf criterion-minus-union
               (set-difference original-criterion-neighborhood
                               smart*-neighborhood
                               :test (lambda (x y)
                                       (obj= (first x)
                                             (first y)))))


         (setf criterion-minus-union
               (reverse criterion-minus-union))

         ;; just for testing purposes,
         ;; let's print the original-criterion-neighborhood
         (format t "Missing elements ~a"
                 (length criterion-minus-union))
         (if (> (length criterion-minus-union) 0)
             (format t ":~%~{~a~%~}"
                     criterion-minus-union)
             (format t ".~%"))
         ))
     #+END_SRC
     
**** handmade code for the rerehgs* vs rarac + rereg + rehreg
     #+BEGIN_SRC lisp +n -r :results none :exports code  :tangle ../src/vrp-tests.lisp  
     (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8 9 10 11 12) (13 14 5)))
       (bformat t "Testing rerehgs* vs rarac")
       (let* ( ;; (criteria-union nil)
              (smart*-neighborhood nil)
              (original-criterion-neighborhood nil)
              (criterion-minus-union nil)
              ;; (criterion-intersertion-union nil)
              ;; (original-criterion-format "[~a, ~a]")

              (ops-list nil)
              (wc (basic-working-copy s1))
              (current-solution nil))

         (prepare-solution-for-neighborhood-exploration wc)
         ;; let's create the original criterion
         ;; and populate the original-criterion-neighborhood
         (doselect-route (r1 wc)
           (doselect-subroute (c1 r1 wc)
             (doselect-route (r2 wc)
               (doselect-subroute (c2 r2 wc
                  :ex-cond               
                  (or
                   ;; if both routes are equal this is rehreg
                   (/= r1 r2)
                   ;; if both subroutes have length 1
                   ;; exclude if r2 < r1
                   (and
                    (= c1.length c2.length 1)
                    (< r2 r1))
                   ;; let's apply the following rules
                   ;; if both subroutes are selected
                   ;; from the same route
                   (and ;; both subroutes are from the same subroute
                    (= r1 r2)
                    (or  ;; let's analyze all the cases
                     (and ;; |c1| = |c2| = 1
                      (= c1.length 1)
                      (= c2.length 1)
                      (or
                       ;; c2 is "before" c1
                       (< c2.position c1.position)
                       (or ;; exclued the pivoting effect
                        ;; c1.pos < c2.pos
                        (= c2.position
                           (+ c1.position 1)))))
                     (and ;; |c1| = 1, |c2| > 1
                      (= c1.length 1)
                      (> c2.length 1)
                      ;; let's remove the pivoting effect
                      (or ;; pivoting and symmetric effect
                       ;; c1.pos < c2.pos
                       (= c2.position
                          (+ c1.position 1))
                       ;; c1.pos > c2.pos
                       (= c2.position
                          (- c1.position c2.length 1))
                       ;; let's remove the symmetric repetitions
                       (= c2.position
                          (- c1.position c2.length)))




                      )
                     (and ;; |c1| > 1, |c2| = 1
                      ;; there are not repetitions in this case :-o
                      ;; I tested up to 10 clients
                      ;; but when we mix it with the other
                      ;; cases, some repeated elements appear :-/
                      ;; so we should remove the pivoting effect
                      (and
                       (> c1.length 1)
                       (= c2.length 1)
                       (or ;; let's remove the pivoting effect
                        ;; this is the case where c2.pos > c1.pos
                        (= c2.position
                           (+ c1.position 1))         
                        ;; this is the case where c2.pos < c1.pos
                        (= c2.position
                           (- c1.position c2.length 1))
                        ;; and this one is for the symmetric effect
                        (= c2.position
                           (- c1.position 1)))))
                     (and ;; |c1| > 1, |c2| > 1
                      (> c1.length 1)
                      (> c2.length 1)
                      (or ;; let's analyze the possible problems

                       (and ;; don't stop before me
                        ;;  ;; It worked!!!
                        ;;  ;; Now Iosvanny must find out why :-o
                        (< c2.position c1.position)

                        (= (+ c2.position c2.length)
                           c1.position))

                       (or ;; let's remove the pivoting effect
                        ;; this is the case where c2.pos > c1.pos
                        (= c2.position
                           (+ c1.position 1))         
                        ;; this is the case where c2.pos < c1.pos
                        (= c2.position
                           (- c1.position c2.length 1)))
                       ))))))
                 (doreverse-subroute (c2 wc)
                   (doswap-subroutes (c1 c2 wc)
                     ;; here we collect the elements
                     ;; in this neighboorhood
                     (setf current-solution
                           (clone-working-copy-as-solution wc))
                     ;; (if (member current-solution
                     ;;             original-criterion-neighborhood
                     ;;             :test (lambda (x y) (obj= x (first y))))
                     ;;     (error "WTF!!!!"))
                     (push (list (clone current-solution)
                                 (format nil "[~a | ~a]"
                                         (subroute-selected-at-operation c1 wc)
                                         (subroute-selected-at-operation c2 wc)))
                           original-criterion-neighborhood)))

                 ))))

         ;; now let's create the criteria union
         ;; to gather all the neighbors from all
         ;; the other criteria, in this case
         ;; the rarac, and rereg.

         ;; here comes rarac
         (doselect-route (r1 wc)
           (doselect-client (c1 r1 wc)
             (doselect-route (r2 wc :ge r1)
               (doselect-client (c2 r2 wc
                  :ge (list r1 c1.select.position))
                 (doswap-clients (c1 c2 wc)
                   ;; let's add the neighbors
                   (setf current-solution
                         (clone-working-copy-as-solution wc))
                   (push (list current-solution
                               (format nil "rarac: [~a, ~a]"
                                       (client-selected-at-operation c1 wc)
                                       (client-selected-at-operation c2 wc)))
                         smart*-neighborhood))))))

         ;; here comes rereg
         (doselect-route (r1 wc)
           (doselect-subroute (z1 r1 wc)
             (doselect-route (r2 wc :ge r1)
               (doselect-subroute (z2 r2 wc
                  :ge z1.select.coord)
                 (doswap-subroutes (z1 z2 wc)
                   ;; let's add the neighbors
                   (setf current-solution
                         (clone-working-copy-as-solution wc))
                   (push (list current-solution
                               (format nil "rereg: [~a | ~a]."
                                       (subroute-selected-at-operation z1 wc)
                                       (subroute-selected-at-operation z2 wc)))
                         smart*-neighborhood))))))

         ;; here comes rehreg
         (doselect-route (r1 wc)
           (doselect-subroute (c1 r1 wc
              ;; if c1.length is 1 then we don't
              ;; reverse anything and all those
              ;; neighboors are explored in rereg
              :ldt 1)
             (doreverse-subroute (c1 wc)
              (doselect-route (r2 wc :ge r1)
                (doselect-subroute (c2 r2 wc
                  ;; to avoid collisions with rarac
                  ;; don't select both subroutes with length 1
                  :lex-cond (= c1.length c2.length 1)
                  ;; ;; but also we should not select c2
                  ;; ;; right where c1 ends, if c1.length is 2
                  ;; ;; I'm adding this constraint
                  ;; ;; to the ex-cond                                   
                  :ex-cond               
                  (or
                   (and ;; avoid other collisions with rarac
                    ;; we should avoid the case
                    ;; when c1.length is 2, c2.length is 1
                    ;; and we are in the same route, and c2 is
                    ;; selected from the same place as c1
                    ;; this can also be obtained in rarac
                    (= r1 r2)
                    (= c1.length 2)
                    (= c2.length 1)
                    (= c2.position c1.position))

                   ;; (and ;; |c1| = |c2| = 1 and r1 < r2
                   ;;  ;; we don't need this because we have already
                   ;;  ;; forbidden r1 = r2.
                   ;;  (= c1.length c2.length 1)
                   ;;  (< r1 r2))
                   ;; (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
                   ;;  ;; we don't need this because we have already
                   ;;  ;; forbidden r1 = r2.
                   ;;  (= r1 r2)
                   ;;  (= c1.length c2.length 1)
                   ;;  (< c2.position c1.position))
                   ;; otherwise we'll apply the constraints
                   ;; if we are in the same route
                   (and
                    (= r1 r2)
                    (or ;; each case in isolation
                     ;; we'll split the analysis in several cases
                     ;; that I'll write in the comments

                     ;; |c1| = 1 and |c2| = 1
                     ;; we don't need this because we have already
                     ;; forbidden r1 = r2
                     ;; to avoid collisions with rarac

                     ;; |c1| = 1 and |c2| > 1
                     ;; no need to analyze this because
                     ;; we have already ruled out this case
                     ;; to avoid collisions with rereg


                     (and ;; |c1| > 1 and |c2| = 1
                      (> c1.length 1)
                      (= c2.length 1)
                      (or ;; pivot and symmetry
                       ;; the first two remove the "pivoting effect"
                       ;; this is the case where c2.pos > c1.pos
                       (= c2.position
                          (+ c1.position 1))
                       ;; this is the case where c2.pos > c1.pos
                       (= c2.position
                          (- c1.position 2))
                       ;; and this one removes the
                       ;; symmetry effect
                       (= c2.position
                          (- c1.position 1))))

                     ;; |c1| > 1 and |c2| > 1
                     (and
                      (> c1.length 1)
                      (> c2.length 1)
                      (or
                       (and
                        (< c2.position c1.position)
                        (>= (1- (+ c2.position c2.length))
                            c1.position))
                       (or ;; pivoting effect  
                        ;; this is the case where c2.pos < c1.pos
                        (= c2.position
                           (- c1.position c2.length 1))
                        ;; this is the case where c2.pos > c1.pos
                        (= c2.position
                           (+ c1.position 1)))))))))
                  (doswap-subroutes (c1 c2 wc)
                    ;; let's add the neighbors
                    (setf current-solution
                          (clone-working-copy-as-solution wc))
                    (push (list current-solution
                                (format nil "rereg: [~a | ~a]."
                                        (subroute-selected-at-operation c1 wc)
                                        (subroute-selected-at-operation c2 wc)))
                          smart*-neighborhood)))))))


         ;; here comes the smart* version of rerehg
         (doselect-route (r1 wc)
           (doselect-subroute (c1 r1 wc)
             ;; (doselect-route (r2 wc)
               (doselect-subroute (c2 r1 wc
                  ;; to avoid collisions with rarac                         
                  ;; avoid |c1| = |c2| = 1
                  :lex-cond (= c1.length c2.length 1)
                  ;; we also need to avoid c2.pos = c1.pos
                  ;; because we can get the same neighbor
                  ;; with rarac. This is the same restriction
                  ;; as in rehreg. I'll also add it to the
                  ;; ex-cond.

                  ;; the following line avoids collisions
                  ;; with rereg
                  :ldt 1

                  ;; an from here on is to avoid
                  ;; collisions with itself
                  :ex-cond               
                  (or
                   (and ;; avoid other collisions with rarac
                    ;; we should avoid the case
                    ;; when |c1| = 1, |c2| = 2, r1 = r2,
                    ;; and c2 is selected from the same place
                    ;; as c1 this can also be obtained in rarac.
                    (= c2.length 2)
                    (= c1.length 1)
                    (= c2.position c1.position))
                   ;; |c1| = |c2| = 1 ;; ruled out by rarac
                   (and ;; |c1| = 1, |c2| > 1
                    (= c1.length 1)
                    (> c2.length 1)

                    (or ;; all the constraints here
                     (or ;; pivoting effect and symmetry
                      ;; c1.pos < c2.pos
                      (= c2.position
                         (+ c1.position 1))
                      ;; c1.pos > c2.pos
                      (= c2.position
                         (- c1.position c2.length 1))
                      ;; let's remove the symmetric repetitions
                      (= c2.position
                         (- c1.position c2.length))
                      ;; don't go beyond me!!! to avoid
                      ;; collisions with rereg
                      (and ;; |c1| = 1, |c2| > 1
                       (< c2.position c1.position)
                       (= (+ c2.position c2.length -1)
                          c1.position))
                      )
                     ;; avoid |c2| >= 3 and concatenation
                     (and ;; avoid |c2| >= 3 and concatenation
                      (>= c2.length 3)
                      (= c1.position c2.position))
                     (or ;; to avoid collisions with rehreg pivots with length
                      (or ;; c2.pos > c1.pos
                       (> c2.position (+ c1.position 1))
                       ;; c2.pos < c1.pos
                       (> c1.position (+ c2.position c2.length))))
                     ) ;; here ends |c1| = 1, |c2| > 1

                    )
                   ;; |c1| > 1, |c2| = 1 ;; no need [it is rereg]
                   (and ;; |c1| > 1, |c2| > 1
                    (> c1.length 1)
                    (> c2.length 1)
                    (or ;; let's analyze the possible problems
                     (and ;; [don't stop before me]
                      ;;  ;; It worked!!!
                      (< c2.position c1.position)
                      (= (+ c2.position c2.length)
                         c1.position))

                     ;; |c1| > 1, |c2| > 1
                     (and ;; don't go beyond me!!! to avoid rereg
                      ;; collisions with rereg
                      ;; |c1| > 1, |c2| > 1
                      (< c2.position c1.position)
                      (= (+ c2.position c2.length -1)
                         c1.position))
                     (and ;; to avoid collisions with rereg
                      ;; |c2| = 2 and c2.pos = c1.pos + c1.length - 1
                      ;; this is equivalent to a rereg with pivot
                      ;; 
                      (= c2.length 2)
                      (= (+ c2.position c2.position)))
                     (or ;; let's remove the pivoting effect
                      ;; this is the case where c2.pos > c1.pos
                      (= c2.position
                         (+ c1.position 1))         
                      ;; this is the case where c2.pos < c1.pos
                      (= c2.position
                         (- c1.position c2.length 1)))
                     ;; avoid |c2| >= 3 and concatenation
                     (and ;; avoid |c2| >= 3 and concatenation
                      (>= c2.length 3)
                      (= c1.position c2.position))
                     (or ;; to avoid collisions with rehreg pivots with length
                      (or ;; c2.pos > c1.pos
                       (> c2.position (+ c1.position 1))
                       ;; c2.pos < c1.pos
                       (> c1.position (+ c2.position c2.length)))))
                    ) ;; here ends the case ;; |c1| > 1, |c2| > 1 
                   )  ;; ex-cond
                   )
                 (doreverse-subroute (c2 wc)
                   (doswap-subroutes (c1 c2 wc)
                     ;; let's add the neighbors
                     (setf current-solution
                           (clone-working-copy-as-solution wc))
                     (push (list current-solution
                                 (format nil "rerehgs*: [~a | ~a]."
                                         (subroute-selected-at-operation c1 wc)
                                         (subroute-selected-at-operation c2 wc)))
                           smart*-neighborhood))))))
         ;; ) the doselect-route r2 that was removed

         ;; let's compute the difference
         (setf criterion-minus-union
               (set-difference original-criterion-neighborhood
                               smart*-neighborhood
                               :test (lambda (x y)
                                       (obj= (first x)
                                             (first y)))))


         (setf criterion-minus-union
               (reverse criterion-minus-union))

         ;; just for testing purposes,
         ;; let's print the original-criterion-neighborhood
         (format t "Missing elements ~a"
                 (length criterion-minus-union))
         (if (> (length criterion-minus-union) 0)
             (format t ":~%~{~a~%~}"
                     criterion-minus-union)
             (format t ".~%"))
         ))
     #+END_SRC
     
**** handmade code for the rerehgs* version
     #+BEGIN_SRC lisp +n -r :results none :exports code  :tangle ../src/vrp-tests.lisp  

     (with-basic-solution (s1 ((1 2 3 4 5)))
       (bformat t "Testing rerehgs*")
       (let* ( ;; (criteria-union nil)
              (smart*-neighborhood nil)
              (original-criterion-neighborhood nil)
              (criterion-minus-union nil)
              ;; (criterion-intersertion-union nil)
              ;; (original-criterion-format "[~a, ~a]")

              (ops-list nil)
              (wc (basic-working-copy s1))
              (current-solution nil))

         (prepare-solution-for-neighborhood-exploration wc)
         ;; let's create the original criterion
         ;; and populate the original-criterion-neighborhood
         (doselect-route (r1 wc)
           (doselect-subroute (c1 r1 wc)
             (doselect-route (r2 wc)
               (doselect-subroute (c2 r2 wc
                                      :ex-cond               
                                      (or
                                       ;; if both subroutes have length 1
                                       ;; exclude if r2 < r1
                                       (and
                                        (= c1.length c2.length 1)
                                        (< r2 r1))
                                       ;; let's apply the following rules
                                       ;; if both subroutes are selected
                                       ;; from the same route
                                       (and ;; both subroutes are from the same subroute
                                        (= r1 r2)
                                        (or ;; let's analyze all the cases
                                         (and ;; |c1| = |c2| = 1
                                          (= c1.length 1)
                                          (= c2.length 1)
                                          (or
                                           ;; c2 is "before" c1
                                           (< c2.position c1.position)
                                           (or ;; exclued the pivoting effect
                                            ;; c1.pos < c2.pos
                                            (= c2.position
                                               (+ c1.position 1)))))
                                         (and ;; |c1| = 1, |c2| > 1
                                          (= c1.length 1)
                                          (> c2.length 1)
                                          ;; let's remove the pivoting effect
                                          (or ;; pivoting and symmetric effect
                                           ;; c1.pos < c2.pos
                                           (= c2.position
                                              (+ c1.position 1))
                                           ;; c1.pos > c2.pos
                                           (= c2.position
                                              (- c1.position c2.length 1))
                                           ;; let's remove the symmetric repetitions
                                           (= c2.position
                                              (- c1.position c2.length)))




                                          )
                                         (and ;; |c1| > 1, |c2| = 1
                                          ;; there are not repetitions in this case :-o
                                          ;; I tested up to 10 clients
                                          ;; but when we mix it with the other
                                          ;; cases, some repeated elements appear :-/
                                          ;; so we should remove the pivoting effect
                                          (and
                                           (> c1.length 1)
                                           (= c2.length 1)
                                           (or ;; let's remove the pivoting effect
                                            ;; this is the case where c2.pos > c1.pos
                                            (= c2.position
                                               (+ c1.position 1))         
                                            ;; this is the case where c2.pos < c1.pos
                                            (= c2.position
                                               (- c1.position c2.length 1))
                                            ;; and this one is for the symmetric effect
                                            (= c2.position
                                               (- c1.position 1)))))
                                         (and ;; |c1| > 1, |c2| > 1
                                          (> c1.length 1)
                                          (> c2.length 1)
                                          (or ;; let's analyze the possible problems

                                           (and ;; don't stop before me
                                            ;;  ;; It worked!!!
                                            ;;  ;; Now Iosvanny must find out why :-o
                                            (< c2.position c1.position)

                                            (= (+ c2.position c2.length)
                                               c1.position))

                                           (or ;; let's remove the pivoting effect
                                            ;; this is the case where c2.pos > c1.pos
                                            (= c2.position
                                               (+ c1.position 1))         
                                            ;; this is the case where c2.pos < c1.pos
                                            (= c2.position
                                               (- c1.position c2.length 1)))
                                           ))))))
                 (doreverse-subroute (c2 wc)
                   (doswap-subroutes (c1 c2 wc)
                     ;; here we collect the elements
                     ;; in this neighboorhood
                     (setf current-solution
                           (clone-working-copy-as-solution wc))
                     ;; (if (member current-solution
                     ;;             original-criterion-neighborhood
                     ;;             :test (lambda (x y) (obj= x (first y))))
                     ;;     (error "WTF!!!!"))
                     (push (list (clone current-solution)
                                 (format nil "[~a | ~a]"
                                         (subroute-selected-at-operation c1 wc)
                                         (subroute-selected-at-operation c2 wc)))
                           original-criterion-neighborhood)))

                 ))))

         ;; now let's create the criteria union
         ;; to gather all the neighbors from all
         ;; the other criteria, in this case
         ;; the rarac, and rereg.

         ;; here comes rarac
         (doselect-route (r1 wc)
           (doselect-client (c1 r1 wc)
             (doselect-route (r2 wc :ge r1)
               (doselect-client (c2 r2 wc
                                    :ge (list r1 c1.select.position))
                 (doswap-clients (c1 c2 wc)
                   ;; let's add the neighbors
                   (setf current-solution
                         (clone-working-copy-as-solution wc))
                   (push (list current-solution
                               (format nil "rarac: [~a, ~a]"
                                       (client-selected-at-operation c1 wc)
                                       (client-selected-at-operation c2 wc)))
                         smart*-neighborhood))))))

         ;; here comes rereg
         (doselect-route (r1 wc)
           (doselect-subroute (z1 r1 wc)
             (doselect-route (r2 wc :ge r1)
               (doselect-subroute (z2 r2 wc
                                      :ge z1.select.coord)
                 (doswap-subroutes (z1 z2 wc)
                   ;; let's add the neighbors
                   (setf current-solution
                         (clone-working-copy-as-solution wc))
                   (push (list current-solution
                               (format nil "rereg: [~a | ~a]."
                                       (subroute-selected-at-operation z1 wc)
                                       (subroute-selected-at-operation z2 wc)))
                         smart*-neighborhood))))))

         ;; here comes rereg [again?]
         ;; (doselect-route (r1 wc)
         ;;   (doselect-subroute (z1 r1 wc)
         ;;     (doselect-route (r2 wc :ge r1)
         ;;       (doselect-subroute (z2 r2 wc
         ;;                              :ge z1.select.coord)
         ;;         (doswap-subroutes (z1 z2 wc)
         ;;           ;; let's add the neighbors
         ;;           (setf current-solution
         ;;                 (clone-working-copy-as-solution wc))
         ;;           (push (list current-solution
         ;;                       (format nil "rereg: [~a | ~a]."
         ;;                               (subroute-selected-at-operation z1 wc)
         ;;                               (subroute-selected-at-operation z2 wc)))
         ;;                 smart*-neighborhood))))))

    
         ;; here comes the smart* version of rerehg
         (doselect-route (r1 wc)
           (doselect-subroute (c1 r1 wc)
             (doselect-route (r2 wc)
               (doselect-subroute (c2 r2 wc
                  ;; to avoid collisions with rarac                         
                  ;; avoid |c1| = |c2| = 1
                  :lex-cond (= c1.length c2.length 1)
                  ;; we also need to avoid c2.pos = c1.pos
                  ;; because we can get the same neighbor
                  ;; with rarac. This is the same restriction
                  ;; as in rehreg. I'll also add it to the
                  ;; ex-cond.

                  ;; the following line avoids collisions
                  ;; with rereg
                  :ldt 1

                  ;; an from here on is to avoid
                  ;; collisions with itself
                  :ex-cond               
                  (or
                   (and ;; avoid other collisions with rarac
                    ;; we should avoid the case
                    ;; when |c1| = 1, |c2| = 2, r1 = r2,
                    ;; and c2 is selected from the same place
                    ;; as c1 this can also be obtained in rarac.
                    (= r1 r2)
                    (= c2.length 2)
                    (= c1.length 1)
                    (= c2.position c1.position))
                   (and ;; |c1| = 1, |c2| > 1
                    (= c1.length 1)
                    (> c2.length 1)
                    ;; let's remove the pivoting effect
                    (or
                     ;; c1.pos < c2.pos
                     (= c2.position
                        (+ c1.position 1))
                     ;; c1.pos > c2.pos
                     (= c2.position
                        (- c1.position c2.length 1))
                     ;; let's remove the symmetric repetitions
                     (= c2.position
                        (- c1.position c2.length))
                     ;; don't go beyond me!!! to avoid
                     ;; collisions with rereg
                     ;; (and
                     ;;  (< c2.position c1.position)
                     ;;  (>= (+ c2.position c2.length -1)
                     ;;      c1.position))
                     )
                    )
                   ;; (and ;; |c1| > 1, |c2| = 1 ;; no need: rereg
                   ;;  ;; we should remove this case to avoid
                   ;;  ;; collisions with rereg
                   ;;  ;; so we should remove the pivoting effect
                   ;;  (and
                   ;;   (> c1.length 1)
                   ;;   (= c2.length 1)
                   ;;   (or ;; let's remove the pivoting effect
                   ;;    ;; this is the case where c2.pos > c1.pos
                   ;;    (= c2.position
                   ;;       (+ c1.position 1))         
                   ;;    ;; this is the case where c2.pos < c1.pos
                   ;;    (= c2.position
                   ;;       (- c1.position c2.length 1))
                   ;;    ;; and this one is for the symmetric effect
                   ;;    (= c2.position
                   ;;       (- c1.position 1)))))
                   (and ;; |c1| > 1, |c2| > 1
                    (> c1.length 1)
                    (> c2.length 1)
                    (or ;; let's analyze the possible problems

                     (and ;; [don't stop before me]
                      (< c2.position c1.position)
                      (= (+ c2.position c2.length)
                         c1.position))
                     ;; (and ;; don't go beyond me!!! to avoid
                     ;;  ;; collisions with rereg
                     ;;  (< c2.position c1.position)
                     ;;  (>= (+ c2.position c2.length -1)
                     ;;      c1.position))
                     (and ;; to avoid collisions with rereg
                      ;; |c2| = 2 and c2.pos = c1.pos + c1.length - 1
                      ;; this is equivalent to a rereg with pivot
                      ;; 
                      (= c2.length 2)
                      (= (+ c2.position c2.position)))
                     (or ;; let's remove the pivoting effect
                      ;; this is the case where c2.pos > c1.pos
                      (= c2.position
                         (+ c1.position 1))         
                      ;; this is the case where c2.pos < c1.pos
                      (= c2.position
                         (- c1.position c2.length 1)))
                     ))
                   ;; here ends the case ;; |c1| > 1, |c2| > 1 
                   ))
                 (doreverse-subroute (c2 wc)
                   (doswap-subroutes (c1 c2 wc)
                     ;; let's add the neighbors
                     (setf current-solution
                           (clone-working-copy-as-solution wc))
                     (push (list current-solution
                                 (format nil "rerehgs*: [~a | ~a]."
                                         (subroute-selected-at-operation c1 wc)
                                         (subroute-selected-at-operation c2 wc)))
                           smart*-neighborhood)))))))

         ;; let's compute the difference
         (setf criterion-minus-union
               (set-difference original-criterion-neighborhood
                               smart*-neighborhood
                               :test (lambda (x y)
                                       (obj= (first x)
                                             (first y)))))
      

         (setf criterion-minus-union
               (reverse criterion-minus-union))
      
         ;; just for testing purposes,
         ;; let's print the original-criterion-neighborhood
         (format t "Missing elements ~a"
                 (length criterion-minus-union))
         (if (> (length criterion-minus-union) 0)
             (format t ":~%~{~a~%~}"
                     criterion-minus-union)
             (format t ".~%"))
         ))
     #+END_SRC
     
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code  
     (defmacro explore-smart*-criterion (&key
                                           criterion
                                           other-criteria
                                           ;; smart-version-info
                                           ;; name-for-bformat
                                           ;; print-smart-repeated
                                           print-intersection
                                           show-intersection
                                           print-difference
                                           ;; print-smart-neighborhood
                                           ;; print-neighborhood
                                           (solution `((1 2 3 4))))
       ;; other criteria is a list with the code for the
       ;; other smart* criteria.

       (let* (
              ;; here we write the code for the analysis of the
              ;; criterion
              (code-for-the-criterion
               `(progn
                  ;; here we create a new solution from a working-copy
                  (setf current-neighbor
                        (clone-working-copy-as-solution wc))

                  ;; let's see how many repeated are there
                  (if (member current-neighbor all-neighborhood
                              :test 'obj=)
                      ;; then
                      (pushnew current-neighbor repeated-neighbors
                               :test 'obj=)
                      ;; else
                      (push current-neighbor once-only-neigbors))

                  (push current-neighbor all-neighborhood)))
              ;; this is the code for the criterion
              ;; with the macro headings
              (code-with-headings-for-criterion
               (append (car (last criterion))
                       (list code-for-the-criterion)))
              ;; here is the code with the instructions for
              ;; the smart version
              (smart-version-format-str
               ;; if we want to print some info,
               ;; first, let's build the format string
               (if smart-version-info
                   (with-output-to-string (s)
                     (format s "[~~a")
                     (loop for i in (rest smart-version-info)
                           do (format s " |~~a"))
                     (format s "]"))))
              ;; here we write how we build the
              ;; current-neighbor representation
              (build-solution-to-store-code
               `(setf current-neighbor
                        (clone-working-copy-as-solution wc)))
              ;; the code which defines what info
              ;; we should store about the current-neighbor
              (initial-code-for-the-smart-version
               (if smart-version-info
                   (list
                    build-solution-to-store-code
                    ;; let's get the info from this neighbor
                    `(setf info-to-print
                           (format nil ,smart-version-format-str
                                   ,@smart-version-info)))
                   (list
                    build-solution-to-store-code
                    `(setf info-to-print ""))))
              ;; and this is the code we always execute
              ;; to count the repeated neighbors and so
              (rest-of-the-code-to-store
               `(
                 ;; let's see if the current neighbor has already
                 ;; been visited
                 (setf membership-info
                       (first (member current-neighbor smart-neighborhood
                                      :test (lambda (x y) (obj= x (first y))))))

                 ;; now in membership-info we have a list
                 ;; where the 1st element is the neighbor and the
                 ;; 2nd is the "coords" from the moment it was added
                 ;; if it is nil, the neighbor is new.

                 (if membership-info 

                     ;; then it is repeated, so let's add it
                     ;; to the repeated ones
                     ;; but before we need to know if it was already
                     ;; added to the repeated ones
                     (progn
                       (setf repeated-info
                             (first (member current-neighbor
                                            smart-repeated-neighbors
                                            :test (lambda (x y)
                                                    (obj= x (first y))))))
                       ;; if repeated-info is non nil, the it has all the
                       ;; info we need about the repeated-neighbor.
                       ;; AND we need to remove it from the
                       ;; smart-repeated-neighbors
                       (if repeated-info
                           (then
                             (setf smart-repeated-neighbors
                                   (remove current-neighbor
                                           smart-repeated-neighbors
                                           :test (lambda (x y)
                                                   (obj= x (first y))))))
                           (else
                             ;; let's set it to an appropriate value
                             ;; in this case, to membership-info
                             (setf repeated-info
                                   membership-info)))

                       ;; now we should add the current-neighbor to
                       ;; the list of repeated-neighbors.
                       (push (append
                              repeated-info
                              (list info-to-print))
                             smart-repeated-neighbors))
                     ;; else
                     (push current-neighbor smart-once-only-neigbors))

                 ;; in any case
                 (push (list current-neighbor
                             info-to-print)
                       smart-neighborhood)))
              ;; here we append everything in a single
              ;; block of code
              (code-to-use-in-the-smart-version
               (append
                initial-code-for-the-smart-version
                rest-of-the-code-to-store))
              ;; here we add the code for the smart
              ;; version with the headings included
              (code-with-headings-for-smart-version
               (append (car (last smart-criterion))
                       code-to-use-in-the-smart-version))
              ;; and this is the code we use to print
              ;; the info we want
              (code-to-print-the-info
               (if criterion
                   `((progn
                       (format t "neighborhood size:        ~a~%"
                               (length all-neighborhood))
                       (format t "repeated elements:        ~a~%"
                               (length repeated-neighbors))
                       (format t "once-only elements:       ~a~%"
                               (length once-only-neigbors))))))
              ;; here I'll add the code to print info
              ;; about the repeated elements in the
              ;; smart version
              ;; first, a way to deal with several formats
              ;; to print the info
              (what-to-print-in-the-repeated
               (cond
                 ((eql print-smart-repeated 'all)
                  `(" ~a~%~{   ~a~%~}~%"
                    (first repeated)
                    (rest repeated)))
                 (t `(" ~a~%"
                      (first repeated)))))
              ;; and here is the actual code to print
              (code-to-print-the-smart-repeated-neighbors
               `((if (and ',print-smart-repeated
                          (> (length smart-repeated-neighbors) 0))
                     (progn
                       (format t "Repeated elements (~a):~%"
                               (length smart-repeated-neighbors))
                       (loop for repeated in smart-repeated-neighbors
                             do (format t ,(first what-to-print-in-the-repeated)
                                        ,@(rest what-to-print-in-the-repeated)
                                        ))))))
              ;; Now I'll add the code to print the intersection
              ;; of the criterion and the smart version
              ;; (what-to-print-in-the-intersection
              ;;  (cond
              ;;    ((eql print-intersection 'all)
              ;;     `(" ~a~%~{   ~a~%~}~%"
              ;;       (first i)
              ;;       (rest i)))
              ;;    (t `(" ~a~%"
              ;;         i))))
              ;; and here is the actual code to print
              ;; the intersection
              (code-to-print-the-intersection
               `((if (and (or ',print-intersection
                              ',show-intersection)
                          ',smart-criterion
                          ',criterion)
                     (progn
                       (setf intersection
                             (intersection once-only-neigbors
                                           smart-once-only-neigbors
                                           :test (lambda (x y)
                                                   (obj= x y))
                                           ))))
                 ;; here we display the actual info
                 ;; first, only the data
                 (if ',show-intersection
                     (format t "Elements in the intersection: ~a~%"
                             (length intersection)))
                 ;; now, if the user asked for it,
                 ;; we print the intersection 
                 (if (and ',print-intersection
                          (> (length intersection) 0))
                     (then
                       (loop for i in intersection
                             do (progn
                                  (pp-solution i t) (terpri)))))))
              ;; here we'll write the code for the difference
              ;; the difference will always be
              ;; original minus smart
              (what-to-print-in-the-difference
               (cond
                 ((eql print-difference 'all)
                  `(" ~a~%"
                    d))
                 (t `(" ~a~%"
                      d))))
              ;; and here is the code to actually print
              ;; the difference
              (code-to-print-the-difference
               `((if (and ',print-difference
                          ',smart-criterion
                          ',criterion)
                     (setf difference
                           (set-difference once-only-neigbors
                                           (mapcar (lambda (x)
                                                     (first x))
                                                   smart-neighborhood)
                                           :test #'obj=
                                           )))
                 (if (and ',print-difference
                          (> (length difference) 0))
                     (progn
                       (format t "Missing elements: ~a~%"
                               (length difference))
                       (loop for d in difference
                             do (format t ,(first what-to-print-in-the-difference)
                                        ,@(rest what-to-print-in-the-difference)
                                        ))
                       )
                     ;; else
                     (if ',print-difference
                         (format t "There are not missing elements.~%")))))
              ;; here I'll add the code to print the
              ;; smart neighborhood
              (code-to-print-the-smart-neighborhood
               `((if (and ',print-smart-neighborhood)
                     (progn
                       (format t "Smart-neighborhood (~a):~%"
                               (length smart-neighborhood))
                       (loop for elt in (reverse smart-neighborhood)
                             do (progn
                                  (pp-solution (first elt) t)
                                  (if (eql ',print-smart-neighborhood 'all)
                                      (format t "~{ ~a~%~}"
                                              (rest elt))))

                             ;; (terpri)
                             )))))
              (code-to-print-the-original-neighborhood
               `((if (and ',print-neighborhood)
                     (progn
                       (format t "Original-neighborhood (~a):~%"
                               (length all-neighborhood))
                       (loop for elt in (reverse all-neighborhood)
                             do (pp-solution elt t)
                             ;; (terpri)
                             )))))
              )


         ;; let's build the code with what to do
         ;; inside the criterion
         (loop for h in (reverse (butlast criterion))
               doing (setf code-with-headings-for-criterion
                           (append h (list code-with-headings-for-criterion))))

         ;; if we have a smart version, let's build the code
         (loop for h in (reverse (butlast smart-criterion))
               do (setf code-with-headings-for-smart-version
                        (append h (list code-with-headings-for-smart-version))))

         ;; let's write the code to print the info
         (setf code-to-print-the-info
               (append code-to-print-the-info
                       (if smart-criterion
                           `((progn
                               (format t "smart neighborhood size:  ~a~%"
                                       (length smart-neighborhood))
                               (format t "smart repeated elements:  ~a~%"
                                       (length smart-repeated-neighbors))
                               (format t "smart once-only elements: ~a~%"
                                       (length smart-once-only-neigbors))
                               )))))



        `(with-basic-solution (s1 ,solution)

           (bformat t "Exploring neighborhood ~a"
                    ,name-for-bformat)

           ;; (format t "code-to-use-in-the-smart-version: ~a~%"
           ;;         ',code-to-use-in-the-smart-version)

           ;; (format t "inner code for the smart version: ~a~%"
           ;;         ',inner-code-for-the-smart-version)

           (let* ((wc (basic-working-copy s1))
                  (ops-list nil)
                  (current-neighbor nil)
                  (all-neighborhood nil)
                  (repeated-neighbors nil)
                  (once-only-neigbors nil)
                  (smart-neighborhood nil)
                  (smart-repeated-neighbors nil)
                  (smart-once-only-neigbors nil)
                  (repeated-info nil)
                  (intersection nil)
                  (difference nil)
                  (membership-info nil)
                  (info-to-print nil)
                  )

             (prepare-solution-for-neighborhood-exploration wc)

             ;; here we execute the criterion with the code

             ,code-with-headings-for-criterion

             (prepare-solution-for-neighborhood-exploration wc)
             ;; now let's test the "smart" version
             ,code-with-headings-for-smart-version

             ,@code-to-print-the-info

             ,@code-to-print-the-smart-repeated-neighbors

             ,@code-to-print-the-intersection

             ,@code-to-print-the-difference

             ,@code-to-print-the-smart-neighborhood

             ,@code-to-print-the-original-neighborhood

             ;; (format t "repeated neighborhood:~%~a~%"
             ;;         smart-neighborhood)

             ;; (format t "intersection:~%~{~a~%~}~%"
             ;;         (intersection all-neighborhood
             ;;                             smart-neighborhood
             ;;                             :test (lambda (x y)
             ;;                                     (obj= x (first y)))
             ;;                             ))

             ))))
     #+END_SRC
**** tests for v2
***** testing rarac
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (explore-neighborhood-criteria-v2 ((doselect-route (r1 wc))
                                         (doselect-client (c1 r1 wc))
                                         (doselect-route (r2 wc))
                                         (doselect-client (c2 r2 wc))
                                         (doswap-clients (c1 c2 wc)))
                                        :smart-criterion
                                        ((doselect-route (r1 wc))
                                         (doselect-client (c1 r1 wc))
                                         (doselect-route (r2 wc
                                                :ge r1))
                                         (doselect-client (c2 r2 wc
                                                :ge c1.select.coord
                                                ))
                                         (doswap-clients (c1 c2 wc)))
                                        :name-for-bformat 'rarac
                                        :smart-version-info
                                        ((client-selected-at-operation c1 wc)
                                         (client-selected-at-operation c2 wc))
                                        :solution ((1 2 3 4) (5 6))
                                        :print-difference nil
                                        :print-intersection nil
                                        :show-intersection t
                                        :print-smart-neighborhood nil
                                        :print-neighborhood nil
                                      )
      #+END_SRC
***** testing rarac to find the bug
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4 5))) 
         (let* ((wc (basic-working-copy s1))
                (ops-list nil)
                (counter 0))
           (prepare-solution-for-neighborhood-exploration wc)
           (doselect-route (r1 wc)
             (doselect-client (c1 r1 wc)
               (doselect-route (r2 wc :ge r1)
                 (doselect-client (c2 r2 wc :ge c1.select.coord)
                   (doswap-clients (c1 c2 wc)
                     (incf counter)
                     (pp-solution wc t) (terpri)
                     (format t "Number of neighbors: ~a~%"
                             counter))))))))
      #+END_SRC
***** testing rereg
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (explore-neighborhood-criteria ((doselect-subroute (c1 1 wc))
                                       (doselect-subroute (c2 1 wc))
                                       (doswap-subroutes (c1 c2 wc))) 
                                      :name-for-bformat 'rereg
                                      :smart-criterion
                                      ((doselect-subroute (c1 1 wc))
                                       (doselect-subroute (c2 1 wc
                                                              :ge c1.select.position
                                                   
                                                              ))
                                       (doswap-subroutes (c1 c2 wc)))
                                      :smart-version-info 
                                      ((subroute-selected-at-operation c1 wc)
                                       (subroute-selected-at-operation c2 wc))
                                      :solution ((1 2 3 4))
                                      :print-smart-repeated nil
                                      :print-intersection nil
                                      :print-difference t
                                      )
      #+END_SRC

***** testing ref
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (explore-neighborhood-criteria ((doselect-subroute (c1 1 wc))
                                      (doinsert-subroute (c1 1 wc))) 
                                     :name-for-bformat 'rereg
                                     :smart-criterion
                                     ((doselect-subroute
                                          (c1 1 wc))
                                      (doinsert-subroute
                                          (c1 1 wc :gt c1.select.coord)))
                                     :smart-version-info 
                                     ((subroute-selected-at-operation c1 wc))
                                     :solution ((1 2 3 4 5 6))
                                     :print-smart-repeated all
                                     :print-intersection nil
                                     :print-difference t
                                     )
      #+END_SRC
    
*** code for the macro v2 (with full solutions)
**** description
     In this section we'll modify the macro so it analyzes a full solution instead of just a single route as we did in the first version.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code  :tangle ../src/vrp-criteria.lisp  
     (defmacro explore-neighborhood-criteria-v2 (criterion
                                                 &key
                                                   smart-criterion
                                                   smart-version-info
                                                   name-for-bformat
                                                   print-smart-repeated
                                                   print-intersection
                                                   show-intersection
                                                   print-difference
                                                   print-smart-neighborhood
                                                   print-neighborhood
                                                   print-smart-intersection
                                                   (solution `((1 2 3 4))))

       (let* (
              ;; here we write the code for the analysis of the
              ;; criterion
              (code-for-the-criterion
               `(progn
                  ;; here we create a new solution from a working-copy
                  (setf current-neighbor
                        (clone-working-copy-as-solution wc))
                  ;; (loop for r from 1 to (number-of-routes wc)
                  ;;       do (loop for c from 1 to (route-length r wc)
                  ;;                collect (clone
                  ;;                         (client-at (list r i) wc))))


                  ;; let's see how many repeated are there
                  (if (member current-neighbor all-neighborhood
                              :test 'obj=)
                      ;; then
                      (pushnew current-neighbor repeated-neighbors
                               :test 'obj=)
                      ;; else
                      (push current-neighbor once-only-neigbors))

                  (push current-neighbor all-neighborhood)))
              ;; this is the code for the criterion
              ;; with the macro headings
              (code-with-headings-for-criterion
               (append (car (last criterion))
                       (list code-for-the-criterion)))
              ;; here is the code with the instructions for
              ;; the smart version
              (smart-version-format-str
               ;; if we want to print some info,
               ;; first, let's build the format string
               (if smart-version-info
                   (with-output-to-string (s)
                     (format s "[~~a")
                     (loop for i in (rest smart-version-info)
                           do (format s " |~~a"))
                     (format s "]"))))
              ;; here we write how we build the
              ;; current-neighbor representation
              (build-solution-to-store-code
               `(setf current-neighbor
                        (clone-working-copy-as-solution wc)))
              ;; the code which defines what info
              ;; we should store about the current-neighbor
              (initial-code-for-the-smart-version
               (if smart-version-info
                   (list
                    build-solution-to-store-code
                    ;; let's get the info from this neighbor
                    `(setf info-to-print
                           (format nil ,smart-version-format-str
                                   ,@smart-version-info)))
                   (list
                    build-solution-to-store-code
                    `(setf info-to-print ""))))
              ;; and this is the code we always execute
              ;; to count the repeated neighbors and so
              (rest-of-the-code-to-store
               `(
                 ;; let's see if the current neighbor has already
                 ;; been visited
                 (setf membership-info
                       (first (member current-neighbor smart-neighborhood
                                      :test (lambda (x y) (obj= x (first y))))))

                 ;; now in membership-info we have a list
                 ;; where the 1st element is the neighbor and the
                 ;; 2nd is the "coords" from the moment it was added
                 ;; if it is nil, the neighbor is new.

                 (if membership-info 

                     ;; then it is repeated, so let's add it
                     ;; to the repeated ones
                     ;; but before we need to know if it was already
                     ;; added to the repeated ones
                     (progn
                       (setf repeated-info
                             (first (member current-neighbor
                                            smart-repeated-neighbors
                                            :test (lambda (x y)
                                                    (obj= x (first y))))))
                       ;; if repeated-info is non nil, the it has all the
                       ;; info we need about the repeated-neighbor.
                       ;; AND we need to remove it from the
                       ;; smart-repeated-neighbors
                       (if repeated-info
                           (then
                             (setf smart-repeated-neighbors
                                   (remove current-neighbor
                                           smart-repeated-neighbors
                                           :test (lambda (x y)
                                                   (obj= x (first y))))))
                           (else
                             ;; let's set it to an appropriate value
                             ;; in this case, to membership-info
                             (setf repeated-info
                                   membership-info)))

                       ;; now we should add the current-neighbor to
                       ;; the list of repeated-neighbors.
                       (push (append
                              repeated-info
                              (list info-to-print))
                             smart-repeated-neighbors))
                     ;; else
                     (push current-neighbor smart-once-only-neigbors))

                 ;; in any case
                 (push (list current-neighbor
                             info-to-print)
                       smart-neighborhood)))
              ;; here we append everything in a single
              ;; block of code
              (code-to-use-in-the-smart-version
               (append
                initial-code-for-the-smart-version
                rest-of-the-code-to-store))
              ;; here we add the code for the smart
              ;; version with the headings included
              (code-with-headings-for-smart-version
               (append (car (last smart-criterion))
                       code-to-use-in-the-smart-version))
              ;; and this is the code we use to print
              ;; the info we want
              (code-to-print-the-info
               (if criterion
                   `((progn
                       (format t "neighborhood size:        ~a~%"
                               (length all-neighborhood))
                       (format t "repeated elements:        ~a~%"
                               (length repeated-neighbors))
                       (format t "once-only elements:       ~a~%"
                               (length once-only-neigbors))))))
              ;; here I'll add the code to print info
              ;; about the repeated elements in the
              ;; smart version
              ;; first, a way to deal with several formats
              ;; to print the info
              (what-to-print-in-the-repeated
               (cond
                 ((eql print-smart-repeated 'all)
                  `(" ~a~%~{   ~a~%~}~%"
                    (first repeated)
                    (rest repeated)))
                 (t `(" ~a~%"
                      (first repeated)))))
              ;; and here is the actual code to print
              (code-to-print-the-smart-repeated-neighbors
               `((if (and ',print-smart-repeated
                          (> (length smart-repeated-neighbors) 0))
                     (progn
                       (format t "Repeated elements (~a):~%"
                               (length smart-repeated-neighbors))
                       (loop for repeated in smart-repeated-neighbors
                             do (format t ,(first what-to-print-in-the-repeated)
                                        ,@(rest what-to-print-in-the-repeated)
                                        ))))))
              ;; Now I'll add the code to print the intersection
              ;; of the criterion and the smart version
              ;; (what-to-print-in-the-intersection
              ;;  (cond
              ;;    ((eql print-intersection 'all)
              ;;     `(" ~a~%~{   ~a~%~}~%"
              ;;       (first i)
              ;;       (rest i)))
              ;;    (t `(" ~a~%"
              ;;         i))))
              ;; and here is the actual code to print
              ;; the intersection
              (code-to-print-the-intersection
               `((if (and (or ',print-intersection
                              ',show-intersection
                              ',print-smart-intersection)
                          ',smart-criterion
                          ',criterion)
                     (progn
                       (setf intersection
                             (intersection once-only-neigbors
                                           smart-once-only-neigbors
                                           :test (lambda (x y)
                                                   (obj= x y))
                                           ))))
                 ;; here we display the actual info
                 ;; first, only the data
                 (if ',show-intersection
                     (format t "Elements in the intersection: ~a~%"
                             (length intersection)))
                 ;; now, if the user asked for it,
                 ;; we print the intersection 
                 (if (and ',print-intersection
                          (> (length intersection) 0))
                     (then
                       (loop for i in intersection
                             do (progn
                                  (pp-solution i t) (terpri)))))))
              ;; here we'll write the code for the difference
              ;; the difference will always be
              ;; original minus smart
              (what-to-print-in-the-difference
               (cond
                 ((eql print-difference 'all)
                  `(" ~a~%"
                    d))
                 (t `(" ~a~%"
                      d))))
              ;; and here is the code to actually print
              ;; the difference
              (code-to-print-the-difference
               `((if (and ',print-difference
                          ',smart-criterion
                          ',criterion)
                     (setf difference
                           (set-difference once-only-neigbors
                                           (mapcar (lambda (x)
                                                     (first x))
                                                   smart-neighborhood)
                                           :test #'obj=
                                           )))
                 (if (and ',print-difference
                          (> (length difference) 0))
                     (progn
                       (format t "Missing elements: ~a~%"
                               (length difference))
                       (loop for d in difference
                             do (format t ,(first what-to-print-in-the-difference)
                                        ,@(rest what-to-print-in-the-difference)
                                        ))
                       )
                     ;; else
                     (if ',print-difference
                         (format t "There are not missing elements.~%")))))
              ;; here I'll add the code to print the
              ;; smart neighborhood
              (code-to-print-the-smart-neighborhood
               `((if (and ',print-smart-neighborhood)
                     (progn
                       (format t "Smart-neighborhood (~a):~%"
                               (length smart-neighborhood))
                       (loop for elt in (reverse smart-neighborhood)
                             do (progn
                                  (pp-solution (first elt) t)
                                  (if (eql ',print-smart-neighborhood 'all)
                                      (format t "~{ ~a~%~}"
                                              (rest elt))))

                             ;; (terpri)
                             )))))
              (code-to-print-the-original-neighborhood
               `((if (and ',print-neighborhood)
                     (progn
                       (format t "Original-neighborhood (~a):~%"
                               (length all-neighborhood))
                       (loop for elt in (reverse all-neighborhood)
                             do (pp-solution elt t)
                             ;; (terpri)
                             )))))
              )


         ;; let's build the code with what to do
         ;; inside the criterion
         (loop for h in (reverse (butlast criterion))
               doing (setf code-with-headings-for-criterion
                           (append h (list code-with-headings-for-criterion))))

         ;; if we have a smart version, let's build the code
         (loop for h in (reverse (butlast smart-criterion))
               do (setf code-with-headings-for-smart-version
                        (append h (list code-with-headings-for-smart-version))))

         ;; let's write the code to print the info
         (setf code-to-print-the-info
               (append code-to-print-the-info
                       (if smart-criterion
                           `((progn
                               (format t "smart neighborhood size:  ~a~%"
                                       (length smart-neighborhood))
                               (format t "smart repeated elements:  ~a~%"
                                       (length smart-repeated-neighbors))
                               (format t "smart once-only elements: ~a~%"
                                       (length smart-once-only-neigbors))
                               )))))



        `(with-basic-solution (s1 ,solution)

           (bformat t "Exploring neighborhood ~a"
                    ,name-for-bformat)

           ;; (format t "code-to-use-in-the-smart-version: ~a~%"
           ;;         ',code-to-use-in-the-smart-version)

           ;; (format t "inner code for the smart version: ~a~%"
           ;;         ',inner-code-for-the-smart-version)

           (let* ((wc (basic-working-copy s1))
                  (ops-list nil)
                  (current-neighbor nil)
                  (all-neighborhood nil)
                  (repeated-neighbors nil)
                  (once-only-neigbors nil)
                  (smart-neighborhood nil)
                  (smart-repeated-neighbors nil)
                  (smart-once-only-neigbors nil)
                  (smart-intersection nil)
                  (repeated-info nil)
                  (intersection nil)
                  (difference nil)
                  (membership-info nil)
                  (info-to-print nil)
                  )

             (prepare-solution-for-neighborhood-exploration wc)

             ;; here we execute the criterion with the code

             ,code-with-headings-for-criterion

             (prepare-solution-for-neighborhood-exploration wc)
             ;; now let's test the "smart" version
             ,code-with-headings-for-smart-version

             ,@code-to-print-the-info

             ,@code-to-print-the-smart-repeated-neighbors

             ,@code-to-print-the-intersection

             ,@code-to-print-the-difference

             ,@code-to-print-the-smart-neighborhood

             ,@code-to-print-the-original-neighborhood

             (if (and ,print-smart-intersection
                      intersection)
                 ;; let's compute the smart intersection
                 (progn
                   (loop for elt in intersection
                         doing (push (first (member elt smart-neighborhood
                                                    :test (lambda (x y)
                                                            (obj= x
                                                                  (first y)))))
                                     smart-intersection))
                   ;; and now let's print it:
                   (format t "Elements in the (smart) intersection: ~a~%~{~a~%~%~}"
                           (length smart-intersection)
                           (reverse smart-intersection))))

             ;; (format t "repeated neighborhood:~%~a~%"
             ;;         smart-neighborhood)

             ;; (format t "intersection:~%~{~a~%~}~%"
             ;;         (intersection all-neighborhood
             ;;                             smart-neighborhood
             ;;                             :test (lambda (x y)
             ;;                                     (obj= x (first y)))
             ;;                             ))

             ))))
     #+END_SRC
**** tests for v2
***** testing rarac
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (explore-neighborhood-criteria-v2 ((doselect-route (r1 wc))
                                         (doselect-client (c1 r1 wc))
                                         (doselect-route (r2 wc))
                                         (doselect-client (c2 r2 wc))
                                         (doswap-clients (c1 c2 wc)))
                                        :smart-criterion
                                        ((doselect-route (r1 wc))
                                         (doselect-client (c1 r1 wc))
                                         (doselect-route (r2 wc
                                                :ge r1))
                                         (doselect-client (c2 r2 wc
                                                :ge c1.select.coord
                                                ))
                                         (doswap-clients (c1 c2 wc)))
                                        :name-for-bformat 'rarac
                                        :smart-version-info
                                        ((client-selected-at-operation c1 wc)
                                         (client-selected-at-operation c2 wc))
                                        :solution ((1 2 3 4) (5 6))
                                        :print-difference nil
                                        :print-intersection nil
                                        :show-intersection t
                                        :print-smart-neighborhood nil
                                        :print-neighborhood nil
                                      )
      #+END_SRC
***** testing rarac to find the bug
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4 5))) 
         (let* ((wc (basic-working-copy s1))
                (ops-list nil)
                (counter 0))
           (prepare-solution-for-neighborhood-exploration wc)
           (doselect-route (r1 wc)
             (doselect-client (c1 r1 wc)
               (doselect-route (r2 wc :ge r1)
                 (doselect-client (c2 r2 wc :ge c1.select.coord)
                   (doswap-clients (c1 c2 wc)
                     (incf counter)
                     (pp-solution wc t) (terpri)
                     (format t "Number of neighbors: ~a~%"
                             counter))))))))
      #+END_SRC
***** testing rereg
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (explore-neighborhood-criteria ((doselect-subroute (c1 1 wc))
                                       (doselect-subroute (c2 1 wc))
                                       (doswap-subroutes (c1 c2 wc))) 
                                      :name-for-bformat 'rereg
                                      :smart-criterion
                                      ((doselect-subroute (c1 1 wc))
                                       (doselect-subroute (c2 1 wc
                                                              :ge c1.select.position
                                                   
                                                              ))
                                       (doswap-subroutes (c1 c2 wc)))
                                      :smart-version-info 
                                      ((subroute-selected-at-operation c1 wc)
                                       (subroute-selected-at-operation c2 wc))
                                      :solution ((1 2 3 4))
                                      :print-smart-repeated nil
                                      :print-intersection nil
                                      :print-difference t
                                      )
      #+END_SRC

***** testing ref
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (explore-neighborhood-criteria ((doselect-subroute (c1 1 wc))
                                      (doinsert-subroute (c1 1 wc))) 
                                     :name-for-bformat 'rereg
                                     :smart-criterion
                                     ((doselect-subroute
                                          (c1 1 wc))
                                      (doinsert-subroute
                                          (c1 1 wc :gt c1.select.coord)))
                                     :smart-version-info 
                                     ((subroute-selected-at-operation c1 wc))
                                     :solution ((1 2 3 4 5 6))
                                     :print-smart-repeated all
                                     :print-intersection nil
                                     :print-difference t
                                     )
      #+END_SRC
    
*** code for the macro v1
**** description
     This is a very simple version for the macro where we just analyze solutions with one route.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (defmacro explore-neighborhood-criteria (criterion
                                              &key
                                                smart-criterion
                                                smart-version-info
                                                name-for-bformat
                                                print-smart-repeated
                                                print-intersection
                                                print-difference
                                                (solution `((1 2 3 4))))

       (let* (
              ;; here we write the code for the analysis of the
              ;; criterion
              (code-for-the-criterion
               `(progn
                  (setf current-neighbor
                        (loop for i from 1 to (route-length 1 wc)
                              collecting (id (client-at (list 1 i) wc))))

                  ;; let's see how many repeated are there
                  (if (member current-neighbor all-neighborhood
                              :test 'obj=)
                      ;; then
                      (pushnew current-neighbor repeated-neighbors
                               :test 'obj=)
                      ;; else
                      (push current-neighbor once-only-neigbors))

                  (push current-neighbor all-neighborhood)))
              ;; this is the code for the criterion
              ;; with the macro headings
              (code-with-headings-for-criterion
               (append (car (last criterion))
                       (list code-for-the-criterion)))
              ;; here is the code with the instructions for
              ;; the smart version
              (smart-version-format-str
               ;; if we want to print some info,
               ;; first, let's build the format string
               (if smart-version-info
                   (with-output-to-string (s)
                     (format s "[~~a")
                     (loop for i in (rest smart-version-info)
                           do (format s " |~~a"))
                     (format s "]"))))
              ;; here we write how we build the
              ;; current-neighbor representation
              (build-solution-to-store-code
               `(setf current-neighbor
                      (loop for i from 1 to (route-length 1 wc)
                            collecting (id (client-at (list 1 i) wc)))))
              ;; the code which defines what info
              ;; we should store about the current-neighbor
              (initial-code-for-the-smart-version
               (if smart-version-info
                   (list
                    build-solution-to-store-code
                    ;; let's get the info from this neighbor
                    `(setf info-to-print
                           (format nil ,smart-version-format-str
                                   ,@smart-version-info)))
                   (list
                    build-solution-to-store-code)))
              ;; and this is the code we always execute
              ;; to count the repeated neighbors and so
              (rest-of-the-code-to-store
               `(
                 ;; let's see if the current neighbor has already
                 ;; been visited
                 (setf membership-info
                       (first (member current-neighbor smart-neighborhood
                                      :test (lambda (x y) (obj= x (first y))))))

                 ;; now in membership-info we have a list
                 ;; where the 1st element is the neighbor and the
                 ;; 2nd is the "coords" from the moment it was added
                 ;; if it is nil, the neighbor is new.

                 (if membership-info 

                     ;; then it is repeated, so let's add it
                     ;; to the repeated ones
                     ;; but before we need to know if it was already
                     ;; added to the repeated ones
                     (progn
                       (setf repeated-info
                             (first (member current-neighbor
                                            smart-repeated-neighbors
                                            :test (lambda (x y)
                                                    (obj= x (first y))))))
                       ;; if repeated-info is non nil, the it has all the
                       ;; info we need about the repeated-neighbor.
                       ;; AND we need to remove it from the
                       ;; smart-repeated-neighbors
                       (if repeated-info
                           (then
                             (setf smart-repeated-neighbors
                                   (remove current-neighbor
                                           smart-repeated-neighbors
                                           :test (lambda (x y)
                                                   (obj= x (first y))))))
                           (else
                             ;; let's set it to an appropriate value
                             ;; in this case, to membership-info
                             (setf repeated-info
                                   membership-info)))

                       ;; now we should add the current-neighbor to
                       ;; the list of repeated-neighbors.
                       (push (append
                              repeated-info
                              (list info-to-print))
                             smart-repeated-neighbors))
                     ;; else
                     (push current-neighbor smart-once-only-neigbors))

                 ;; in any case
                 (push (list current-neighbor
                             info-to-print)
                       smart-neighborhood)))
              ;; here we append everything in a single
              ;; block of code
              (code-to-use-in-the-smart-version
               (append
                initial-code-for-the-smart-version
                rest-of-the-code-to-store))
              ;; here we add the code for the smart
              ;; version with the headings included
              (code-with-headings-for-smart-version
               (append (car (last smart-criterion))
                       code-to-use-in-the-smart-version))
              ;; and this is the code we use to print
              ;; the info we want
              (code-to-print-the-info
               (if criterion
                   `((progn
                       (format t "neighborhood size:        ~a~%"
                               (length all-neighborhood))
                       (format t "repeated elements:        ~a~%"
                               (length repeated-neighbors))
                       (format t "once-only elements:       ~a~%"
                               (length once-only-neigbors))))))
              ;; here I'll add the code to print info
              ;; about the repeated elements in the
              ;; smart version
              ;; first, a way to deal with several formats
              ;; to print the info
              (what-to-print-in-the-repeated
               (cond
                 ((eql print-smart-repeated 'all)
                  `(" ~a~%~{   ~a~%~}~%"
                    (first repeated)
                    (rest repeated)))
                 (t `(" ~a~%"
                      (first repeated)))))
              ;; and here is the actual code to print
              (code-to-print-the-smart-repeated-neighbors
               `((if (and ',print-smart-repeated
                          (> (length smart-repeated-neighbors) 0))
                     (progn
                       (format t "Repeated elements (~a):~%"
                               (length smart-repeated-neighbors))
                       (loop for repeated in smart-repeated-neighbors
                             do (format t ,(first what-to-print-in-the-repeated)
                                        ,@(rest what-to-print-in-the-repeated)
                                        ))
                       ))))
              ;; Now I'll add the code to print the intersection
              ;; of the criterion and the smart version
              (what-to-print-in-the-intersection
               (cond
                 ((eql print-intersection 'all)
                  `(" ~a~%~{   ~a~%~}~%"
                    (first repeated)
                    (rest repeated)))
                 (t `(" ~a~%"
                      (first repeated)))))
              ;; and here is the actual code to print
              ;; the intersection
              (code-to-print-the-intersection
               `((if (and ',print-intersection
                          ',smart-criterion
                          ',criterion)
                     (setf intersection
                           (intersection all-neighborhood
                                         smart-neighborhood
                                         :test (lambda (x y)
                                                 (obj= x (first y)))
                                         )))
                 (if (and ',print-intersection
                          (> (length intersection) 0))
                     (progn
                       (format t "Elements in the intersection: ~a~%"
                               (length smart-repeated-neighbors))
                       (loop for repeated in smart-repeated-neighbors
                             do (format t ,(first what-to-print-in-the-intersection)
                                        ,@(rest what-to-print-in-the-intersection)
                                        ))
                       )
                     ;; else
                     (if ',print-intersection
                         (format t "Intersection is empty.~%")))))
              ;; here we'll write the code for the difference
              ;; the difference will always be
              ;; original minus smart
              (what-to-print-in-the-difference
               (cond
                 ((eql print-difference 'all)
                  `(" ~a~%"
                    d))
                 (t `(" ~a~%"
                      d))))
              ;; and here is the code to actually print
              ;; the difference
              (code-to-print-the-difference
               `((if (and ',print-difference
                          ',smart-criterion
                          ',criterion)
                     (setf difference
                           (set-difference once-only-neigbors
                                           (mapcar (lambda (x)
                                                     (first x))
                                                   smart-neighborhood)
                                           :test #'obj=
                                           )))
                 (if (and ',print-difference
                          (> (length difference) 0))
                     (progn
                       (format t "Missing elements: ~a~%"
                               (length difference))
                       (loop for d in difference
                             do (format t ,(first what-to-print-in-the-difference)
                                        ,@(rest what-to-print-in-the-difference)
                                        ))
                       )
                     ;; else
                     (if ',print-difference
                         (format t "There are not missing elements.~%")))))

              )


         ;; let's build the code with what to do
         ;; inside the criterion
         (loop for h in (reverse (butlast criterion))
               doing (setf code-with-headings-for-criterion
                           (append h (list code-with-headings-for-criterion))))

         ;; if we have a smart version, let's build the code
         (loop for h in (reverse (butlast smart-criterion))
               do (setf code-with-headings-for-smart-version
                        (append h (list code-with-headings-for-smart-version))))

         ;; let's write the code to print the info
         (setf code-to-print-the-info
               (append code-to-print-the-info
                       (if smart-criterion
                           `((progn
                               (format t "smart neighborhood size:  ~a~%"
                                       (length smart-neighborhood))
                               (format t "smart repeated elements:  ~a~%"
                                       (length smart-repeated-neighbors))
                               (format t "smart once-only elements: ~a~%"
                                       (length smart-once-only-neigbors))
                               )))))



        `(with-basic-solution (s1 ,solution)

           (bformat t "Exploring neighborhood ~a"
                    ,name-for-bformat)

           ;; (format t "code-to-use-in-the-smart-version: ~a~%"
           ;;         ',code-to-use-in-the-smart-version)

           ;; (format t "inner code for the smart version: ~a~%"
           ;;         ',inner-code-for-the-smart-version)

           (let* ((wc (basic-working-copy s1))
                  (ops-list nil)
                  (current-neighbor nil)
                  (all-neighborhood nil)
                  (repeated-neighbors nil)
                  (once-only-neigbors nil)
                  (smart-neighborhood nil)
                  (smart-repeated-neighbors nil)
                  (smart-once-only-neigbors nil)
                  (repeated-info nil)
                  (intersection nil)
                  (difference nil)
                  (membership-info nil)
                  (info-to-print nil)
                  )

             (prepare-solution-for-neighborhood-exploration wc)

             ;; here we execute the criterion with the code

             ,code-with-headings-for-criterion

             ;; now let's test the "smart" version
             ,code-with-headings-for-smart-version

             ,@code-to-print-the-info

             ,@code-to-print-the-smart-repeated-neighbors

             ,@code-to-print-the-intersection

             ,@code-to-print-the-difference

             ;; (format t "all neighborhood:~%~{ ~a~%~}~%" all-neighborhood)
             ;; (format t "~a~%" smart-neighborhood)


             ;; (format t "full neighborhood:~%~{~a~%~}~%"
             ;;         (reverse all-neighborhood)
             ;;         ;; (reverse (mapcar 'first smart-neighborhood))
             ;;         )


             ;; (format t "smart neighborhood:~%~{~a~%~}~%"
             ;;         (reverse smart-neighborhood)
             ;;         ;; (reverse (mapcar 'first smart-neighborhood))
             ;;         )
             ))))
     #+END_SRC
    
**** tests for v1
***** testing rarac
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (explore-neighborhood-criteria ((doselect-client (c1 1 wc))
                                       (doselect-client (c2 1 wc))
                                       (doswap-clients (c1 c2 wc))) 
                                      :name-for-bformat 'rarac
                                      :smart-criterion
                                      ((doselect-client (c1 1 wc))
                                       (doselect-client (c2 1 wc
                                                            :ge c1.select.position))
                                       (doswap-clients (c1 c2 wc)))
                                      :smart-version-info 
                                      ((client-selected-at-operation c1 wc)
                                      (client-selected-at-operation c2 wc)
                                       (route-length 1 wc))
                                      )
      #+END_SRC
***** testing rereg
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (explore-neighborhood-criteria ((doselect-subroute (c1 1 wc))
                                       (doselect-subroute (c2 1 wc))
                                       (doswap-subroutes (c1 c2 wc))) 
                                      :name-for-bformat 'rereg
                                      :smart-criterion
                                      ((doselect-subroute (c1 1 wc))
                                       (doselect-subroute (c2 1 wc
                                                              :ge c1.select.position
                                                   
                                                              ))
                                       (doswap-subroutes (c1 c2 wc)))
                                      :smart-version-info 
                                      ((subroute-selected-at-operation c1 wc)
                                       (subroute-selected-at-operation c2 wc))
                                      :solution ((1 2 3 4))
                                      :print-smart-repeated nil
                                      :print-intersection nil
                                      :print-difference t
                                      )
      #+END_SRC

***** testing ref
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (explore-neighborhood-criteria ((doselect-subroute (c1 1 wc))
                                      (doinsert-subroute (c1 1 wc))) 
                                     :name-for-bformat 'rereg
                                     :smart-criterion
                                     ((doselect-subroute
                                          (c1 1 wc))
                                      (doinsert-subroute
                                          (c1 1 wc :gt c1.select.coord)))
                                     :smart-version-info 
                                     ((subroute-selected-at-operation c1 wc))
                                     :solution ((1 2 3 4 5 6))
                                     :print-smart-repeated all
                                     :print-intersection nil
                                     :print-difference t
                                     )
      #+END_SRC
** rab (move client inside its route)
*** rab (classical)
**** description
     This is the classical move inside its route.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion
      rab
      ((select-route r1)
       (select-client c1 from r1)
       (insert-client c1 into r1)))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4)))

       (format t "original solution:~%")
       (pp-solution s1 t) (terpri)

       (funcall (make-neighborhood-criterion
                 rab
                 +exhaustive-search-strategy+
                 +search-with-a-basic-wc+
                 :inside-macro `((progn
                                   (format t "insertion route: ~a~%"
                                           c1.insert.route)
                                  (pp-solution wc t)
                                  (terpri))))
                s1 t t))
     #+END_SRC
*** rabs (smart)
**** description
     This is the classical move inside its route.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rabs ((select-route r1)
                                    (select-client c1 from r1)
                                    (insert-client c1 into r1
                                      :ex (list
                                           (list r1 c1.select.position)
                                           (list r1 (1- c1.select.position)))
                                      )))
     #+END_SRC
**** tests
***** testing rabs with the macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (bformat t "Testing rehregs")
      (explore-neighborhood-criteria-v2
       ((doselect-route (r1 wc))
        (doselect-client (c1 r1 wc))
        (doinsert-client (c1 r1 wc)))
       :smart-criterion
       ((doselect-route (r1 wc))
        (doselect-client (c1 r1 wc))
        (doinsert-client (c1 r1 wc
           :ex (list
                (list r1 c1.position)
                (list r1 (1- c1.position))))))

       :name-for-bformat 'rabs
       :smart-version-info
       ((client-selected-at-operation c1 wc)
        c1.ins.pos)
       :solution ((1 2 3 4 5 6 7 8 9))
       :print-difference t
       :print-intersection nil
       :show-intersection nil
       :print-neighborhood nil
       :print-smart-neighborhood nil
       :print-smart-repeated all
       )
      #+END_SRC
    
*** rabs* (smart*) (Move client inside its route)
**** description
     This is the classical move inside its route.  The smart* version of the criteria should avoid the neighbors that were already visited by another criterion in the set of neighborhood that is being used.
     In this case, the criterion rabs* is the same as rabs, because there is nothing else to compare to.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rabs*
        ((select-route r1)
         (select-client c1 from r1)
         (insert-client c1 into r1
            :ex (list
                 (list r1 c1.select.position)
                 (list r1 (1- c1.select.position))))))
     #+END_SRC
**** tests
***** no tests because it is too basic
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Testing rabs*")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-client (c1 r1 wc))
          (doinsert-client (c1 r1 wc)))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-client (c1 r1 wc))
          (doinsert-client (c1 r1 wc
                               :ex (list
                                    (list r1 c1.position)
                                    (list r1 (1- c1.position))))))

         :name-for-bformat 'rabs
         :smart-version-info
         ((client-selected-at-operation c1 wc)
          c1.ins.pos)
         :solution ((1 2 3 4 5 6 7 8 9))
         :print-difference t
         :print-intersection nil
         :show-intersection nil
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated all
         ))
      #+END_SRC
    
** rad (create subroute from client)
*** rad (classical)
**** description
     This criterion selects a client and creates a new route with it
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rad ((select-route r1)
                                     (select-client c1 from r1)
                                     (add-route c1)))
     #+END_SRC
*** rads (smart)
**** description
     This criterion selects a client and creates a new route with it
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rads ((select-route r1)
                                     (select-client c1 from r1)
                                     (add-route c1)))
     #+END_SRC
*** rads*
**** description
     This criterion selects a client and creates a new route with it.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rads* ((select-route r1)
                                      (select-client c1 from r1)
                                      (add-route c1)))
     #+END_SRC
** rarb (move client to another route)
*** rarb
**** description
     This is the classical move client to a different route
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rarb
       ((select-route r1)
        (select-client c1 from r1)
        (select-route r2)
        (insert-client c1 into r2)))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2) (3 4)))

       (format t "Testing smart rarb with (s1 ((1 2) (3 4)))")

       (format t "original solution:~%")
       (pp-solution s1 t) (terpri)

       (let* ((ccc 0))
         (funcall (make-neighborhood-criterion
                            rarb
                            +exhaustive-search-strategy+
                            +search-with-a-basic-wc+
                            :inside-macro `((progn
                                              (format t "Neighboor #~a:~%"
                                                      ccc)
                                              (incf ccc)
                                              (pp-solution wc t)
                                              (terpri))))
                         s1 t t)))
     #+END_SRC
    
*** rarbs (smart)
**** description
     This is the classical move client to a different route
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rarbs
       ((select-route r1)
        (select-client c1 from r1)
        (select-route r2)
        (insert-client c1 into r2
         :ex (list c1.select.coord
                   (list c1.route
                         (1- c1.select.position))))))
     #+END_SRC
**** tests
***** testing rarbs with the macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Testing rarbs")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-client (c1 r1 wc))
          (doselect-route (r2 wc))
          (doinsert-client (c1 r2 wc))) 
         :name-for-bformat 'rarbs
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-client (c1 r1 wc))
          (doselect-route (r2 wc))
          (doinsert-client (c1 r2 wc
                               :ex (list c1.select.coord
                                         (list c1.route
                                               (1- c1.select.position))
                                         ))))
         :smart-version-info 
         ((client-selected-at-operation c1 wc))
         :solution ((1 2 3) (4 5 6) (7 8 9 10 11))
         :print-smart-repeated all
         :print-intersection nil
         :print-difference t
         ))
      #+END_SRC
***** without macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2) (3 4)))

        (format t "Testing smart rarb with (s1 ((1 2) (3 4)))")

        (format t "original solution:~%")
        (pp-solution s1 t) (terpri)

        (let* ((ccc 0))
          (funcall (make-neighborhood-criterion
                             rarbs
                             +exhaustive-search-strategy+
                             +search-with-a-basic-wc+
                             :inside-macro `((progn
                                               (format t "Neighboor #~a:~%"
                                                       ccc)
                                               (incf ccc)
                                               (pp-solution wc t)
                                               (terpri))))
                          s1 t t)))
      #+END_SRC

*** rarbs*
**** description
     This is the classical move client to a different route.  As we are using it together with rab, we won't allow to move the selected client to the same route where it was selected from.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rarbs*
       ((select-route r1)
        (select-client c1 from r1)
        (select-route r2 :dt r1)
        ;; we don't need to add any constraint
        ;; to the insertion of the client
        ;; because the only constraints were
        ;; in the same route as in the selection
        ;; but that case is excluded now
        (insert-client c1 into r2)))
     #+END_SRC
**** tests
***** comparing rarbs* with rabs*
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rarbs* with rabs*")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-client (c1 r1 wc))
          (doinsert-client (c1 r1 wc
             :ex (list
                  (list r1 c1.position)
                  (list r1 (1- c1.position)))))) 
         :name-for-bformat 'rarbs*
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-client (c1 r1 wc))
          (doselect-route (r2 wc :dt r1))
          (doinsert-client (c1 r2 wc)))
         :smart-version-info 
         ((client-selected-at-operation c1 wc))
         :solution ((1 2 3) (4 5 6))
         :print-smart-repeated nil
         :print-intersection t
         :show-intersection t
         :print-difference nil
         ))
      #+END_SRC

***** comparing rarbs* with itself*
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rarbs* with rabs*")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-client (c1 r1 wc))
          (doselect-route (r2 wc))
          (doinsert-client (c1 r2 wc
             :ex (list c1.select.coord
                       (list c1.route
                             (1- c1.select.position))))))
         :name-for-bformat 'rarbs*
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-client (c1 r1 wc))
          (doselect-route (r2 wc :dt r1))
          ;; we don't need to add any constraint
          ;; to the insertion of the client
          ;; because the only constraints were
          ;; in the same route as in the selection
          ;; but that case is excluded now
          (doinsert-client (c1 r2 wc)))
         :smart-version-info 
         ((client-selected-at-operation c1 wc))
         :solution ((1 2 3) (4 5 6))
         :print-smart-repeated nil
         :print-intersection nil
         :show-intersection nil
         :print-difference t
         ))
      #+END_SRC

** rarac (swap clients)
*** rarac (classical)
**** description
     This is the classical swap clients
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rarac ((select-route r1)
                                      (select-client c1 from r1)
                                      (select-route r2)
                                      (select-client c2 from r2)
                                      (swap-clients c1 c2)))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4)))

       (format t "original solution:~%")
       (pp-solution s1 t) (terpri)

       (funcall (make-neighborhood-criterion
                 rarac
                 +exhaustive-search-strategy+
                 +search-with-a-basic-wc+
                 :inside-macro `((progn
                                  (pp-solution wc t)
                                  (terpri))))
                s1 t t))
     #+END_SRC
    
*** raracs (smart)
**** description
     This is the classical swap clients
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion raracs ((select-route r1)
                                      (select-client c1 from r1)
                                      (select-route r2 :ge r1)
                                      (select-client
                                       c2 from r2
                                       :ge (list r1 c1.select.position))
                                      (swap-clients c1 c2)))
     #+END_SRC
**** tests
***** testing rarac with the macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (bformat t "Testing rehregs")
      (explore-neighborhood-criteria-v2
       ((doselect-route (r1 wc))
        (doselect-client (c1 r1 wc))
        (doselect-route (r2 wc))
        (doselect-client (c2 r2 wc))
        (doswap-clients (c1 c2 wc)))
       :smart-criterion
       ((doselect-route (r1 wc))
        (doselect-client (c1 r1 wc))
        (doselect-route (r2 wc :ge r1))
        (doselect-client (c2 r2 wc
           :ge (list r1 c1.select.position)))
        (doswap-clients (c1 c2 wc)))

       :name-for-bformat 'rarac
       :smart-version-info
       ((client-selected-at-operation c1 wc)
        (client-selected-at-operation c2 wc))
       :solution ((1 2 3 4 5) (6 7 8 9 10))
       :print-difference t
       :print-intersection nil
       :show-intersection nil
       :print-neighborhood nil
       :print-smart-neighborhood nil
       :print-smart-repeated all
       )
      #+END_SRC
    
***** basic test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3 4)))

        (format t "original solution:~%")
        (pp-solution s1 t) (terpri)

        (funcall (make-neighborhood-criterion
                  rarac
                  +exhaustive-search-strategy+
                  +search-with-a-basic-wc+
                  :inside-macro `((progn
                                   (pp-solution wc t)
                                   (terpri))))
                 s1 t t))
      #+END_SRC
    
*** raracs*
**** description
     This is the classical swap clients.  In the smart* version we avoid the elements that were already explored by another criterion.  As in rabs*, In the smart* version of this criteria we exclude swapping two consecutive elements because that happens in rab :-o
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion raracs*
        ((select-route r1)
         (select-client c1 from r1)
         (select-route r2 :ge r1)
         (select-client c2 from r2
           ;; avoid the insertion in the same coord
           ;; where c1 was selected from
           ;; because this also happens in rab
           ;; and as we need to avoid insertions
           ;; before c1.coord, we can translate it
           ;; into:
           :gt c1.select.coord)
         (swap-clients c1 c2)))
     #+END_SRC
**** tests
***** comparing rarac with rab
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing raracs* with rarbs*")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-client (c1 r1 wc))
          (doselect-route (r2 wc :dt r1))
          (doinsert-client (c1 r2 wc)))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-client (c1 r1 wc))
          (doselect-route (r2 wc :ge r1))
          (doselect-client (c2 r2 wc
             ;; avoid the insertion in the same coord
             ;; where c1 was selected from
             ;; because this also happens in rab
             ;; and as we need to avoid insertions
             ;; before c1.coord, we can translate it
             ;; into
             :gt c1.select.coord))
          (doswap-clients (c1 c2 wc)))

         :name-for-bformat 'rerehg
         :smart-version-info
         ((client-selected-at-operation c1 wc)
          (client-selected-at-operation c2 wc))
         :solution ((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15) (16 17 18))
         :print-difference nil
         :print-intersection nil
         :show-intersection t
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated nil
         ))
      #+END_SRC
    
** ref (move subroute inside its route)
*** ref
**** description
     This criterion means to move a subroute inside its route.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion ref ((select-route r1)
                                    (select-subroute z1 from r1)
                                    (insert-subroute z1 into r1)))
     #+END_SRC
    
*** refs (smart)
**** description
     This criterion means to move a subroute inside its route.  To make it a smart criterion we should not insert the subroute in the same position where it was selected from.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion refs
       ((select-route r1)
        (select-subroute z1 from r1)
        (insert-subroute z1 into r1
          ;; insert beyond the selection coord
          :gt z1.select.coord)))
     #+END_SRC
    
**** tests
***** testing refs with the macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn

        (bformat t "Testing refs")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doinsert-subroute (c1 r1 wc))) 
         :name-for-bformat 'rerf
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doinsert-subroute (c1 r1 wc
                                 :gt c1.select.coord)))
         :smart-version-info 
         ((subroute-selected-at-operation c1 wc))
         :solution ((1 2 3 4) (5 6) (7 8 9 10))
         :print-smart-repeated all
         :print-intersection nil
         :print-difference t
         ))
      #+END_SRC

***** basic test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3 4)))

        (bformat t "Testing ref (smart)")
        (format t "original solution:~%")
        (pp-solution s1 t) (terpri)

        (funcall (make-neighborhood-criterion
                  refs
                  +exhaustive-search-strategy+
                  +search-with-a-basic-wc+
                  :inside-macro `((progn
                                    (format t "Selected length ~a from ~a. Inserted at ~a~%"
                                            z1.subroute.length
                                            z1.select.coord
                                            z1.insert.coord)
                                    (pp-solution wc t)
                                    (terpri))))
                 s1 t t))
      #+END_SRC

*** refs*
**** description
     This criterion means to move a subroute inside its route.  To make it a smart criterion we should not insert the subroute in the same position where it was selected from.  In the smart* version we forbid the subroute with length 1, because this is the same as in rab.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion refs*
       ((select-route r1)
        (select-subroute z1 from r1
          ;; avoid collisions with rabs*
          :ldt 1)
        (insert-subroute z1 into r1
          ;; insert beyond the selection coord
          :gt z1.select.coord
          ;; don't insert right after the
          ;; select coord
          ;; because this is equivalent to select
          ;; the client at that position and
          ;; insert it right before the subroute
          :dt (list r1 (1+ z1.position)))))
     #+END_SRC
    
**** tests
***** comparing refs* with rabs*
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing refs* with rabs*")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-client (c1 r1 wc))
          (doinsert-client (c1 r1 wc
             :ex (list
                  (list r1 c1.position)
                  (list r1 (1- c1.position)))))) 
         :name-for-bformat 'rerfs*
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc :ldt 1))
          (doinsert-subroute (c1 r1 wc
             ;; do not insert where you selected it from
             :gt c1.select.coord
             ;; do not insert 1+ where you selected it
             ;; because this is equivalent to rab
             ;; the client at that position to before
             ;; the subroute
             :dt (list r1
                       (1+ c1.position))
                                 )))
         :smart-version-info 
         ((subroute-selected-at-operation c1 wc))
         :solution ((1 2 3 4 5))
         :print-smart-repeated nil
         :print-difference nil
         :print-intersection t
         :show-intersection t
         :print-intersection nil
         :print-smart-neighborhood nil
         :print-neighborhood nil
         ))
      #+END_SRC

***** comparing refs* with itself*
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing refs* with rabs*")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc :ldt 1))
          (doinsert-subroute (c1 r1 wc
             ;; do not insert where you selected it from
             :gt c1.select.coord
             ;; do not insert 1+ where you selected it
             ;; :dt (list r1
             ;;           (1+ c1.position))
                                 ))) 
         :name-for-bformat 'rerfs*
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc :ldt 1))
          (doinsert-subroute (c1 r1 wc
             ;; do not insert where you selected it from
             :gt c1.select.coord
             ;; do not insert 1+ where you selected it
             ;; because this is equivalent to a rarac
             :dt (list r1
                       (1+ c1.position))
                                 )))
         :smart-version-info 
         ((subroute-selected-at-operation c1 wc))
         :solution ((1 2 3 4 5))
         :print-smart-repeated nil
         :print-difference t
         :print-intersection nil
         :show-intersection nil
         :print-intersection nil
         :print-smart-neighborhood nil
         :print-neighborhood nil
         ))
      #+END_SRC

** rerf (move subroute to another route)
*** rerf
**** description
     This is the classical move subroute to a different route
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rerf ((select-route r1)
                                     (select-subroute c1 from r1)
                                     (select-route r2)
                                     (insert-subroute c1 into r2)))
     #+END_SRC
**** tests
***** testing rerfs
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (bformat t "Testing rerfs")
      (explore-neighborhood-criteria-v2
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc))
        (doselect-route (r2 wc))
        (doinsert-subroute (c1 r2 wc)))
       :smart-criterion
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc))
        (doselect-route (r2 wc))
        (doinsert-subroute (c1 r2 wc
           :gt c1.select.coord)))
       :name-for-bformat 'rerfs
       :smart-version-info
       ((subroute-selected-at-operation c1 wc))
       :solution ((1 2 3 4 5) (6 7 8))
       :print-difference t
       :print-intersection nil
       :show-intersection t
       :print-smart-neighborhood nil
       :print-neighborhood nil
       :print-smart-repeated all
       )
      #+END_SRC
***** original test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-solution (s1 ((1 2 3 4)))
       (bformat t "Testing rerf")
       (format t "original solution:~%")
       (pp-solution s1 t) (terpri)

       (funcall (make-neighborhood-criterion
                 ref
                 +exhaustive-search-strategy+
                 +search-with-a-basic-wc+
                 :inside-macro `((progn
                                   (format t "length: ~a. select pos: ~a
     insert pos: ~a.~%"
                                           z1.length
                                           z1.select.position
                                           z1.insert.position)
                                   (pp-solution wc t)
                                   (terpri))))
                s1 t t))
     #+END_SRC

*** rerfs (smart)
**** description
     This is the classical move subroute to a different route. In the smart version we have the same constraint as in ref.  We just need to avoid inserting in the same place where it was selected from.  This is wrong.  We need to add more constraints.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rerfs ((select-route r1)
                                      (select-subroute z1 from r1)
                                      (select-route r2)
                                      (insert-subroute z1 into r2
                                         :ex-cond (and
                                                   (= r1 r2)
                                                   (<= z1.ins.pos
                                                       z1.position)))))
     #+END_SRC
    
**** tests
***** testing rerfs with the macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Testing rerfs")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doselect-route (r2 wc))
          (doinsert-subroute (c1 r2 wc)))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doselect-route (r2 wc))
          (doinsert-subroute (c1 r2 wc
                                 ;; ;; this is wrong :gt c1.select.coord
                                 :ex-cond (and
                                           (= r1 r2)
                                           (<= c1.ins.pos c1.position))
                                 )))
         :name-for-bformat 'rerfs
         :smart-version-info
         ((subroute-selected-at-operation c1 wc))
         :solution ((1 2 3) (4 5 6) (7 8 9 10))
         :print-difference t
         :print-intersection nil
         :show-intersection t
         :print-smart-neighborhood nil
         :print-neighborhood nil
         :print-smart-repeated all
         ))
      #+END_SRC
***** basic-test    
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (with-basic-solution (s1 ((1 2 3 4) (5 6 7)))

        (bformat t "Testing rerf")
        (format t "original solution:~%")
        (pp-solution s1 t) (terpri)

        (funcall (make-neighborhood-criterion
                  rerfs
                  +exhaustive-search-strategy+
                  +search-with-a-basic-wc+
                  :inside-macro `((progn
                                    (format t "select pos: ~a
      insert pos: ~a.~%"
                                            z1.select.position
                                            z1.insert.position)
                                    (pp-solution wc t)
                                    (terpri))))
                 s1 t t))
     #+END_SRC
*** rerfs*
**** description
     This is the classical move subroute to a different route.

     In the smart* version we forbid moving to the selection's route.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rerfs* 
       ((select-route r1)
        (select-subroute c1 from r1
           ;; avoid collisions with rarbs*
           :ldt 1)
        (select-route r2
          ;; avoid collisions with rerfs
          :dt r1)
        (insert-subroute c1 into r2
           ;; avoid collisions with itself
           :ex-cond (and
                     (= r1 r2)
                     (<= c1.ins.pos c1.position)))))
     #+END_SRC
    
**** tests
***** comparing rerfs* with rarbs*
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rerfs* with rarbs*")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-client (c1 r1 wc))
          (doselect-route (r2 wc :dt r1))
          (doinsert-client (c1 r2 wc)))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc
             :ldt 1))
          (doselect-route (r2 wc :dt r1
                              ))
          (doinsert-subroute (c1 r2 wc
                                 :ex-cond (and
                                           (= r1 r2)
                                           (<= c1.ins.pos c1.position))
                                 )))
         :name-for-bformat 'rerfs
         :smart-version-info
         ((subroute-selected-at-operation c1 wc))
         :solution ((1 2 3 4) (5 6 7 8) (9 10 11 12))
         :print-difference nil
         :print-intersection nil
         :show-intersection t
         :print-smart-neighborhood nil
         :print-neighborhood nil
         :print-smart-repeated nil
         ))
      #+END_SRC
***** comparing rerfs* with refs*
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rerfs* with refs*")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc :ldt 1))
          (doinsert-subroute (c1 r1 wc
                                 :gt c1.select.coord
                                 :dt (list r1
                                           (1+ c1.position)))))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc
             ;; avoid collisions with rarbs*
             :ldt 1))
          (doselect-route (r2 wc
                              ;; avoid collisions with
                              ;; rerfs
                              :dt r1))
          (doinsert-subroute (c1 r2 wc
                                 :ex-cond (and
                                           (= r1 r2)
                                           (<= c1.ins.pos c1.position))
                                 )))
         :name-for-bformat 'rerfs
         :smart-version-info
         ((subroute-selected-at-operation c1 wc))
         :solution ((1 2 3 4 5 6 7 8) (9 10 11 12))
         :print-difference nil
         :print-intersection nil
         :show-intersection t
         :print-smart-neighborhood nil
         :print-neighborhood nil
         :print-smart-repeated nil
         ))
      #+END_SRC
** rereg (swap subroutes)
*** rereg
**** description
     This is the classical swap subroutes
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rereg ((select-route r1)
                                      (select-subroute c1 from r1)
                                      (select-route r2)
                                      (select-subroute c2 from r2)
                                      (swap-subroutes c1 c2)))
     #+END_SRC
*** reregs (smart)
**** description
     This is the classical swap subroutes.  To make it smart we can not let z2.select.pos be greater or equal to z1.select.pos.  I think that it should be enough.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion reregs ((select-route r1)
                                       (select-subroute z1 from r1)
                                       (select-route r2)
                                       (select-subroute z2 from r2
                                          :ge z1.select.coord)
                                       (swap-subroutes z1 z2)))
     #+END_SRC
**** tests
***** testing reregs with the macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (bformat t "Testing reregs")
      (explore-neighborhood-criteria-v2
       ((doselect-route (r1 wc))
        (doselect-subroute (z1 r1 wc))
        (doselect-route (r2 wc))
        (doselect-subroute (z2 r2 wc))
        (doswap-subroutes (z1 z2 wc)))
       :smart-criterion
       ((doselect-route (r1 wc))
        (doselect-subroute (z1 r1 wc))
        (doselect-route (r2 wc :ge r1))
        (doselect-subroute (z2 r2 wc
           :ge z1.select.coord))
        (doswap-subroutes (z1 z2 wc)))
       :name-for-bformat 'rerfs
       :smart-version-info
       ((subroute-selected-at-operation z1 wc)
        (subroute-selected-at-operation z2 wc))
       :solution ((1 2 3 4) (5 6 7 8 9) (10 11 12 13))
       :print-difference t
       :print-intersection nil
       :show-intersection t
       :print-smart-neighborhood nil
       :print-neighborhood nil
       :print-smart-repeated nil
       )
      #+END_SRC
***** handmade reregs v3 (with Iosvanny)
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17)))

          (bformat t "Exploring handmade reregs 17")
          ;; (format t "original solution:~%")
          ;; (pp-solution s1 t) (terpri)
          ;; (format t "==================~%")

          (let* ((wc (basic-working-copy s1))
                 (ops-list nil)
                 (current-neighbor nil)
                 (all-neighborhood nil)
                 (repeated-neighbors nil)
                 (once-only-neigbors nil)
                 (smart-neighborhood nil)
                 (smart-repeated-neighbors nil)
                 (smart-once-only-neigbors nil)
                 (repeated-info nil)
                 (membership-info nil)
                 (info-to-print nil)
                 )

            (prepare-solution-for-neighborhood-exploration wc)

            (doselect-subroute (z1 1 wc)
              (doselect-subroute (z2 1 wc
                                     ;; :lex-cond (= z1.length z2.length 1)
                                     )
                (doswap-subroutes (z1 z2 wc)
                  (setf current-neighbor
                        (loop for i from 1 to (route-length 1 wc)
                              collecting (id (client-at (list 1 i) wc))))

                  ;; let's see how many repeated are there
                  (if (member current-neighbor all-neighborhood
                              :test 'obj=)
                      ;; then
                      (pushnew current-neighbor repeated-neighbors
                               :test 'obj=)
                      ;; else
                      (push current-neighbor once-only-neigbors))

                  (push current-neighbor all-neighborhood)
                  ;; (pp-solution wc t)
                  ;; (terpri)
                  )))


            ;; now let's test the "smart" version
            (doselect-subroute (z1 1 wc)
              (doselect-subroute (z2 1 wc
                                     ;; :lex-cond (= z1.length z2.length 1)
                                     :ge (list z1.select.route
                                               z1.select.position))
                (doswap-subroutes (z1 z2 wc)

                  (setf current-neighbor
                        (loop for i from 1 to (route-length 1 wc)
                              collecting (id (client-at (list 1 i) wc))))

                  ;; let's get the info from this neighbor
                  (setf info-to-print
                        (format nil "[~a | ~a]"
                                (subroute-selected-at-operation z1 wc)
                                (subroute-selected-at-operation z2 wc)))

                  ;; let's see if the current neighbor has already
                  ;; been visited
                  (setf membership-info
                        (first (member current-neighbor smart-neighborhood
                                       :test (lambda (x y) (obj= x (first y))))))

                  ;; now in membership-info we have a list
                  ;; where the 1st element is the neighbor and the
                  ;; 2nd is the "coords" from the moment it was added
                  ;; if it is nil, the neighbor is new.

                  (if membership-info 

                      ;; then it is repeated, so let's add it
                      ;; to the repeated ones
                      ;; but before we need to know if it was already
                      ;; added to the repeated ones
                      (progn
                        (setf repeated-info
                              (first (member current-neighbor
                                             smart-repeated-neighbors
                                             :test (lambda (x y)
                                                     (obj= x (first y))))))
                        ;; if repeated-info is non nil, the it has all the
                        ;; info we need about the repeated-neighbor.
                        ;; AND we need to remove it from the
                        ;; smart-repeated-neighbors
                        (if repeated-info
                            (then
                              (setf smart-repeated-neighbors
                                    (remove current-neighbor
                                            smart-repeated-neighbors
                                            :test (lambda (x y)
                                                    (obj= x (first y))))))
                            (else
                              ;; let's set it to an appropriate value
                              ;; in this case, to membership-info
                              (setf repeated-info
                                    membership-info)))

                        ;; now we should add the current-neighbor to
                        ;; the list of repeated-neighbors.
                        (push (append
                                  repeated-info
                                  (list info-to-print))
                                 smart-repeated-neighbors))
                      ;; else
                      (push current-neighbor smart-once-only-neigbors))

                  ;; in any case
                  (push (list current-neighbor
                              info-to-print)
                        smart-neighborhood)

                  ;; (pp-solution wc t)
                  ;; (terpri)
                  )))


            (format t "neighborhood size:        ~a~%"
                    (length all-neighborhood))
            (format t "repeated elements:        ~a~%"
                    (length repeated-neighbors))
            (format t "once-only elements:       ~a~%"
                    (length once-only-neigbors))

            (format t "smart neighborhood size:  ~a~%"
                    (length smart-neighborhood))
            (format t "smart repeated elements:  ~a~%"
                    (length smart-repeated-neighbors))
            (format t "smart once-only elements: ~a~%"
                    (length smart-once-only-neigbors))

            ;; (format t "Missing elements:~%~{~a~%~}"
            ;;         (set-difference
            ;;          once-only-neigbors
            ;;          smart-once-only-neigbors
            ;;          :test #'obj=)
            ;;         ;; (set-difference (mapcar 'first once-only-neigbors)
            ;;         ;;                 (mapcar 'first smart-once-only-neigbors)
            ;;         ;;                 :test #'obj=)
            ;;         )

            ;; (format t "~a repeated elements:~%"
            ;;         (length smart-repeated-neighbors))

            ;; (let* ((len (length (clients (first (routes s1))))))
            ;;   (loop for repeated in smart-repeated-neighbors
            ;;         do (format t "(1")
            ;;         do (loop for i from 2 to len
            ;;                  do (format t " ~a" i))
            ;;         doing (format t ") -> ~a ~%~{  ~a~%~}~%"
            ;;                       (first repeated)
            ;;                       (rest repeated))))

            ;; (format t "intersection: ~a~%"
            ;;         (intersection (mapcar 'first smart-neighborhood)
            ;;                       all-neighborhood
            ;;                       :test 'obj=))

            ;; (format t "full neighborhood:~%~{~a~%~}~%"
            ;;         (reverse all-neighborhood)
            ;;         ;; (reverse (mapcar 'first smart-neighborhood))
            ;;         )


            ;; (format t "smart neighborhood:~%~{~a~%~}~%"
            ;;         (reverse smart-neighborhood)
            ;;         ;; (reverse (mapcar 'first smart-neighborhood))
            ;;         )
            ))
      #+END_SRC
***** handmade reregs v2
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3 4 5 6)))

          (bformat t "Exploring handmade reregs")
          ;; (format t "original solution:~%")
          ;; (pp-solution s1 t) (terpri)
          ;; (format t "==================~%")

          (let* ((wc (basic-working-copy s1))
                 (ops-list nil)
                 (current-neighbor nil)
                 (all-neighborhood nil)
                 (repeated-neighbors nil)
                 (once-only-neigbors nil)
                 (smart-neighborhood nil)
                 (smart-repeated-neighbors nil)
                 (smart-once-only-neigbors nil)
                 (repeated-info nil)
                 (membership-info nil)
                 (info-to-print nil)
                 )

            (prepare-solution-for-neighborhood-exploration wc)

            (doselect-subroute (z1 1 wc)
              (doselect-subroute (z2 1 wc
                                     :lex-cond (= z1.length z2.length 1))
                (doswap-subroutes (z1 z2 wc)
                  (setf current-neighbor
                        (loop for i from 1 to (route-length 1 wc)
                              collecting (id (client-at (list 1 i) wc))))

                  ;; let's see how many repeated are there
                  (if (member current-neighbor all-neighborhood
                              :test 'obj=)
                      ;; then
                      (pushnew current-neighbor repeated-neighbors
                               :test 'obj=)
                      ;; else
                      (push current-neighbor once-only-neigbors))

                  (push current-neighbor all-neighborhood)
                  ;; (pp-solution wc t)
                  ;; (terpri)
                  )))


            ;; now let's test the "smart" version
            (doselect-subroute (z1 1 wc
                                   :ge 2)
              (doselect-subroute (z2 1 wc
                                     :lex-cond (= z1.length z2.length 1)
                                     :le (list z1.select.route
                                               (+ 1 (- z1.select.position
                                                       z2.subroute.length))))
                (doswap-subroutes (z1 z2 wc)

                  (setf current-neighbor
                        (loop for i from 1 to (route-length 1 wc)
                              collecting (id (client-at (list 1 i) wc))))

                  ;; let's get the info from this neighbor
                  (setf info-to-print
                        (format nil "[~a | ~a]"
                                (subroute-selected-at-operation z1 wc)
                                (subroute-selected-at-operation z2 wc)))

                  ;; let's see if the current neighbor has already
                  ;; been visited
                  (setf membership-info
                        (first (member current-neighbor smart-neighborhood
                                       :test (lambda (x y) (obj= x (first y))))))

                  ;; now in membership-info we have a list
                  ;; where the 1st element is the neighbor and the
                  ;; 2nd is the "coords" from the moment it was added
                  ;; if it is nil, the neighbor is new.

                  (if membership-info 

                      ;; then it is repeated, so let's add it
                      ;; to the repeated ones
                      ;; but before we need to know if it was already
                      ;; added to the repeated ones
                      (progn
                        (setf repeated-info
                              (first (member current-neighbor
                                             smart-repeated-neighbors
                                             :test (lambda (x y)
                                                     (obj= x (first y))))))
                        ;; if repeated-info is non nil, the it has all the
                        ;; info we need about the repeated-neighbor.
                        ;; AND we need to remove it from the
                        ;; smart-repeated-neighbors
                        (if repeated-info
                            (then
                              (setf smart-repeated-neighbors
                                    (remove current-neighbor
                                            smart-repeated-neighbors
                                            :test (lambda (x y)
                                                    (obj= x (first y))))))
                            (else
                              ;; let's set it to an appropriate value
                              ;; in this case, to membership-info
                              (setf repeated-info
                                    membership-info)))

                        ;; now we should add the current-neighbor to
                        ;; the list of repeated-neighbors.
                        (push (append
                                  repeated-info
                                  (list info-to-print))
                                 smart-repeated-neighbors))
                      ;; else
                      (push current-neighbor smart-once-only-neigbors))

                  ;; in any case
                  (push (list current-neighbor
                              info-to-print)
                        smart-neighborhood)

                  ;; (pp-solution wc t)
                  ;; (terpri)
                  )))


            (format t "neighborhood size:        ~a~%"
                    (length all-neighborhood))
            (format t "repeated elements:        ~a~%"
                    (length repeated-neighbors))
            (format t "once-only elements:       ~a~%"
                    (length once-only-neigbors))

            (format t "smart neighborhood size:  ~a~%"
                    (length smart-neighborhood))
            (format t "smart repeated elements:  ~a~%"
                    (length smart-repeated-neighbors))
            (format t "smart once-only elements: ~a~%"
                    (length smart-once-only-neigbors))


            ;; (format t "intersection: ~a~%"
            ;;         (intersection (mapcar 'first smart-neighborhood)
            ;;                       all-neighborhood
            ;;                       :test 'obj=))

            ;; (format t "smart neighborhood:~%~{~a~%~}~%"
            ;;         (reverse smart-neighborhood)
            ;;         ;; (reverse (mapcar 'first smart-neighborhood))
            ;;         )

            ;; (format t "Missing elements:~%~{~a~%~}"
            ;;         (set-difference
            ;;          once-only-neigbors
            ;;          smart-once-only-neigbors
            ;;          :test #'obj=)
            ;;         ;; (set-difference (mapcar 'first once-only-neigbors)
            ;;         ;;                 (mapcar 'first smart-once-only-neigbors)
            ;;         ;;                 :test #'obj=)
            ;;         )

            (format t "~a repeated elements:~%"
                    (length smart-repeated-neighbors))

            (let* ((len (length (clients (first (routes s1))))))
              (loop for repeated in smart-repeated-neighbors
                    do (format t "(1")
                    do (loop for i from 2 to len
                             do (format t " ~a" i))
                    doing (format t ") -> ~a ~%~{  ~a~%~}~%"
                                  (first repeated)
                                  (rest repeated))))
            ))
      #+END_SRC
***** handmade reregs
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3 4 )))

          (bformat t "Exploring handmade reregs")
          ;; (format t "original solution:~%")
          ;; (pp-solution s1 t) (terpri)
          ;; (format t "==================~%")

          (let* ((wc (basic-working-copy s1))
                 (ops-list nil)
                 (current-neighbor nil)
                 (all-neighborhood nil)
                 (repeated-neighbors nil)
                 (once-only-neigbors nil)
                 (smart-neighborhood nil)
                 (smart-repeated-neighbors nil)
                 (smart-once-only-neigbors nil)
                 (repeated-info nil)
                 (membership-info nil)
                 (info-to-print nil)
                 )

            (prepare-solution-for-neighborhood-exploration wc)

            (doselect-subroute (z1 1 wc)
              (doselect-subroute (z2 1 wc
                                     :lex-cond (= z1.length z2.length 1))
                (doswap-subroutes (z1 z2 wc)
                  (setf current-neighbor
                        (loop for i from 1 to (route-length 1 wc)
                              collecting (id (client-at (list 1 i) wc))))

                  ;; let's see how many repeated are there
                  (if (member current-neighbor all-neighborhood
                              :test 'obj=)
                      ;; then
                      (pushnew current-neighbor repeated-neighbors
                               :test 'obj=)
                      ;; else
                      (push current-neighbor once-only-neigbors))

                  (push current-neighbor all-neighborhood)
                  ;; (pp-solution wc t)
                  ;; (terpri)
                  )))


            ;; now let's test the "smart" version
            (doselect-subroute (z1 1 wc)
              (doselect-subroute (z2 1 wc
                                     :lex-cond (= z1.length z2.length 1)
                                     :le (list z1.select.route
                                               (+ 1 (- z1.select.position
                                                       z2.subroute.length))))
                (doswap-subroutes (z1 z2 wc)
                  (setf current-neighbor
                        (loop for i from 1 to (route-length 1 wc)
                              collecting (id (client-at (list 1 i) wc))))

                  ;; let's see how many repeated are there
                  (setf membership-info
                        (member current-neighbor smart-neighborhood
                                :test (lambda (x y)
                                        (obj= x (first y)))))

                  (setf info-to-print (format nil "[~a | ~a]"
                                              (subroute-selected-at-operation
                                               z1 wc)
                                              (subroute-selected-at-operation
                                               z2 wc)))

                  (if membership-info ;; if it was already there
                      ;; then
                      ;; let's check if this is not
                      ;; the first time it repeats
                      (progn
                        (setf repeated-info
                              (first (member current-neighbor
                                              smart-repeated-neighbors
                                              :test (lambda (x y)
                                                      (obj= x (first y))))))
                        ;; if repeated-info is non nil
                        ;; then it was already in the list
                        ;; and we should remove it
                        (if repeated-info
                            (then
                              (remove current-neighbor smart-repeated-neighbors
                                      :test (lambda (x y)
                                              (obj= x (first y)))))
                            (else
                              ;; let's create the new repeated-info
                              (setf repeated-info
                                    (append
                                     (first membership-info)
                                     (list info-to-print)))
                              ))


                        (push (append repeated-info
                                      (list info-to-print))
                              smart-repeated-neighbors))
                      ;; else
                      (push (list current-neighbor
                                  info-to-print)
                            smart-once-only-neigbors))

                  (push (list current-neighbor
                              info-to-print)
                        smart-neighborhood)
                  ;; (pp-solution wc t)
                  ;; (terpri)
                  )))


            (format t "neighborhood size:        ~a~%"
                    (length all-neighborhood))
            (format t "repeated elements:        ~a~%"
                    (length repeated-neighbors))
            (format t "once-only elements:       ~a~%"
                    (length once-only-neigbors))

            (format t "smart neighborhood size:  ~a~%"
                    (length smart-neighborhood))
            (format t "smart repeated elements:  ~a~%"
                    (length smart-repeated-neighbors))
            (format t "smart once-only elements: ~a~%"
                    (length smart-once-only-neigbors))

            (format t "repeated elements:~%~{~a~%~}~%"
                    smart-repeated-neighbors)
            ))
      #+END_SRC
***** basic test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3 4)))

          (bformat t "Testing reregs")
          (format t "original solution:~%")
          (pp-solution s1 t) (terpri)
          (format t "==================~%")

          (funcall (make-neighborhood-criterion
                    reregs
                    +exhaustive-search-strategy+
                    +search-with-a-basic-wc+
                    :inside-macro `((progn
                                      (format t "z1: ~a, at ~a~%z2: ~a at ~a~%"
                                              (subroute-selected-at-operation
                                               z1 wc)
                                              z1.select.position
                                              (subroute-selected-at-operation
                                               z2 wc)
                                              z2.select.position)

                                      (pp-solution wc t)
                                      (terpri)
                                      )))
                   s1 t t))
      #+END_SRC
*** reregs*
**** description
     This is the classical swap subroutes.  We avoid both subroutes with length 1 because that's rarac.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion reregs* ((select-route r1)
                                        (select-subroute z1 from r1)
                                        (select-route r2 :ge r1)
                                        (select-subroute z2 from r2
                                           :lex-cond
                                           (= z1.length z2.length 1)
                                           :ge z1.select.coord)
                                        (swap-subroutes z1 z2)))
     #+END_SRC
**** tests
***** comparing rereg with raracs*
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (bformat t "Testing reregs")
      (explore-neighborhood-criteria-v2
       ((doselect-route (r1 wc))
        (doselect-client (c1 r1 wc))
        (doselect-route (r2 wc :ge r1))
        (doselect-client (c2 r2 wc
           :ge (list r1 c1.select.position)))
        (doswap-clients (c1 c2 wc)))
       :smart-criterion
       ((doselect-route (r1 wc))
        (doselect-subroute (z1 r1 wc))
        (doselect-route (r2 wc))
        (doselect-subroute (z2 r2 wc
           ;; to avoid collisions with rarac
           :lex-cond (= z1.length z2.length 1)
           ;; to avoid collisions with itself                    
           :ge (list z1.select.route
                     z1.select.position)))
        (doswap-subroutes (z1 z2 wc)))
       :name-for-bformat 'rerfs
       :smart-version-info
       ((subroute-selected-at-operation z1 wc)
        (subroute-selected-at-operation z2 wc))
       :solution ((1 2 3 4) (5 6 7 8 9))
       :print-difference nil
       :print-intersection nil
       :show-intersection t
       :print-smart-neighborhood nil
       :print-neighborhood nil
       :print-smart-repeated nil
       )
      #+END_SRC
** rehf (move reversed subroute into its route)
*** rehf
**** description
     This criterion means to move a reversed subroute inside its route.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rehf ((select-route r1)
                                     (select-subroute z1 from r1)
                                     (reverse-subroute z1)
                                     (insert-subroute z1 into r1)))
     #+END_SRC
    
*** rehfs (smart)
**** description
     This criterion means to move a reversed subroute inside its route.  In the smart version we forbid the insertion in the select.coord and in the coord just before the select coordinate.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rehfs ((select-route r1)
                                      (select-subroute z1 from r1)
                                      (reverse-subroute z1)
                                      (insert-subroute z1 into r1
                                        :ex-cond
                                        (or (= z1.ins.pos
                                               z1.select.position)
                                            (= z1.ins.pos
                                               (1- z1.select.position))))))
     #+END_SRC
    
**** tests
***** testing rehfs with the macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (bformat t "Testing rehfs")
      (explore-neighborhood-criteria-v2
       ((doselect-route (r1 wc))
        (doselect-subroute (z1 r1 wc))
        (doreverse-subroute (z1 wc))
        (doinsert-subroute (z1 r1 wc)))
       :smart-criterion
       ((doselect-route (r1 wc))
        (doselect-subroute (z1 r1 wc))
        (doreverse-subroute (z1 wc))
        (doinsert-subroute (z1 r1 wc
                               :ex-cond
                               (or (= z1.ins.pos
                                        z1.select.position)
                                     (= z1.ins.pos
                                        (1- z1.select.position)))
                               ;; :dt z1.select.coord
                               )))

       :name-for-bformat 'rehfs
       :smart-version-info
       ((subroute-selected-at-operation z1 wc)
        z1.ins.pos)
       :solution ((1 2 3 4 5 6 7 8 9))
       :print-difference t
       :print-intersection nil
       :show-intersection nil
       :print-neighborhood nil
       :print-smart-neighborhood nil
       :print-smart-repeated  all
       )
      #+END_SRC
***** handmade rehfs
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3 4 5)))

          (bformat t "Exploring handmade refs")
          ;; (format t "original solution:~%")
          ;; (pp-solution s1 t) (terpri)
          ;; (format t "==================~%")

          (let* ((wc (basic-working-copy s1))
                 (ops-list nil)
                 (current-neighbor nil)
                 (all-neighborhood nil)
                 (repeated-neighbors nil)
                 (once-only-neigbors nil)
                 ;; (smart-neighborhood nil)
                 ;; (smart-repeated-neighbors nil)
                 ;; (smart-once-only-neigbors nil)
                 ;; (repeated-info nil)
                 ;; (membership-info nil)
                 ;; (info-to-print nil)
                 )

            (prepare-solution-for-neighborhood-exploration wc)

            (doselect-subroute (z1 1 wc
                                   :lex-cond (= 1 z1.length)
                                   )
              ;; (doreverse-subroute (z1 wc)
              (doinsert-subroute (z1 1 wc
                                     :dt z1.select.coord)
                  (setf current-neighbor
                        (loop for i from 1 to (route-length 1 wc)
                              collecting (id (client-at (list 1 i) wc))))

                  ;; let's see how many repeated are there
                  (if (member current-neighbor all-neighborhood
                              :test 'obj=)
                      ;; then
                      (pushnew current-neighbor repeated-neighbors
                               :test 'obj=)
                      ;; else
                      (push current-neighbor once-only-neigbors))

                  (push current-neighbor all-neighborhood)
                  ;; (pp-solution wc t)
                  ;; (terpri)
                  ))
            ;)
    


            ;; now let's test the "smart" version
            ;; (doselect-subroute (z1 1 wc)
            ;;   (doselect-subroute (z2 1 wc
            ;;                          ;; :lex-cond (= z1.length z2.length 1)
            ;;                          :ge (list z1.select.route
            ;;                                    z1.select.position))
            ;;     (doswap-subroutes (z1 z2 wc)

            ;;       (setf current-neighbor
            ;;             (loop for i from 1 to (route-length 1 wc)
            ;;                   collecting (id (client-at (list 1 i) wc))))

            ;;       ;; let's get the info from this neighbor
            ;;       (setf info-to-print
            ;;             (format nil "[~a | ~a]"
            ;;                     (subroute-selected-at-operation z1 wc)
            ;;                     (subroute-selected-at-operation z2 wc)))

            ;;       ;; let's see if the current neighbor has already
            ;;       ;; been visited
            ;;       (setf membership-info
            ;;             (first (member current-neighbor smart-neighborhood
            ;;                            :test (lambda (x y) (obj= x (first y))))))

            ;;       ;; now in membership-info we have a list
            ;;       ;; where the 1st element is the neighbor and the
            ;;       ;; 2nd is the "coords" from the moment it was added
            ;;       ;; if it is nil, the neighbor is new.

            ;;       (if membership-info 

            ;;           ;; then it is repeated, so let's add it
            ;;           ;; to the repeated ones
            ;;           ;; but before we need to know if it was already
            ;;           ;; added to the repeated ones
            ;;           (progn
            ;;             (setf repeated-info
            ;;                   (first (member current-neighbor
            ;;                                  smart-repeated-neighbors
            ;;                                  :test (lambda (x y)
            ;;                                          (obj= x (first y))))))
            ;;             ;; if repeated-info is non nil, the it has all the
            ;;             ;; info we need about the repeated-neighbor.
            ;;             ;; AND we need to remove it from the
            ;;             ;; smart-repeated-neighbors
            ;;             (if repeated-info
            ;;                 (then
            ;;                   (setf smart-repeated-neighbors
            ;;                         (remove current-neighbor
            ;;                                 smart-repeated-neighbors
            ;;                                 :test (lambda (x y)
            ;;                                         (obj= x (first y))))))
            ;;                 (else
            ;;                   ;; let's set it to an appropriate value
            ;;                   ;; in this case, to membership-info
            ;;                   (setf repeated-info
            ;;                         membership-info)))

            ;;             ;; now we should add the current-neighbor to
            ;;             ;; the list of repeated-neighbors.
            ;;             (push (append
            ;;                       repeated-info
            ;;                       (list info-to-print))
            ;;                      smart-repeated-neighbors))
            ;;           ;; else
            ;;           (push current-neighbor smart-once-only-neigbors))

            ;;       ;; in any case
            ;;       (push (list current-neighbor
            ;;                   info-to-print)
            ;;             smart-neighborhood)

            ;;       ;; (pp-solution wc t)
            ;;       ;; (terpri)
            ;;       )))


            (format t "neighborhood size:        ~a~%"
                    (length all-neighborhood))
            (format t "repeated elements:        ~a~%"
                    (length repeated-neighbors))
            (format t "once-only elements:       ~a~%"
                    (length once-only-neigbors))

            ;; (format t "smart neighborhood size:  ~a~%"
            ;;         (length smart-neighborhood))
            ;; (format t "smart repeated elements:  ~a~%"
            ;;         (length smart-repeated-neighbors))
            ;; (format t "smart once-only elements: ~a~%"
            ;;         (length smart-once-only-neigbors))

            ;; (format t "Missing elements:~%~{~a~%~}"
            ;;         (set-difference
            ;;          once-only-neigbors
            ;;          smart-once-only-neigbors
            ;;          :test #'obj=)
            ;;         ;; (set-difference (mapcar 'first once-only-neigbors)
            ;;         ;;                 (mapcar 'first smart-once-only-neigbors)
            ;;         ;;                 :test #'obj=)
            ;;         )

            (format t "repeated elements: ~a~%"
                    (length repeated-neighbors))

            (let* ((len (length (clients (first (routes s1))))))
              (loop for repeated in repeated-neighbors
                    do (format t "(1")
                    do (loop for i from 2 to len
                             do (format t " ~a" i))
                    doing (format t ") -> ~a~{ ~a~}~%"
                                  (first repeated)
                                  (rest repeated))))

            ;; (format t "intersection: ~a~%"
            ;;         (intersection (mapcar 'first smart-neighborhood)
            ;;                       all-neighborhood
            ;;                       :test 'obj=))

            (format t "full neighborhood:~%~{~a~%~}~%"
                    (reverse all-neighborhood)
                    ;; (reverse (mapcar 'first smart-neighborhood))
                    )


            ;; (format t "smart neighborhood:~%~{~a~%~}~%"
            ;;         (reverse smart-neighborhood)
            ;;         ;; (reverse (mapcar 'first smart-neighborhood))
            ;;         )
            ))
      #+END_SRC
*** rehfs*
**** description
     This criterion means to move a reversed subroute inside its route.  We forbid the selection of a sobroute with length 1 because that would be rab.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rehfs*
         ((select-route r1)
          (select-subroute z1 from r1
            ;; avoid collisions with rabs*
            :ldt 1)
          (reverse-subroute z1)
          (insert-subroute z1 into r1
             ;; avoid collisions with itself
             :ex-cond
             (or (= z1.ins.pos
                    z1.select.position)
                 (= z1.ins.pos
                    (1- z1.select.position))))))
     #+END_SRC
    
**** tests
***** comparing rehfs* with rab
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rehfs* with rabs*")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-client (c1 r1 wc))
          (doinsert-client (c1 r1 wc
             :ex (list
                  (list r1 c1.position)
                  (list r1 (1- c1.position))))))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (z1 r1 wc
             ;; avoid collisions with rabs*
             :ldt 1))
          (doreverse-subroute (z1 wc))
          (doinsert-subroute (z1 r1 wc
             ;; avoid collisions with itself
             :ex-cond
             (or (= z1.ins.pos
                    z1.select.position)
                 (= z1.ins.pos
                    (1- z1.select.position))))))

         :name-for-bformat 'rehfs
         :smart-version-info
         ((subroute-selected-at-operation z1 wc)
          z1.ins.pos)
         :solution ((1 2 3 4 5 6 7 8 9))
         :print-difference nil
         :print-intersection t
         :show-intersection t
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated  all
         ))
      #+END_SRC
***** comparing rehfs* with itself
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (bformat t "Comparing rehfs* with rabs*")
      (explore-neighborhood-criteria-v2
       ((doselect-route (r1 wc))
        (doselect-subroute (z1 r1 wc))
        (doreverse-subroute (z1 wc))
        (doinsert-subroute (z1 r1 wc
           ;; avoid collisions with itself
           :ex-cond
            (or (= z1.ins.pos
                   z1.select.position)
                (= z1.ins.pos
                   (1- z1.select.position))))))
       :smart-criterion
       ((doselect-route (r1 wc))
        (doselect-subroute (z1 r1 wc
           ;; avoid collisions with rabs*
           :ldt 1))
        (doreverse-subroute (z1 wc))
        (doinsert-subroute (z1 r1 wc
           ;; avoid collisions with itself
           :ex-cond
            (or (= z1.ins.pos
                   z1.select.position)
                (= z1.ins.pos
                   (1- z1.select.position))))))

       :name-for-bformat 'rehfs
       :smart-version-info
       ((subroute-selected-at-operation z1 wc)
        z1.ins.pos)
       :solution ((1 2 3 4 5))
       :print-difference t
       :print-intersection nil
       :show-intersection nil
       :print-neighborhood nil
       :print-smart-neighborhood nil
       :print-smart-repeated  all
       )
      #+END_SRC
** rehrf (move a reversed suboroute to another route)
*** rehrf
**** description
     This is the classical move a reversed subroute to a different route
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rehrf ((select-route r1)
                                      (select-subroute z1 from r1)
                                      (select-route r2)
                                      (reverse-subroute z1)
                                      (insert-subroute z1 into r2)))
     #+END_SRC
    
*** rehrfs (smart)
**** description
     This is the smart version of the classical "move a reversed subroute to a different route".
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rehrfs ((select-route r1)
                                       (select-subroute z1 from r1)
                                       (select-route r2)
                                       (reverse-subroute z1)
                                       (insert-subroute z1 into r2
                                           :ex-cond
                                           (and
                                            (= r1 r2)
                                            (or
                                             (= z1.ins.pos
                                                z1.select.position)
                                             (= z1.ins.pos
                                                (1- z1.select.position)))))))
     #+END_SRC
**** tests
***** testing rehfs with the macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Testing rehrfs")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-subroute (z1 r1 wc))
          (doreverse-subroute (z1 wc))
          (doselect-route (r2 wc))
          (doinsert-subroute (z1 r2 wc)))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (z1 r1 wc))
          (doreverse-subroute (z1 wc))
          (doselect-route (r2 wc))
          (doinsert-subroute (z1 r2 wc
             :ex-cond (and
                       (= r1 r2)
                       (or
                        (= z1.ins.pos
                           z1.select.position)
                        (= z1.ins.pos
                           (1- z1.select.position)))))))

         :name-for-bformat 'rehfs
         :smart-version-info
         ((subroute-selected-at-operation z1 wc)
          z1.ins.pos)
         :solution ((1 2 3 4 5 6 7) (8 9 10 11))
         :print-difference t
         :print-intersection nil
         :show-intersection t
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated  nil
         ))
      #+END_SRC
    
*** rehrfs*
**** description
     This is the smart version of the classical "move a reversed subroute to a different route".

     In the smart* version we forbid moving to the selection's route (to avoid collisions with rehf), and we forbid subroutes with length 1 (to avoid collisions with rarb)
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rehrfs*
       ((select-route r1)
        (select-subroute z1 from r1
           ;; to avoid collisions with rarb
           :ldt 1)
        (select-route r2
           ;; to avoid collisions with rehf
           :dt r1)
        (reverse-subroute z1)
        (insert-subroute z1 into r2
          ;; 
          ;; we don't need to avoid collisions
          ;; with itself because these collisions
          ;; appear when r1 = r2 and we have
          ;; have already forbidden that.
          )))
     #+END_SRC
**** tests
***** comparing rehrfs* with rarbs*
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rerfs* with rarbs*")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-client (c1 r1 wc))
          (doselect-route (r2 wc :dt r1))
          (doinsert-client (c1 r2 wc)))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc
             ;; to avoid collisions with rarb
             ;; do not allow subroutes with length 1
             :ldt 1))
          (doselect-route (r2 wc
             ;; to avoid collisions with rehf
             ;; do not insert in the same route
             ;; where it was selected from
             :dt r1))
          (doinsert-subroute (c1 r2 wc
             ;; to avoid collisions with itself
             ;; we can remove this constraint
             ;; because we have already ruled out
             ;; r1 = r2
             ;; :ex-cond (and
             ;;           (= r1 r2)
             ;;           (<= c1.ins.pos c1.position))
             )))
         :name-for-bformat 'rerfs
         :smart-version-info
         ((subroute-selected-at-operation c1 wc))
         :solution ((1 2 3 4 5 6) (7 8 9 10 11))
         :print-difference nil
         :print-intersection nil
         :show-intersection t
         :print-smart-neighborhood nil
         :print-neighborhood nil
         :print-smart-repeated nil
         ))
      #+END_SRC
***** comparing rehrfs* with rehfs*
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rehrfs* with rerfs*")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-subroute (z1 r1 wc
             ;; avoid collisions with rabs*
             :ldt 1))
          (doreverse-subroute (z1 wc))
          (doinsert-subroute (z1 r1 wc
             ;; avoid collisions with itself
             :ex-cond
             (or (= z1.ins.pos
                    z1.select.position)
                 (= z1.ins.pos
                    (1- z1.select.position))))))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc
             ;; to avoid collisions with rarb
             :ldt 1))
          (doselect-route (r2 wc
             ;; to avoid collisions with rehf
             :dt r1))
          (doinsert-subroute (c1 r2 wc
             ;; to avoid collisions with itself
             ;; we don't need this anymore because
             ;; we have already forbidden r1 = r2
             ;; :ex-cond (and
             ;;           (= r1 r2)
             ;;           (<= c1.ins.pos c1.position))
             )))
         :name-for-bformat 'rerfs
         :smart-version-info
         ((subroute-selected-at-operation c1 wc))
         :solution ((1 2 3 4 5 6) (7 8 9 10 11) (12 13 14 15 16))
         :print-difference nil
         :print-intersection nil
         :show-intersection t
         :print-smart-neighborhood nil
         :print-neighborhood nil
         :print-smart-repeated nil
         ))
      #+END_SRC
***** comparing rehrfs* with itself*
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rehrfs* with rerhfs")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-subroute (z1 r1 wc))
          (doreverse-subroute (z1 wc))
          (doselect-route (r2 wc))
          (doinsert-subroute (z1 r2 wc
             :ex-cond (and
                       (= r1 r2)
                       (or
                        (= z1.ins.pos
                           z1.select.position)
                        (= z1.ins.pos
                           (1- z1.select.position)))))))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc
             ;; to avoid collisions with rarb
                                 :ldt 1))
          (doreverse-subroute (c1 wc))
          (doselect-route (r2 wc
             ;; to avoid collisions with rehf
             :dt r1))
          (doinsert-subroute (c1 r2 wc
             ;; to avoid collisions with itself
             ;; we don't need this anymore because
             ;; we have already forbidden r1 = r2
             ;; :ex-cond (and
             ;;           (= r1 r2)
             ;;           (<= c1.ins.pos c1.position))
             )))
         :name-for-bformat 'rerhfs
         :smart-version-info
         ((subroute-selected-at-operation c1 wc))
         :solution ((1 2 3 4) (5 6 7 8))
         :print-difference t
         :print-intersection nil
         :show-intersection nil
         :print-smart-neighborhood nil
         :print-neighborhood nil
         :print-smart-repeated nil
         ))
      #+END_SRC
** rehreg (swap a reversed subroute with a non reversed one)
*** rehreg
**** description
     This is the classical swap subroutes (the first one reversed)
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rehreg ((select-route r1)
                                       (select-subroute c1 from r1)
                                       (select-route r2)
                                       (select-subroute c2 from r2)
                                       (reverse-subroute c1)
                                       (swap-subroutes c1 c2)))
     #+END_SRC
*** rehregs (smart)
**** description
     This is the smart version of the classical swap subroutes (the first one reversed)
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rehregs
        ((select-route r1)
         (select-subroute c1 from r1)
         (select-route r2)
         (select-subroute c2 from r2
           :ex-cond               
           (or
            (and ;; both routes with length 1 and r1 < r2
             (= c1.length c2.length 1)
             (< r1 r2)
             )
            (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
             (= c1.length c2.length 1)
             (= r1 r2)
             (< c2.position c1.position))
            ;; otherwise we'll apply the constraints
            ;; if we are in the same route
            (and
             (= r1 r2)
             (or ;; each case in isolation
              ;; we'll split the analysis in several cases
              ;; that I'll write in the comments
              ;; |c1| = 1 and |c2| = 1
              (and ;; these are the case where both length are 1
               (= c1.length 1)
               (= c2.length 1)
               (or ;; pivoting effect
                ;; the first two remove the "pivoting effect"
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1))
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (- c1.position 2))))

              ;; |c1| = 1 and |c2| > 1 
              (and
               (= c1.length 1)
               (> c2.length 1)
               (or
                (and ;; don't go pass me
                 (< c2.position c1.position)
                 (>= (1-
                      (+ c2.position c2.length))
                     c1.position))
                (or ;; pivoting effect
                 ;; the first two remove the "pivoting effect"
                 ;; this is the case where c2.pos < c1.pos
                 (= c2.position
                    (- c1.position c2.length 1))
                 ;; this is the case where c2.pos > c1.pos
                 (= c2.position
                    (+ c1.position 1)))))
              ;; TODO |c1| > 1 and |c2| = 1
              (and
               (> c1.length 1)
               (= c2.length 1)
               (or ;; pivot and symmetry
                ;; the first two remove the "pivoting effect"
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1))
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (- c1.position 2))
                ;; and this one removes the
                ;; symmetry effect
                (= c2.position
                   (- c1.position 1))))

              ;; |c1| > 1 and |c2| > 1
              (and
               (> c1.length 1)
               (> c2.length 1)
               (or
                (and
                 (< c2.position c1.position)
                 (>= (1- (+ c2.position c2.length))
                     c1.position))
                (or ;; pivoting effect  
                 ;; this is the case where c2.pos < c1.pos
                 (= c2.position
                    (- c1.position c2.length 1))
                 ;; this is the case where c2.pos > c1.pos
                 (= c2.position
                    (+ c1.position 1)))))
              ))))
         (reverse-subroute c1)
         (swap-subroutes c1 c2)))
     #+END_SRC
**** tests
***** testing rehregs with the macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Testing rehregs")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc))
          (doreverse-subroute (c1 wc))
          (doswap-subroutes (c1 c2 wc)))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc
             :ex-cond               
             (or
              (and ;; both routes with length 1 and r1 < r2
               (= c1.length c2.length 1)
               (< r1 r2)
               )
              (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
               (= c1.length c2.length 1)
               (= r1 r2)
               (< c2.position c1.position))
              ;; we'll only apply the constraints
              ;; if we are in the same route
              (and
               (= r1 r2)
               (or
                ;; we'll split the analysis in several cases
                ;; that I'll write in the comments
                ;; |c1| = 1 and |c2| = 1
                (and ;; these are the case where both length are 1
                 (= c1.length 1)
                 (= c2.length 1)
                 (or ;; pivoting effect
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))))

                ;; |c1| = 1 and |c2| > 1 
                (and
                 (= c1.length 1)
                 (> c2.length 1)
                 (or
                  (and ;; don't go pass me
                   (< c2.position c1.position)
                   (>= (1-
                        (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect
                   ;; the first two remove the "pivoting effect"
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))))
                ;; TODO |c1| > 1 and |c2| = 1
                (and
                 (> c1.length 1)
                 (= c2.length 1)
                 (or ;; pivot and symmetry
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))
                  ;; and this one removes the
                  ;; symmetry effect
                  (= c2.position
                     (- c1.position 1))))
                ;; |c1| > 1 and |c2| > 1
                (and
                 (> c1.length 1)
                 (> c2.length 1)
                 (or
                  (and ;; don't go beyond me!
                   (< c2.position c1.position)
                   (>= (1- (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect  
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))))
                )))
                                 ))
          (doreverse-subroute (c1 wc))
          (doswap-subroutes (c1 c2 wc)))

         :name-for-bformat 'rehregs
         :smart-version-info
         ((subroute-selected-at-operation c1 wc)
          (subroute-selected-at-operation c2 wc))
         :solution ((1 2 3 4 5 6) (7 8 9 10 11 12))
         :print-difference t
         :print-intersection nil
         :show-intersection t
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated all
         ))
      #+END_SRC
    
***** testing rehregs where Iosvanny claims no repetition.
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (bformat t "Testing rehregs")
      (explore-neighborhood-criteria-v2
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc))
        ;; (doselect-route (r2 wc))
        (doselect-subroute (c2 r1 wc
           :ex-cond (or
                     (= c1.length 1)
                     (> c2.length 1))
           ))
        (doreverse-subroute (c1 wc))
        (doswap-subroutes (c1 c2 wc)))
       :smart-criterion
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc))
        ;; (doselect-route (r2 wc))
        (doselect-subroute (c2 r1 wc
           :ex-cond (or 
                     (or
                      (= c1.length 1)
                      (> c2.length 1))
                     (or
                      ;; the first two remove the "pivoting effect"
                      ;; this is the case where c2.pos > c1.pos
                      (= c2.position
                         (+ c1.position 1))
                      ;; this is the case where c2.pos > c1.pos
                      (= c2.position
                         (- c1.position 2))
                     ;; and this one removes the
                     ;; symmetry effect
                      (= c2.position
                         (- c1.position 1)))
                     )
           ))
        (doreverse-subroute (c1 wc))
        (doswap-subroutes (c1 c2 wc)))

       :name-for-bformat 'rehregs
       :smart-version-info
       ((subroute-selected-at-operation c1 wc)
        (subroute-selected-at-operation c2 wc))
       :solution ((1 2 3 4 5 6 7 8 9 10 11 12 13))
       :print-difference t
       :print-intersection nil
       :show-intersection t
       :print-neighborhood nil
       :print-smart-neighborhood nil
       :print-smart-repeated all
       )
      #+END_SRC
    
*** rehregs*
**** description
     This is the smart* version of the classical swap subroutes (the first one reversed).  We need to avoid collisions with rarac (and with reheg but as it is not included in this set of criteria, we don't need to analyze it).
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rehregs*
        ((select-route r1)
         (select-subroute c1 from r1
            ;; if c1.length is 1 then we don't
            ;; reverse anything and all those
            ;; neighboors are explored in rereg
            :ldt 1)
         (select-route r2)
         (select-subroute c2 from r2
            ;; to avoid collisions with rarac
            ;; don't select both subroutes with length 1
            :lex-cond (= c1.length c2.length 1)
            ;; ;; but also we should not select c2
            ;; ;; right where c1 ends, if c1.length is 2
            ;; ;; I'm adding this constraint
            ;; ;; to the ex-cond

           :ex-cond               
           (or
            (and ;; avoid other collisions with rarac
              ;; we should avoid the case
              ;; when c1.length is 2, c2.length is 1
              ;; and we are in the same route, and c2 is
              ;; selected from the same place as c1
              ;; this can also be obtained in rarac
              (= r1 r2)
              (= c1.length 2)
              (= c2.length 1)
              (= c2.position c1.position))

            ;; (and ;; |c1| = |c2| = 1 and r1 < r2
            ;;  ;; we don't need this because we have already
            ;;  ;; forbidden r1 = r2.
            ;;  (= c1.length c2.length 1)
            ;;  (< r1 r2))
            ;; (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
            ;;  ;; we don't need this because we have already
            ;;  ;; forbidden r1 = r2.
            ;;  (= r1 r2)
            ;;  (= c1.length c2.length 1)
            ;;  (< c2.position c1.position))
            ;; otherwise we'll apply the constraints
            ;; if we are in the same route
            (and
             (= r1 r2)
             (or ;; each case in isolation
              ;; we'll split the analysis in several cases
              ;; that I'll write in the comments

              ;; |c1| = 1 and |c2| = 1
              ;; we don't need this because we have already
              ;; forbidden r1 = r2
              ;; to avoid collisions with rarac

              ;; |c1| = 1 and |c2| > 1
              ;; no need to analyze this because
              ;; we have already ruled out this case
              ;; to avoid collisions with rereg


              (and ;; |c1| > 1 and |c2| = 1
               (> c1.length 1)
               (= c2.length 1)
               (or ;; pivot and symmetry
                ;; the first two remove the "pivoting effect"
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1))
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (- c1.position 2))
                ;; and this one removes the
                ;; symmetry effect
                (= c2.position
                   (- c1.position 1))))

              ;; |c1| > 1 and |c2| > 1
              (and
               (> c1.length 1)
               (> c2.length 1)
               (or
                (and
                 (< c2.position c1.position)
                 (>= (1- (+ c2.position c2.length))
                     c1.position))
                (or ;; pivoting effect  
                 ;; this is the case where c2.pos < c1.pos
                 (= c2.position
                    (- c1.position c2.length 1))
                 ;; this is the case where c2.pos > c1.pos
                 (= c2.position
                    (+ c1.position 1)))))))))
         (reverse-subroute c1)
         (swap-subroutes c1 c2)))
     #+END_SRC
**** tests
***** comparing rehregs* with rarac
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rehregs* with rarac")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-client (c1 r1 wc))
          (doselect-route (r2 wc :ge r1))
          (doselect-client (c2 r2 wc
            :ge c1.select.coord))
          (doswap-clients (c1 c2 wc)))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc
             ;; to avoid collisions with rarac
             ;; don't select both subroutes with length 1

             :lex-cond (= c1.length c2.length 1)

             ;; ;; but also we should not select c2
             ;; ;; right where c1 ends, if c1.length is 2
             ;; ;; I'm adding this constraint
             ;; ;; to the ex-cond


             ;; to avoid collisions with itself
             :ex-cond               
             (or
              (and ;; avoid other collisions with rarac
               ;; we should avoid the case
               ;; when c1.length is 2, and c2.length is 1
               ;; and we are in the same route, and c2 is
               ;; selected from the same place as c1
               ;; this is the same as rarac
               (= r1 r2)
               (= c1.length 2)
               (= c2.length 1)
               (= c2.position c1.position))
              (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
               (= c1.length c2.length 1)
               (= r1 r2)
               (< c2.position c1.position))
              ;; we'll only apply the constraints
              ;; if we are in the same route
              (and
               (= r1 r2)
               (or
                ;; we'll split the analysis in several cases
                ;; that I'll write in the comments
                ;; |c1| = 1 and |c2| = 1
                (and ;; these are the case where both length are 1
                 (= c1.length 1)
                 (= c2.length 1)
                 (or ;; pivoting effect
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))))

                ;; |c1| = 1 and |c2| > 1 
                (and
                 (= c1.length 1)
                 (> c2.length 1)
                 (or
                  (and ;; don't go pass me
                   (< c2.position c1.position)
                   (>= (1-
                        (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect
                   ;; the first two remove the "pivoting effect"
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))))
                ;; |c1| > 1 and |c2| = 1
                (and
                 (> c1.length 1)
                 (= c2.length 1)
                 (or ;; pivot and symmetry
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))
                  ;; and this one removes the
                  ;; symmetry effect
                  (= c2.position
                     (- c1.position 1))))
                ;; |c1| > 1 and |c2| > 1
                (and
                 (> c1.length 1)
                 (> c2.length 1)
                 (or
                  (and ;; don't go beyond me!
                   (< c2.position c1.position)
                   (>= (1- (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect  
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))))
                )))))
          (doreverse-subroute (c1 wc))
          (doswap-subroutes (c1 c2 wc)))

         :name-for-bformat 'rehregs
         :smart-version-info
         ((subroute-selected-at-operation c1 wc)
          (subroute-selected-at-operation c2 wc))
         :solution ((1 2 3 4 5 6) (7 8 9 10 11 12))
         :print-difference nil
         :print-intersection nil
         :show-intersection t
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated nil
         ))
      #+END_SRC
    
***** comparing rehregs* with a version of itself
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Testing rehregs")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc
             ;; to avoid collisions with rarac
             ;; don't select both subroutes with length 1
             :lex-cond (= c1.length c2.length 1)
             ;; ;; but also we should not select c2
             ;; ;; right where c1 ends, if c1.length is 2
             ;; ;; I'm adding this constraint
             ;; ;; to the ex-cond


             ;; to avoid collisions with itself
             :ex-cond               
             (or
              ;; (and ;; avoid collisions with rarac
              ;;  ;; when c1.length is 2 and c2 is
              ;;  ;; selected from the same place as c1
              ;;  (= c1.length 2)
              ;;  (= c2.position c1.position)
              ;;  )
              (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
               (= c1.length c2.length 1)
               (= r1 r2)
               (< c2.position c1.position))
              ;; we'll only apply the constraints
              ;; if we are in the same route
              (and
               (= r1 r2)
               (or
                ;; we'll split the analysis in several cases
                ;; that I'll write in the comments
                ;; |c1| = 1 and |c2| = 1
                (and ;; these are the case where both length are 1
                 (= c1.length 1)
                 (= c2.length 1)
                 (or ;; pivoting effect
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))))

                ;; |c1| = 1 and |c2| > 1 
                (and
                 (= c1.length 1)
                 (> c2.length 1)
                 (or
                  (and ;; don't go pass me
                   (< c2.position c1.position)
                   (>= (1-
                        (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect
                   ;; the first two remove the "pivoting effect"
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))))
                ;; TODO |c1| > 1 and |c2| = 1
                (and
                 (> c1.length 1)
                 (= c2.length 1)
                 (or ;; pivot and symmetry
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))
                  ;; and this one removes the
                  ;; symmetry effect
                  (= c2.position
                     (- c1.position 1))))
                ;; |c1| > 1 and |c2| > 1
                (and
                 (> c1.length 1)
                 (> c2.length 1)
                 (or
                  (and ;; don't go beyond me!
                   (< c2.position c1.position)
                   (>= (1- (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect  
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))))
                )))
                                 ))
          (doreverse-subroute (c1 wc))
          (doswap-subroutes (c1 c2 wc)))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc
             ;; to avoid collisions with rarac
             ;; don't select both subroutes with length 1
             :lex-cond (= c1.length c2.length 1)
             ;; to avoid collisions with itself
             :ex-cond               
             (or
              (and ;; avoid collisions with rarac
               ;; we should avoid the case
               ;; when c1.length is 2, and c2.length is 1
               ;; and we are in the same route, and c2 is
               ;; selected from the same place as c1
               ;; this is the same as rarac
               (= r1 r2)
               (= c1.length 2)
               (= c2.length 1)
               (= c2.position c1.position)
               )
              (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
               (= c1.length c2.length 1)
               (= r1 r2)
               (< c2.position c1.position))
              ;; we'll only apply the constraints
              ;; if we are in the same route
              (and
               (= r1 r2)
               (or
                ;; we'll split the analysis in several cases
                ;; that I'll write in the comments
                ;; |c1| = 1 and |c2| = 1
                (and ;; these are the case where both length are 1
                 (= c1.length 1)
                 (= c2.length 1)
                 (or ;; pivoting effect
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))))

                ;; |c1| = 1 and |c2| > 1 
                (and
                 (= c1.length 1)
                 (> c2.length 1)
                 (or
                  (and ;; don't go pass me
                   (< c2.position c1.position)
                   (>= (1-
                        (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect
                   ;; the first two remove the "pivoting effect"
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))))
                ;; TODO |c1| > 1 and |c2| = 1
                (and
                 (> c1.length 1)
                 (= c2.length 1)
                 (or ;; pivot and symmetry
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))
                  ;; and this one removes the
                  ;; symmetry effect
                  (= c2.position
                     (- c1.position 1))))
                ;; |c1| > 1 and |c2| > 1
                (and
                 (> c1.length 1)
                 (> c2.length 1)
                 (or
                  (and ;; don't go beyond me!
                   (< c2.position c1.position)
                   (>= (1- (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect  
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))))
                )))
                                 ))
          (doreverse-subroute (c1 wc))
          (doswap-subroutes (c1 c2 wc)))

         :name-for-bformat 'rehregs
         :smart-version-info
         ((subroute-selected-at-operation c1 wc)
          (subroute-selected-at-operation c2 wc))
         :solution ((1 2 3 4 5 6) (7 8 9 10 11 12))
         :print-difference t
         :print-intersection nil
         :show-intersection nil
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated nil
         ))
      #+END_SRC
    
***** comparing rehregs* with rereg
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rehregs to rereg")
        (explore-neighborhood-criteria-v2
         ;; rereg
         ((doselect-route (r1 wc))
          (doselect-subroute (z1 r1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (z2 r2 wc
            ;; to avoid collisions with rarac
            :lex-cond (= z1.length z2.length 1)
            ;; to avoid collisions with itself                    
            :ge (list z1.select.route
                      z1.select.position)))
          (doswap-subroutes (z1 z2 wc)))

         :smart-criterion
         ;; rehreg
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc
             ;; if c1.length is 1 then we don't
             ;; reverse anything and all those
             ;; neighboors were explored in rereg
             :ldt 1))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc
             ;; to avoid collisions with rarac
             ;; don't select both subroutes with length 1
             :lex-cond (= c1.length c2.length 1)
             ;; ;; but also we should not select c2
             ;; ;; right where c1 ends, if c1.length is 2
             ;; ;; I'm adding this constraint
             ;; ;; to the ex-cond


             ;; to avoid collisions with itself
             :ex-cond               
             (or
              (and ;; avoid other collisions with rarac
               ;; we should avoid the case
               ;; when c1.length is 2, and c2.length is 1
               ;; and we are in the same route, and c2 is
               ;; selected from the same place as c1
               ;; this is the same as rarac
               (= r1 r2)
               (= c1.length 2)
               (= c2.length 1)
               (= c2.position c1.position))
              ;; from here on is to avoid collisions with itself
              (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
               (= c1.length c2.length 1)
               (= r1 r2)
               (< c2.position c1.position))
              ;; we'll only apply the constraints
              ;; if we are in the same route
              (and
               (= r1 r2)
               (or
                ;; we'll split the analysis in several cases
                ;; that I'll write in the comments
                ;; |c1| = 1 and |c2| = 1
                ;; no need to analyze this because
                ;; we have already ruled out this case
                ;; to avoid collisions with rarac

                ;; |c1| = 1 and |c2| > 1 
                ;; no need to analyze this because
                ;; we have already ruled out this case
                ;; to avoid collisions with rereg

                ;; |c1| > 1 and |c2| = 1
                (and
                 (> c1.length 1)
                 (= c2.length 1)
                 (or ;; pivot and symmetry [to avoid collisions with self]
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))
                  ;; and this one removes the
                  ;; symmetry effect
                  (= c2.position
                     (- c1.position 1)))
                 )

                ;; |c1| > 1 and |c2| > 1
                (and
                 (> c1.length 1)
                 (> c2.length 1)
                 (or ;; to avoid collisions with self
                  (and ;; don't go beyond me! to avoid collisions with self
                   (< c2.position c1.position)
                   (>= (1- (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect to avoid collision with self
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))
                  (or ;; don't touch me [to avoid collision with rereg]
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      c1.position)
                   ;; this is the case where c2.pos < c1.pos
                   (= c1.position
                      (+ c2.position c2.length))
                   ))
                 )
                )))
                                 ))
          (doreverse-subroute (c1 wc))
          (doswap-subroutes (c1 c2 wc)))

         :name-for-bformat 'rehregs
         :smart-version-info
         ((subroute-selected-at-operation c1 wc)
          (subroute-selected-at-operation c2 wc))
         :solution ((1 2 3 4 5 6 7 8 9)  (10 11 12 13 14 15)
                    )
         :print-difference nil
         :print-intersection t
         :show-intersection t
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated nil
         ))
      #+END_SRC
    
***** comparing rehregs* with itself v2
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rehregs* with itself")
        (explore-neighborhood-criteria-v2
         ;; rehreg
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc
             ;; to avoid collisions with rarac
             ;; don't select both subroutes with length 1
             :lex-cond (= c1.length c2.length 1)
             ;; ;; but also we should not select c2
             ;; ;; right where c1 ends, if c1.length is 2
             ;; ;; I'm adding this constraint
             ;; ;; to the ex-cond


             ;; to avoid collisions with itself
             :ex-cond               
             (or
              ;; (and ;; avoid collisions with rarac
              ;;  ;; when c1.length is 2 and c2 is
              ;;  ;; selected from the same place as c1
              ;;  (= c1.length 2)
              ;;  (= c2.position c1.position)
              ;;  )
              (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
               (= c1.length c2.length 1)
               (= r1 r2)
               (< c2.position c1.position))
              ;; we'll only apply the constraints
              ;; if we are in the same route
              (and
               (= r1 r2)
               (or
                ;; we'll split the analysis in several cases
                ;; that I'll write in the comments
                ;; |c1| = 1 and |c2| = 1
                (and ;; these are the case where both length are 1
                 (= c1.length 1)
                 (= c2.length 1)
                 (or ;; pivoting effect
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))))

                ;; |c1| = 1 and |c2| > 1 
                (and
                 (= c1.length 1)
                 (> c2.length 1)
                 (or
                  (and ;; don't go pass me
                   (< c2.position c1.position)
                   (>= (1-
                        (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect
                   ;; the first two remove the "pivoting effect"
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))))
                ;; TODO |c1| > 1 and |c2| = 1
                (and
                 (> c1.length 1)
                 (= c2.length 1)
                 (or ;; pivot and symmetry
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))
                  ;; and this one removes the
                  ;; symmetry effect
                  (= c2.position
                     (- c1.position 1))))
                ;; |c1| > 1 and |c2| > 1
                (and
                 (> c1.length 1)
                 (> c2.length 1)
                 (or
                  (and ;; don't go beyond me!
                   (< c2.position c1.position)
                   (>= (1- (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect  
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))))
                )))
                                 ))
          (doreverse-subroute (c1 wc))
          (doswap-subroutes (c1 c2 wc)))

         :smart-criterion
         ;; rehreg
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc
             ;; if c1.length is 1 then we don't
             ;; reverse anything and all those
             ;; neighboors were explored in rereg
             :ldt 1))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc
             ;; to avoid collisions with rarac
             ;; don't select both subroutes with length 1
             :lex-cond (= c1.length c2.length 1)
             ;; ;; but also we should not select c2
             ;; ;; right where c1 ends, if c1.length is 2
             ;; ;; I'm adding this constraint
             ;; ;; to the ex-cond


             ;; to avoid collisions with itself
             :ex-cond               
             (or
              (and ;; avoid other collisions with rarac
               ;; we should avoid the case
               ;; when c1.length is 2, and c2.length is 1
               ;; and we are in the same route, and c2 is
               ;; selected from the same place as c1
               ;; this is the same as rarac
               (= r1 r2)
               (= c1.length 2)
               (= c2.length 1)
               (= c2.position c1.position))
              ;; from here on is to avoid collisions with itself
              (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
               (= c1.length c2.length 1)
               (= r1 r2)
               (< c2.position c1.position))
              ;; we'll only apply the constraints
              ;; if we are in the same route
              (and
               (= r1 r2)
               (or
                ;; we'll split the analysis in several cases
                ;; that I'll write in the comments
                ;; |c1| = 1 and |c2| = 1
                ;; no need to analyze this because
                ;; we have already ruled out this case
                ;; to avoid collisions with rarac

                ;; |c1| = 1 and |c2| > 1 
                ;; no need to analyze this because
                ;; we have already ruled out this case
                ;; to avoid collisions with rereg

                ;; |c1| > 1 and |c2| = 1
                (and
                 (> c1.length 1)
                 (= c2.length 1)
                 (or ;; pivot and symmetry [to avoid collisions with self]
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))
                  ;; and this one removes the
                  ;; symmetry effect
                  (= c2.position
                     (- c1.position 1)))
                 )

                ;; |c1| > 1 and |c2| > 1
                (and
                 (> c1.length 1)
                 (> c2.length 1)
                 (or ;; to avoid collisions with self
                  (and ;; don't go beyond me! to avoid collisions with self
                   (< c2.position c1.position)
                   (>= (1- (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect to avoid collision with self
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))
                  (or ;; pivoting effect to avoid collision with rereg
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      c1.position)
                   ;; this is the case where c2.pos < c1.pos
                   ;; (= c1.position
                   ;;    (+ c2.position c2.length))
                   ))
                 ))))))
          (doreverse-subroute (c1 wc))
          (doswap-subroutes (c1 c2 wc)))

         :name-for-bformat 'rehregs
         :smart-version-info
         ((subroute-selected-at-operation c1 wc)
          (subroute-selected-at-operation c2 wc))
         :solution ((1 2 3 4 5) (6 7 8 9 10))
         :print-difference t
         :print-intersection nil
         :show-intersection nil
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated nil
         ))
      #+END_SRC
    
***** comparing rehregs* with rehrf
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rehregs* with rehrf")
        (explore-neighborhood-criteria-v2
         ;; rehrfs*
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc
             ;; to avoid collisions with rarb
                                 :ldt 1))
          (doreverse-subroute (c1 wc))
          (doselect-route (r2 wc
             ;; to avoid collisions with rehf
             :dt r1))
          (doinsert-subroute (c1 r2 wc
             ;; to avoid collisions with itself
             ;; we don't need this anymore because
             ;; we have already forbidden r1 = r2
             ;; :ex-cond (and
             ;;           (= r1 r2)
             ;;           (<= c1.ins.pos c1.position))
             )))

         :smart-criterion
         ;; rehreg
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc
             ;; if c1.length is 1 then we don't
             ;; reverse anything and all those
             ;; neighboors were explored in rereg
             :ldt 1))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc
             ;; to avoid collisions with rarac
             ;; don't select both subroutes with length 1
             :lex-cond (= c1.length c2.length 1)
             ;; ;; but also we should not select c2
             ;; ;; right where c1 ends, if c1.length is 2
             ;; ;; I'm adding this constraint
             ;; ;; to the ex-cond


             ;; to avoid collisions with itself
             :ex-cond               
             (or
              (and ;; avoid other collisions with rarac
               ;; we should avoid the case
               ;; when c1.length is 2, and c2.length is 1
               ;; and we are in the same route, and c2 is
               ;; selected from the same place as c1
               ;; this is the same as rarac
               (= r1 r2)
               (= c1.length 2)
               (= c2.length 1)
               (= c2.position c1.position))
              ;; from here on is to avoid collisions with itself
              ;; (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
              ;;  (= c1.length c2.length 1)
              ;;  (= r1 r2)
              ;;  (< c2.position c1.position))
              ;; we'll only apply the constraints
              ;; if we are in the same route
              (and
               (= r1 r2)
               (or
                ;; we'll split the analysis in several cases
                ;; that I'll write in the comments.
                ;; The first case is
                ;; |c1| = 1 and |c2| = 1 and there is
                ;; no need to analyze this because
                ;; we have already ruled out this case
                ;; to avoid collisions with rarac

                ;; |c1| = 1 and |c2| > 1 
                ;; no need to analyze this because
                ;; we have already ruled out this case
                ;; to avoid collisions with rereg
          

                (and ;; |c1| > 1 and |c2| = 1
                 (> c1.length 1)
                 (= c2.length 1)
                 (or ;; pivot and symmetry [to avoid collisions with self]
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))
                  ;; and this one removes the
                  ;; symmetry effect
                  (= c2.position
                     (- c1.position 1)))
                 )

                ;; |c1| > 1 and |c2| > 1
                (and
                 (> c1.length 1)
                 (> c2.length 1)
                 (or ;; to avoid collisions with self
                  (and ;; don't go beyond me! to avoid collisions with self
                   (< c2.position c1.position)
                   (>= (1- (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect to avoid collision with self
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))
                  (or ;; pivoting effect to avoid collision with rereg
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      c1.position)
                   ;; this is the case where c2.pos < c1.pos
                   ;; (= c1.position
                   ;;    (+ c2.position c2.length))
                   ))
                 ))))))
          (doreverse-subroute (c1 wc))
          (doswap-subroutes (c1 c2 wc)))

         :name-for-bformat 'rehregs
         :smart-version-info
         ((subroute-selected-at-operation c1 wc)
          (subroute-selected-at-operation c2 wc))
         :solution ((1 2 3 4 5) (6 7 8 9 10))
         :print-difference nil
         :print-intersection nil
         :show-intersection t
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated all
         ))
      #+END_SRC
    
** rerehg (swap a non reversed subroute with a reversed one)
*** rerehg
**** description
     This is the classical swap subroutes (the second one reversed)
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rerehg ((select-route r1)
                                       (select-subroute c1 from r1)
                                       (select-route r2)
                                       (select-subroute c2 from r2)
                                       (reverse-subroute c2)
                                       (swap-subroutes c1 c2)))
     #+END_SRC
*** rerehgs (smart)
**** description
     This is the classical swap subroutes (the second one swapped)
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rerehgs
         ((select-route r1)
          (select-subroute c1 from r1)
          (select-route r2)
          (select-subroute c2 from r2
             :ex-cond               
             (or
              ;; if both subroutes have length 1
              ;; exclude if r2 < r1
              (and
               (= c1.length c2.length 1)
               (< r2 r1))
              ;; let's apply the following rules
              ;; if both subroutes are selected
              ;; from the same route
              (and ;; both subroutes are from the same subroute
               (= r1 r2)
               (or ;; let's analyze all the cases
                (and ;; |c1| = |c2| = 1
                 (= c1.length 1)
                 (= c2.length 1)
                 (or
                  ;; c2 is "before" c1
                  (< c2.position c1.position)
                  (or ;; exclued the pivoting effect
                   ;; c1.pos < c2.pos
                   (= c2.position
                      (+ c1.position 1)))))
                (and ;; |c1| = 1, |c2| > 1
                 (= c1.length 1)
                 (> c2.length 1)
                 ;; let's remove the pivoting effect
                 (or ;; pivoting and symmetric effect
                  ;; c1.pos < c2.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; c1.pos > c2.pos
                  (= c2.position
                     (- c1.position c2.length 1))
                  ;; let's remove the symmetric repetitions
                  (= c2.position
                     (- c1.position c2.length)))




                 )
                (and ;; |c1| > 1, |c2| = 1
                 ;; there are not repetitions in this case :-o
                 ;; I tested up to 10 clients
                 ;; but when we mix it with the other
                 ;; cases, some repeated elements appear :-/
                 ;; so we should remove the pivoting effect
                 (and
                  (> c1.length 1)
                  (= c2.length 1)
                  (or ;; let's remove the pivoting effect
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1))         
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; and this one is for the symmetric effect
                   (= c2.position
                      (- c1.position 1)))))
                (and ;; |c1| > 1, |c2| > 1
                 (> c1.length 1)
                 (> c2.length 1)
                 (or ;; let's analyze the possible problems

                  (and ;; don't stop before me
                   ;;  ;; It worked!!!
                   ;;  ;; Now Iosvanny must find out why :-o
                   (< c2.position c1.position)

                   (= (+ c2.position c2.length)
                      c1.position))

                  (or ;; let's remove the pivoting effect
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1))         
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1)))
                  ))))))
          (reverse-subroute c2)
          (swap-subroutes c1 c2)))
     #+END_SRC
**** tests
***** testing rehegs with the macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (bformat t "Testing rehregs")
      (explore-neighborhood-criteria-v2
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc))
        ;; (doselect-route (r2 wc))
        (doselect-subroute (c2 r1 wc
           :ex-cond (or
                     (and ;; exclued if |c1| = 1 or |c2| = 1
                      (= c1.length 1)
                      (= c2.length 1))
                     )
           ))
        (doreverse-subroute (c2 wc))
        (doswap-subroutes (c1 c2 wc)))
       :smart-criterion
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc))
        ;; (doselect-route (r2 wc))
        (doselect-subroute (c2 r1 wc
           :ex-cond               
           (or
            (or ;; exclued if both subroutes have length 1 [that's a swap]
             (and
              (= c1.length 1)
              (= c2.length 1))
             )
            (and ;; |c1| = |c2| = 1
             (and ;; exclude if c2 is "before" c1
              (= c1.length 1)
              (= c2.length 1)
              (< c2.position c1.position)))
            (and ;; |c1| = 1, |c2| > 1
             (= c1.length 1)
             (> c2.length 1)
             ;; let's remove the pivoting effect
             (or
              ;; c1.pos < c2.pos
              (= c2.position
                 (+ c1.position 1))
              ;; c1.pos > c2.pos
              (= c2.position
                 (- c1.position c2.length 1))
              ;; let's remove the symmetric repetitions
              (= c2.position
                 (- c1.position c2.length))
              ;; don't go beyond me!
              ;; (and ;; don't go beyond me!
              ;;  ;; it looks like this is an important property of
              ;;  ;; this neighborhood, and thus we can't
              ;;  ;; impose this constraint :-/
              ;;  (< c2.position c1.position)
              ;;  (>= (1- (+ c2.position c2.length))
              ;;      c1.position))

              )




             )
            (and ;; |c1| > 1, |c2| = 1
             ;; there are not repetitions in this case :-o
             ;; I tested up to 10 clients
             ;; but when we mix it with the other
             ;; cases, some repeated elements appear :-/
             ;; so we should remove the pivoting effect
             (and
              (> c1.length 1)
              (= c2.length 1)
              (or ;; let's remove the pivoting effect
               ;; this is the case where c2.pos > c1.pos
               (= c2.position
                  (+ c1.position 1))         
               ;; this is the case where c2.pos < c1.pos
               (= c2.position
                  (- c1.position c2.length 1))
               ;; and this one is for the symmetric effect
               (= c2.position
                  (- c1.position 1))
               ))
             )
            (and ;; TODO |c1| > 1, |c2| > 1
             (> c1.length 1)
             (> c2.length 1)
             (or ;; let's analyze the possible problems

              (and ;; don't go beyond me! [don't stop before me]
              ;;  ;; it looks like this is an important property of
              ;;  ;; this neighborhood, and thus we can't
              ;;  ;; impose this constraint :-/
              ;;  ;; I'm going to try the following:
              ;;  ;; don't stop right in front of me
              ;;  ;; It worked!!!
              ;;  ;; Now Iosvanny must find out why :-o
               (< c2.position c1.position)
               (= (+ c2.position c2.length)
                   c1.position))

              (or ;; let's remove the pivoting effect
               ;; this is the case where c2.pos > c1.pos
               (= c2.position
                  (+ c1.position 1))         
               ;; this is the case where c2.pos < c1.pos
               (= c2.position
                  (- c1.position c2.length 1)))
               ))
            ;; here ends the case ;; |c1| > 1, |c2| > 1 
             )
            )
           )
        (doreverse-subroute (c2 wc))
        (doswap-subroutes (c1 c2 wc)))

       :name-for-bformat 'rerehgs
       :smart-version-info
       ((subroute-selected-at-operation c1 wc)
        (subroute-selected-at-operation c2 wc))
       :solution ((1 2 3 4 5 6 7 8))
       :print-difference t
       :print-intersection nil
       :show-intersection nil
       :print-neighborhood nil
       :print-smart-neighborhood nil
       :print-smart-repeated all
       )
      #+END_SRC
    
***** testing rerehgs with the macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Testing rerehgs")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc))
          (doreverse-subroute (c2 wc))
          (doswap-subroutes (c1 c2 wc)))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc
             :ex-cond               
             (or
              ;; if both subroutes have length 1
              ;; exclude if r2 < r1
              (and
               (= c1.length c2.length 1)
               (< r2 r1))
              ;; let's apply the following rules
              ;; if both subroutes are selected
              ;; from the same route
              (and ;; both subroutes are from the same subroute
               (= r1 r2)
               (or                       ;; let's analyze all the cases
                (and                     ;; |c1| = |c2| = 1
                 (= c1.length 1)
                 (= c2.length 1)
                 (or
                  ;; c2 is "before" c1
                  (< c2.position c1.position)
                  (or ;; exclued the pivoting effect
                   ;; c1.pos < c2.pos
                   (= c2.position
                      (+ c1.position 1)))))
                (and ;; |c1| = 1, |c2| > 1
                 (= c1.length 1)
                 (> c2.length 1)
                 ;; let's remove the pivoting effect
                 (or ;; pivoting and symmetric effect
                  ;; c1.pos < c2.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; c1.pos > c2.pos
                  (= c2.position
                     (- c1.position c2.length 1))
                  ;; let's remove the symmetric repetitions
                  (= c2.position
                     (- c1.position c2.length)))




                 )
                (and ;; |c1| > 1, |c2| = 1
                 ;; there are not repetitions in this case :-o
                 ;; I tested up to 10 clients
                 ;; but when we mix it with the other
                 ;; cases, some repeated elements appear :-/
                 ;; so we should remove the pivoting effect
                 (and
                  (> c1.length 1)
                  (= c2.length 1)
                  (or ;; let's remove the pivoting effect
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1))         
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; and this one is for the symmetric effect
                   (= c2.position
                      (- c1.position 1)))))
                (and ;; |c1| > 1, |c2| > 1
                 (> c1.length 1)
                 (> c2.length 1)
                 (or ;; let's analyze the possible problems

                  (and ;; don't stop before me
                   ;;  ;; It worked!!!
                   ;;  ;; Now Iosvanny must find out why :-o
                   (< c2.position c1.position)

                   (= (+ c2.position c2.length)
                      c1.position))

                  (or ;; let's remove the pivoting effect
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1))         
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1)))
                  )))))))
          (doreverse-subroute (c2 wc))
          (doswap-subroutes (c1 c2 wc)))

         :name-for-bformat 'rerehgs
         :smart-version-info
         ((subroute-selected-at-operation c1 wc)
          (subroute-selected-at-operation c2 wc))
         :solution ((1 2 3 4 5 6) (7 8 9 10 11 12)
                    ;; (13 14 15 16 17 18)
                    )
         :print-difference t
         :print-intersection nil
         :show-intersection nil
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated all
         ))
      #+END_SRC
    
*** rerehgs*
**** description
     This is the smart* version of the criterion swap two subroutes with the second one reversed.
     We should avoid collisions with rarac and rereg
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rerehgs*
         ((select-route r1)
          (select-subroute c1 from r1)
          ;; (select-route r2)
          (select-subroute c2 from r1
            ;; to avoid collisions with rarac                         
            ;; avoid |c1| = |c2| = 1
            :lex-cond (= c1.length c2.length 1)
            ;; we also need to avoid c2.pos = c1.pos
            ;; because we can get the same neighbor
            ;; with rarac. This is the same restriction
            ;; as in rehreg. I'll also add it to the
            ;; ex-cond.

            ;; the following line avoids collisions
            ;; with rereg
            :ldt 1

            ;; an from here on is to avoid
            ;; collisions with itself
            :ex-cond               
            (or
             (and ;; avoid other collisions with rarac
              ;; we should avoid the case
              ;; when |c1| = 1, |c2| = 2, r1 = r2,
              ;; and c2 is selected from the same place
              ;; as c1 this can also be obtained in rarac.
              (= c2.length 2)
              (= c1.length 1)
              (= c2.position c1.position))
             ;; |c1| = |c2| = 1 ;; ruled out by rarac
             (and ;; |c1| = 1, |c2| > 1
              (= c1.length 1)
              (> c2.length 1)

              (or ;; all the constraints here
               (or ;; pivoting effect and symmetry
                ;; c1.pos < c2.pos
                (= c2.position
                   (+ c1.position 1))
                ;; c1.pos > c2.pos
                (= c2.position
                   (- c1.position c2.length 1))
                ;; let's remove the symmetric repetitions
                (= c2.position
                   (- c1.position c2.length))
                ;; don't go beyond me!!! to avoid
                ;; collisions with rereg
                (and ;; |c1| = 1, |c2| > 1
                 (< c2.position c1.position)
                 (= (+ c2.position c2.length -1)
                    c1.position))
                )
               ;; avoid |c2| >= 3 and concatenation
               (and ;; avoid |c2| >= 3 and concatenation
                (>= c2.length 3)
                (= c1.position c2.position))
               (or ;; to avoid collisions with rehreg pivots with length
                (or ;; c2.pos > c1.pos
                 (> c2.position (+ c1.position 1))
                 ;; c2.pos < c1.pos
                 (> c1.position (+ c2.position c2.length))))
               ) ;; here ends |c1| = 1, |c2| > 1

              )
             ;; |c1| > 1, |c2| = 1 ;; no need [it is rereg]
             (and ;; |c1| > 1, |c2| > 1
              (> c1.length 1)
              (> c2.length 1)
              (or ;; let's analyze the possible problems
               (and ;; [don't stop before me]
                ;;  ;; It worked!!!
                (< c2.position c1.position)
                (= (+ c2.position c2.length)
                   c1.position))

               ;; |c1| > 1, |c2| > 1
               (and ;; don't go beyond me!!! to avoid rereg
                ;; collisions with rereg
                ;; |c1| > 1, |c2| > 1
                (< c2.position c1.position)
                (= (+ c2.position c2.length -1)
                   c1.position))
               (and ;; to avoid collisions with rereg
                ;; |c2| = 2 and c2.pos = c1.pos + c1.length - 1
                ;; this is equivalent to a rereg with pivot
                ;; 
                (= c2.length 2)
                (= (+ c2.position c2.position)))
               (or ;; let's remove the pivoting effect
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1))         
                ;; this is the case where c2.pos < c1.pos
                (= c2.position
                   (- c1.position c2.length 1)))
               ;; avoid |c2| >= 3 and concatenation
               (and ;; avoid |c2| >= 3 and concatenation
                (>= c2.length 3)
                (= c1.position c2.position))
               (or ;; to avoid collisions with rehreg pivots with length
                (or ;; c2.pos > c1.pos
                 (> c2.position (+ c1.position 1))
                 ;; c2.pos < c1.pos
                 (> c1.position (+ c2.position c2.length)))))
              )
             ))
          (reverse-subroute c2)
          (swap-subroutes c1 c2)))
     #+END_SRC
**** tests
***** comparing rerehgs with rarac
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rerehgs* with raracs")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-client (c1 r1 wc))
          (doselect-route (r2 wc :ge r1))
          (doselect-client (c2 r2 wc
            ;; avoid the insertion in the same coord
            ;; where c1 was selected from
            ;; because this also happens in rab
            ;; and as we need to avoid insertions
            ;; before c1.coord, we can translate it
            ;; into
            :ge c1.select.coord))
          (doswap-clients (c1 c2 wc)))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc
            ;; to avoid collisions with rarac                         
            ;; avoid |c1| = |c2| = 1
            :lex-cond (= c1.length c2.length 1)
            ;; we also need to avoid c2.pos = c1.pos
            ;; because we can get the same neighbor
            ;; with rarac. This is the same restriction
            ;; as in rehreg. I'll also add it to the
            ;; ex-cond

            ;; to avoid collisions with itself
            :ex-cond               
            (or
             (and ;; avoid other collisions with rarac
              ;; we should avoid the case
              ;; when |c1| = 1, |c2| = 2, r1 = r2,
              ;; and c2 is selected from the same place
              ;; as c1 this can also be obtained in rarac.
              (= r1 r2)
              (= c2.length 2)
              (= c1.length 1)
              (= c2.position c1.position))
             ;; (or ;; |c1| = |c2| = 1
             ;;  ;; we have already ruled this case out
             ;;  (and
             ;;   (= c1.length 1)
             ;;   (= c2.length 1))
             ;;  )
             ;; (and ;; |c1| = |c2| = 1
             ;;  ;; we have already ruled this case out
             ;;  ;; to avoid collisions with rarac
             ;;  (and ;; exclude if c2 is "before" c1
             ;;   (= c1.length 1)
             ;;   (= c2.length 1)
             ;;   (< c2.position c1.position)))
             (and ;; |c1| = 1, |c2| > 1
              (= c1.length 1)
              (> c2.length 1)
              ;; let's remove the pivoting effect
              (or
               ;; c1.pos < c2.pos
               (= c2.position
                  (+ c1.position 1))
               ;; c1.pos > c2.pos
               (= c2.position
                  (- c1.position c2.length 1))
               ;; let's remove the symmetric repetitions
               (= c2.position
                  (- c1.position c2.length))
               ;; don't go beyond me!
               ;; (and ;; don't go beyond me!
               ;;  ;; it looks like this is an important property of
               ;;  ;; this neighborhood, and thus we can't
               ;;  ;; impose this constraint :-/
               ;;  (< c2.position c1.position)
               ;;  (>= (1- (+ c2.position c2.length))
               ;;      c1.position))

               )




              )
             (and ;; |c1| > 1, |c2| = 1
              ;; there are not repetitions in this case :-o
              ;; I tested up to 10 clients
              ;; but when we mix it with the other
              ;; cases, some repeated elements appear :-/
              ;; so we should remove the pivoting effect
              (and
               (> c1.length 1)
               (= c2.length 1)
               (or ;; let's remove the pivoting effect
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1))         
                ;; this is the case where c2.pos < c1.pos
                (= c2.position
                   (- c1.position c2.length 1))
                ;; and this one is for the symmetric effect
                (= c2.position
                   (- c1.position 1))
                ))
              )
             (and ;; |c1| > 1, |c2| > 1
              (> c1.length 1)
              (> c2.length 1)
              (or ;; let's analyze the possible problems

               (and ;; don't go beyond me! [don't stop before me]
                ;;  ;; it looks like this is an important property of
                ;;  ;; this neighborhood, and thus we can't
                ;;  ;; impose this constraint :-/
                ;;  ;; I'm going to try the following:
                ;;  ;; don't stop right in front of me
                ;;  ;; It worked!!!
                ;;  ;; Now Iosvanny must find out why :-o
                (< c2.position c1.position)
                (= (+ c2.position c2.length)
                   c1.position))

               (or ;; let's remove the pivoting effect
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1))         
                ;; this is the case where c2.pos < c1.pos
                (= c2.position
                   (- c1.position c2.length 1)))
               ))
             ;; here ends the case ;; |c1| > 1, |c2| > 1 
             )))
          (doreverse-subroute (c2 wc))
          (doswap-subroutes (c1 c2 wc)))

         :name-for-bformat 'rerehg-vs-rarac
         :smart-version-info
         ((subroute-selected-at-operation c1 wc)
          (subroute-selected-at-operation c2 wc))
         :solution ((1 2 3 4 5) ;; (6 7 8 9 10)
                    )
         :print-difference nil
         :print-intersection t
         :show-intersection t
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated nil
         ))
      #+END_SRC
***** comparing rerehgs with reregs
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rerehgs* with raracs")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-subroute (z1 r1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (z2 r2 wc
             ;; to avoid collisions with rarac
             :lex-cond (= z1.length z2.length 1)
             ;; to avoid collisions with itself                    
             :ge z1.select.coord
             ;; to avoid collisions with rerehg
             :ex-cond
             (or
              (= z2.position z1.position))))
          (doswap-subroutes (z1 z2 wc)))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc
             ;; to avoid collisions with rarac                         
             ;; avoid |c1| = |c2| = 1
             :lex-cond (= c1.length c2.length 1)
             ;; we also need to avoid c2.pos = c1.pos
             ;; because we can get the same neighbor
             ;; with rarac. This is the same restriction
             ;; as in rehreg. I'll also add it to the
             ;; ex-cond.

             ;; the following line avoids collisions
             ;; with rereg
             :ldt 1

             ;; an from here on is to avoid
             ;; collisions with itself
             :ex-cond               
             (or
              (and ;; avoid other collisions with rarac
               ;; we should avoid the case
               ;; when |c1| = 1, |c2| = 2, r1 = r2,
               ;; and c2 is selected from the same place
               ;; as c1 this can also be obtained in rarac.
               (= r1 r2)
               (= c2.length 2)
               (= c1.length 1)
               (= c2.position c1.position))
              ;; (or ;; |c1| = |c2| = 1
              ;;  ;; we have already ruled this case out
              ;;  (and
              ;;   (= c1.length 1)
              ;;   (= c2.length 1))
              ;;  )
              ;; (and ;; |c1| = |c2| = 1
              ;;  ;; we have already ruled this case out
              ;;  ;; to avoid collisions with rarac
              ;;  (and ;; exclude if c2 is "before" c1
              ;;   (= c1.length 1)
              ;;   (= c2.length 1)
              ;;   (< c2.position c1.position)))
              (and ;; |c1| = 1, |c2| > 1
               (= c1.length 1)
               (> c2.length 1)
               ;; let's remove the pivoting effect
               (or
                ;; c1.pos < c2.pos
                (= c2.position
                   (+ c1.position 1))
                ;; c1.pos > c2.pos
                (= c2.position
                   (- c1.position c2.length 1))
                ;; let's remove the symmetric repetitions
                (= c2.position
                   (- c1.position c2.length))
                ;; don't go beyond me!!! to avoid
                ;; collisions with rereg
                (and ;; |c1| = 1, |c2| > 1
                 (< c2.position c1.position)
                 (= (+ c2.position c2.length -1)
                    c1.position))
                )

               )
              ;; (and ;; |c1| > 1, |c2| = 1 ;; no need [it is rereg]
              ;;  ;; we should remove this case to avoid
              ;;  ;; collisions with rereg
              ;;  ;; so we should remove the pivoting effect
              ;;  (and
              ;;   (> c1.length 1)
              ;;   (= c2.length 1)
              ;;   (or ;; let's remove the pivoting effect
              ;;    ;; this is the case where c2.pos > c1.pos
              ;;    (= c2.position
              ;;       (+ c1.position 1))         
              ;;    ;; this is the case where c2.pos < c1.pos
              ;;    (= c2.position
              ;;       (- c1.position c2.length 1))
              ;;    ;; and this one is for the symmetric effect
              ;;    (= c2.position
              ;;       (- c1.position 1)))))
              (and ;; |c1| > 1, |c2| > 1
               (> c1.length 1)
               (> c2.length 1)
               (or ;; let's analyze the possible problems

                (and ;; [don't stop before me]
                 ;;  ;; It worked!!!
                 (< c2.position c1.position)
                 (= (+ c2.position c2.length)
                    c1.position))

                ;; |c1| > 1, |c2| > 1
                (and ;; don't go beyond me!!! to avoid rereg
                 ;; collisions with rereg
                 ;; |c1| > 1, |c2| > 1
                 (< c2.position c1.position)
                 (= (+ c2.position c2.length -1)
                    c1.position))


                (and ;; to avoid collisions with rereg
                 ;; |c2| = 2 and c2.pos = c1.pos + c1.length - 1
                 ;; this is equivalent to a rereg with pivot
                 ;; 
                 (= c2.length 2)
                 (= (+ c2.position c2.position)))
                (or ;; let's remove the pivoting effect
                 ;; this is the case where c2.pos > c1.pos
                 (= c2.position
                    (+ c1.position 1))         
                 ;; this is the case where c2.pos < c1.pos
                 (= c2.position
                    (- c1.position c2.length 1)))
                ))
              ;; here ends the case ;; |c1| > 1, |c2| > 1 
              )))
          (doreverse-subroute (c2 wc))
          (doswap-subroutes (c1 c2 wc)))

         :name-for-bformat 'rerehgs*-vs-rereg
         :smart-version-info
         ((subroute-selected-at-operation c1 wc)
          (subroute-selected-at-operation c2 wc))
         :solution ((1 2 3 4 5 6) ;; (6 7 8 9 10) (11 12 13 14 15)
                    )
         :print-difference nil
         :print-intersection t
         :show-intersection t
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated nil
         ))
      #+END_SRC
    
***** comparing rerehgs with rehregs (no need. rehreg is a subset of rerehg)
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rerehgs* with rehregs*")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc
             ;; if c1.length is 1 then we don't
             ;; reverse anything and all those
             ;; neighboors were explored in rereg
             :ldt 1))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc
             ;; to avoid collisions with rarac
             ;; don't select both subroutes with length 1
             :lex-cond (= c1.length c2.length 1)
             ;; ;; but also we should not select c2
             ;; ;; right where c1 ends, if c1.length is 2
             ;; ;; I'm adding this constraint
             ;; ;; to the ex-cond


             ;; to avoid collisions with itself
             :ex-cond               
             (or
              (and ;; avoid other collisions with rarac
               ;; we should avoid the case
               ;; when c1.length is 2, and c2.length is 1
               ;; and we are in the same route, and c2 is
               ;; selected from the same place as c1
               ;; this is the same as rarac
               (= r1 r2)
               (= c1.length 2)
               (= c2.length 1)
               (= c2.position c1.position))
              ;; from here on is to avoid collisions with itself
              ;; (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
              ;;  (= c1.length c2.length 1)
              ;;  (= r1 r2)
              ;;  (< c2.position c1.position))
              ;; we'll only apply the constraints
              ;; if we are in the same route
              (and
               (= r1 r2)
               (or
                ;; we'll split the analysis in several cases
                ;; that I'll write in the comments.
                ;; The first case is
                ;; |c1| = 1 and |c2| = 1 and there is
                ;; no need to analyze this because
                ;; we have already ruled out this case
                ;; to avoid collisions with rarac

                ;; |c1| = 1 and |c2| > 1 
                ;; no need to analyze this because
                ;; we have already ruled out this case
                ;; to avoid collisions with rereg


                (and ;; |c1| > 1 and |c2| = 1
                 (> c1.length 1)
                 (= c2.length 1)
                 (or ;; pivot and symmetry [to avoid collisions with self]
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))
                  ;; and this one removes the
                  ;; symmetry effect
                  (= c2.position
                     (- c1.position 1)))
                 )

                ;; |c1| > 1 and |c2| > 1
                (and
                 (> c1.length 1)
                 (> c2.length 1)
                 (or ;; to avoid collisions with self
                  (and ;; don't go beyond me! to avoid collisions with self
                   (< c2.position c1.position)
                   (>= (1- (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect to avoid collision with self
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))
                  (or ;; pivoting effect to avoid collision with rereg
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      c1.position)
                   ;; this is the case where c2.pos < c1.pos
                   ;; (= c1.position
                   ;;    (+ c2.position c2.length))
                   ))
                 ))))))
          (doreverse-subroute (c1 wc))
          (doswap-subroutes (c1 c2 wc)))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc
             ;; to avoid collisions with rarac                         
             ;; avoid |c1| = |c2| = 1
             :lex-cond (= c1.length c2.length 1)
             ;; we also need to avoid c2.pos = c1.pos
             ;; because we can get the same neighbor
             ;; with rarac. This is the same restriction
             ;; as in rehreg. I'll also add it to the
             ;; ex-cond.

             ;; the following line avoids collisions
             ;; with rereg
             :ldt 1

             ;; an from here on is to avoid
             ;; collisions with itself
             :ex-cond               
             (or
              (and ;; avoid other collisions with rarac
               ;; we should avoid the case
               ;; when |c1| = 1, |c2| = 2, r1 = r2,
               ;; and c2 is selected from the same place
               ;; as c1 this can also be obtained in rarac.
               (= r1 r2)
               (= c2.length 2)
               (= c1.length 1)
               (= c2.position c1.position))
              ;; |c1| = |c2| = 1 ;; no need is the rarac
              (and ;; |c1| = 1, |c2| > 1
               (= c1.length 1)
               (> c2.length 1)
               ;; let's remove the pivoting effect
               (or
                ;; c1.pos < c2.pos
                (= c2.position
                   (+ c1.position 1))
                ;; c1.pos > c2.pos
                (= c2.position
                   (- c1.position c2.length 1))
                ;; let's remove the symmetric repetitions
                (= c2.position
                   (- c1.position c2.length))
                ;; don't go exactly beyond me!!! to avoid
                ;; collisions with rereg
                (and ;; |c1| = 1, |c2| > 1
                 (< c2.position c1.position)
                 (= (+ c2.position c2.length -1)
                    c1.position))

                ;; avoid |c2| >= 3 and concatenation
                (and ;; avoid |c2| >= 3 and concatenation
                 (>= c2.length 3)
                 (= c1.position c2.position))
                (or ;; to avoid collisions with rehreg pivots with length
                 (or ;; c2.pos > c1.pos
                  (> c2.position (+ c1.position 1))
                  ;; c2.pos < c1.pos
                  (> c1.position (+ c2.position 1)))))
               )
              ;; |c1| > 1, |c2| = 1 ;; no need [it is rereg]
              (and ;; |c1| > 1, |c2| > 1
               (> c1.length 1)
               (> c2.length 1)
               (or ;; let's analyze the possible problems

                (and ;; [don't stop before me]
                 ;;  ;; It worked!!!
                 (< c2.position c1.position)
                 (= (+ c2.position c2.length)
                    c1.position))

                ;; |c1| > 1, |c2| > 1
                (and ;; don't go beyond me!!! to avoid rereg
                 ;; collisions with rereg
                 ;; |c1| > 1, |c2| > 1
                 (< c2.position c1.position)
                 (= (+ c2.position c2.length -1)
                    c1.position))


                (and ;; to avoid collisions with rereg
                 ;; |c2| = 2 and c2.pos = c1.pos + c1.length - 1
                 ;; this is equivalent to a rereg with pivot
                 ;; 
                 (= c2.length 2)
                 (= (+ c2.position c2.position)))
                (or ;; let's remove the pivoting effect
                 ;; this is the case where c2.pos > c1.pos
                 (= c2.position
                    (+ c1.position 1))         
                 ;; this is the case where c2.pos < c1.pos
                 (= c2.position
                    (- c1.position c2.length 1))
                 ;; avoid |c2| >= 3 and concatenation
                 (and ;; avoid |c2| >= 3 and concatenation
                  (>= c2.length 3)
                  (= c1.position c2.position))
                )
                (or ;; to avoid collisions with rehreg pivots with length
                 (or ;; c2.pos > c1.pos
                  (> c2.position (+ c1.position 1))
                  ;; c2.pos < c1.pos
                  (> c1.position (+ c2.position c2.length))))
          
                ))
              )))
          (doreverse-subroute (c2 wc))
          (doswap-subroutes (c1 c2 wc)))

         :name-for-bformat 'rerehgs*-vs-rereg
         :smart-version-info
         ((subroute-selected-at-operation c1 wc)
          (subroute-selected-at-operation c2 wc))
         :solution ((1 2 3) (4 5 6) ;; (6 7 8 9 10) ;; (11 12 13 14 15)
                    )
         :print-difference nil
         :print-intersection nil
         :print-smart-intersection t
         :show-intersection t
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated nil
         ))
      #+END_SRC
    
***** comparing rerehgs with rehregs
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rerehgs* with rehregs*")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc
             :ex-cond               
             (or
              (and ;; both routes with length 1 and r1 < r2
               (= c1.length c2.length 1)
               (< r1 r2)
               )
              (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
               (= c1.length c2.length 1)
               (= r1 r2)
               (< c2.position c1.position))
              ;; we'll only apply the constraints
              ;; if we are in the same route
              (and
               (= r1 r2)
               (or
                ;; we'll split the analysis in several cases
                ;; that I'll write in the comments
                ;; |c1| = 1 and |c2| = 1
                (and ;; these are the case where both length are 1
                 (= c1.length 1)
                 (= c2.length 1)
                 (or ;; pivoting effect
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))))

                ;; |c1| = 1 and |c2| > 1 
                (and
                 (= c1.length 1)
                 (> c2.length 1)
                 (or
                  (and ;; don't go pass me
                   (< c2.position c1.position)
                   (>= (1-
                        (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect
                   ;; the first two remove the "pivoting effect"
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))))
                ;; TODO |c1| > 1 and |c2| = 1
                (and
                 (> c1.length 1)
                 (= c2.length 1)
                 (or ;; pivot and symmetry
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))
                  ;; and this one removes the
                  ;; symmetry effect
                  (= c2.position
                     (- c1.position 1))))
                ;; |c1| > 1 and |c2| > 1
                (and
                 (> c1.length 1)
                 (> c2.length 1)
                 (or
                  (and ;; don't go beyond me!
                   (< c2.position c1.position)
                   (>= (1- (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect  
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))))
                )))
                                 ))
          (doreverse-subroute (c1 wc))
          (doswap-subroutes (c1 c2 wc)))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc
             ;; to avoid collisions with rereg
             :ldt 1              
             :ex-cond               
             (or
              ;; if both subroutes have length 1
              ;; exclude if r2 < r1
              (and
               (= c1.length c2.length 1)
               (< r2 r1))
              ;; let's apply the following rules
              ;; if both subroutes are selected
              ;; from the same route
              (and ;; both subroutes are from the same subroute
               (= r1 r2)
               (or                       ;; let's analyze all the cases
                (and                     ;; |c1| = |c2| = 1
                 (= c1.length 1)
                 (= c2.length 1)
                 (or
                  ;; c2 is "before" c1
                  (< c2.position c1.position)
                  (or ;; exclued the pivoting effect
                   ;; c1.pos < c2.pos
                   (= c2.position
                      (+ c1.position 1)))))
                (and ;; |c1| = 1, |c2| > 1
                 (= c1.length 1)
                 (> c2.length 1)
                 ;; let's remove the pivoting effect
                 (or ;; pivoting and symmetric effect
                  ;; c1.pos < c2.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; c1.pos > c2.pos
                  (= c2.position
                     (- c1.position c2.length 1))
                  ;; let's remove the symmetric repetitions
                  (= c2.position
                     (- c1.position c2.length)))




                 )
                (and ;; |c1| > 1, |c2| = 1
                 ;; there are not repetitions in this case :-o
                 ;; I tested up to 10 clients
                 ;; but when we mix it with the other
                 ;; cases, some repeated elements appear :-/
                 ;; so we should remove the pivoting effect
                 (and
                  (> c1.length 1)
                  (= c2.length 1)
                  (or ;; let's remove the pivoting effect
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1))         
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; and this one is for the symmetric effect
                   (= c2.position
                      (- c1.position 1)))))
                (and ;; |c1| > 1, |c2| > 1
                 (> c1.length 1)
                 (> c2.length 1)
                 (or ;; let's analyze the possible problems

                  (and ;; don't stop before me
                   ;;  ;; It worked!!!
                   ;;  ;; Now Iosvanny must find out why :-o
                   (< c2.position c1.position)

                   (= (+ c2.position c2.length)
                      c1.position))

                  (or ;; let's remove the pivoting effect
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1))         
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1)))
                  )))))))
          (doreverse-subroute (c2 wc))
          (doswap-subroutes (c1 c2 wc)))

         :name-for-bformat 'rerehgs-vs-rehreg
         :smart-version-info
         ((subroute-selected-at-operation c1 wc)
          (subroute-selected-at-operation c2 wc))
         :solution ((1 2 3 4 5 6 7) (8 9 10) (11 12 13 14 15)
                    )
         :print-difference t
         :print-intersection nil
         :show-intersection t
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated nil
         ))
      #+END_SRC
    
***** fixing comparison of rerehgs with rehregs
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Comparing rerehgs* with rehregs*")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc
             :ex-cond               
             (or
              (and ;; both routes with length 1 and r1 < r2
               (= c1.length c2.length 1)
               (< r1 r2)
               )
              (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
               (= c1.length c2.length 1)
               (= r1 r2)
               (< c2.position c1.position))
              ;; we'll only apply the constraints
              ;; if we are in the same route
              (and
               (= r1 r2)
               (or
                ;; we'll split the analysis in several cases
                ;; that I'll write in the comments
                ;; |c1| = 1 and |c2| = 1
                (and ;; these are the case where both length are 1
                 (= c1.length 1)
                 (= c2.length 1)
                 (or ;; pivoting effect
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))))

                ;; |c1| = 1 and |c2| > 1 
                (and
                 (= c1.length 1)
                 (> c2.length 1)
                 (or
                  (and ;; don't go pass me
                   (< c2.position c1.position)
                   (>= (1-
                        (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect
                   ;; the first two remove the "pivoting effect"
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))))
                ;; TODO |c1| > 1 and |c2| = 1
                (and
                 (> c1.length 1)
                 (= c2.length 1)
                 (or ;; pivot and symmetry
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))
                  ;; and this one removes the
                  ;; symmetry effect
                  (= c2.position
                     (- c1.position 1))))
                ;; |c1| > 1 and |c2| > 1
                (and
                 (> c1.length 1)
                 (> c2.length 1)
                 (or
                  (and ;; don't go beyond me!
                   (< c2.position c1.position)
                   (>= (1- (+ c2.position c2.length))
                       c1.position))
                  (or ;; pivoting effect  
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))))
                )))
                                 ))
          (doreverse-subroute (c1 wc))
          (doswap-subroutes (c1 c2 wc)))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          ;; (doselect-route (r2 wc))
          (doselect-subroute (c2 r1 wc
             ;; to avoid collisions with rarac                         
             ;; avoid |c1| = |c2| = 1
             :lex-cond (= c1.length c2.length 1)
             ;; we also need to avoid c2.pos = c1.pos
             ;; because we can get the same neighbor
             ;; with rarac. This is the same restriction
             ;; as in rehreg. I'll also add it to the
             ;; ex-cond.

             ;; the following line avoids collisions
             ;; with rereg
             :ldt 1

             ;; an from here on is to avoid
             ;; collisions with itself
             :ex-cond               
             (or
              ;; the routes should be the same or it is rehreg?
              ;; (/= r1 r2)

              (and ;; avoid other collisions with rarac
               ;; we should avoid the case
               ;; when |c1| = 1, |c2| = 2, r1 = r2,
               ;; and c2 is selected from the same place
               ;; as c1 this can also be obtained in rarac.
               (= c2.length 2)
               (= c1.length 1)
               (= c2.position c1.position))
              ;; |c1| = |c2| = 1 ;; ruled out by rarac
              (and ;; |c1| = 1, |c2| > 1
               (= c1.length 1)
               (> c2.length 1)

               (or ;; all the constraints here
                (or ;; pivoting effect and symmetry
                 ;; c1.pos < c2.pos
                 (= c2.position
                    (+ c1.position 1))
                 ;; c1.pos > c2.pos
                 (= c2.position
                    (- c1.position c2.length 1))
                 ;; let's remove the symmetric repetitions
                 (= c2.position
                    (- c1.position c2.length))
                 ;; don't go beyond me!!! to avoid
                 ;; collisions with rereg
                 (and ;; |c1| = 1, |c2| > 1
                  (< c2.position c1.position)
                  (= (+ c2.position c2.length -1)
                     c1.position))
                 )
                ;; avoid |c2| >= 3 and concatenation
                (and ;; avoid |c2| >= 3 and concatenation
                 (>= c2.length 3)
                 (= c1.position c2.position))
                (or ;; to avoid collisions with rehreg pivots with length
                 (or ;; c2.pos > c1.pos
                  (> c2.position (+ c1.position 1))
                  ;; c2.pos < c1.pos
                  (> c1.position (+ c2.position c2.length))))
                ) ;; here ends |c1| = 1, |c2| > 1

               )
              ;; (and ;; |c1| > 1, |c2| = 1 ;; no need [it is rereg]
              ;;  ;; we should remove this case to avoid
              ;;  ;; collisions with rereg
              ;;  ;; so we should remove the pivoting effect
              ;;  (and
              ;;   (> c1.length 1)
              ;;   (= c2.length 1)
              ;;   (or ;; let's remove the pivoting effect
              ;;    ;; this is the case where c2.pos > c1.pos
              ;;    (= c2.position
              ;;       (+ c1.position 1))         
              ;;    ;; this is the case where c2.pos < c1.pos
              ;;    (= c2.position
              ;;       (- c1.position c2.length 1))
              ;;    ;; and this one is for the symmetric effect
              ;;    (= c2.position
              ;;       (- c1.position 1)))))
              (and ;; |c1| > 1, |c2| > 1
               (> c1.length 1)
               (> c2.length 1)
               (or ;; let's analyze the possible problems

                (and ;; [don't stop before me]
                 ;;  ;; It worked!!!
                 (< c2.position c1.position)
                 (= (+ c2.position c2.length)
                    c1.position))

                ;; |c1| > 1, |c2| > 1
                (and ;; don't go beyond me!!! to avoid rereg
                 ;; collisions with rereg
                 ;; |c1| > 1, |c2| > 1
                 (< c2.position c1.position)
                 (= (+ c2.position c2.length -1)
                    c1.position))


                (and ;; to avoid collisions with rereg
                 ;; |c2| = 2 and c2.pos = c1.pos + c1.length - 1
                 ;; this is equivalent to a rereg with pivot
                 ;; 
                 (= c2.length 2)
                 (= (+ c2.position c2.position)))
                (or ;; let's remove the pivoting effect
                 ;; this is the case where c2.pos > c1.pos
                 (= c2.position
                    (+ c1.position 1))         
                 ;; this is the case where c2.pos < c1.pos
                 (= c2.position
                    (- c1.position c2.length 1)))
                ;; avoid |c2| >= 3 and concatenation
                (and ;; avoid |c2| >= 3 and concatenation
                 (>= c2.length 3)
                 (= c1.position c2.position))
                (or ;; to avoid collisions with rehreg pivots with length
                 (or ;; c2.pos > c1.pos
                  (> c2.position (+ c1.position 1))
                  ;; c2.pos < c1.pos
                  (> c1.position (+ c2.position c2.length)))))
               ) ;; here ends the case ;; |c1| > 1, |c2| > 1 

              )))
          (doreverse-subroute (c2 wc))
          (doswap-subroutes (c1 c2 wc)))

         :name-for-bformat 'rerehgs-vs-rehreg
         :smart-version-info
         ((subroute-selected-at-operation c1 wc)
          (subroute-selected-at-operation c2 wc))
         :solution ((1 2 3 4) (5 6 7 8)  (9 10 11 12 13 14 15)
                    )
         :print-difference nil
         :print-intersection nil
         :show-intersection t
         :print-smart-intersection t
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated nil
         ))
      #+END_SRC
    
** rehrehg (swap two reversed subroutes)
*** rehrehg
**** description
     This is the classical swap two swapped subroutes.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rehrehg ((select-route r1)
                                        (select-subroute c1 from r1)
                                        (select-route r2)
                                        (select-subroute c2 from r2)
                                        (reverse-subroute c1)
                                        (reverse-subroute c2)
                                        (swap-subroutes c1 c2)))
     #+END_SRC
**** tests
***** testing rehehgs with the macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (bformat t "Testing rehregs")
      (explore-neighborhood-criteria-v2
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc))
        (doreverse-subroute (c1 wc))
        ;; (doselect-route (r2 wc))
        (doselect-subroute (c2 r1 wc
           ;; :ex-cond (or
           ;;           (and ;; debug exclude if |c1| = 1 and |c2| = 1
           ;;            (= c1.length 1)
           ;;            (= c2.length 1))
           ;;           )
           ))
        (doreverse-subroute (c2 wc))
        (doswap-subroutes (c1 c2 wc)))
       :smart-criterion
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc))
        (doreverse-subroute (c1 wc))
        ;; (doselect-route (r2 wc))
        (doselect-subroute (c2 r1 wc
           :ex-cond               
           (or
            ;; (and ;; debug exclude if |c1| = 1 or |c2| > 1
            ;;  (= c1.length 1)
            ;;  (= c2.length 1))
            (or ;; the general constraints
       
             (and ;; |c1| = |c2| = 1
              (= c1.length 1)
              (= c2.length 1)
              (or ;; the constraints here
               ;; c2 should be selected after c1
               (< c2.position c1.position)
               ;; probably the pivoting effect
               (or ;; pivoting effect
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1)))
               ))
             (and ;; |c1| = 1 and |c2| > 1
              (= c1.length 1)
              (> c2.length 1)
              (or ;; pivoting and symmetric effects
               ;; c1.pos < c2.pos
               (= c2.position
                  (+ c1.position 1))
               ;; c1.pos > c2.pos
               (= c2.position
                  (- c1.position c2.length 1))
               ;; let's remove the symmetric repetitions
               (= c2.position
                  (- c1.position c2.length))
               ))
             (and ;; |c1| > 1 and |c2| = 1
              (> c1.length 1)
              (= c2.length 1)
              (or
               (or ;; pivot and symmetry
                ;; the first two remove the "pivoting effect"
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1))
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (- c1.position 2))
                ;; ;; and this one removes the
                ;; ;; symmetry effect
                (= c2.position
                   (- c1.position 1)))
               (or ;; don't append to end of a subroute
                (= c2.position c1.position))
               (or ;; the anti pivot??? :-/
                ;; c2 > c1
                (/= c2.position
                   (+ c1.position 1))
                ;; c2 < c1
                (/= c2.position
                   (- c1.position 2)))))
             (and ;; |c1| > 1 and |c2| > 1
              (> c1.length 1)
              (> c2.length 1)
              (or ;; the constraints here
               (or ;; pivoting effect
                ;; this is the case where c2.pos < c1.pos
                (= c2.position
                   (- c1.position c2.length 1))
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1)))
               (or  ;; "don't touch me! (if we are both subroutes)"
                (and ;; c1.pos <= c2.pos
                 (>= c2.position c1.position)
                 (= c2.position c1.position))
                (and ;; c1.pos >= c2.pos
                 (<= c2.position c1.position)
                 (= (+ c2.position c2.length)
                    c1.position)))
               (or ;; the anti pivot??? :-/
                 ;; let's remove the second one when c2 > c1
                 (> c2.position
                    (+ c1.position 1)))
               ))))))
  
        (doreverse-subroute (c2 wc))
        (doswap-subroutes (c1 c2 wc)))

       :name-for-bformat 'rerehgs
       :smart-version-info
       ((subroute-selected-at-operation c1 wc)
        (subroute-selected-at-operation c2 wc))
       :solution ((1 2 3 4 5 6 7 8 9 10))
       :print-difference t
       :print-intersection nil
       :show-intersection nil
       :print-neighborhood nil
       :print-smart-neighborhood nil
       :print-smart-repeated all
       )
      #+END_SRC
    
***** testing rehrehgs with the macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (bformat t "Testing rehrehgs")
      (explore-neighborhood-criteria-v2
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc))
        (doreverse-subroute (c1 wc))
        (doselect-route (r2 wc))
        (doselect-subroute (c2 r2 wc
           ;; :ex-cond (or
           ;;           (and ;; debug exclude if |c1| = 1 and |c2| = 1
           ;;            (= c1.length 1)
           ;;            (= c2.length 1))
           ;;           )
           ))
        (doreverse-subroute (c2 wc))
        (doswap-subroutes (c1 c2 wc)))
       :smart-criterion
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc))
        (doreverse-subroute (c1 wc))
        (doselect-route (r2 wc))
        (doselect-subroute (c2 r2 wc
           :ex-cond               
           (or
            (and ;; let's exclude the case c2.pos < c1.pos
             (< r2 r1))
            ;; else both subroutes are from the same route
            (and
             (= r1 r2)
             (or   ;; the general constraints
              (and ;; |c1| = |c2| = 1
               (= c1.length 1)
               (= c2.length 1)
               (or ;; the constraints here
                ;; c2 should be selected after c1
                (< c2.position c1.position)
                ;; probably the pivoting effect
                (or ;; pivoting effect
                 ;; this is the case where c2.pos > c1.pos
                 (= c2.position
                    (+ c1.position 1)))
                ))
              (and ;; |c1| = 1 and |c2| > 1
               (= c1.length 1)
               (> c2.length 1)
               (or ;; pivoting and symmetric effects
                ;; c1.pos < c2.pos
                (= c2.position
                   (+ c1.position 1))
                ;; c1.pos > c2.pos
                (= c2.position
                   (- c1.position c2.length 1))
                ;; let's remove the symmetric repetitions
                (= c2.position
                   (- c1.position c2.length))
                ))
              (and ;; |c1| > 1 and |c2| = 1
               (> c1.length 1)
               (= c2.length 1)
               (or
                (or ;; pivot and symmetry
                 ;; the first two remove the "pivoting effect"
                 ;; this is the case where c2.pos > c1.pos
                 (= c2.position
                    (+ c1.position 1))
                 ;; this is the case where c2.pos > c1.pos
                 (= c2.position
                    (- c1.position 2))
                 ;; ;; and this one removes the
                 ;; ;; symmetry effect
                 (= c2.position
                    (- c1.position 1)))
                (or ;; don't append to end of a subroute
                 (= c2.position c1.position))
                (or ;; the anti pivot??? :-/
                 ;; c2 > c1
                 (/= c2.position
                     (+ c1.position 1))
                 ;; c2 < c1
                 (/= c2.position
                     (- c1.position 2)))))
              (and ;; |c1| > 1 and |c2| > 1
               (> c1.length 1)
               (> c2.length 1)
               (or  ;; the constraints here
                (or ;; pivoting effect
                 ;; this is the case where c2.pos < c1.pos
                 (= c2.position
                    (- c1.position c2.length 1))
                 ;; this is the case where c2.pos > c1.pos
                 (= c2.position
                    (+ c1.position 1)))
                (or   ;; "don't touch me! (if we are both subroutes)"
                 (and ;; c1.pos <= c2.pos
                  (>= c2.position c1.position)
                  (= c2.position c1.position))
                 (and ;; c1.pos >= c2.pos
                  (<= c2.position c1.position)
                  (= (+ c2.position c2.length)
                     c1.position)))
                (or ;; the anti pivot??? :-/
                 ;; let's remove the second one when c2 > c1
                 (> c2.position
                    (+ c1.position 1)))
                )))))))

        (doreverse-subroute (c2 wc))
        (doswap-subroutes (c1 c2 wc)))

       :name-for-bformat 'rerehgs
       :smart-version-info
       ((subroute-selected-at-operation c1 wc)
        (subroute-selected-at-operation c2 wc))
       :solution ((1 2 3 4 5 6) (7 8 9 10 11 12) (13 14 15 16 17 18))
       :print-difference t
       :print-intersection nil
       :show-intersection nil
       :print-neighborhood nil
       :print-smart-neighborhood nil
       :print-smart-repeated all
       )
      #+END_SRC
    
*** rehrehg (smart)
**** description
     This is the smart version of the classical swap two reversed subroutes.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rehrehgs
        ((select-route r1)
         (select-subroute c1 from r1)
         (reverse-subroute c1)
         (select-route r2 :ge r1)
         (select-subroute c2 from r2
            :ex-cond               
            (or
             ;; both subroutes are from the same route
             ;; because we exclude the situation
             ;; r2 < r1 in the selection of r2.
             (and
              (= r1 r2)
              (or ;; the general constraints
               (and ;; |c1| = |c2| = 1
                (= c1.length 1)
                (= c2.length 1)
                (or ;; the constraints here
                 ;; c2 should be selected after c1
                 (< c2.position c1.position)
                 (or ;; pivoting effect
                  ;; this is the case where c2.pos > c1.pos
                  ;; (the case c2.pos < c1.pos is excluded
                  ;; in the previous "or")
                  (= c2.position
                     (+ c1.position 1)))))
               (and ;; |c1| = 1 and |c2| > 1
                (= c1.length 1)
                (> c2.length 1)
                (or ;; pivoting and symmetric effects
                 ;; c1.pos < c2.pos
                 (= c2.position
                    (+ c1.position 1))
                 ;; c1.pos > c2.pos
                 (= c2.position
                    (- c1.position c2.length 1))
                 ;; let's remove the symmetric repetitions
                 (= c2.position
                    (- c1.position c2.length))
                 ))
               (and ;; |c1| > 1 and |c2| = 1
                (> c1.length 1)
                (= c2.length 1)
                (or ;; the constraints here
                 (or ;; pivot and symmetry
                  ;; the first two remove the "pivoting effect"
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (- c1.position 2))
                  ;; ;; and this one removes the
                  ;; ;; symmetry effect
                  (= c2.position
                     (- c1.position 1)))
                 (or ;; don't append to end of a subroute
                  (= c2.position c1.position))
                 (or ;; the anti pivot??? :-/
                  ;; c2 > c1
                  (/= c2.position
                      (+ c1.position 1))
                  ;; c2 < c1
                  (/= c2.position
                      (- c1.position 2)))))
               (and ;; |c1| > 1 and |c2| > 1
                (> c1.length 1)
                (> c2.length 1)
                (or ;; the constraints here
                 (or ;; pivoting effect
                  ;; this is the case where c2.pos < c1.pos
                  (= c2.position
                     (- c1.position c2.length 1))
                  ;; this is the case where c2.pos > c1.pos
                  (= c2.position
                     (+ c1.position 1)))
                 (or ;; "don't touch me! (if we are both subroutes)"
                  (and ;; c1.pos <= c2.pos
                   (>= c2.position c1.position)
                   (= c2.position c1.position))
                  (and ;; c1.pos >= c2.pos
                   (<= c2.position c1.position)
                   (= (+ c2.position c2.length)
                      c1.position)))
                 (or ;; the anti pivot??? :-/
                  ;; let's remove the second one when c2 > c1
                  (> c2.position
                     (+ c1.position 1)))
                 ))))))
         (reverse-subroute c2)
         (swap-subroutes c1 c2)))
     #+END_SRC
**** tests
***** testing rehehgs with the macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (bformat t "Testing rehregs")
      (explore-neighborhood-criteria-v2
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc))
        (doreverse-subroute (c1 wc))
        ;; (doselect-route (r2 wc))
        (doselect-subroute (c2 r1 wc
           ;; :ex-cond (or
           ;;           (and ;; debug exclude if |c1| = 1 and |c2| = 1
           ;;            (= c1.length 1)
           ;;            (= c2.length 1))
           ;;           )
           ))
        (doreverse-subroute (c2 wc))
        (doswap-subroutes (c1 c2 wc)))
       :smart-criterion
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc))
        (doreverse-subroute (c1 wc))
        ;; (doselect-route (r2 wc))
        (doselect-subroute (c2 r1 wc
           :ex-cond               
           (or
            ;; (and ;; debug exclude if |c1| = 1 or |c2| > 1
            ;;  (= c1.length 1)
            ;;  (= c2.length 1))
            (or ;; the general constraints
       
             (and ;; |c1| = |c2| = 1
              (= c1.length 1)
              (= c2.length 1)
              (or ;; the constraints here
               ;; c2 should be selected after c1
               (< c2.position c1.position)
               ;; probably the pivoting effect
               (or ;; pivoting effect
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1)))
               ))
             (and ;; |c1| = 1 and |c2| > 1
              (= c1.length 1)
              (> c2.length 1)
              (or ;; pivoting and symmetric effects
               ;; c1.pos < c2.pos
               (= c2.position
                  (+ c1.position 1))
               ;; c1.pos > c2.pos
               (= c2.position
                  (- c1.position c2.length 1))
               ;; let's remove the symmetric repetitions
               (= c2.position
                  (- c1.position c2.length))
               ))
             (and ;; |c1| > 1 and |c2| = 1
              (> c1.length 1)
              (= c2.length 1)
              (or
               (or ;; pivot and symmetry
                ;; the first two remove the "pivoting effect"
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1))
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (- c1.position 2))
                ;; ;; and this one removes the
                ;; ;; symmetry effect
                (= c2.position
                   (- c1.position 1)))
               (or ;; don't append to end of a subroute
                (= c2.position c1.position))
               (or ;; the anti pivot??? :-/
                ;; c2 > c1
                (/= c2.position
                   (+ c1.position 1))
                ;; c2 < c1
                (/= c2.position
                   (- c1.position 2)))))
             (and ;; |c1| > 1 and |c2| > 1
              (> c1.length 1)
              (> c2.length 1)
              (or ;; the constraints here
               (or ;; pivoting effect
                ;; this is the case where c2.pos < c1.pos
                (= c2.position
                   (- c1.position c2.length 1))
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1)))
               (or  ;; "don't touch me! (if we are both subroutes)"
                (and ;; c1.pos <= c2.pos
                 (>= c2.position c1.position)
                 (= c2.position c1.position))
                (and ;; c1.pos >= c2.pos
                 (<= c2.position c1.position)
                 (= (+ c2.position c2.length)
                    c1.position)))
               (or ;; the anti pivot??? :-/
                 ;; let's remove the second one when c2 > c1
                 (> c2.position
                    (+ c1.position 1)))
               ))))))
  
        (doreverse-subroute (c2 wc))
        (doswap-subroutes (c1 c2 wc)))

       :name-for-bformat 'rerehgs
       :smart-version-info
       ((subroute-selected-at-operation c1 wc)
        (subroute-selected-at-operation c2 wc))
       :solution ((1 2 3 4 5 6 7 8 9 10))
       :print-difference t
       :print-intersection nil
       :show-intersection nil
       :print-neighborhood nil
       :print-smart-neighborhood nil
       :print-smart-repeated all
       )
      #+END_SRC
    
***** testing rehrehgs with the macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (progn
        (bformat t "Testing rehrehgs")
        (explore-neighborhood-criteria-v2
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doreverse-subroute (c1 wc))
          (doselect-route (r2 wc))
          (doselect-subroute (c2 r2 wc))
          (doreverse-subroute (c2 wc))
          (doswap-subroutes (c1 c2 wc)))
         :smart-criterion
         ((doselect-route (r1 wc))
          (doselect-subroute (c1 r1 wc))
          (doreverse-subroute (c1 wc))
          (doselect-route (r2 wc :ge r1))
          (doselect-subroute (c2 r2 wc
             :ex-cond               
             (or
              ;; both subroutes are from the same route
              ;; because we exclude the situation
              ;; r2 < r1 in the selection of r2.
              (and
               (= r1 r2)
               (or                       ;; the general constraints
                (and                     ;; |c1| = |c2| = 1
                 (= c1.length 1)
                 (= c2.length 1)
                 (or ;; the constraints here
                  ;; c2 should be selected after c1
                  (< c2.position c1.position)
                  (or ;; pivoting effect
                   ;; this is the case where c2.pos > c1.pos
                   ;; (the case c2.pos < c1.pos is excluded
                   ;; in the previous "or")
                   (= c2.position
                      (+ c1.position 1)))))
                (and ;; |c1| = 1 and |c2| > 1
                 (= c1.length 1)
                 (> c2.length 1)
                 (or ;; pivoting and symmetric effects
                  ;; c1.pos < c2.pos
                  (= c2.position
                     (+ c1.position 1))
                  ;; c1.pos > c2.pos
                  (= c2.position
                     (- c1.position c2.length 1))
                  ;; let's remove the symmetric repetitions
                  (= c2.position
                     (- c1.position c2.length))
                  ))
                (and ;; |c1| > 1 and |c2| = 1
                 (> c1.length 1)
                 (= c2.length 1)
                 (or ;; the constraints here
                  (or ;; pivot and symmetry
                   ;; the first two remove the "pivoting effect"
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (- c1.position 2))
                   ;; ;; and this one removes the
                   ;; ;; symmetry effect
                   (= c2.position
                      (- c1.position 1)))
                  (or ;; don't append to end of a subroute
                   (= c2.position c1.position))
                  (or ;; the anti pivot??? :-/
                   ;; c2 > c1
                   (/= c2.position
                       (+ c1.position 1))
                   ;; c2 < c1
                   (/= c2.position
                       (- c1.position 2)))))
                (and ;; |c1| > 1 and |c2| > 1
                 (> c1.length 1)
                 (> c2.length 1)
                 (or ;; the constraints here
                  (or ;; pivoting effect
                   ;; this is the case where c2.pos < c1.pos
                   (= c2.position
                      (- c1.position c2.length 1))
                   ;; this is the case where c2.pos > c1.pos
                   (= c2.position
                      (+ c1.position 1)))
                  (or ;; "don't touch me! (if we are both subroutes)"
                   (and ;; c1.pos <= c2.pos
                    (>= c2.position c1.position)
                    (= c2.position c1.position))
                   (and ;; c1.pos >= c2.pos
                    (<= c2.position c1.position)
                    (= (+ c2.position c2.length)
                       c1.position)))
                  (or ;; the anti pivot??? :-/
                   ;; let's remove the second one when c2 > c1
                   (> c2.position
                      (+ c1.position 1)))
                  )))))))

          (doreverse-subroute (c2 wc))
          (doswap-subroutes (c1 c2 wc)))

         :name-for-bformat 'rehrehgs
         :smart-version-info
         ((subroute-selected-at-operation c1 wc)
          (subroute-selected-at-operation c2 wc))
         :solution ((1 2 3 4 5 6) (7 8 9 10 11 12) (13 14 15 16 17 18))
         :print-difference t
         :print-intersection nil
         :show-intersection nil
         :print-neighborhood nil
         :print-smart-neighborhood nil
         :print-smart-repeated all
         ))
      #+END_SRC
*** rehrehg*
**** description
     This is the smart* version of the classical swap two reversed subroutes.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rehrehgs*
        ((select-route r1)
         (select-subroute c1 from r1)
         (reverse-subroute c1)
         (select-route r2 :ge r1)
         (select-subroute c2 from r2
            ;; to avoid collisions with rarac
            :lex-cond (or
                       (= c1.length 1)
                       (= c2.length 1))
            :ex-cond               
            (or
             (or     ;; the general constraints
              ;; we have ruled out the following cases:
              ;; |c1| = |c2| = 1 because it is rarac
              ;; |c1| = 1 and |c2| > 1 because it is rerehg
              ;; |c1| > 1 and |c2| = 1 because it is rehreg
              (and ;; |c1| > 1 and |c2| > 1
               (> c1.length 1)
               (> c2.length 1)
               (or    ;; the constraints here
                (or   ;; pivoting effect
                 ;; this is the case where c2.pos < c1.pos
                 (= c2.position
                    (- c1.position c2.length 1))
                 ;; this is the case where c2.pos > c1.pos
                 (= c2.position
                    (+ c1.position 1)))
                (or     ;; "don't touch me! (if we are both subroutes)"
                 (and   ;; c1.pos <= c2.pos
                  (>= c2.position c1.position)
                  (= c2.position c1.position))
                 (and ;; c1.pos >= c2.pos
                  (<= c2.position c1.position)
                  (= (+ c2.position c2.length)
                     c1.position)))
                (or ;; the anti pivot??? :-/
                 ;; let's remove the second one when c2 > c1
                 (> c2.position
                    (+ c1.position 1)))
                )))))
         (reverse-subroute c2)
         (swap-subroutes c1 c2)))
     #+END_SRC
**** tests
***** comparing rerehgs* to rarac +
      #+BEGIN_SRC lisp +n -r :results none :exports code  :tangle ../src/vrp-tests.lisp  
      (with-basic-solution (s1 ((1 2 3 4 5);; (5 6 7 8)
                                ;; (7 8 9 10 11 12)
                                ;; (13 14 5)
                                ))
        (bformat t "Testing rehrehgs* vs rarac")
        (let* ( ;; (criteria-union nil)
               ;; (smart*-neighborhood nil)
               ;; (original-criterion-neighborhood nil)
               (criterion-minus-union nil)
               ;; (criterion-intersertion-union nil)
               ;; (original-criterion-format "[~a, ~a]")

               (ops-list nil)
               (wc (basic-working-copy s1))
               (current-solution nil))

          (prepare-solution-for-neighborhood-exploration wc)
          ;; let's create the original criterion
          ;; and populate the original-criterion-neighborhood
          (doselect-route (r1 wc)
            (doselect-subroute (c1 r1 wc)
              (doreverse-subroute (c1 wc)
               (doselect-route (r2 wc :ge r1)
                 (doselect-subroute (c2 r2 wc
                    :ex-cond               
                    (or
                     ;; both subroutes are from the same route
                     ;; because we exclude the situation
                     ;; r2 < r1 in the selection of r2.
                     (and
                      (= r1 r2)
                      (or ;; the general constraints
                       (and ;; |c1| = |c2| = 1
                        (= c1.length 1)
                        (= c2.length 1)
                        (or ;; the constraints here
                         ;; c2 should be selected after c1
                         (< c2.position c1.position)
                         (or ;; pivoting effect
                          ;; this is the case where c2.pos > c1.pos
                          ;; (the case c2.pos < c1.pos is excluded
                          ;; in the previous "or")
                          (= c2.position
                             (+ c1.position 1)))))
                       (and ;; |c1| = 1 and |c2| > 1
                        (= c1.length 1)
                        (> c2.length 1)
                        (or ;; pivoting and symmetric effects
                         ;; c1.pos < c2.pos
                         (= c2.position
                            (+ c1.position 1))
                         ;; c1.pos > c2.pos
                         (= c2.position
                            (- c1.position c2.length 1))
                         ;; let's remove the symmetric repetitions
                         (= c2.position
                            (- c1.position c2.length))
                         ))
                       (and ;; |c1| > 1 and |c2| = 1
                        (> c1.length 1)
                        (= c2.length 1)
                        (or ;; the constraints here
                         (or ;; pivot and symmetry
                          ;; the first two remove the "pivoting effect"
                          ;; this is the case where c2.pos > c1.pos
                          (= c2.position
                             (+ c1.position 1))
                          ;; this is the case where c2.pos > c1.pos
                          (= c2.position
                             (- c1.position 2))
                          ;; ;; and this one removes the
                          ;; ;; symmetry effect
                          (= c2.position
                             (- c1.position 1)))
                         (or ;; don't append to end of a subroute
                          (= c2.position c1.position))
                         (or ;; the anti pivot??? :-/
                          ;; c2 > c1
                          (/= c2.position
                              (+ c1.position 1))
                          ;; c2 < c1
                          (/= c2.position
                              (- c1.position 2)))))
                       (and ;; |c1| > 1 and |c2| > 1
                        (> c1.length 1)
                        (> c2.length 1)
                        (or ;; the constraints here
                         (or ;; pivoting effect
                          ;; this is the case where c2.pos < c1.pos
                          (= c2.position
                             (- c1.position c2.length 1))
                          ;; this is the case where c2.pos > c1.pos
                          (= c2.position
                             (+ c1.position 1)))
                         (or ;; "don't touch me! (if we are both subroutes)"
                          (and ;; c1.pos <= c2.pos
                           (>= c2.position c1.position)
                           (= c2.position c1.position))
                          (and ;; c1.pos >= c2.pos
                           (<= c2.position c1.position)
                           (= (+ c2.position c2.length)
                              c1.position)))
                         (or ;; the anti pivot??? :-/
                          ;; let's remove the second one when c2 > c1
                          (> c2.position
                             (+ c1.position 1)))
                         ))))))
                   (doreverse-subroute (c2 wc)
                     (doswap-subroutes (c1 c2 wc)
                       ;; here we collect the elements
                       ;; in this neighboorhood
                       (setf current-solution
                             (clone-working-copy-as-solution wc))
                       ;; (if (member current-solution
                       ;;             original-criterion-neighborhood
                       ;;             :test (lambda (x y) (obj= x (first y))))
                       ;;     (error "WTF!!!!"))
                       (push (list (clone current-solution)
                                   (format nil "[~a | ~a]"
                                           (subroute-selected-at-operation c1 wc)
                                           (subroute-selected-at-operation c2 wc)))
                             original-criterion-neighborhood))))))))

          ;; now let's create the criteria union
          ;; to gather all the neighbors from all
          ;; the other criteria, in this case
          ;; the rarac, and rereg.

          ;; here comes rarac
          (doselect-route (r1 wc)
            (doselect-client (c1 r1 wc)
              (doselect-route (r2 wc :ge r1)
                (doselect-client (c2 r2 wc
                   :ge (list r1 c1.select.position))
                  (doswap-clients (c1 c2 wc)
                    ;; let's add the neighbors
                    (setf current-solution
                          (clone-working-copy-as-solution wc))
                    (push (list current-solution
                                (format nil "rehreg: [~a, ~a]"
                                        (client-selected-at-operation c1 wc)
                                        (client-selected-at-operation c2 wc)))
                          smart*-neighborhood))))))

          ;; ;; here comes rehreg
          (doselect-route (r1 wc)
            (doselect-subroute (c1 r1 wc)
              (doreverse-subroute (c1 wc)
               (doselect-route (r1 wc)
                 (doselect-route (r2 wc :ge r1)
                   (doselect-subroute (c2 r2 wc
                      :ex-cond               
                      (or
                                           (and ;; both routes with length 1 and r1 < r2
                                            (= c1.length c2.length 1)
                                            (< r1 r2)
                                            )
                                           (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
                                            (= c1.length c2.length 1)
                                            (= r1 r2)
                                            (< c2.position c1.position))
                                           ;; we'll only apply the constraints
                                           ;; if we are in the same route
                                           (and
                                            (= r1 r2)
                                            (or
                                             ;; we'll split the analysis in several cases
                                             ;; that I'll write in the comments
                                             ;; |c1| = 1 and |c2| = 1
                                             (and ;; these are the case where both length are 1
                                              (= c1.length 1)
                                              (= c2.length 1)
                                              (or ;; pivoting effect
                                               ;; the first two remove the "pivoting effect"
                                               ;; this is the case where c2.pos > c1.pos
                                               (= c2.position
                                                  (+ c1.position 1))
                                               ;; this is the case where c2.pos > c1.pos
                                               (= c2.position
                                                  (- c1.position 2))))

                                             ;; |c1| = 1 and |c2| > 1 
                                             (and
                                              (= c1.length 1)
                                              (> c2.length 1)
                                              (or
                                               (and ;; don't go pass me
                                                (< c2.position c1.position)
                                                (>= (1-
                                                     (+ c2.position c2.length))
                                                    c1.position))
                                               (or ;; pivoting effect
                                                ;; the first two remove the "pivoting effect"
                                                ;; this is the case where c2.pos < c1.pos
                                                (= c2.position
                                                   (- c1.position c2.length 1))
                                                ;; this is the case where c2.pos > c1.pos
                                                (= c2.position
                                                   (+ c1.position 1)))))
                                             ;; TODO |c1| > 1 and |c2| = 1
                                             (and
                                              (> c1.length 1)
                                              (= c2.length 1)
                                              (or ;; pivot and symmetry
                                               ;; the first two remove the "pivoting effect"
                                               ;; this is the case where c2.pos > c1.pos
                                               (= c2.position
                                                  (+ c1.position 1))
                                               ;; this is the case where c2.pos > c1.pos
                                               (= c2.position
                                                  (- c1.position 2))
                                               ;; and this one removes the
                                               ;; symmetry effect
                                               (= c2.position
                                                  (- c1.position 1))))
                                             ;; |c1| > 1 and |c2| > 1
                                             (and
                                              (> c1.length 1)
                                              (> c2.length 1)
                                              (or
                                               (and ;; don't go beyond me!
                                                (< c2.position c1.position)
                                                (>= (1- (+ c2.position c2.length))
                                                    c1.position))
                                               (or ;; pivoting effect  
                                                ;; this is the case where c2.pos < c1.pos
                                                (= c2.position
                                                   (- c1.position c2.length 1))
                                                ;; this is the case where c2.pos > c1.pos
                                                (= c2.position
                                                   (+ c1.position 1)))))
                                             ))))
             
                     (doswap-subroutes (c1 c2 wc)
                       ;; let's add the neighbors
                       (setf current-solution
                             (clone-working-copy-as-solution wc))
                       (push (list current-solution
                                   (format nil "rehreg: [~a | ~a]."
                                           (subroute-selected-at-operation c1 wc)
                                           (subroute-selected-at-operation c2 wc)))
                             smart*-neighborhood))))))))

          ;; ;; here comes rerehg
          (doselect-route (r1 wc)
            (doselect-subroute (c1 r1 wc)
               (doselect-route (r1 wc)
                 (doselect-route (r2 wc :ge r1)
                   (doselect-subroute (c2 r2 wc
                      :ex-cond               
                      (or
                       ;; if both subroutes have length 1
                       ;; exclude if r2 < r1
                       (and
                        (= c1.length c2.length 1)
                        (< r2 r1))
                       ;; let's apply the following rules
                       ;; if both subroutes are selected
                       ;; from the same route
                       (and ;; both subroutes are from the same subroute
                        (= r1 r2)
                        (or ;; let's analyze all the cases
                         (and ;; |c1| = |c2| = 1
                          (= c1.length 1)
                          (= c2.length 1)
                          (or
                           ;; c2 is "before" c1
                           (< c2.position c1.position)
                           (or ;; exclued the pivoting effect
                            ;; c1.pos < c2.pos
                            (= c2.position
                               (+ c1.position 1)))))
                         (and ;; |c1| = 1, |c2| > 1
                          (= c1.length 1)
                          (> c2.length 1)
                          ;; let's remove the pivoting effect
                          (or ;; pivoting and symmetric effect
                           ;; c1.pos < c2.pos
                           (= c2.position
                              (+ c1.position 1))
                           ;; c1.pos > c2.pos
                           (= c2.position
                              (- c1.position c2.length 1))
                           ;; let's remove the symmetric repetitions
                           (= c2.position
                              (- c1.position c2.length)))




                          )
                         (and ;; |c1| > 1, |c2| = 1
                          ;; there are not repetitions in this case :-o
                          ;; I tested up to 10 clients
                          ;; but when we mix it with the other
                          ;; cases, some repeated elements appear :-/
                          ;; so we should remove the pivoting effect
                          (and
                           (> c1.length 1)
                           (= c2.length 1)
                           (or ;; let's remove the pivoting effect
                            ;; this is the case where c2.pos > c1.pos
                            (= c2.position
                               (+ c1.position 1))         
                            ;; this is the case where c2.pos < c1.pos
                            (= c2.position
                               (- c1.position c2.length 1))
                            ;; and this one is for the symmetric effect
                            (= c2.position
                               (- c1.position 1)))))
                         (and ;; |c1| > 1, |c2| > 1
                          (> c1.length 1)
                          (> c2.length 1)
                          (or ;; let's analyze the possible problems

                           (and ;; don't stop before me
                            ;;  ;; It worked!!!
                            ;;  ;; Now Iosvanny must find out why :-o
                            (< c2.position c1.position)

                            (= (+ c2.position c2.length)
                               c1.position))

                           (or ;; let's remove the pivoting effect
                            ;; this is the case where c2.pos > c1.pos
                            (= c2.position
                               (+ c1.position 1))         
                            ;; this is the case where c2.pos < c1.pos
                            (= c2.position
                               (- c1.position c2.length 1)))
                           ))))))
                     (doreverse-subroute (c2 wc)
                       (doswap-subroutes (c1 c2 wc)
                         ;; let's add the neighbors
                         (setf current-solution
                               (clone-working-copy-as-solution wc))
                         (push (list current-solution
                                     (format nil "rerehg: [~a | ~a]."
                                             (subroute-selected-at-operation c1 wc)
                                             (subroute-selected-at-operation c2 wc)))
                               smart*-neighborhood))))))))

          ;; here is the smart* version of rehrehg
          (doselect-route (r1 wc)
            (doselect-subroute (c1 r1 wc)
              (doreverse-subroute (c1 wc)
               (doselect-route (r2 wc :ge r1)
                 (doselect-subroute (c2 r2 wc
                    ;; to avoid collisions with rarac
                    :lex-cond (or
                      (= c1.length 1)
                      (= c2.length 1))
                    :ex-cond               
                    (or
                     (or ;; the general constraints
                      ;; we'll rule out the following cases
                      ;; |c1| = |c2| = 1 because it is rarac
                      ;; |c1| = 1 and |c2| > 1 because it is rerehg
                      ;; |c1| > 1 and |c2| = 1 because it is rehreg
                      (and ;; |c1| > 1 and |c2| > 1
                       (> c1.length 1)
                       (> c2.length 1)
                       (or ;; the constraints here
                        (or ;; pivoting effect
                         ;; this is the case where c2.pos < c1.pos
                         (= c2.position
                            (- c1.position c2.length 1))
                         ;; this is the case where c2.pos > c1.pos
                         (= c2.position
                            (+ c1.position 1)))
                        (or ;; "don't touch me! (if we are both subroutes)"
                         (and ;; c1.pos <= c2.pos
                          (>= c2.position c1.position)
                          (= c2.position c1.position))
                         (and ;; c1.pos >= c2.pos
                          (<= c2.position c1.position)
                          (= (+ c2.position c2.length)
                             c1.position)))
                        (or ;; the anti pivot??? :-/
                         ;; let's remove the second one when c2 > c1
                         (> c2.position
                            (+ c1.position 1)))
                        ))))) 
                   (doreverse-subroute (c2 wc)
                     (doswap-subroutes (c1 c2 wc)
                       ;; let's add the neighbors
                       (setf current-solution
                             (clone-working-copy-as-solution wc))
                       (push (list current-solution
                                   (format nil "rehrehgs*: [~a | ~a]."
                                           (subroute-selected-at-operation c1 wc)
                                           (subroute-selected-at-operation c2 wc)))
                             smart*-neighborhood))))))))

          ;; let's compute the difference
          (setf criterion-minus-union
                (set-difference original-criterion-neighborhood
                                smart*-neighborhood
                                :test (lambda (x y)
                                        (obj= (first x)
                                              (first y)))))


          (setf criterion-minus-union
                (reverse criterion-minus-union))

    

          (format t "Missing elements ~a"
                  (length criterion-minus-union))
          (if (> (length criterion-minus-union) 0)
              (format t ":~%~{~a~%~}"
                      criterion-minus-union)
              (format t ".~%"))
          ))
      #+END_SRC
***** comparing rehehgs with rarac
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (bformat t "Testing rehrehgs vs rarac")
      (explore-neighborhood-criteria-v2
       ((doselect-route (r1 wc))
        (doselect-client (c1 r1 wc))
        (doselect-route (r2 wc :ge r1))
        (doselect-client (c2 r2 wc
           :ge (list r1 c1.select.position)))
        (doswap-clients (c1 c2 wc)))
       :smart-criterion
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc ))
        (doreverse-subroute (c1 wc))
        (doselect-route (r1 wc :ge r1))
        (doselect-subroute (c2 r1 wc
           :lex-cond (and
                      (= c1.length 1)
                      (= c2.length 1))
           :ex-cond               
           (or
      

            (or ;; the general constraints

             ;; |c1| = |c2| = 1 is rarac
             (and ;; |c1| = 1 and |c2| > 1
              (= c1.length 1)
              (> c2.length 1)
              (or ;; pivoting and symmetric effects
               ;; c1.pos < c2.pos
               (= c2.position
                  (+ c1.position 1))
               ;; c1.pos > c2.pos
               (= c2.position
                  (- c1.position c2.length 1))
               ;; let's remove the symmetric repetitions
               (= c2.position
                  (- c1.position c2.length))
               ))
             (and ;; |c1| > 1 and |c2| = 1
              (> c1.length 1)
              (= c2.length 1)
              (or
               (or ;; pivot and symmetry
                ;; the first two remove the "pivoting effect"
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1))
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (- c1.position 2))
                ;; ;; and this one removes the
                ;; ;; symmetry effect
                (= c2.position
                   (- c1.position 1)))
               (or ;; don't append to end of a subroute
                (= c2.position c1.position))
               (or ;; the anti pivot??? :-/
                ;; c2 > c1
                (/= c2.position
                    (+ c1.position 1))
                ;; c2 < c1
                (/= c2.position
                    (- c1.position 2)))))
             (and ;; |c1| > 1 and |c2| > 1
              (> c1.length 1)
              (> c2.length 1)
              (or  ;; the constraints here
               (or ;; pivoting effect
                ;; this is the case where c2.pos < c1.pos
                (= c2.position
                   (- c1.position c2.length 1))
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1)))
               (or   ;; "don't touch me! (if we are both subroutes)"
                (and ;; c1.pos <= c2.pos
                 (>= c2.position c1.position)
                 (= c2.position c1.position))
                (and ;; c1.pos >= c2.pos
                 (<= c2.position c1.position)
                 (= (+ c2.position c2.length)
                    c1.position)))
               (or ;; the anti pivot??? :-/
                ;; let's remove the second one when c2 > c1
                (> c2.position
                   (+ c1.position 1)))
               ))))))

        (doreverse-subroute (c2 wc))
        (doswap-subroutes (c1 c2 wc)))

       :name-for-bformat 'rerehgs
       :smart-version-info
       ((subroute-selected-at-operation c1 wc)
        (subroute-selected-at-operation c2 wc))
       :solution ((1 2 3 4 5 6) (7 8 9 10 11 12)
                  ;; (13 14 15 16 17 18)
                  )
       :print-difference nil
       :print-intersection nil
       :show-intersection t
       :print-smart-intersection t
       :print-neighborhood nil
       :print-smart-neighborhood nil
       :print-smart-repeated nil
       )
      #+END_SRC
***** comparing rehehgs with rehreg
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (bformat t "Testing rehrehgs vs rehreg")
      (explore-neighborhood-criteria-v2
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc
          ;; if c1.length is 1 then we don't
          ;; reverse anything and all those
          ;; neighboors were explored in rereg
          :ldt 1))
        (doselect-route (r2 wc))
        (doselect-subroute (c2 r2 wc
          ;; to avoid collisions with rarac
          ;; don't select both subroutes with length 1
          :lex-cond (= c1.length c2.length 1)
          ;; ;; but also we should not select c2
          ;; ;; right where c1 ends, if c1.length is 2
          ;; ;; I'm adding this constraint
          ;; ;; to the ex-cond


          ;; to avoid collisions with itself
          :ex-cond               
          (or
           (and ;; avoid other collisions with rarac
            ;; we should avoid the case
            ;; when c1.length is 2, and c2.length is 1
            ;; and we are in the same route, and c2 is
            ;; selected from the same place as c1
            ;; this is the same as rarac
            (= r1 r2)
            (= c1.length 2)
            (= c2.length 1)
            (= c2.position c1.position))
           ;; from here on is to avoid collisions with itself
           ;; (and ;; |c1| = |c2| = 1, r1 = r2, and c2 < c1
           ;;  (= c1.length c2.length 1)
           ;;  (= r1 r2)
           ;;  (< c2.position c1.position))
           ;; we'll only apply the constraints
           ;; if we are in the same route
           (and
            (= r1 r2)
            (or
             ;; we'll split the analysis in several cases
             ;; that I'll write in the comments.
             ;; The first case is
             ;; |c1| = 1 and |c2| = 1 and there is
             ;; no need to analyze this because
             ;; we have already ruled out this case
             ;; to avoid collisions with rarac

             ;; |c1| = 1 and |c2| > 1 
             ;; no need to analyze this because
             ;; we have already ruled out this case
             ;; to avoid collisions with rereg


             (and ;; |c1| > 1 and |c2| = 1
              (> c1.length 1)
              (= c2.length 1)
              (or ;; pivot and symmetry [to avoid collisions with self]
               ;; the first two remove the "pivoting effect"
               ;; this is the case where c2.pos > c1.pos
               (= c2.position
                  (+ c1.position 1))
               ;; this is the case where c2.pos > c1.pos
               (= c2.position
                  (- c1.position 2))
               ;; and this one removes the
               ;; symmetry effect
               (= c2.position
                  (- c1.position 1)))
              )

             ;; |c1| > 1 and |c2| > 1
             (and
              (> c1.length 1)
              (> c2.length 1)
              (or                        ;; to avoid collisions with self
               (and ;; don't go beyond me! to avoid collisions with self
                (< c2.position c1.position)
                (>= (1- (+ c2.position c2.length))
                    c1.position))
               (or ;; pivoting effect to avoid collision with self
                ;; this is the case where c2.pos < c1.pos
                (= c2.position
                   (- c1.position c2.length 1))
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1)))
               (or ;; pivoting effect to avoid collision with rereg
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   c1.position)
                ;; this is the case where c2.pos < c1.pos
                ;; (= c1.position
                ;;    (+ c2.position c2.length))
                ))
              ))))))
        (doreverse-subroute (c1 wc))
        (doswap-subroutes (c1 c2 wc)))
       :smart-criterion
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc ))
        (doreverse-subroute (c1 wc))
        (doselect-route (r2 wc :ge r1))
        (doselect-subroute (c2 r2 wc
           :lex-cond (or
                      (= c1.length 1)
                      (= c2.length 1))
           :ex-cond               
           (or

            (or ;; the general constraints
             ;; this is rarac
             ;; |c1| = |c2| = 1 is rarac
             ;; |c1| = 1 and |c2| > 1 is rerehg
             ;; |c1| > 1 and |c2| = 1 is rehreg
             (and ;; |c1| > 1 and |c2| > 1
              (> c1.length 1)
              (> c2.length 1)
              (or  ;; the constraints here
               (or ;; pivoting effect
                ;; this is the case where c2.pos < c1.pos
                (= c2.position
                   (- c1.position c2.length 1))
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1)))
               (or   ;; "don't touch me! (if we are both subroutes)"
                (and ;; c1.pos <= c2.pos
                 (>= c2.position c1.position)
                 (= c2.position c1.position))
                (and ;; c1.pos >= c2.pos
                 (<= c2.position c1.position)
                 (= (+ c2.position c2.length)
                    c1.position)))
               (or ;; the anti pivot??? :-/
                ;; let's remove the second one when c2 > c1
                (> c2.position
                   (+ c1.position 1)))
               ))))))

        (doreverse-subroute (c2 wc))
        (doswap-subroutes (c1 c2 wc)))

       :name-for-bformat 'rerehgs
       :smart-version-info
       ((subroute-selected-at-operation c1 wc)
        (subroute-selected-at-operation c2 wc))
       :solution ((1 2 3 4 5 6) (7 8 9 10 11 12)
                  ;; (13 14 15 16 17 18)
                  )
       :print-difference nil
       :print-intersection nil
       :show-intersection t
       :print-smart-intersection t
       :print-neighborhood nil
       :print-smart-neighborhood nil
       :print-smart-repeated nil
       )
      #+END_SRC
***** comparing rehehgs with rerehg
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (bformat t "Testing rehrehgs vs rehreg")
      (explore-neighborhood-criteria-v2
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc))
        (doselect-route (r2 wc))
        (doselect-subroute (c2 r2 wc
           :ex-cond               
           (or
            ;; if both subroutes have length 1
            ;; exclude if r2 < r1
            (and
             (= c1.length c2.length 1)
             (< r2 r1))
            ;; let's apply the following rules
            ;; if both subroutes are selected
            ;; from the same route
            (and ;; both subroutes are from the same subroute
             (= r1 r2)
             (or ;; let's analyze all the cases
              (and ;; |c1| = |c2| = 1
               (= c1.length 1)
               (= c2.length 1)
               (or
                ;; c2 is "before" c1
                (< c2.position c1.position)
                (or ;; exclued the pivoting effect
                 ;; c1.pos < c2.pos
                 (= c2.position
                    (+ c1.position 1)))))
              (and ;; |c1| = 1, |c2| > 1
               (= c1.length 1)
               (> c2.length 1)
               ;; let's remove the pivoting effect
               (or ;; pivoting and symmetric effect
                ;; c1.pos < c2.pos
                (= c2.position
                   (+ c1.position 1))
                ;; c1.pos > c2.pos
                (= c2.position
                   (- c1.position c2.length 1))
                ;; let's remove the symmetric repetitions
                (= c2.position
                   (- c1.position c2.length)))




               )
              (and ;; |c1| > 1, |c2| = 1
               ;; there are not repetitions in this case :-o
               ;; I tested up to 10 clients
               ;; but when we mix it with the other
               ;; cases, some repeated elements appear :-/
               ;; so we should remove the pivoting effect
               (and
                (> c1.length 1)
                (= c2.length 1)
                (or ;; let's remove the pivoting effect
                 ;; this is the case where c2.pos > c1.pos
                 (= c2.position
                    (+ c1.position 1))         
                 ;; this is the case where c2.pos < c1.pos
                 (= c2.position
                    (- c1.position c2.length 1))
                 ;; and this one is for the symmetric effect
                 (= c2.position
                    (- c1.position 1)))))
              (and ;; |c1| > 1, |c2| > 1
               (> c1.length 1)
               (> c2.length 1)
               (or ;; let's analyze the possible problems

                (and ;; don't stop before me
                 ;;  ;; It worked!!!
                 ;;  ;; Now Iosvanny must find out why :-o
                 (< c2.position c1.position)

                 (= (+ c2.position c2.length)
                    c1.position))

                (or ;; let's remove the pivoting effect
                 ;; this is the case where c2.pos > c1.pos
                 (= c2.position
                    (+ c1.position 1))         
                 ;; this is the case where c2.pos < c1.pos
                 (= c2.position
                    (- c1.position c2.length 1)))
                )))))))
        (doreverse-subroute (c2 wc))
        (doswap-subroutes (c1 c2 wc)))
       :smart-criterion
       ((doselect-route (r1 wc))
        (doselect-subroute (c1 r1 wc ))
        (doreverse-subroute (c1 wc))
        (doselect-route (r2 wc :ge r1))
        (doselect-subroute (c2 r2 wc
           :lex-cond (or
                      (= c1.length 1)
                      (= c2.length 1))
           :ex-cond               
           (or

            (or ;; the general constraints
             ;; this is rarac
             ;; |c1| = |c2| = 1 is rarac
             ;; |c1| = 1 and |c2| > 1 is rerehg
             ;; |c1| > 1 and |c2| = 1 is rehreg
             (and ;; |c1| > 1 and |c2| > 1
              (> c1.length 1)
              (> c2.length 1)
              (or  ;; the constraints here
               (or ;; pivoting effect
                ;; this is the case where c2.pos < c1.pos
                (= c2.position
                   (- c1.position c2.length 1))
                ;; this is the case where c2.pos > c1.pos
                (= c2.position
                   (+ c1.position 1)))
               (or   ;; "don't touch me! (if we are both subroutes)"
                (and ;; c1.pos <= c2.pos
                 (>= c2.position c1.position)
                 (= c2.position c1.position))
                (and ;; c1.pos >= c2.pos
                 (<= c2.position c1.position)
                 (= (+ c2.position c2.length)
                    c1.position)))
               (or ;; the anti pivot??? :-/
                ;; let's remove the second one when c2 > c1
                (> c2.position
                   (+ c1.position 1)))
               ))))))

        (doreverse-subroute (c2 wc))
        (doswap-subroutes (c1 c2 wc)))

       :name-for-bformat 'rerehgs
       :smart-version-info
       ((subroute-selected-at-operation c1 wc)
        (subroute-selected-at-operation c2 wc))
       :solution ((1 2 3 4 5 6) (7 8 9 10 11 12)
                  ;; (13 14 15 16 17 18)
                  )
       :print-difference nil
       :print-intersection nil
       :show-intersection t
       :print-smart-intersection t
       :print-neighborhood nil
       :print-smart-neighborhood nil
       :print-smart-repeated nil
       )
      #+END_SRC
** rereehf (ugly criterion that breaks things)
*** rehrehg
**** description
     This is a criteria that can potentially break the algorithms.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-criteria.lisp 
     (make-classical-criterion rereehf
        ((select-route route1)
         (select-subroute subroute1 from route1)
         (select-route route2)
         (select-subroute subroute2 from route2)
         (select-subroute subroute3 from route2)
         (swap-subroutes subroute3 subroute2)
         (insert-subroute subroute1 into route1)
         ))
     #+END_SRC
