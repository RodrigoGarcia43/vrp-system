#+TITLE: VRP solver environment
#+AUTHOR: Fernando Rodriguez Flores
#+AUTHOR: Eduardo Núñez de Villavicencio Sánchez
#+DATE 2018-08-13
#+TODO: TODO WIP BROKEN | DONE

* description

  In this file i'm going to add the variables and methods needed to simulate the operations in a neighborhood in a local search algorithm.

  The idea to effectively compute the delta-cost after the changes have been made to the solution is, of course, to not actually make the changes but to somehow simulate that they were made.

  It is also important to consider that this will be used in the context of an exhaustive search of a neighborhood in local search methods such as vns.  this means that we need to make (or simulate) all possible changes in a neighboorhood criterion :-o.

  So, the idea is to

    - Create a copy of the solution, but in a format where the changes can be effectively stored (and reused).
      
    - Create functions to simulate the operations in the solution

      Instead of modifying the copy of the solution, we'll just modify the functions that compute the actual position of the clients in the solution (the coordinates).  We can have the following functions:

      - actual-position (i,j)

        this function returns the original coordinate of the client that is currently at position (i,j).

        - examples

          for instance, if we have the following solution s1:

          #+begin_example
          s1:
            r1: c1, c2, c3
            r2: c4, c5
            r3: c6
          #+end_example
        
          and we =select-client= at position (1,2) we get the following solution:

          #+begin_example
          s2:
            r1: c1, c3
            r2: c4, c5
            r3: c6
          #+end_example

          instead of actually making the change, we just modify the function =actual-position= to return (1,3) when called with argument (1,2).  this is because the client that originally was at the position (1,3) is now at position (1,2).

          likewise, if we insert the client c2 at position (2,1) we get the solution:

          #+begin_example
          s3:
            r1: c1, c3
            r2: c2, c4, c5
            r3: c6
          #+end_example

          but again, instead of actually modifying the solution, we just modify the function =actual-position= in a way that when called with argument (2,2) it returns (2,1), and when called with argument (2,3) it returns (2,2).

        the idea behind this function is simple:

        when a client-selection occurs at coordinate (r,p), the position of all the clients in the route r with a previous position greater than p is reduced by 1.  that's why the actual-position of a coordinate of the form (r,q) with q>p returns is (r, q+1).

        likewise, if we insert a client at coordinate (r,p), the position of all the clients in the route r with a previous position greater than p is increased by 1. that's why, from that moment on, the actual-position of a coordinate of the form (r,q) with q>p returns is (r, q-1).

        the only case not covered by this idea is when we want to access the client that was just inserted, but that is solved by the function =client-at-position=, that is introduced below.
          
      - client-at-position (i,j)

        - basic description

          the function =actual-position= returns the coordinates of the client that we are really interested in when we asked for coordinate (i,j).  this function only fails if there was an insertion at the coordinate (i,j).

          for example, the solution s3, is the result of inserting the client c2 in the coordinate (2,1):

            #+begin_example
            s3:
              r1: c1, c3
              r2: c2, c4, c5
              r3: c6
            #+end_example

          the position (2,1) was not afected by any previous insertion or selection, so when we call =actual-position= with argument (2,1) it will return (2,1) and if we ask for the client at that position in the original solution we'll get c4, that is not what we want.

          to avoid that, the function =client-at-position= will keep a log of where has any client been inserted, so when asked for the client in a position, it will first check this list for the desired position and if it is there, it will return the client inserted there.

          in the case of s3, the insertion list will contain something like

          #+begin_example
          ((2,1,c2))
          #+end_example
        
          because the client c2 was inserted into position (2,1).

          in this case, if =client-at-position= is called with argument (2,1) it will return c2, after checking the list.  if it is called with any other argument, it will return the client at that position in the original solution.  of course, in the context of a neighborhood exploration the argument passed to this function should be preprocessed by the function =actual-position=.

        - handling further insertions
          
          the results of the function =client-at-position= can be affected by others insertions in the same route.  for example, suppose that the client c7 is inserted at position (2,1) in s3.  in that case we get the solution s4:

            #+begin_example
            s4:
              r1: c1, c3
              r2: c7, c2, c4, c5
              r3: c6
            #+end_example

          in a naive approach, after this insertion the list is updated to:    

          #+begin_example
          ((2,1,c7) (2,1,c2))
          #+end_example

          if we call =client-at-position= with position (2,2), this position won't be in the insertions list and it will return c5, the client at that position in the original solution.

          the easy way to solve this problem is that everytime we make an insertion at position (r,p) we update every element (r,q,c_k) in the insertion list with $q \geq p$, to (r,q+1, c_k).

          if we do this, the insertion list for s4 would have been:

          #+begin_example
          ((2,1,c7) (2,2,c2))
          #+end_example

          and now it all should work fine ;-) (hopefully).

      - current-route-length (route)

        this function returns the current-route-length of a given route after some insertions and selections have been made.

    - representation of the modifications

      we'll represent a set of operations as a list of insertions and selections.  the elements of this list will be instances of classes.

    - basic sketch of the algorithm

      the algorithm is based on the following functions:

        - =client-at= :: returns the client at the given position after all the insertions and selections was made.

        when asked for the =(client-at r p)= a given position we do the following:

        check whether an insertion was made at (r p)
         if it was, return the client that was inserted.
         if there wasn't, return the client at =(actual-position r p)=.

        - =simulate-neighborhood-operation= :: simulates the operation on the given working-copy.

        - =undo-neighborhood-operation= :: undoes the simulation of the operation.



* add the package to the beginning of file
  #+begin_src lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
  (in-package :vrp)
  #+end_src


      
* Actual-position function
** description
*** idea
    The actual-position function is a function that receives a coordinate and a working copy, and returns the coordinate in the original solution of the client that currently is at that coordinate.

    For example, if we have the solution:

    #+BEGIN_EXAMPLE
    S1:
      r1: c1, c2, c3
      r2: c4, c5
      r3: c6
    #+END_EXAMPLE

    where no operations have been made, the function actual-position for any (r p) returns the same (r p), because after no operations the client in the position (r p) is the client that originally was at the position (r p).

    However, if we select c2 from (1 2), insert it at (2 1) and actually make the changes, we get the following solution:

    #+BEGIN_EXAMPLE
    S3:
      r1: c1, c3
      r2: c2, c4, c5
      r3: c6
    #+END_EXAMPLE

    After these operations, the affected clients were c3, c4 and c5, because their coordinates changed.  The goal of the function actual-position is to return the coordinates in the original solution of the client that is now at the position (r p).

    For example, if we ask what is the actual-position of (1 1) in S3, what we are actually asking is: what coordinate had in the original solution (the original solution is the solution before any operation was made) the client that in S3 is in the position (1 1)?  In this case, the answer is (1 1) because the operations made didn't affect the coordinate (1 1).

    On the other hand, if we ask for the actual-position of (1 2), the answer is (1 3), because the client that is now at the coordinate (1 2) is c3, and in the original solution c3 was at the position (1 3).

    Had we asked about the actual-position of (2 2) the answer would have been (2 1) because the client c4 (with coordinate (2 2) in the current solution) was at (2 1) in the original solution.

*** implementation details
    
    The idea in this version is to have a generic function actual-position, and specialize it according to the operations.

    To do that we'll need two functions:
     - make-initia-actual-position-function
     - update-actual-position-function-after-operation
      
    The second one will be a generic function to specialize it according to the operation. 
    
    To implement this idea we are going to have an actual-position function that is updated after each operation.  To be able to undo the operations, we need to return to the previous function.  To do that, we propose to have a stack of actual-position functions.  This stack will be stored in the working-copy.

** generic-function
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (defgeneric actual-position (coordinate working-copy)
      (:documentation "A function to return the coordinates in the original solution of the client that in the working-copy is at coordinate coordinate."))
    #+END_SRC
** method (list basic-working-copy)
*** description
    In this method we specialize the actual-position function for a basic-working-copy.  In this case we'll just call the function at the top of the actual-position-functions-stack in the working copy.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (defmethod actual-position (coordinate (wc basic-working-copy))
      "Return the result of the function in the top of the actual-position-functions-stack in the working-copy."
      (funcall (first (actual-position-functions-stack wc)) coordinate))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
    (with-basic-solution (s1 ((1 2 3) (4 5)))
      (let* ((wc (basic-working-copy s1)))
        ;; set the actual-position-functions-stack
        (push (lambda (x) x) (actual-position-functions-stack wc))
        (format t "==============================================
    Testing actual-position (t basic-working-copy)
    ==============================================~2%")
        (check-= 2 (actual-position 2 wc))
        (check-list= `(1 2) (actual-position `(1 2) wc))

        (format t "Pushing another function into the stack~%")
        (push (lambda (x) (* 2 x)) (actual-position-functions-stack wc))
        (check-= 4 (actual-position 2 wc))
        (check-= 16 (actual-position 8 wc))

        (format t "Pop a function from the stack~%")
        (pop (actual-position-functions-stack wc))
    
        (check-= 2 (actual-position 2 wc))
        (check-list= `(1 2) (actual-position `(1 2) wc))))

    #+END_SRC
** API to manipulate the actual-position-functions-stack
*** make-initial-actual-position-function
**** description
     This function returns the actual-position function that should be used when when no operations have been made to the solution.
**** generic-function
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric make-initial-actual-position (working-copy)
      (:documentation "A function to create the initial actual-position function."))
     #+END_SRC

**** method (basic-working-copy)
***** description
      When we are working with a basic-working-copy we just create an identity function, empty the stack and push the identity function into it.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmethod make-initial-actual-position ((wc basic-working-copy))
        "Sets the actual-position-functions-stack of the working copy appropriately to an identity function."
        (setf (actual-position-functions-stack wc)
              (list (lambda (coord) coord))))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4 5)))
        (let* ((wc (basic-working-copy s1)))
          ;; set the actual-position-functions-stack
          (make-initial-actual-position wc)
          (format t "=========================================================
      Testing make-initial-actual-position (basic-working-copy)
      =========================================================~2%")
          (check-= 2 (actual-position 2 wc))
          (check-list= `(1 2) (actual-position `(1 2) wc))

          (format t "Pushing another function into the stack~%")
          (push (lambda (x) (* 2 x)) (actual-position-functions-stack wc))
          (check-= 4 (actual-position 2 wc))
          (check-= 16 (actual-position 8 wc))

          (format t "Pop a function from the stack~%")
          (pop (actual-position-functions-stack wc))

          (check-= 2 (actual-position 2 wc))
          (check-list= `(1 2) (actual-position `(1 2) wc))))

      #+END_SRC

*** update-actual-position-after-operation
**** description
     This function receives an instance of an neighborhood-operation and a working-copy, and updates the actual-position function that takes into account the operation indicated by the instance.
**** generic-function
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric update-actual-position-after (op working-copy)
      (:documentation "A function to update the actual-position function in a working-copy."))
     #+END_SRC
**** method (op-select-client basic-working-copy)
***** description
      In this case we create the new function and update the stack in the working-copy.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      ;; Method for select-client operation
      (defmethod update-actual-position-after
          ((operation operation-select-client)
           (wc basic-working-copy))
        ;; first we get the actual function from te stack
        (let* ((old-function (first (actual-position-functions-stack wc)))
               (new-function
                (lambda (coord)
                  ;; coord is of the form (i j)
                  ;; where i is the route and j is the position.
                  ;; first let's increment p if it is in route r
                  ;; and it is greater or equal to p
                  (let* ((i (first coord))
                         (j (second coord))
                         (newj (if (and
                                    (obj= i (route operation))
                                    (>= j (pos operation)))
                                   (then (+ 1 j))
                                   (else j))))
                    ;; now let's call the previous function
                    (funcall old-function (list i newj))))))

          ;; now we push the new function into the stack
          (push new-function (actual-position-functions-stack wc))))

      #+END_SRC
***** test
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3) (4 5 6)))
         (let* ((wc (basic-working-copy s1))
                (op1 (op-select-client 1 2 0))
                (op2 (op-select-client 2 2 1)))
           ;; set the actual-position-functions-stack
           (make-initial-actual-position wc)
           (format t "===================================================================
       Testing update-actual-position-after-operation (basic-working-copy)
       ===================================================================~2%")
           (format t "Testing the initial actual-position-function:~%")
           (check-list= `(1 2) (actual-position `(1 2) wc))

           (format t "Updating the actual-position function with op1:~%")
           (update-actual-position-after op1 wc)

           (check-list= `(1 1) (actual-position `(1 1) wc))
           (check-list= `(1 3) (actual-position `(1 2) wc))

           (format t "Updating the actual-position function with op2:~%")
           (update-actual-position-after op2 wc)

           (check-list= `(2 1) (actual-position `(2 1) wc))
           (check-list= `(2 3) (actual-position `(2 2) wc))))

       #+END_SRC
     
**** method (op-insert-client basic-working-copy)
***** description
      In this case we create the new function and update the stack in the working-copy.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      ;; Method for select-client operation
      (defmethod update-actual-position-after
          ((operation operation-insert-client)
           (wc basic-working-copy))
        ;; first we get the actual function from te stack
        (let* ((old-function (first (actual-position-functions-stack wc)))
               (new-function
                (lambda (coord)
                  ;; coord is of the form (i j)
                  ;; where i is the route and j is the position.
                 ;; first let's decrement j if it is in route i
                 ;; and it is greater or equal to j
                  (let* ((i (first coord))
                         (j (second coord))
                         (newj (if (and
                                    (obj= i (route operation))
                                    (>= j (pos operation)))
                                   (then (- j 1))
                                   (else j))))
                    ;; now let's call the previous function
                    (funcall old-function (list i newj))))))

          ;; now we push the new function into the stack
          (push new-function (actual-position-functions-stack wc))))

      #+END_SRC
***** tests
****** testing op-insert-client
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2 3) (4 5 6)))
          (let* ((wc (basic-working-copy s1))
                 (op1 (op-insert-client 1 2 0))
                 (op2 (op-insert-client 2 2 1)))
            ;; set the actual-position-functions-stack
            (make-initial-actual-position wc)
            (format t "===================================================================
        Testing update-actual-position-after-operation (basic-working-copy)
        ===================================================================~2%")
            (format t "Testing the initial actual-position-function:~%")
            (check-list= `(1 2) (actual-position `(1 2) wc))

            (format t "Updating the actual-position function with op1:~%")
            (update-actual-position-after op1 wc)

            (check-list= `(1 1) (actual-position `(1 1) wc))
            (check-list= `(1 2) (actual-position `(1 3) wc))

            (format t "Updating the actual-position function with op2:~%")
            (update-actual-position-after op2 wc)

            (check-list= `(2 1) (actual-position `(2 1) wc))
            (check-list= `(2 2) (actual-position `(2 3) wc))))

        #+END_SRC
****** testing op-insert-client and op-select-client
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (with-basic-solution (s1 ((1 2) (3 4 5 6)))
          (let* ((wc (basic-working-copy s1))
                 (op1 (op-select-client 2 1 0))
                 (op2 (op-insert-client 2 2 1))
                 (op3 (op-insert-client 2 2 2)))
            ;; set the actual-position-functions-stack
            (make-initial-actual-position wc)
            (format t "~%===================================================================
        Testing update-actual-position-after-operation (basic-working-copy)
        ===================================================================~2%")

            (format t "Updating the actual-position function with op1:~%")
            (update-actual-position-after op1 wc)

            (check-list= `(2 2) (actual-position `(2 1) wc))
            (check-list= `(2 3) (actual-position `(2 2) wc))

            ;; so far we have: (4 5 6)

            (format t "Updating the actual-position function with op2:~%")
            (update-actual-position-after op2 wc)
            ;; now we have: (4 I 5 6)
            ;; original:    (3 4 5 6)

            (check-list= `(2 2) (actual-position `(2 1) wc))
            (check-list= `(2 3) (actual-position `(2 3) wc))

            (format t "Updating the actual-position function with op3:~%")
            (update-actual-position-after op3 wc)
            ;; now we have: (4 J I 5 6)
            ;; original:    (3 4 5 6)

            (check-list= `(2 2) (actual-position `(2 1) wc))
            (check-list= `(2 3) (actual-position `(2 4) wc))
            (check-list= `(2 4) (ACTUAL-POSITION `(2 5) WC))))

        #+END_SRC
*** undo-actual-position
**** description
     Syntax:

       =(undo-actual-position operations working-copy)=
    
     This function returns the actual-position function to the state it was before the given operation was simulated in the working-copy.
**** generic-function
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defgeneric undo-actual-position (op working-copy)
        (:documentation "A function to undo the update of the working-copy when the operation op is simulated."))
      #+END_SRC
**** method (any-operation basic-working-copy)
***** description
      In this case we just pop the actual-position-functions-stack.  We always do that regardless of the operation, so the firs arg specializes on T.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      ;; Method for select-client operation
      (defmethod undo-actual-position
          (operation (wc basic-working-copy))
        ;; pop from the stack
        (pop (actual-position-functions-stack wc)))

      #+END_SRC
***** test
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (with-basic-solution (s1 ((1 2 3) (4 5 6)))
         (let* ((wc (basic-working-copy s1))
                (op1 (op-select-client 1 2 0))
                (op2 (op-select-client 1 1 1))
                (op-list nil))
           ;; set the actual-position-functions-stack
           (prepare-solution-for-neighborhood-exploration wc)
           (format t "=================================================
       Testing undo-actual-position (basic-working-copy)
       =================================================~2%")
           (format t "Before any operation:~%")
           (pp-solution wc t) (terpri)

           (setf op-list (list op1 op2))

           (loop for op in op-list
                 doing (progn
                         (format t "After operation ~a:~%" op)
                         (simulate-neighborhood-operation op wc)
                         (pp-solution wc t) (terpri)))

           (loop for op in (reverse op-list)
                 doing (progn
                         (format t "After undoing operation ~a:~%" op)
                         (undo-routes-lengths op wc)
                         (undo-actual-position op wc)
                         (pp-solution wc t) (terpri)))))

       #+END_SRC
       


* Route management in the working copy
** description
   In this section we add the functions and methods required to deal with the routes in the working-copy.

   Here we'll deal with the following:

    - initial-routes-lengths
      These are the lengths of the routes in the original solution.
      
    - route-lengths
      These are the lengths of the routes after some operations have been made.

   Those two should be slots in the basic-working-copy class.   
** make-initial-routes-lengths
*** description
    This function sets the slot initial-routes-lengths of the working copy to its value according to the solution.  In the case of the basic-working-copy this is an array where in each position is the number of clients in that route in the solution.
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric make-initial-routes-lengths (working-copy)
       (:documentation "Sets the slot initial-route-length of the working copy to its value according to the solution."))
     #+END_SRC
*** method (basic-working-copy)
**** code
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
       (defmethod make-initial-routes-lengths ((wc basic-working-copy))
        "This function returns an array with the lengths of each route in the given basic solution. It assumes that the id of the routes are consecutive and ordered from 1 to n."

        (let* ((solution (solution wc))
               (initial-lengths (loop for route in (routes solution)
                                      collecting (length (clients route))))
               (length-array (make-array (1+ (length initial-lengths))
                                         :initial-contents
                                         (append '(0) initial-lengths)
                                         :fill-pointer (1+ (length initial-lengths))
                                         :adjustable t)))
          (setf (initial-routes-lengths wc) length-array)))
       #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2) (3 4 5 6) (7 8 9)))
        (let* ((wc (basic-working-copy s1)))
          (bformat t "Testing make-initial-routes-lengths (basic-working-copy)")
          (make-initial-routes-lengths wc)
          (format t "initial-routes-lengths: ~a~%" (initial-routes-lengths wc))
          (check-obj= #(0 2 4 3) (initial-routes-lengths wc))))

      #+END_SRC
** update-routes-lengths-after
*** description
    This function updates the routes-length in the working-copy after some operation was made.  It is a generic function and we'll specialize in different working-copies and operations.
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric update-routes-lengths-after (operation working-copy)
       (:documentation "Updates the current routes-length in the given working copy according to the operation was was made."))
     #+END_SRC
*** method (select-client basic-working-copy)
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmethod update-routes-lengths-after ((op operation-select-client)
                                              (wc basic-working-copy))
       "This function updates the routes-length property of the working copy when the working copy is a basic solution and the operation is a select-client operation."

       ;; here we just decrease the number in the route's
       ;; idth element in the routes-lengths slot in the working-copy. 
       (decf (aref (routes-lengths wc) (route op))))
      #+END_SRC
**** test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4 5 6)))
        (let* ((wc (basic-working-copy s1))
               (op1 (op-select-client 1 2 0))
               (op2 (op-select-client 2 2 1)))
          ;; set the actual-position-functions-stack
          (prepare-solution-for-neighborhood-exploration wc)
          (format t "=============================
      Testing update-routes-lengths
      =============================~2%")
          (format t "Testing the initial actual-position-function:~%")
          (check-obj= #(0 3 3) (routes-lengths wc))

          (format t "Updating the routes-lengths with op1:~%")
          (update-routes-lengths-after op1 wc)

          (check-list= #(0 2 3) (routes-lengths wc))


          (format t "Updating the routes-lengths with op2:~%")
          (update-routes-lengths-after op2 wc)

          (check-list= #(0 2 2) (routes-lengths wc))))

      #+END_SRC
*** method (insert-client basic-working-copy)
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmethod update-routes-lengths-after ((op operation-insert-client)
                                              (wc basic-working-copy))
       "This function updates the routes-length property of the working copy when the working copy is a basic solution and the operation is an insert-client operation."

       ;; here we just increase the number in the route's
       ;; idth element in the routes-lengths slot in the working-copy. 
       (incf (aref (routes-lengths wc) (route op))))
      #+END_SRC
**** test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4 5 6)))
        (let* ((wc (basic-working-copy s1))
               (op1 (op-insert-client 1 2 0))
               (op2 (op-insert-client 2 2 1)))
          ;; set the actual-position-functions-stack
          (prepare-solution-for-neighborhood-exploration wc)
          (format t "=============================
      Testing update-routes-lengths
      =============================~2%")
          (format t "Testing the initial actual-position-function:~%")
          (check-obj= #(0 3 3) (routes-lengths wc))

          (format t "Updating the routes-lengths with op1:~%")
          (update-routes-lengths-after op1 wc)

          (check-list= #(0 4 3) (routes-lengths wc))


          (format t "Updating the routes-lengths with op2:~%")
          (update-routes-lengths-after op2 wc)

          (check-list= #(0 4 4) (routes-lengths wc))))
      #+END_SRC
** route-length
*** description
    This function returns the current length of a route.
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric route-length (route working-copy)
       (:documentation "Returns the length of the given route in the working-copy."))
     #+END_SRC
*** method (number basic-working-copy)
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod route-length ((route number) (wc basic-working-copy))
       "Check the value of the property route-length-array in the given position in the given working copy."
       (aref (routes-lengths wc) route))
     #+END_SRC
**** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4 5 6)))
        (let* ((wc (basic-working-copy s1))
               (op1 (op-insert-client 1 2 0))
               (op2 (op-insert-client 2 2 1)))
    
          (prepare-solution-for-neighborhood-exploration wc)
          (format t "====================
      Testing route-length
      ====================~2%")
          (format t "Testing the initial route-length:~%")
          (check-= 3 (route-length 1 wc))
          (check-= 3 (route-length 2 wc))

    
          (format t "Updating the routes-lengths with op1:~%")
          (update-routes-lengths-after op1 wc)
          (check-= 4 (route-length 1 wc))
          (check-= 3 (route-length 2 wc))

          (format t "Updating the routes-lengths with op2:~%")
          (update-routes-lengths-after op2 wc)
          (check-= 4 (route-length 1 wc))
          (check-= 4 (route-length 2 wc))))
      #+END_SRC
** undo-routes-lengths
*** description
    This function undoes the effect of the update in the routes-lengths properties of the working-copy.
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric undo-routes-lengths (operation working-copy)
       (:documentation "Undoes the effect of the update in the routes-lengths properties of the working-copy."))
     #+END_SRC
*** method (select-client basic-working-copy)
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmethod undo-routes-lengths ((op operation-select-client)
                                      (wc basic-working-copy))
       "This function undoes the effect of an update in the routes-lengths property of the working copy when the working copy is a basic solution and the operation is a select-client operation."

       ;; here we just increase the number in the route's
       ;; idth element in the routes-lengths slot in the working-copy. 
       (incf (aref (routes-lengths wc) (route op))))
      #+END_SRC
**** test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4 5 6)))
        (let* ((wc (basic-working-copy s1))
               (op1 (op-select-client 1 2 0))
               (op2 (op-select-client 2 2 1)))
          ;; set the actual-position-functions-stack
          (prepare-solution-for-neighborhood-exploration wc)
          (format t "=============================
      Testing update-routes-lengths
      =============================~2%")
          (format t "Testing the initial actual-position-function:~%")
          (check-obj= #(0 3 3) (routes-lengths wc))

          (format t "Updating the routes-lengths with op1:~%")
          (update-routes-lengths-after op1 wc)

          (check-list= #(0 2 3) (routes-lengths wc))


          (format t "Updating the routes-lengths with op2:~%")
          (update-routes-lengths-after op2 wc)
          (check-list= #(0 2 2) (routes-lengths wc))

          (format t "Undoing op: ~a~%" op2)
          (undo-routes-lengths op2 wc)
          (check-list= #(0 2 3) (routes-lengths wc))

          (format t "Undoing op: ~a~%" op1)
          (undo-routes-lengths op1 wc)
          (check-list= #(0 3 3) (routes-lengths wc))))

      #+END_SRC
*** method (insert-client basic-working-copy)
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmethod undo-routes-lengths ((op operation-insert-client)
                                      (wc basic-working-copy))
       "This function undoes the effect of an update in the routes-lengths property of the working copy when the working copy is a basic solution and the operation is an insert-client operation."

       ;; here we just decrease the number in the route's
       ;; idth element in the routes-lengths slot in the working-copy. 
       (decf (aref (routes-lengths wc) (route op))))
      #+END_SRC
**** test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4 5 6)))
        (let* ((wc (basic-working-copy s1))
               (op1 (op-insert-client 1 2 0))
               (op2 (op-insert-client 2 2 1)))
          ;; set the actual-position-functions-stack
          (prepare-solution-for-neighborhood-exploration wc)
          (format t "=============================
      Testing update-routes-lengths
      =============================~2%")
          (format t "Testing the initial actual-position-function:~%")
          (check-obj= #(0 3 3) (routes-lengths wc))

          (format t "Updating the routes-lengths with op1:~%")
          (update-routes-lengths-after op1 wc)
          (check-list= #(0 4 3) (routes-lengths wc))


          (format t "Updating the routes-lengths with op2:~%")
          (update-routes-lengths-after op2 wc)
          (check-list= #(0 4 4) (routes-lengths wc))

          (format t "Undoing op: ~a~%" op2)
          (undo-routes-lengths op2 wc)
          (check-list= #(0 4 3) (routes-lengths wc))

          (format t "Undoing op: ~a~%" op1)
          (undo-routes-lengths op1 wc)
          (check-list= #(0 3 3) (routes-lengths wc))))
      #+END_SRC
** initialize-number-of-routes
*** description
    This function initializes the number of routes in the working copy.  It should be initialized to the number of routes in the solution.
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric initialize-number-of-routes (working-copy)
       (:documentation "This function initializes the number of routes in the working copy.  It should be initialized to the number of routes in the solution."))
     #+END_SRC
*** method (basic-working-copy)
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmethod initialize-number-of-routes
          ((wc basic-working-copy))
       "This function initializes the number of routes in the working copy.  It should be initialized to the number of routes in the solution."
       ;; here we just increase the number in the route's
       ;; idth element in the routes-lengths slot in the working-copy. 
       (setf (number-of-routes wc) (length (routes (solution wc)))))
      #+END_SRC
**** test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (7) (8 9) (4 5 6)))
        (let* ((wc (basic-working-copy s1)))


          ;; set the actual-position-functions-stack

          (bformat t "Testing initialize-number-of-routes")

          (initialize-number-of-routes wc)

          (check-= 4 (number-of-routes wc))))

      #+END_SRC



* client-at (API to access clients and routes in a working-copy)
  :PROPERTIES:
  :CUSTOM_ID: fun:client-at
  :END:
 
** description
    The client-at function receives a coordinate (or a position) and returns the client in that position.  The idea should be simple:

    - this function should be called with arguments that have been preprocessed with the =actual-position= function.
    - if the position we are asking for has not been the "target" of any insertion, then return the client in the original solution.
    - if the position we are asking for has been the target of an insertion, then check in the "insertions array" to know what is the client that has been inserted there.
    - Of course, everytime there is an insertion or selection, we need to update the insertions array and the selected clients.

    Now we have to implement the functions to acually access the elements.
     
    So, the first thing to do is to create functions to return a route and a client in a working solution.
** get-route-with-id
*** description
    We should read this function as:
     get route with id =id= in solution solution 
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric get-route-with-id (id working-copy)
       (:documentation "Returns the route with the given id in the working copy."))
     #+END_SRC
*** method (number basic-solution)
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod get-route-with-id ((id number) (solution basic-solution))
       "In this function we are going to assume that in a solution there is only a route with a given id."
       (loop for route in (routes solution)
             when (= id (id route)) do (return route)))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3) (4 5) (6)))
       (let* ((r1 (first (routes s1)))
              (r2 (second (routes s1)))
              (*vrp-unit-testing-display-output* nil))
         (check-obj= r1 (get-route-with-id 1 s1))
         (check-obj= r2 (get-route-with-id 2 s1))
         (check-nil (obj= r1 (get-route-with-id 2 s1)))
         (check-nil (obj= r2 (get-route-with-id 3 s1)))))
      #+END_SRC

*** method (number basic-working-copy)
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod get-route-with-id
         ((id number) (wc basic-working-copy))
       "In this function we are going to assume that in a solution there is only a route with a given id."
       (loop for route in (routes (solution wc))
             when (= id (id route)) do (return route)))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3) (4 5) (6)))
       (let* ((r1 (first (routes s1)))
              (r2 (second (routes s1)))
              (wc (basic-working-copy s1))
              (*vrp-unit-testing-display-output* nil))


         (bformat t "Testing get-route-with-id for basic-wc")
         (prepare-solution-for-neighborhood-exploration wc)


         (check-obj= r1 (get-route-with-id 1 wc))
         (check-obj= r2 (get-route-with-id 2 wc))
         (check-nil (obj= r1 (get-route-with-id 2 wc)))
         (check-nil (obj= r2 (get-route-with-id 3 wc)))))
      #+END_SRC

** get-client-at-pos
*** description
    We should read this function as:
     get client at pos =pos= in solution solution 
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric get-client-at-pos (pos working-copy)
       (:documentation "Returns the client at the given pos in the working copy."))
     #+END_SRC
*** method (list basic-solution)
**** description
     In this method, the pos argument is assumed to be a list with two arguments: the id of the route and the position of the client inside that route.  That position is 1 based.  That means that the first element in the route is at pos 1.

      This implementation is based on =nth= and because of that in can be slow and should be improved.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod get-client-at-pos ((pos list) (solution basic-solution))
         "This function returns the client at the given pos in a basic solution. pos is a list with two elements (r,p). r is the id of the desired route, and p is the position of the desired client in the route with id r.

     In this function we are going to assume that in a solution there is only a route with a given id, and that the position inside the route is 1-based. That means that the first element in the route is at pos 1.
     TODO: Maybe this approach is inneficient for big instances because of the nth function."
         (let* ((route-id (first pos))
                (client-pos (second pos))
                selected-route)
           ;; get the selected-route
           (setf selected-route (get-route-with-id route-id solution))
           ;; return the (client-pos - 1)th element in the route
           ;; the -1 is because we want the position to be 1-based
           ;; The next step is potentially a bottleneck because
           ;; of the nth function. That should be improved in future
           ;; versions.
           (nth (- client-pos 1) (clients selected-route))))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-clients (1 2 3 4 5 6)
       (with-basic-solution (s1 ((1 2 3) (4 5) (6)))
         (let* ((*vrp-unit-testing-display-output* t))

           (bformat t "Testing get-client-at-pos")
           (check-obj= c1 (get-client-at-pos '(1 1) s1))
           (check-obj= c5 (get-client-at-pos '(2 2) s1))
           (check-obj= c6 (get-client-at-pos '(3 1) s1))
           (check-obj= c2 (get-client-at-pos '(1 2) s1))
           (check-obj= c3 (get-client-at-pos '(1 3) s1))
           (check-obj= c4 (get-client-at-pos '(2 1) s1))

           (check-nil (obj= c1 (get-client-at-pos '(1 3) s1)))
           (check-nil (obj= c3 (get-client-at-pos '(3 1) s1)))

           (check-nil (get-client-at-pos '(3 2) s1))
           )))
      #+END_SRC
** there-was-an-insertion-at
*** description
    The idea is to have a function that can tell us if there was an insertion at a given position, and if it was, return the client that was inserted there.
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric there-was-an-insertion-at (pos working-copy)
       (:documentation "If there-was-an-insertion-at the given position returns the client that was inserted.  Otherwise returns nil."))
     #+END_SRC
*** method (list basic-working-copy)
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod there-was-an-insertion-at ((pos list)
                                           (wc basic-working-copy))
       "If there was an insertion at the given position in the given basic-solution, return the client that was inserted.  Otherwise return nil.
     pos is a list of the form (r,p) where r is the id of the route and p is the position inside that route. The position is 1 based, meaning that the position of the first element is 1.

     This function uses the variable *insertions-made*."

       (loop for (r p c) in (insertions-made wc)
             ;; if there was a match, return it
             if (and (= r (first pos))
                     (= p (second pos)))
             do (return c)
             ;; if there was no match, return nil.
             finally (return nil)))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-clients (1 2 3 4 5 6 7 8)
       (with-basic-solution (s1 ((1 2 3) (4 5) (6)))
         (let* ((wc (basic-working-copy s1))
                (*vrp-unit-testing-display-output* t))

           (prepare-solution-for-neighborhood-exploration wc)

           (push `(1 2 ,c7) (insertions-made wc))
           (push `(3 2 ,c8) (insertions-made wc))

           (check-non-nil (there-was-an-insertion-at '(1 2) wc))
           (check-non-nil (there-was-an-insertion-at '(3 2) wc))
           (check-nil     (there-was-an-insertion-at '(1 1) wc))
           (check-nil     (there-was-an-insertion-at '(2 2) wc))

           (check-obj= c7 (there-was-an-insertion-at '(1 2) wc))
           (check-obj= c8 (there-was-an-insertion-at '(3 2) wc))
      
           )))
      #+END_SRC
** client-at
*** description
    This function returns the client that is at a given coordinate after some operations have been simulated.
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric client-at (pos working-copy)
       (:documentation "Returns the client at the given pos in the given working copy."))
     #+END_SRC
*** method (list basic-working-copy)
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmethod client-at ((pos list) (wc basic-working-copy))
        "Returns the client at position pos in solution after some selections or insertions have been simulated.  solution is not actually modified by these selections or insertions.  If the position in the route is 0 or greater than the route-length, then return the depot in that route."

        (let* ((solution (solution wc))
               (route-id (first pos))
               (actual-route nil)
               (client-pos (second pos))
               (there-was-an-insertion (there-was-an-insertion-at pos wc))
               actual-pos)
          (cond
            ((< client-pos 1)
             (then ;; return the depot of the route
               (setf actual-route (get-route-with-id route-id solution))
               (if actual-route
                   (depot actual-route)
                   (depot wc))))
            ((> client-pos (route-length route-id wc))
             (then ;; return the depot of the route
               (setf actual-route (get-route-with-id route-id solution))
               (if actual-route
                   (end-depot actual-route)
                   (end-depot wc))))
            (t (else
               (if there-was-an-insertion
                   (then ;; return it
                     there-was-an-insertion)
                   (else ;; get the client in the actual-pos
                     (setf actual-pos
                           (actual-position (list route-id client-pos) wc))
                     ;; return that value
                     (get-client-at-pos actual-pos solution))))))))
      #+END_SRC
**** tests
***** basic test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-clients (1 2 7 8)
        (with-basic-solution (s1 ((1 2 3) (4 5) (6)))
          (let* ((wc (basic-working-copy s1))
                 (op1 (op-insert-client 1 2 0))
                 (op2 (op-insert-client 3 2 1))
                 (d (basic-depot))
                 (*vrp-unit-testing-display-output* t))

            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing client-at:")

            (push `(1 2 ,c7) (insertions-made wc))
            (push `(3 2 ,c8) (insertions-made wc))

            (update-routes-lengths-after op1 wc)
            (update-routes-lengths-after op2 wc)

            (update-actual-position-after op1 wc)
            (update-actual-position-after op2 wc)


            (check-obj= c1 (client-at `(1 1) wc))
            (check-obj= c7 (client-at `(1 2) wc))
            (check-obj= c2 (client-at `(1 3) wc))


            (check-obj= d (client-at `(1 0) wc))
            (check-obj= d (client-at `(1 7) wc))


            )))
       #+END_SRC
***** test with routes-with-end-depot
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-clients (1 2 3 4 5 6 7 8)
        (let* ((v1 (basic-vehicle 1))
               (v2 (basic-vehicle 2))
               (d0 (basic-depot))
               (d1 (basic-depot 9))
               (r1 (route-for-simulation-with-end-depot
                    :id 1
                    :vehicle v1
                    :depot d0
                    :end-depot d1
                    :clients (list c1 c2 c3)))
               (r2 (route-for-simulation-with-end-depot
                    :id 2
                    :vehicle v2
                    :depot d0
                    :end-depot d1
                    :clients (list c4 c5 c6)))
               (s1 (basic-cvrp-solution
                    :id 1
                    :routes (list r1 r2)
                    :cost 0)))

            (let* ((wc (basic-working-copy s1))
                   (op1 (op-insert-client 1 2 0))
                   (op2 (op-insert-client 2 4 1))
                   (*vrp-unit-testing-display-output* t))

              (prepare-solution-for-neighborhood-exploration wc)

              (bformat t "Testing client-at with end-depots:")

              (push `(1 2 ,c7) (insertions-made wc))
              (push `(2 4 ,c8) (insertions-made wc))

              (update-routes-lengths-after op1 wc)
              (update-routes-lengths-after op2 wc)

              (update-actual-position-after op1 wc)
              (update-actual-position-after op2 wc)

              (pp-solution wc t) (terpri)


              (check-obj= c1 (client-at `(1 1) wc))
              (check-obj= c7 (client-at `(1 2) wc))
              (check-obj= c2 (client-at `(1 3) wc))


              (check-obj= d0 (client-at `(1 0) wc))
              (check-obj= d1 (client-at `(1 7) wc))
              (check-obj= d1 (client-at `(2 5) wc))


              )
            ))
       #+END_SRC
**** +code old-code+
      #+BEGIN_SRC lisp +n -r :results none :exports code
      (defmethod client-at ((pos list) (wc basic-working-copy))
        "Returns the client at position pos in solution after some selections or insertions have been simulated.  solution is not actually modified by these selections or insertions.  If the position in the route is 0 or greater than the route-length, then return the depot in that route."

        (let* ((solution (solution wc))
               (route-id (first pos))
               (actual-route nil)
               (client-pos (second pos))
               (there-was-an-insertion (there-was-an-insertion-at pos wc))
               actual-pos)
          (if (or (< client-pos 1)
                  (> client-pos (route-length route-id wc)))
              (then ;; return the depot of the route
                (setf actual-route (get-route-with-id route-id solution))
                (if actual-route
                           (depot actual-route)
                           (depot wc)))
              (else
               (if there-was-an-insertion
                   (then ;; return it
                    there-was-an-insertion)
                   (else ;; get the client in the actual-pos
                     (setf actual-pos
                           (actual-position (list route-id client-pos) wc))
                     ;; return that value
                     (get-client-at-pos actual-pos solution)))))))
      #+END_SRC




* Selected clients management
** description
   In this section we'll add the methods and functions to deal with the selected clients.  Each time a client is selected we need to store that the client was selected and from where.  Later we'll need to access that information.  All those functions will be in this section.

   For the basic-working-copy each element in this array will be a list of the form (c r p), where c is the selected client, r is the route from where it was selected, and p is the position.

   The first thing is to add the selected-clients slot to the basic-working-copy.

   And now we add a function to initialize that slot.
** selections-count
*** description
    This is a number that indicates how many selections have been made in the working copy.  It is a slot in the basic-working-copy class.
   
** initialize-selected-clients
*** description
    This generic function should initialize the selected-clients slot to an empty value.
*** generic-function
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (defgeneric initialize-selected-clients (working-copy)
     (:documentation "A function initialize the selected-clients in a working copy."))
    #+END_SRC
*** method (basic-working-copy)
**** description
     When we are working with a basic-working-copy we just initialize an array with size the number of clients in the routes of the solution. This is the length of the array because that's the maximum number of clients that can be selected.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod initialize-selected-clients ((wc basic-working-copy))
       "initialize an array with size the number of clients in the routes of the solution. This is the length of the array because that's the maximum number of clients that can be selected."
       (setf (selected-clients wc)
             (make-array
              ;; the size of the array is the number
              ;; of clients in the solution, because this is the
              ;; maximum number of possible selections.
              (loop for c across (initial-routes-lengths wc)
                    summing c)
              :initial-element nil)))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-solution (s1 ((1 2) (3 4 5 6) (7 8 9)))
       (let* ((wc (basic-working-copy s1)))
         (format t "~%========================================================
     Testing initialize-selected-clients (basic-working-copy)
     ========================================================~2%")
         (make-initial-routes-lengths wc)
         (initialize-selected-clients wc)
         (check-= 9 (length (selected-clients wc)))))

    #+END_SRC
** API to access the selected clients
*** description
    In this section we add all the functions to access and manipulate the selected-clients.
*** client-selected-at-operation
**** description
     Returns the client selected at a given operation (or at a given operation index.)
**** generic-function
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric client-selected-at-operation (op working-copy)
      (:documentation "Returns client selected at the operation op."))
     #+END_SRC
**** method (number basic-working-copy)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmethod client-selected-at-operation ((op number)
                                               (wc basic-working-copy))
        "Returns client selected at the operation with operand op."
        (first (aref (selected-clients wc) op)))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (with-basic-solution (s1 ((1 2) (3 4 5)))
        (let* ((wc (basic-working-copy s1))
               (c1 (first (clients (first (routes s1)))))
               (c2 (first (clients (second (routes s1))))))
          (format t "~%=========================================================
      Testing client-selected-at-operation (basic-working-copy)
      =========================================================~2%")
          (make-initial-routes-lengths wc)
          (initialize-selected-clients wc)
          ;; add the selected clients
          (setf (aref (selected-clients wc) 0) (list c1 `(1 1 nil)))
          (setf (aref (selected-clients wc) 1) (list c2 `(2 1 nil)))
          ;; let's test the client-selected-at-operation
          (check-obj= c1 (client-selected-at-operation 0 wc))
          (check-obj= c2 (client-selected-at-operation 1 wc))))
     #+END_SRC
*** info-of-client-selected-at-operation
**** description
     Returns the stored information of the selected client at a given operation.
**** generic-function
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric info-of-client-selected-at-operation (op working-copy)
      (:documentation "Returns the coordinates of the client selected at the operation op."))
     #+END_SRC
**** method (number basic-working-copy)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmethod info-of-client-selected-at-operation
          ((op number)
           (wc basic-working-copy))
        "Returns info of the client selected at the operation with operand op."
        (second (aref (selected-clients wc) op)))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (with-basic-solution (s1 ((1 2) (3 4 5)))
        (let* ((wc (basic-working-copy s1))
               (c1 (first (clients (first (routes s1)))))
               (c2 (first (clients (second (routes s1))))))
          (format t "~%=========================================================
      Testing client-selected-at-operation (basic-working-copy)
      =========================================================~2%")
          (make-initial-routes-lengths wc)
          (initialize-selected-clients wc)
          ;; add the selected clients
          (setf (aref (selected-clients wc) 0) (list c1 `(1 1 nil)))
          (setf (aref (selected-clients wc) 1) (list c2 `(2 1 nil)))
          ;; let's test the client-selected-at-operation
          (check-list= `(1 1 nil) (info-of-client-selected-at-operation 0 wc))
          (check-list= `(2 1 nil) (info-of-client-selected-at-operation 1 wc))))
     #+END_SRC
*** route-of-client-selected-at-operation
**** description
     Returns the route of the selected client at a given operation.
**** generic-function
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric route-of-client-selected-at-operation (op working-copy)
      (:documentation "Returns the route of the client selected at the operation op."))
     #+END_SRC
**** method (number basic-working-copy)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmethod route-of-client-selected-at-operation
          ((op number)
           (wc basic-working-copy))
        "Returns info of the client selected at the operation with operand op."
        (first (second (aref (selected-clients wc) op))))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (with-basic-solution (s1 ((1 2) (3 4 5)))
        (let* ((wc (basic-working-copy s1))
               (c1 (first (clients (first (routes s1)))))
               (c2 (first (clients (second (routes s1))))))
          (format t "~%=========================================================
      Testing client-selected-at-operation (basic-working-copy)
      =========================================================~2%")
          (make-initial-routes-lengths wc)
          (initialize-selected-clients wc)
          ;; add the selected clients
          (setf (aref (selected-clients wc) 0) (list c1 `(1 1 nil)))
          (setf (aref (selected-clients wc) 1) (list c2 `(2 1 nil)))
          ;; let's test the client-selected-at-operation
          (check-= 1 (route-of-client-selected-at-operation 0 wc))
          (check-= 2 (route-of-client-selected-at-operation 1 wc))))
     #+END_SRC
*** pos-of-client-selected-at-operation
**** description
     Returns the position of the selected client at a given operation.
**** generic-function
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric pos-of-client-selected-at-operation (op working-copy)
      (:documentation "Returns the route of the client selected at the operation op."))
     #+END_SRC
**** method (number basic-working-copy)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmethod pos-of-client-selected-at-operation
          ((op number)
           (wc basic-working-copy))
        "Returns info of the client selected at the operation with operand op."
        (second (second (aref (selected-clients wc) op))))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (with-basic-solution (s1 ((1 2) (3 4 5)))
        (let* ((wc (basic-working-copy s1))
               (c1 (first (clients (first (routes s1)))))
               (c2 (first (clients (second (routes s1))))))
          (format t "~%=========================================================
      Testing client-selected-at-operation (basic-working-copy)
      =========================================================~2%")
          (make-initial-routes-lengths wc)
          (initialize-selected-clients wc)
          ;; add the selected clients
          (setf (aref (selected-clients wc) 0) (list c1 `(1 1 nil)))
          (setf (aref (selected-clients wc) 1) (list c2 `(2 1 nil)))
          ;; let's test the client-selected-at-operation
          (check-= 1 (pos-of-client-selected-at-operation 0 wc))
          (check-= 1 (pos-of-client-selected-at-operation 1 wc))))
     #+END_SRC
*** incf-pos-of-client-selected-at-operation
**** description
     Incfs the position of the selected client at a given operation.
**** generic-function
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric incf-pos-of-client-selected-at-operation (op working-copy)
      (:documentation "Incfs the pos of the client selected at the operation op."))
     #+END_SRC
**** method (number basic-working-copy)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmethod incf-pos-of-client-selected-at-operation
          ((op number)
           (wc basic-working-copy))
        "Returns info of the client selected at the operation with operand op."
        (incf (second (second (aref (selected-clients wc) op)))))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (with-basic-solution (s1 ((1 2) (3 4 5)))
        (let* ((wc (basic-working-copy s1))
               (c1 (first (clients (first (routes s1)))))
               (c2 (first (clients (second (routes s1))))))
          (format t "~%=========================================================
          Testing incf-pos-of-client-selected-at-operation 
      =========================================================~2%")
          (make-initial-routes-lengths wc)
          (initialize-selected-clients wc)
          ;; add the selected clients
          (setf (aref (selected-clients wc) 0) (list c1 `(1 1 nil)))
          (setf (aref (selected-clients wc) 1) (list c2 `(2 1 nil)))
          ;; let's test the client-selected-at-operation
          (check-= 1 (pos-of-client-selected-at-operation 0 wc))
          (check-= 1 (pos-of-client-selected-at-operation 1 wc))
          ;; let's incf the position of the selected clients
          (incf-pos-of-client-selected-at-operation 0 wc)
          (check-= 2 (pos-of-client-selected-at-operation 0 wc))
          (incf-pos-of-client-selected-at-operation 0 wc)
          (check-= 3 (pos-of-client-selected-at-operation 0 wc))
          (incf-pos-of-client-selected-at-operation 1 wc)
          (check-= 2 (pos-of-client-selected-at-operation 1 wc))))
     #+END_SRC
*** decf-pos-of-client-selected-at-operation
**** description
     Decfs the position of the selected client at a given operation.
**** generic-function
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric decf-pos-of-client-selected-at-operation (op working-copy)
      (:documentation "Decfs the pos of the client selected at the operation op."))
     #+END_SRC
**** method (number basic-working-copy)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmethod decf-pos-of-client-selected-at-operation
          ((op number)
           (wc basic-working-copy))
        "Returns info of the client selected at the operation with operand op."
        (decf (second (second (aref (selected-clients wc) op)))))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (with-basic-solution (s1 ((1 2) (3 4 5)))
        (let* ((wc (basic-working-copy s1))
               (c1 (first (clients (first (routes s1)))))
               (c2 (first (clients (second (routes s1))))))
          (format t "~%=========================================================
      Testing client-selected-at-operation (basic-working-copy)
      =========================================================~2%")
          (make-initial-routes-lengths wc)
          (initialize-selected-clients wc)
          ;; add the selected clients
          (setf (aref (selected-clients wc) 0) (list c1 `(1 3 nil)))
          (setf (aref (selected-clients wc) 1) (list c2 `(2 2 nil)))
          ;; let's test the client-selected-at-operation
          (check-= 3 (pos-of-client-selected-at-operation 0 wc))
          (check-= 2 (pos-of-client-selected-at-operation 1 wc))
          ;; let's decf the position of the selected clients
          (decf-pos-of-client-selected-at-operation 0 wc)
          (check-= 2 (pos-of-client-selected-at-operation 0 wc))
          (decf-pos-of-client-selected-at-operation 0 wc)
          (check-= 1 (pos-of-client-selected-at-operation 0 wc))
          (decf-pos-of-client-selected-at-operation 1 wc)
          (check-= 1 (pos-of-client-selected-at-operation 1 wc))))
     #+END_SRC
** pp-selected-clients-array
*** description
    This function pretty-prints the selected-clients array of a working copy.  So far it is only used in some tests.  That's why it will be tangled to the tests file.
*** code
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-neighborhood-simulation.lisp 
    (defun pp-selected-clients-array (wc &optional (ind 2) (stream t))
      (if (< (selections-count wc) 0)
          (then (format t "selected-clients: NIL~%"))
          (else
            (format stream "selected-clients:~%")
            (loop for op from 0 to (selections-count wc)
                  doing (format stream "~a~a: ~a~%"
                                (make-string ind :initial-element #\SPACE)
                                op 
                                (aref (selected-clients wc) op))))))
    #+END_SRC

    #+RESULTS:

** client-c1-was-before-client-c2
*** description
    This function receives the indices of two selected clients, and returns non nil if in the original solution, the client c1 was before the client c2 in the same route.

    If we have a solution:
    #+BEGIN_EXAMPLE
    S1:
      r1: c1, c4, c3, c2
      r2: c6, c5
      r3: c7
    #+END_EXAMPLE

    Then
      - =(client-c1-was-before-client-c2 1 4 wc)= returns T
      - =(client-c1-was-before-client-c2 3 4 wc)= returns NIL
      - =(client-c1-was-before-client-c2 6 5 wc)= returns T
      - =(client-c1-was-before-client-c2 1 2 wc)= returns T
    

    This is useful in cases like the following.  If we have a solution S1
    #+BEGIN_EXAMPLE
    S1:
      r1: c1, c4, c3, c2
      r2: c6, c5
      r3: c7
    #+END_EXAMPLE

    And we make the following selections:

    Select c2 from (1,4)
    Select c4 from (1,2)
    Select c3 from (1,2)

    The solution is then:

    #+BEGIN_EXAMPLE
    S1:
      r1: c1
      r2: c6, c5
      r3: c7
    #+END_EXAMPLE
    
    And we have the following elements in the *selected-clients-array*

    0: (c2, (1 2))
    1: (c4, (1 2))
    2: (c3, (1 2))

    If we undo the last operation, we have the solution:

    #+BEGIN_EXAMPLE
    S1:
      r1: c1, c3
      r2: c6, c5
      r3: c7
    #+END_EXAMPLE

    and we should end with the following elements in the array:

    0: (c2, (1 3))
    1: (c4, (1 2))

    We know that we have to increment the position of c2 and not c4's because in the original solution c2 was "after" c3 and c4 was "before".  If we have that information we could undo any operation the right way (hopefully).

    In this section we write that function.
*** initialize-original-positions
**** description
     This function initializes the original-positions in the working-copy.  It should be called after the slot =routes-lengths= has been bound.
**** generic-function
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defgeneric initialize-original-positions (working-copy)
        (:documentation "Initializes the original-positions slot in the working-copy."))
      #+END_SRC
     
**** method (basic-working-copy)
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod initialize-original-positions ((wc basic-working-copy))
       "Initializes the original-positions array in the working-copy."
       ;; let's get the data from the insertion object.
       (let* ((number-of-clients (loop for r across (routes-lengths wc)
                                       summing r))
              (solution (solution wc)))
         ;; let's create the array
         (setf (original-positions wc) 
               (make-array (1+ number-of-clients)))
         ;; now let's fill the array
         (loop for r in (routes solution)
               for r-id = (id r)
               do (loop for c in (clients r)
                        for pos from 1
                        do (progn
                             (setf (aref (original-positions wc) (id c))
                                   (list r-id pos)))))))
     #+END_SRC
     
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 5) (4 3 6)))
       (let* ((wc (basic-working-copy s1)))

         (make-initial-routes-lengths wc)
         (setf (routes-lengths wc) (initial-routes-lengths wc))
    
         (format t "Using solution s1: ~a~%" s1)

         (format t "Before anything...~%")
         (format t "Array with the original-positions: ~a~%"
                 (original-positions wc))

         (initialize-original-positions wc)

         (format t "After initialize-original-positions...")
         (format t "Array with the original-positions:~%~a~%"
                 (original-positions wc))
         ))
     #+END_SRC
*** generic function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric client-c1-was-before-client-c2  (c1 c2 working-copy)
       (:documentation "Returns non nil if client c1 was in the same route as c2 and in a smaller position."))
     #+END_SRC
*** method (number number basic-working-copy)
**** documentation
     This methods returns non nil if, in the original solution of the given working copy, the first client was in the same route as the second one and in a smaller position.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod client-c1-was-before-client-c2
         ((c1 number) (c2 number) (wc basic-working-copy))
       "Returns non nil if, in the original solution, the client with id c1 was in a smaller position than the client with id c2 and in the same route. We don't check that they are in the same route. That is supposed to be done by the caller."
       ;; now let's compare the second value of the entries c1 and c2
       ;; in the slot original-positions of the working-copy.
         (< (second (aref (original-positions wc) c1))
            (second (aref (original-positions wc) c2))))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-solution (s1 ((1 2 3) (4 5 6) (7 8)))
       (let* ((wc (basic-working-copy s1)))

         (make-initial-routes-lengths wc)
         (setf (routes-lengths wc) (initial-routes-lengths wc))
         (initialize-original-positions wc)

         (format t "original-positions: ~a~%" (original-positions wc))

         (format t "~2%Testing client-c1-was-before-client-c2:~%")

         (check-t (client-c1-was-before-client-c2 1 2 wc))
         (check-t (client-c1-was-before-client-c2 1 3 wc))
         (check-t (client-c1-was-before-client-c2 2 3 wc))
         (check-t (client-c1-was-before-client-c2 5 6 wc))
         (check-t (client-c1-was-before-client-c2 7 8 wc))

         (check-nil (client-c1-was-before-client-c2 2 1 wc))
         (check-nil (client-c1-was-before-client-c2 5 4 wc))
         (check-nil (client-c1-was-before-client-c2 8 7 wc))
         (check-nil (client-c1-was-before-client-c2 6 4 wc))
         (check-nil (client-c1-was-before-client-c2 3 2 wc))))
    #+END_SRC
** update-selected-clients-after
*** description
    This functions updates the selected-clients in the working-copy.  It should be as simple as adding the appropriate element to the corresponding slot in the working copy and updating the position of the previouly selected clients.
*** generic-function
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (defgeneric update-selected-clients-after (op working-copy)
     (:documentation "A function to update the selected-clients in a working copy after some operation has been made."))
    #+END_SRC
*** method (select-client basic-working-copy)
**** description
     When we have a select-client operation and a basic-working-copy,  we update the position of all the previously selected clients according to the new selection, increment =selections-count=, and add the new element to the array.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod update-selected-clients-after
         ((op operation-select-client)
          (wc basic-working-copy))
       "Update the positions of all the previously selected clients according to the new selection, increment =selections-count=, and add the new element to the array."
       (let* ((selections-count (selections-count wc))
              (route (route op))
              (pos   (pos op)))
         ;; let's update the positions of the previously selected clients
         ;; in the same route than this selection
         (loop for op from 0 to selections-count
               when (and ;; the client is in the same route as the selection
                     (= (route-of-client-selected-at-operation op wc)
                        route)
                     ;; and the position is greater than the one
                     ;; in this in op
                     ;; (it cannot be the same because if they are the same
                     ;;  it means that the previously selected client was
                     ;;  in a position smaller than the one we are selecting
                     ;;  now and thus, this selection does not affect it.)
                     (> (pos-of-client-selected-at-operation op wc) pos))
               do (decf-pos-of-client-selected-at-operation op wc))
         ;; let's incf the selections-count
         (incf (selections-count wc))
         ;; let's store the information of the new insertion
         (setf (aref (selected-clients wc) (operand op))
               (list (client-at (list route pos) wc)   ;; the selected client
                     (list route pos)        ;; the coordinates of the client
                     nil                     ;; mark it as not yet inserted
                     ))))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-clients (2 3)
       (with-basic-solution (s1 ((1 2 3 4 5) (7 8 9)))
         (let* ((wc (basic-working-copy s1))
                (c1 (first (clients (first (routes s1)))))
                (op1 (op-select-client 1 3 0))
                (op2 (op-select-client 1 2 1))
                (op3 (op-select-client 1 1 2))
                (*vrp-unit-testing-display-output* t))
           (format t "~%=========================================================
     Testing client-selected-at-operation (basic-working-copy)
     =========================================================~2%")
           (prepare-solution-for-neighborhood-exploration wc)
           ;; add the selected clients

           (update-selected-clients-after op1 wc)
           (check-= 0 (selections-count wc))
           (check-obj= c3 (client-selected-at-operation 0 wc))
           (check-list= `(1 3)  (info-of-client-selected-at-operation 0 wc))

           (update-selected-clients-after op2 wc)
           (check-= 1 (selections-count wc))
           (check-obj= c2 (client-selected-at-operation 1 wc))
           (check-list= `(1 2)  (info-of-client-selected-at-operation 1 wc))
           (check-list= `(1 2)  (info-of-client-selected-at-operation 0 wc))

           (update-selected-clients-after op3 wc)
           (check-= 2 (selections-count wc))
           (check-obj= c1 (client-selected-at-operation 2 wc))
           (check-list= `(1 1)  (info-of-client-selected-at-operation 0 wc))
           (check-list= `(1 1)  (info-of-client-selected-at-operation 1 wc))
           (check-list= `(1 1)  (info-of-client-selected-at-operation 2 wc))

           ;; (check-= 3 (pos-of-client-selected-at-operation 0 wc))

           ;; (update-selected-clients-after op1 wc)
           ;; ;; let's test the client-selected-at-operation
           ;; (check-= 3 (pos-of-client-selected-at-operation 0 wc))
           ;; (update-selected-clients-after op2 wc)
           ;; (check-= 2 (pos-of-client-selected-at-operation 0 wc))
           ;; (update-selected-clients-after op3 wc)
           ;; (check-= 2 (pos-of-client-selected-at-operation 0 wc))
           ;; (check-= 3 (selections-count wc))



           )))
    #+END_SRC
*** method (insert-client basic-working-copy)
**** description
     When we have an insert-client operation and a basic-working-copy,  we update the position of all the previously selected clients according to the new selection.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod update-selected-clients-after ((op operation-insert-client)
                                               (wc basic-working-copy))
         "Update the positions of all the previously selected clients according to the new selection."
         (let* ((selections-count (selections-count wc))
                (route (route op))
                (pos   (pos op)))
           ;; let's update the positions of the previously selected clients
           ;; in the same route than this selection
           (loop for op from 0 to selections-count
                 when (and ;; the client is in the same route as the selection
                              (= (route-of-client-selected-at-operation op wc)
                                 route)
                              ;; and the position is greater or equal to the one in
                              ;; this in op increment the position
                              (>= (pos-of-client-selected-at-operation op wc) pos))
                 do (incf-pos-of-client-selected-at-operation op wc))))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-clients (2 3)
       (with-basic-solution (s1 ((1 2 3 4 5) (7 8 9)))
         (let* ((wc (basic-working-copy s1))
                (c1 (first (clients (first (routes s1)))))
                (op1 (op-select-client 1 3 0))
                (op2 (op-select-client 1 2 1))
                (op3 (op-select-client 1 1 2))

                (op4 (op-insert-client 1 1 1))
                (op5 (op-insert-client 1 2 2))
                (op6 (op-insert-client 1 1 0))

                (*vrp-unit-testing-display-output* t))
           (format t "~%=========================================================
     Testing client-selected-at-operation (basic-working-copy)
     =========================================================~2%")
           (prepare-solution-for-neighborhood-exploration wc)
           ;; add the selected clients

           (update-selected-clients-after op1 wc)
           (check-= 0 (selections-count wc))
           (check-obj= c3 (client-selected-at-operation 0 wc))
           (check-list= `(1 3)  (info-of-client-selected-at-operation 0 wc))

           (update-selected-clients-after op2 wc)
           (check-= 1 (selections-count wc))
           (check-obj= c2 (client-selected-at-operation 1 wc))
           (check-list= `(1 2)  (info-of-client-selected-at-operation 1 wc))
           (check-list= `(1 2)  (info-of-client-selected-at-operation 0 wc))

           (update-selected-clients-after op3 wc)
           (check-= 2 (selections-count wc))
           (check-obj= c1 (client-selected-at-operation 2 wc))
           (check-list= `(1 1)  (info-of-client-selected-at-operation 0 wc))
           (check-list= `(1 1)  (info-of-client-selected-at-operation 1 wc))
           (check-list= `(1 1)  (info-of-client-selected-at-operation 2 wc))

           (update-selected-clients-after op4 wc)
           (check-= 2 (selections-count wc))
           (check-list=  '(1 2) (info-of-client-selected-at-operation 0 wc))
           (check-list=  '(1 2) (info-of-client-selected-at-operation 1 wc))

           (update-selected-clients-after op5 wc)
           (check-= 2 (selections-count wc))
           (check-list=  '(1 3) (info-of-client-selected-at-operation 0 wc))
      


           )))
    #+END_SRC
** undo-selected-clients
*** description
        Syntax:

       =(undo-selected-clients operations working-copy)=
    
     This function returns the selected-clients in the working-copy to the state it was before the given operation was simulated in the working-copy.

     It should take care of the positions of the elements in the selected-clients, and it should also deal with the value of selections-count.

*** generic-function
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (defgeneric undo-selected-clients (op working-copy)
     (:documentation "A function to undo the effects of the update in the selected-clients of a working copy when an operation is simulated."))
    #+END_SRC
*** method (select-client basic-working-copy)
**** description
     When we have a select-client operation and a basic-working-copy,  we need to restore the the position of all the previously selected clients to value they had before the operation was simulated, and we need to decrement the value of the  =selections-count=.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod undo-selected-clients
         ((operation operation-select-client)
          (wc basic-working-copy))
       "Increment the position of all the previously selected-clients in the same route as the one in the op, and decrease the value of =selections-count=."
       ;; let's decrease the value of the =selections-count=
       (decf (selections-count wc))
       ;; increment the pos of all the previously selected-clients
       ;; in the operations route.
       (let* ((selections-count (selections-count wc))
              (route (route operation))
              (pos   (pos operation)))
         ;; let's update the positions of the previously selected clients
         ;; in the same route than this selection
         (loop for op from 0 to selections-count
               ;; if the the client op is was in a different route
               ;; than the client in the op that we are undoing
               ;; there is nothing to do. We are only interested in
               ;; the case where they both are in the same route.
               ;; That's what we check in the condition of the =when=.
               when ;; the client is in the same route as the selection
                    (= (route-of-client-selected-at-operation op wc)
                        route)
               do (progn ;; there are two (interesting) options
                    (cond
                      ;; the client is after the position
                      ;; of the selection we are undoing
                      ((> (pos-of-client-selected-at-operation op wc)
                          pos)
                       ;; in this case we incf the position of the element
                       (incf-pos-of-client-selected-at-operation op wc))
                      ;; the other (and the actually) interesting
                      ;; case is when the client is at the
                      ;; same position than the
                      ;; selection that we are undoing
                      ((= (pos-of-client-selected-at-operation op wc)
                          pos)
                       ;; in this case we should only increase
                       ;; its position if the client selected
                       ;; at op was after the client selected
                       ;; at the selection we are undoing.
                       ;; We can check that with the function
                       ;; client-c1-was-before-client-c2
                       (let* ((c-id ;; the id of the client
                               ;; selected at the op
                               ;; we are undoing
                               (id (client-selected-at-operation
                                    (operand operation) wc)))
                              (op-id ;; the id of the client
                               ;; at the position op
                               ;; in the selected-clients
                               (id (client-selected-at-operation
                                    op wc))))
                         (if (client-c1-was-before-client-c2
                              c-id op-id wc)
                             (incf-pos-of-client-selected-at-operation
                              op wc)))))))))
     #+END_SRC
**** tests
***** easy test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8)) 0)
       (let* ((wc1 (basic-working-copy s1))
              (c1 0) (c2 1) (c3 2)
              op1 op2 op3 ops1 ops2 ops3
              )

         (prepare-solution-for-neighborhood-exploration wc1)

         (format t "Before any operation:~%")
         (pp-solution wc1 t)    

         (format t "*insertions-made*: ~a~%"
                 (insertions-made wc1))

         (format t "After selection at (1 4):~%")
         (setf ops1 (op-select-client 1 4 c1))
         (simulate-neighborhood-operation ops1 wc1)
         (pp-solution wc1 t)(terpri)
         (format t "*insertions-made*: ~a~%"
                 (insertions-made wc1))
         (pp-selected-clients-array wc1) (terpri)


         (format t "After selection at (1 2):~%")
         (setf ops2 (op-select-client 1 2 c2))
         (simulate-neighborhood-operation ops2 wc1)
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)

         (format t "After selection at (1 1):~%")
         (setf ops3 (op-select-client 1 1 c3))
         (simulate-neighborhood-operation ops3 wc1)
         (pp-solution wc1 t)(terpri)
         (pp-selected-clients-array wc1) (terpri)


         (format t "Let's undo ~a~%" ops3)
         (undo-insertions ops3 wc1)
         (undo-routes-lengths ops3 wc1)
         (undo-actual-position ops3 wc1)
         (undo-selected-clients ops3 wc1)
         (pp-solution wc1 t) (terpri)
         (format t "selections-count: ~a~%" (selections-count wc1))
         (pp-selected-clients-array wc1) (terpri)


         (format t "Let's undo ~a~%" ops2)
         (undo-insertions ops2 wc1)
         (undo-routes-lengths ops2 wc1)
         (undo-actual-position ops2 wc1)
         (undo-selected-clients ops2 wc1)
         (pp-solution wc1 t) (terpri)
         (format t "selections-count: ~a~%" (selections-count wc1))
         (pp-selected-clients-array wc1) (terpri)

         (format t "Let's undo ~a~%" ops1)
         (undo-insertions ops1 wc1)
         (undo-routes-lengths ops1 wc1)
         (undo-actual-position ops1 wc1)
         (undo-selected-clients ops1 wc1)
         (format t "selections-count: ~a~%" (selections-count wc1))
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)

         ))
     #+END_SRC
***** test with several selections from the same position
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5)))
       (let* ((wc1 (basic-working-copy s1))
              (c1 0) (c2 1) (c3 2)
              ops1 ops2 ops3
              )

         (prepare-solution-for-neighborhood-exploration wc1)

         (initialize-original-positions wc1)

         (format t "~2%Fixing bug in undo-selected-clients~2%")

         (format t "Before any operation:~%")
         (pp-solution wc1 t) (terpri)
         (format t "selections-count: ~a~%" (selections-count wc1))
         (format t "*insertions-made*: ~a~%" (insertions-made wc1))

         (format t "After selecting c4 at (1 4):~%")
         (setf ops1 (op-select-client 1 4 c1))
         (simulate-neighborhood-operation ops1 wc1)
         (pp-solution wc1 t)(terpri)
         (format t "selections-count: ~a~%" (selections-count wc1))
         (format t "*insertions-made*: ~a~%" (insertions-made wc1))
         (pp-selected-clients-array wc1) (terpri)


         (format t "After selecting c2 at (1 2):~%")
         (setf ops2 (op-select-client 1 2 c2))
         (simulate-neighborhood-operation ops2 wc1)
         (pp-solution wc1 t) (terpri)
         (format t "selections-count: ~a~%" (selections-count wc1))
         (pp-selected-clients-array wc1) (terpri)

         (format t "After selecting c3 at (1 2):~%")
         (setf ops3 (op-select-client 1 2 c3))
         (simulate-neighborhood-operation ops3 wc1)
         (pp-solution wc1 t)(terpri)
         (format t "selections-count: ~a~%" (selections-count wc1))
         (pp-selected-clients-array wc1) (terpri)


         (format t "Let's undo ~a~%" ops3)
         (undo-insertions ops3 wc1)
         (undo-routes-lengths ops3 wc1)
         (undo-actual-position ops3 wc1)
         (undo-selected-clients ops3 wc1)
         (pp-solution wc1 t) (terpri)
         (format t "selections-count: ~a~%" (selections-count wc1))
         (pp-selected-clients-array wc1) (terpri)


         (format t "Let's undo ~a~%" ops2)
         (undo-insertions ops2 wc1)
         (undo-routes-lengths ops2 wc1)
         (undo-actual-position ops2 wc1)
         (undo-selected-clients ops2 wc1)
         (pp-solution wc1 t) (terpri)
         (format t "selections-count: ~a~%" (selections-count wc1))
         (pp-selected-clients-array wc1) (terpri)


         (format t "Let's undo ~a~%" ops1)
         (undo-insertions ops1 wc1)
         (undo-routes-lengths ops1 wc1)
         (undo-actual-position ops1 wc1)
         (undo-selected-clients ops1 wc1)
         (pp-solution wc1 t) (terpri)
         (format t "selections-count: ~a~%" (selections-count wc1))
         (pp-selected-clients-array wc1) (terpri)

         ))
     #+END_SRC
     
***** more elaborate
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (with-basic-clients (2 3)
        (with-basic-solution (s1 ((1 2 3 4 5) (7 8 9)))
          (let* ((wc (basic-working-copy s1))
                 (c1 (first (clients (first (routes s1)))))
                 (op1 (op-select-client 1 3 0))
                 (op2 (op-select-client 1 2 1))
                 (op3 (op-select-client 1 1 2))
                 (*vrp-unit-testing-display-output* t))
            (format t "~%==================================================
      Testing undo-selected-clients (basic-working-copy)
      ==================================================~2%")
            (prepare-solution-for-neighborhood-exploration wc)
            ;; add the selected clients

            (update-selected-clients-after op1 wc)
            (check-= 0 (selections-count wc))
            (check-obj= c3 (client-selected-at-operation 0 wc))
            (check-list= `(1 3)  (info-of-client-selected-at-operation 0 wc))

            (update-selected-clients-after op2 wc)
            (check-= 1 (selections-count wc))
            (check-obj= c2 (client-selected-at-operation 1 wc))
            (check-list= `(1 2)  (info-of-client-selected-at-operation 1 wc))
            (check-list= `(1 2)  (info-of-client-selected-at-operation 0 wc))

            (update-selected-clients-after op3 wc)
            (check-= 2 (selections-count wc))
            (check-obj= c1 (client-selected-at-operation 2 wc))
            (check-list= `(1 1)  (info-of-client-selected-at-operation 0 wc))
            (check-list= `(1 1)  (info-of-client-selected-at-operation 1 wc))
            (check-list= `(1 1)  (info-of-client-selected-at-operation 2 wc))

            (undo-selected-clients op3 wc)
            (check-= 1 (selections-count wc))
            (check-obj= c2 (client-selected-at-operation 1 wc))
            (check-list= `(1 2)  (info-of-client-selected-at-operation 1 wc))
            (check-list= `(1 2)  (info-of-client-selected-at-operation 0 wc))

            (undo-selected-clients op2 wc)
            (check-= 0 (selections-count wc))
            (check-obj= c3 (client-selected-at-operation 0 wc))
            (check-list= `(1 3)  (info-of-client-selected-at-operation 0 wc))


            )))
     #+END_SRC
*** method (insert-client basic-working-copy)
**** description
     When we have an insert-client operation and a basic-working-copy,  we undo the position of all the previously selected clients according to the operation.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod undo-selected-clients ((op operation-insert-client)
                                       (wc basic-working-copy))
       "Undoes the update of the positions of all the previously selected clients according to the new selection."
       (let* ((selections-count (selections-count wc))
              (route (route op))
              (pos   (pos op)))
         ;; let's update the positions of the previously selected clients
         ;; in the same route than this selection
         (loop for op from 0 to selections-count
               when (and ;; the client is in the same route as the selection
                     (= (route-of-client-selected-at-operation op wc)
                        route)
                     ;; and the position is greater or equal to the one in
                     ;; this in op increment the position
                     (> (pos-of-client-selected-at-operation op wc) pos))
               do (decf-pos-of-client-selected-at-operation op wc))))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-clients (2 3)
       (with-basic-solution (s1 ((1 2 3 4 5) (7 8 9)))
         (let* ((wc (basic-working-copy s1))
                (c1 (first (clients (first (routes s1)))))
                (op1 (op-select-client 1 3 0))
                (op2 (op-select-client 1 2 1))
                (op3 (op-select-client 1 1 2))

                (op4 (op-insert-client 1 1 1))
                (op5 (op-insert-client 1 2 2))

                (*vrp-unit-testing-display-output* t))
           (format t "~%=========================================================
     Testing client-selected-at-operation (basic-working-copy)
     =========================================================~2%")
           (prepare-solution-for-neighborhood-exploration wc)
           ;; add the selected clients

           (update-selected-clients-after op1 wc)
           ;; (check-obj= c3 (client-selected-at-operation 0 wc))
           ;; (check-list= `(1 3)  (info-of-client-selected-at-operation 0 wc))

           (update-selected-clients-after op2 wc)
           ;; (check-obj= c2 (client-selected-at-operation 1 wc))
           ;; (check-list= `(1 2)  (info-of-client-selected-at-operation 1 wc))
           ;; (check-list= `(1 2)  (info-of-client-selected-at-operation 0 wc))

           (update-selected-clients-after op3 wc)
           ;; (check-obj= c1 (client-selected-at-operation 2 wc))
           ;; (check-list= `(1 1)  (info-of-client-selected-at-operation 0 wc))
           ;; (check-list= `(1 1)  (info-of-client-selected-at-operation 1 wc))
           ;; (check-list= `(1 1)  (info-of-client-selected-at-operation 2 wc))

           ;; ;; from here on start the insertions

           (update-selected-clients-after op4 wc)
           ;; (check-= 2 (selections-count wc))
           ;; (check-list=  '(1 2) (info-of-client-selected-at-operation 0 wc))
           ;; (check-list=  '(1 2) (info-of-client-selected-at-operation 1 wc))

           (update-selected-clients-after op5 wc)
           ;; (check-= 2 (selections-count wc))
           ;; (check-list=  '(1 3) (info-of-client-selected-at-operation 0 wc))

           ;; ;; testing the undo of the insertions

           (undo-selected-clients op5 wc)
           (check-= 2 (selections-count wc))
           (check-list=  '(1 2) (info-of-client-selected-at-operation 0 wc))
           (check-list=  '(1 2) (info-of-client-selected-at-operation 1 wc))

           (undo-selected-clients op4 wc)
           (check-obj= c1 (client-selected-at-operation 2 wc))
           (check-list= `(1 1)  (info-of-client-selected-at-operation 0 wc))
           (check-list= `(1 1)  (info-of-client-selected-at-operation 1 wc))
           (check-list= `(1 1)  (info-of-client-selected-at-operation 2 wc))


           )))
    #+END_SRC

    

* Insertion management
** description
   In this section we create the generic-functions and method required to manage the insertions in a working copy.

   The idea is that we'll have a data structure with all the insertions made, and we'll query this data structure for the data we want related to the insertions.

   In this initial idea the data structure will be the a list where each element is a list of the form (r,p,c) where r and p are the route and the position where the insertion was made and c is the client that was inserted.

   This list will be a slot in the basic working copy.

   We are going to have several functions to deal with this.  These functions are:

   - there-was-an-insertion-at (moved to the client-at section)
   - update-insertions

** update-insertions
*** description
    This function, as its name suggests, updates the insertions made during the neighborhood-explorations.  It will be a generic function and we'll specialize it for diferent types of neighborhood operations.
*** generic function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric update-insertions-after  (op working-copy)
       (:documentation "A function to update the insertions made during the neighborhood exploration."))
     #+END_SRC
*** method (op-insert-client basic-working-copy)
**** documentation
     In this case we add the insertion to the insertions-made and update the insertions previously made in the same route.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod update-insertions-after  ((operation operation-insert-client)
                                   (wc basic-working-copy))
       "Updates the insertions-made list of working-copy with the new insertion."
       ;; let's get the data from the insertion object.
       (let*
           ((insertions-made (insertions-made wc))
            (route-id (route operation))
            (pos (pos operation))
            (cindex (operand operation))
            (client (client-selected-at-operation cindex wc)))

         ;; update the insertions previously made to the same route
         (loop for (r p c) in insertions-made
               for insertion in insertions-made
               if (and (= r route-id)
                       (>= p pos))
               do (incf (second insertion)))
         ;; push the insertion into the list
         (push `(,route-id ,pos ,client) (insertions-made wc))))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-clients (2 3)
       (with-basic-solution (s1 ((1 2 3 4 5) (7 8 9)))
         (let* ((wc (basic-working-copy s1))
                (c1 (first (clients (first (routes s1)))))
                (op1 (op-select-client 1 3 0))
                (op2 (op-insert-client 2 3 0))
                (op3 (op-insert-client 2 2 0))
                (op4 (op-select-client 2 1 1))
                (*vrp-unit-testing-display-output* t))
           (format t "~%=========================
     Testing update-insertions
     =========================~2%")
           (prepare-solution-for-neighborhood-exploration wc)

           (check-nil (insertions-made wc))

           ;; add the selected clients
           (update-selected-clients-after op1 wc)
           (update-insertions-after  op1 wc)
           (update-actual-position-after op1 wc)
           (format t "After op1: ~a~%" (insertions-made wc))

           (update-selected-clients-after op2 wc)
           (update-insertions-after  op2 wc)
           (update-actual-position-after op2 wc)
           (format t "After op2: ~a~%" (insertions-made wc))
           (check-obj= `(2 3 ,c3) (first (insertions-made wc)))

      
           (update-selected-clients-after op3 wc)
           (update-insertions-after  op3 wc)
           (update-actual-position-after op3 wc)
           (format t "After op2: ~a~%" (insertions-made wc))
           (check-obj= `(2 2 ,c3) (first (insertions-made wc)))
           (check-obj= `(2 4 ,c3) (second (insertions-made wc)))
      
           (update-selected-clients-after op4 wc)
           (update-insertions-after  op4 wc)
           (update-actual-position-after op4 wc)
           (format t "After op3: ~a~%" (insertions-made wc))
           (check-obj= `(2 1 ,c3) (first (insertions-made wc)))
           (check-obj= `(2 3 ,c3) (second (insertions-made wc)))

           (format t "selected-clients: ~a~%" (selected-clients wc))





           )))
    #+END_SRC
*** method (op-select-client basic-working-copy)
**** documentation
     In this case we update the positions of the previously inserted clients.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod update-insertions-after  ((operation operation-select-client)
                                   (wc basic-working-copy))
     "After a selection operation we just update the insertions previously made to the same route."
     (let*
         ((route-id (route operation))
          (pos (pos operation)))
       ;; update the insertions previously made to the same route
       (loop for (r p c) in (insertions-made wc)
          for insertion in (insertions-made wc)
          if (and (= r route-id)
                  (>= p pos))
          do (decf (second insertion)))))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-clients (2 3)
       (with-basic-solution (s1 ((1 2 3 4 5) (7 8 9)))
         (let* ((wc (basic-working-copy s1))
                (c1 (first (clients (first (routes s1)))))
                (op1 (op-select-client 1 3 0))
                (op2 (op-select-client 1 2 1))
                (op3 (op-select-client 1 1 2))
                (*vrp-unit-testing-display-output* t))
           (format t "~%=========================
     Testing update-insertions
     =========================~2%")
           (prepare-solution-for-neighborhood-exploration wc)
           ;; add the selected clients

           (check-nil (insertions-made wc))
           (update-insertions-after  op1 wc)
           (format t "After op1: ~a~%" (insertions-made wc))



           )))
    #+END_SRC
** undo-insertions
*** description
    This function undoes the updates the insertions made during the neighborhood-explorations.
*** generic function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric undo-insertions  (op working-copy)
       (:documentation "A function to undo the updates due to the insertions made during the neighborhood exploration."))
     #+END_SRC
*** method (op-insert-client basic-working-copy)
**** documentation
     In this case we remove the insertion from the insertions-made and restore the values of the insertions previously made in the same route.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod undo-insertions  ((operation operation-insert-client)
                                  (wc basic-working-copy))
       "Remove the insertion from the insertions-made list of the working-copy and restores the values of the previously made insertions to the same route."
       ;; let's remove the insertions from the insertions list
       ;; it should be the first element of the list
       ;; because it is added with a push
       (pop (insertions-made wc))
       ;; now restore the pos of the previously inserted clients
       ;; in the same route than the one in the operation
       (let* ((route (route operation))
              (pos   (pos   operation))
              (insertions-made (insertions-made wc)))
         (loop for (r p c) in insertions-made
                     for insertion in insertions-made
                     if (and (= r route)
                             (> p pos))
                     do (decf (second insertion)))))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-clients (2 3)
       (with-basic-solution (s1 ((1 2 3 4 5) (7 8 9)))
         (let* ((wc (basic-working-copy s1))
                (c1 (first (clients (first (routes s1)))))
                (op1 (op-select-client 1 3 0))
                (op2 (op-insert-client 2 3 0))
                (op3 (op-insert-client 2 2 0))
                (*vrp-unit-testing-display-output* t))
           (format t "~%=========================
     Testing update-insertions
     =========================~2%")
           (prepare-solution-for-neighborhood-exploration wc)

           ;; (check-nil (insertions-made wc))

           ;; add the selected clients
           (update-selected-clients-after op1 wc)
           (update-insertions-after  op1 wc)
           (update-actual-position-after op1 wc)
           ;; (format t "After op1: ~a~%" (insertions-made wc))

           (update-selected-clients-after op2 wc)
           (update-insertions-after  op2 wc)
           (update-actual-position-after op2 wc)
           ;; (format t "After op2: ~a~%" (insertions-made wc))
           ;; (check-obj= `(2 3 ,c3) (first (insertions-made wc)))




           (update-selected-clients-after op3 wc)
           (update-insertions-after  op3 wc)
           (update-actual-position-after op3 wc)
           ;; (format t "After op3: ~a~%" (insertions-made wc))
           ;; (check-obj= `(2 2 ,c3) (first (insertions-made wc)))
           ;; (check-obj= `(2 4 ,c3) (second (insertions-made wc)))


           ;; ;; testing the undo-insertions-made
      
           (undo-selected-clients op3 wc)
           (undo-actual-position  op3 wc)
           (undo-insertions       op3 wc)
           (format t "After undoing op3: ~a~%" (insertions-made wc))
           (check-obj= `(2 3 ,c3) (first (insertions-made wc)))

      
           (undo-selected-clients op2 wc)
           (undo-insertions       op2 wc)
           (undo-actual-position  op2 wc)
           (format t "After undoing op2: ~a~%" (insertions-made wc))
      





           )))
    #+END_SRC
*** method (op-select-client basic-working-copy)
**** documentation
     In this case we just undo the updates in the positions of the previously inserted clients in the same route.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod undo-insertions ((op operation-select-client)
                                 (wc basic-working-copy))
       "After a selection operation we just undo the updates in the insertions-made due to the insertions previously made to the same route.  As we are not going to allow the selections of clients after the first insertion has been made, there is nothing to undo here."
       nil)
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-solution (s1 ((1 2 3 4 5) (7 8 9)))
         (let* ((wc (basic-working-copy s1))
                (op1 (op-select-client 1 3 0))
                (*vrp-unit-testing-display-output* t))
           (format t "~%=========================
     Testing update-insertions
     =========================~2%")
           (prepare-solution-for-neighborhood-exploration wc)
           ;; add the selected clients

           (check-nil (insertions-made wc))
           (update-insertions-after  op1 wc)
           (format t "After op1: ~a~%" (insertions-made wc))))
    #+END_SRC
** API to access the inserted clients info
*** description
    In this section we add all the functions to access info related to the inserted-clients.
*** get-inserted-client-info
**** description
     Returns the stored information of the inserted client at a given operation.
**** generic-function
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric get-inserted-client-info (operand working-copy)
      (:documentation "Returns the coordinates where the client selected at op operand was inserted."))
     #+END_SRC
**** method (number basic-working-copy)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmethod get-inserted-client-info
          ((op number)
           (wc basic-working-copy))
        "Returns info of the client selected at the operation with operand op."
        (let* ((client (client-selected-at-operation op wc)))
          ;; now let's get the info about the insertion
          (loop for (r p c) in (insertions-made wc)
                when (obj= c client)
                do (return (list r p)))))
      #+END_SRC
***** tests
****** basic tests
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (with-basic-solution (s1 ((1 2 6) (3 4 5 7)))
         (let* ((wc (basic-working-copy s1))
                (op1 (op-select-client 1 3 0))
                (op2 (op-select-client 2 4 1))
                (op3 (op-insert-client 1 2 0))
                (op4 (op-insert-client 1 1 1)))

             (bformat t "Testing get-inserted-client-info")

             (prepare-solution-for-neighborhood-exploration wc)

             ;; ;; let's simulate the selections
             (loop for op in (get-simpler-operations-from op1 wc)
                   do (simulate-neighborhood-operation op wc))

             (loop for op in (get-simpler-operations-from op2 wc)
                   do (simulate-neighborhood-operation op wc))

             ;; (format t "Solution after the selections:~%")
             ;; (pp-solution wc t) (terpri)

             ;; ;; let's simulate the insertions
             (loop for op in (get-simpler-operations-from op3 wc)
                   do (simulate-neighborhood-operation op wc))


             ;; (format t "Solution after the 1st insertion:~%")
             ;; (pp-solution wc t) (terpri)

             ;; (format t "info of client selected at 0: ~a~%"
             ;;         (get-inserted-client-info 0 wc))

             (loop for op in (get-simpler-operations-from op4 wc)
                   do (simulate-neighborhood-operation op wc))


             ;; (format t "Solution after the insertions:~%")
             ;; (pp-solution wc t) (terpri)

             ;; (format t "info of client selected at 1: ~a~%"
             ;;         (get-inserted-client-info 1 wc))

             ;; (format t "info of client selected at 0 after 2nd insertion: ~a~%"
             ;;         (get-inserted-client-info 0 wc))
             ;; let's test the client-selected-at-operation
             (check-list= `(1 3) (get-inserted-client-info 0 wc))
             (check-list= `(1 1) (get-inserted-client-info 1 wc))
             ))
      #+END_SRC
*** get-inserted-client-route
**** description
     Returns the route of where the selected client at a given operation was inserted.
**** generic-function
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric get-inserted-client-route (op working-copy)
      (:documentation "Returns the route where the client selected at the operation op was inserted."))
     #+END_SRC
**** method (number basic-working-copy)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmethod get-inserted-client-route
          ((op number)
           (wc basic-working-copy))
        "Returns the route where the client selected at the operation with operand op was inserted."
        (first (get-inserted-client-info op wc)))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (with-basic-solution (s1 ((1 2 6) (3 4 5 7)))
         (let* ((wc (basic-working-copy s1))
                (op1 (op-select-client 1 3 0))
                (op2 (op-select-client 2 4 1))
                (op3 (op-insert-client 2 2 0))
                (op4 (op-insert-client 1 1 1)))

             (bformat t "Testing get-inserted-client-route")

             (prepare-solution-for-neighborhood-exploration wc)

             ;; ;; let's simulate the selections
             (loop for op in (get-simpler-operations-from op1 wc)
                   do (simulate-neighborhood-operation op wc))

             (loop for op in (get-simpler-operations-from op2 wc)
                   do (simulate-neighborhood-operation op wc))

             ;; (format t "Solution after the selections:~%")
             ;; (pp-solution wc t) (terpri)

             ;; ;; let's simulate the insertions
             (loop for op in (get-simpler-operations-from op3 wc)
                   do (simulate-neighborhood-operation op wc))


             ;; (format t "Solution after the 1st insertion:~%")
             ;; (pp-solution wc t) (terpri)

             ;; (format t "info of client selected at 0: ~a~%"
             ;;         (get-inserted-client-route 0 wc))

             (loop for op in (get-simpler-operations-from op4 wc)
                   do (simulate-neighborhood-operation op wc))

             (check-= 2 (get-inserted-client-route 0 wc))
             (check-= 1 (get-inserted-client-route 1 wc))


             ;; (format t "Solution after the insertions:~%")
             ;; (pp-solution wc t) (terpri)

             ;; (format t "info of client selected at 1: ~a~%"
             ;;         (get-inserted-client-route 1 wc))

             ;; (format t "info of client selected at 0 after 2nd insertion: ~a~%"
             ;;         (get-inserted-client-route 0 wc))
       
             ))
     #+END_SRC
*** get-inserted-client-pos
**** description
     Returns the position where the selected client at a given operation was inserted.
**** generic-function
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric get-inserted-client-pos (op working-copy)
      (:documentation "Returns the position where the client selected at the operation op was inserted."))
     #+END_SRC
**** method (number basic-working-copy)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmethod get-inserted-client-pos
          ((op number)
           (wc basic-working-copy))
        "Returns the position where the client selected at the operation with operand op was inserted."
        (second (get-inserted-client-info op wc)))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (with-basic-solution (s1 ((1 2 6) (3 4 5 7)))
         (let* ((wc (basic-working-copy s1))
                (op1 (op-select-client 1 3 0))
                (op2 (op-select-client 2 4 1))
                (op3 (op-insert-client 1 2 0))
                (op4 (op-insert-client 1 1 1)))

             (bformat t "Testing get-inserted-client-pos")

             (prepare-solution-for-neighborhood-exploration wc)

             ;; ;; let's simulate the selections
             (loop for op in (get-simpler-operations-from op1 wc)
                   do (simulate-neighborhood-operation op wc))

             (loop for op in (get-simpler-operations-from op2 wc)
                   do (simulate-neighborhood-operation op wc))

             ;; (format t "Solution after the selections:~%")
             ;; (pp-solution wc t) (terpri)

             ;; ;; let's simulate the insertions
             (loop for op in (get-simpler-operations-from op3 wc)
                   do (simulate-neighborhood-operation op wc))


             ;; (format t "Solution after the 1st insertion:~%")
             ;; (pp-solution wc t) (terpri)

             ;; (format t "info of client selected at 0: ~a~%"
             ;;         (get-inserted-client-route 0 wc))

             (check-= 2 (get-inserted-client-pos 0 wc))
       
             (loop for op in (get-simpler-operations-from op4 wc)
                   do (simulate-neighborhood-operation op wc))

             (check-= 3 (get-inserted-client-pos 0 wc))
             (check-= 1 (get-inserted-client-pos 1 wc))


             ;; (format t "Solution after the insertions:~%")
             ;; (pp-solution wc t) (terpri)

             ;; (format t "info of client selected at 1: ~a~%"
             ;;         (get-inserted-client-route 1 wc))

             ;; (format t "info of client selected at 0 after 2nd insertion: ~a~%"
             ;;         (get-inserted-client-route 0 wc))

             ))
     #+END_SRC
    
     

* Prepare solution for neighborhood exploration
** description
   The function that we are going to create in this section should initialize the working copy for the neighborhood exploration.

   In the case of the basic-working-copy this function should do the following:

    - create the working-copy from the solution
    - initialize the actual-position function
    - set the insertions-made slot to nil

   I think that it will be a good idea to make this a generic function, so it can behave differently accordingly to the solution passed as argument.

   This function modifies the working-copy it receives and doesn't return anything.
   
** generic-function
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
   (defgeneric prepare-solution-for-neighborhood-exploration
       (working-copy)
    (:documentation "A function to create the working copy from a given solution."))
   #+END_SRC
** method (basic-working-copy)
*** description
    In this case we receive a basic-solution and sets all the values to start the neighborhood exploration.

    We need to do the following:
     - create the working-copy from the solution
     - initialize the actual-position function
     - initialize the insertions made
     - initialize the selected-clients

*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (defmethod prepare-solution-for-neighborhood-exploration
        ((wc basic-working-copy))
      "Initializes the working-copy to start a neighborhood exploration."

      ;; initialize the actual-position function
      (make-initial-actual-position wc)
      ;; initialize the insertions-made to nil
      (setf (insertions-made wc) nil)
      ;; add the number of routes
      (initialize-number-of-routes wc)
      ;; add the info about the routes lengths
      ;;   first the initial routes
      (make-initial-routes-lengths wc)
      ;;   and now the current routes length
      (setf (routes-lengths wc) (clone (initial-routes-lengths wc)))
      ;; set the selections count to -1
      (setf (selections-count wc) -1)
      ;; initialize-selected-clients
      (initialize-selected-clients wc)

      ;; initialize the original positions
      (initialize-original-positions wc)

      ;; initialize the selected-subroutes info
      (setf (selected-subroutes wc) nil)

      ;; initialize the selected-clients-during-apply
      (setf (selected-clients-during-apply wc) nil)

      )
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
    (with-basic-solution (s1 ((1 2) (3 4 5 6)))
         (let* ((wc (basic-working-copy s1))
                (op1 (op-select-client 2 1 0))
                (op2 (op-insert-client 2 2 1))
                (op3 (op-insert-client 2 2 2)))
           ;; set the actual-position-functions-stack
           (prepare-solution-for-neighborhood-exploration wc)
           (bformat t "Testing prepare-solution-for-neighborhood-exploration")

           (check-= 2 (number-of-routes wc))

           (format t "Testing actual-positions~%")
           (update-actual-position-after op1 wc)

           (check-list= `(2 2) (actual-position `(2 1) wc))
           (check-list= `(2 3) (actual-position `(2 2) wc))

           ;; so far we have: (4 5 6)
           (update-actual-position-after op2 wc)
           ;; now we have: (4 I 5 6)
           ;; original:    (3 4 5 6)

           (check-list= `(2 2) (actual-position `(2 1) wc))
           (check-list= `(2 3) (actual-position `(2 3) wc))
           (update-actual-position-after op3 wc)
           ;; now we have: (4 J I 5 6)
           ;; original:    (3 4 5 6)

           (check-list= `(2 2) (actual-position `(2 1) wc))
           (check-list= `(2 3) (actual-position `(2 4) wc))
           (check-list= `(2 4) (actual-position `(2 5) wc))

           (format t "Testing insertions-made:~%")
           (check-nil (insertions-made wc))

           (format t "Testing Initial routes-length:~%")
           (check-obj= #(0 2 4) (initial-routes-lengths wc))

           (format t "Testing routes-length:~%")
           (check-obj= #(0 2 4) (routes-lengths wc))

           (format t "Testing selections-count:~%")
           (check-= -1 (selections-count wc))

           (format t "Testing selected-clients:~%")
           (check-= 6 (length (selected-clients wc)))

           (format t "Testing selected-subroutes:~%")
           (check-nil (selected-subroutes wc))

           (format t "Testing selected-clients-during-apply:~%")
           (check-nil (selected-clients-during-apply wc))

           ))

    #+END_SRC



* Pretty printing
  
** description
   In this section I'm going to add the pretty-printing functions.  They will be named with the following convention: =pp-thing=

** pp-route
*** description
    In this section we write how to pp a route.
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric pp-route (route working-copy stream)
       (:documentation "Pretty prints the given route from the given working copy to the given stream."))
     #+END_SRC
*** method (number basic-working-copy t)
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (defmethod pp-route ((route number)
                         (wc basic-working-copy)
                         stream)
        "Pretty prints a route of the given working copy using the client-at and the route-length functions, by writing to the given stream."

        (let* ((length (route-length route wc)))
          (format stream "  R~a: (" route)
          (if (> length 0)
              (then
                (format stream "~a"
                        (id 
                         (funcall 'client-at (list route 1) wc)))
                (loop for pos from 2 to length 
                      doing (format stream ", ~a"
                                    (id (client-at (list route pos) wc))))))
          (format stream ")")))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4) (5 6 7)))
       (let* ((wc (basic-working-copy s1)))
         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing pp-route")
         (pp-route 1 wc t) (terpri)
         (pp-route 2 wc t) (terpri)))
     #+END_SRC
*** method (number basic-solution t)
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod pp-route ((route-id number)
                          (wc basic-solution)
                          stream)
         "Pretty prints a route of the given solution using the client-at and the route-length functions, by writing to the given stream."

         (let* ((route (get-route-with-id route-id wc))
                (length (length (clients route))))
           (format stream "  R~a: (" route-id)
           (if (> length 0)
               (then
                 (format stream "~a"
                         (id 
                          (get-client-at-pos (list route-id 1) wc)))
            
                 (loop for pos from 2 to length 
                       doing (format stream ", ~a"
                                     (id (get-client-at-pos
                                              (list route-id pos) wc))))))
           (format stream ")")))
     #+END_SRC
**** tests
***** basic test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3 4) (5 6 7) (8 9)))

        (bformat t "Testing pp-route for basic-solution")
        (pp-route 1 s1 t) (terpri)
        (pp-route 2 s1 t) (terpri))
      #+END_SRC
***** basic writing to a file
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3 4) (5 6 7) (8 9)))

        (bformat t "Testing pp-route for basic-solution (to a file)")

        (with-open-file (f "/tmp/vrp-suite-tests.txt"
                           :direction :output
                           :if-exists :supersede)
          (pp-route 1 s1 f) (terpri f)
          (pp-route 2 s1 f) (terpri f)))
      #+END_SRC
** pp-solution
*** description
    In this section we write how to pp a solution (actually it will be a working-copy, although we could specialize it in basic-solutions).
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric pp-solution ( working-copy stream)
       (:documentation "Pretty prints the given solution (usually a working-copy) to the given stream."))
     #+END_SRC
*** +method (basic-working-copy t)+
**** description
     In this code we don't take into account that we can create routes on the fly, and we work directly with the routes in the solution.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code
     (defmethod pp-solution ((wc basic-working-copy) stream)
       "Pretty prints a basic-working-copy using the client-at and the route-length functions."
       ;; first let's print the id of the working copy
       (format stream "S~a:~%" (id (solution wc)))
       ;; now let's print each route on one line each
       (loop for route in (routes (solution wc))
             for id = (id route)
             ;; add some indentation,
             doing (format stream "  ")
             ;; pp the route,
             doing (pp-route id wc stream)
             ;; add a newline after the route.
             doing (format stream "~%")))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4)
                               (5 6 7)
                               ()
                               (8 9 10)))
       (let* ((wc (basic-working-copy s1)))
         (prepare-solution-for-neighborhood-exploration wc)

         (format t "================
     Testing pp-route
     ================~2%")
         (pp-solution wc t) (terpri)))
     #+END_SRC
*** method (basic-working-copy t)
**** description
     In this code we take into account that we can create routes on the fly, and we assume that the routes' ids start from 1 and are all smaller or equal to the number-of-routes in the working-copy.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod pp-solution ((wc basic-working-copy) stream)
       "Pretty prints a basic-working-copy using the client-at and the route-length functions."
       ;; first let's print the id of the working copy
       (format stream "S~a:~%" (id (solution wc)))
       ;; now let's print each route on one line each
       (loop for route-id from 1 to (number-of-routes wc)
             ;; add some indentation,
             doing (format stream "  ")
             ;; pp the route,
             doing (pp-route route-id wc stream)
             ;; add a newline after the route.
             doing (format stream "~%")))
     #+END_SRC
**** tests
***** simple test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3 4)
                                (5 6 7)
                                ()
                                (8 9 10)))
        (let* ((wc (basic-working-copy s1)))
          (prepare-solution-for-neighborhood-exploration wc)

          (format t "================
      Testing pp-route
      ================~2%")
          (pp-solution wc t) (terpri)))
      #+END_SRC
***** simple with added route
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3 4)
                                (5 6 7)
                                ()
                                (8 9 10)))
        (let* ((wc (basic-working-copy s1)))
          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing pp-solution")
    
          (format t "Original solution~%")
          (pp-solution wc t) (terpri)

          (format t "routes-lengths: ~a~%"
                  (routes-lengths wc))



          (vector-push-extend 0 (routes-lengths wc))
          (incf (number-of-routes wc))

          (format t "After `adding' another route~%")
          (pp-solution wc t) (terpri)

          (vector-push-extend 0 (routes-lengths wc))
          (incf (number-of-routes wc))
          (format t "After `adding' yet another route~%")
          (pp-solution wc t) (terpri)

          (format t "Removing the last route~%")
          (vector-pop (routes-lengths wc))
          (decf (number-of-routes wc))
          (pp-solution wc t) (terpri)


          (format t "After finish-apply-neighborhood-operations:~%")
          (finish-apply-neighborhood-operations wc)
          (pp-solution (solution wc) t) (terpri)

          (prepare-solution-for-neighborhood-exploration wc)
          (pp-solution (solution wc) t) (terpri)
    
    
  
        ))
      #+END_SRC
***** simple with added route writing to file
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3 4)
                                (5 6 7)
                                ()
                                (8 9 10)))
        (with-open-file (f "/tmp/vrp-suite-tests.txt"
                           :direction :output
                           :if-exists :supersede)
          (let* ((wc (basic-working-copy s1)))
            (prepare-solution-for-neighborhood-exploration wc)

            (bformat f "Testing pp-solution (to file)")

            (format f "Original solution~%")
            (pp-solution wc f) (terpri f)

            (format f "routes-lengths: ~a~%"
                    (routes-lengths wc))



            (vector-push-extend 0 (routes-lengths wc))
            (incf (number-of-routes wc))

            (format f "After `adding' another route~%")
            (pp-solution wc f) (terpri f)

            (vector-push-extend 0 (routes-lengths wc))
            (incf (number-of-routes wc))
            (format f "After `adding' yet another route~%")
            (pp-solution wc f) (terpri f)

            (format f "Removing the last route~%")
            (vector-pop (routes-lengths wc))
            (decf (number-of-routes wc))
            (pp-solution wc f) (terpri f)


            (format f "After finish-apply-neighborhood-operations:~%")
            (finish-apply-neighborhood-operations wc)
            (pp-solution (solution wc) f) (terpri f)

            (format f "After prepare-solution-for-neighborhood-exploration:~%")
            (prepare-solution-for-neighborhood-exploration wc)
            (pp-solution (solution wc) f) (terpri f)



            )))
      #+END_SRC
*** method (basic-solution t)
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod pp-solution ((wc basic-solution) stream)
       "Pretty prints a basic-working-copy using the client-at and the route-length functions."
       ;; first let's print the id of the working copy
       (format stream "S~a:~%" (id wc))
       ;; now let's print each route on one line each
       (loop for route in (routes wc)
             for id = (id route)
             ;; add some indentation,
             doing (format stream "  ")
             ;; pp the route,
             doing (pp-route id wc stream)
             ;; add a newline after the route.
             doing (format stream "~%")))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4)
                               (5 6 7)
                               ()
                               (8 9 10)))

       (bformat t "Testing pp-solution")
       (pp-solution s1 t))
     #+END_SRC



* Simulate neighborhood operation
  
** description
   In this section we add the functions to simulate a neighborhood operation.  Ideally, this functions should be simple and easily extensible, in a way that if anyone is interested in extending it, the actions should be to implement a new class, and ideally add some :after or :before methods.
** generic-function
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (defgeneric simulate-neighborhood-operation 
        (op working-copy)
      (:documentation "Updates the working copy in a way that client-at will behave as if the operation described by the first argument had actually taken place."))
    #+END_SRC
** method (any-operation basic-working-copy)
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (defmethod simulate-neighborhood-operation
        (op (wc basic-working-copy))
      "Simulates a selection in a basic-working-copy."

      (update-selected-clients-after op wc)
      (update-insertions-after       op wc)
      (update-actual-position-after  op wc)
      (update-routes-lengths-after   op wc))
    #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
    (with-basic-solution (s1 ((1 2 3 4 5 6) (7)))
       (let* ((wc (basic-working-copy s1))
              (op1 (op-select-client 1 4 0))
              (op2 (op-select-client 1 2 1))
              (op3 (op-insert-client 2 1 0))
              (op4 (op-insert-client 1 5 1)))

         (prepare-solution-for-neighborhood-exploration wc)

         (format t "=======================================
    Testing simulate-neighborhood-operation
    =======================================~2%")

         (format t "Before any operation:~%")
         (pp-solution wc t) (terpri)

         (loop for op in (list op1 op2 op3 op4)

               doing (progn
                       (format t "After operation ~a~%" op)
                       (simulate-neighborhood-operation op wc)
                       (pp-solution wc t) (terpri)

                       (format t "insertions-made: ~a~%"
                               (insertions-made wc))

                       (format t "selected-clients ~a~2%"
                               (selected-clients wc))))))
     #+END_SRC



* Undo neighborhood operation

** description
   In this section I'm going to write functions to simulate an undo for a given operation.  This undo functions can be used in a full exploration of a neighborhood.

   The main assumption with these functions is that the undo is done in a LIFO order.  

** generic function
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (defgeneric undo-neighborhood-operation 
        (op working-copy)
      (:documentation "Undoes the updates done by the simulate-neighborhood-operation when processing the given op."))
    #+END_SRC

** method (any operation basic-working-copy)
*** description
    So far, we'll only need one method because all the specifics will be handled by the lower-level `undo' functions. 
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (defmethod undo-neighborhood-operation
       (operation (working-copy basic-working-copy))
     "Undoes the effect of the operation passed as the first argument in the working-copy. It restores the actual-position, the routes-lengths, the insertions-made and the selected-clients to the state they were before the operation was simulated."
     ;; first we undo the effect in the route-lengths
     (undo-routes-lengths operation working-copy)
     ;; now we undo the actual-positions
     (undo-actual-position operation working-copy)
     ;; now we undo the effect on the insertions-made
     (undo-insertions operation working-copy)
     ;; undo the selected-clients
     (undo-selected-clients operation working-copy))
    #+END_SRC
*** tests
**** tests for insert-client
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
    (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8)) 0)
      (let* ((wc (basic-working-copy s1))
             op1 op2 ops1 ops2)

        (prepare-solution-for-neighborhood-exploration wc)

    
        (format t "~2%===================================
    Testing undo-neighborhood-operation
    ===================================~2%")
    
        (format t "Before any operation:~%")
        (pp-solution wc t) (terpri)    

        (format t "insertions-made: ~a~%" (insertions-made wc))

        (format t "After selection at (2 1):~%")
        (setf ops1 (op-select-client 2 1 0))
        (simulate-neighborhood-operation ops1 wc)
        (pp-solution wc t) (terpri)
        (format t "insertions-made: ~a~%"
                (insertions-made wc))
        (pp-selected-clients-array wc) (terpri)

        (format t "After selection at (1 3):~%")
        (setf ops2 (op-select-client 1 3 1))
        (simulate-neighborhood-operation ops2 wc)
        (pp-solution wc t) (terpri)
    
        (format t "insertions-made: ~a~%"
                (insertions-made wc))
        (pp-selected-clients-array wc) (terpri)

        (format t "After insertion at (1 3):~%")
        (setf op1 (op-insert-client 1 3 0))
        (simulate-neighborhood-operation op1 wc)
        (pp-solution wc t) (terpri)
        ;; let's print again
        (format t "insertions-made: ~a~%"
                (insertions-made wc))
        (pp-selected-clients-array wc) (terpri)


        (format t "After another insertion at (2 2):~%")
        ;; let's simulate insertion at (2 1)
        (setf op2 (op-insert-client 2 2 0))
        (simulate-neighborhood-operation op2 wc)
        (pp-solution wc t) (terpri)
        (format t "insertions-made: ~a~%"
                (insertions-made wc))       
        (pp-selected-clients-array wc) (terpri)


        (format t "Let's undo ~a and check (insertions-made wc1)~%" op2)
        (undo-neighborhood-operation op2 wc)
        (pp-solution wc t) (terpri)
        (format t "insertions-made: ~a~%"
                (insertions-made wc))
        (pp-selected-clients-array wc) (terpri)

    
        (format t "Let's undo ~a and check (insertions-made wc1)~%" op1)
        (undo-neighborhood-operation op1 wc)
        (pp-solution wc t) (terpri)
        ;; let's print again
        (format t "insertions-made: ~a~%"
                (insertions-made wc))
        (pp-selected-clients-array wc) (terpri)


        ))
    #+END_SRC

**** test with several selections from the same position
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
    (with-basic-solution (s1 ((1 2 3 4 5)))
      (let* ((wc1 (basic-working-copy s1))
             (c1 0) (c2 1) (c3 2)
             ops1 ops2 ops3)

        (prepare-solution-for-neighborhood-exploration wc1)

        (format t "Before any operation:~%")
        (pp-solution wc1 t) (terpri)

        (format t "insertions-made: ~a~%" (insertions-made wc1))

        (format t "After selecting c4 at (1 4):~%")
        (setf ops1 (op-select-client 1 4 c1))
        (simulate-neighborhood-operation ops1 wc1)
        (pp-solution wc1 t) (terpri)
        (format t "insertions-made: ~a~%" (insertions-made wc1))
        (pp-selected-clients-array wc1) (terpri)


        (format t "After selecting c2 at (1 2):~%")
        (setf ops2 (op-select-client 1 2 c2))
        (simulate-neighborhood-operation ops2 wc1)
        (pp-solution wc1 t) (terpri)
        (pp-selected-clients-array wc1) (terpri)

        (format t "After selecting c3 at (1 2):~%")
        (setf ops3 (op-select-client 1 2 c3))
        (simulate-neighborhood-operation ops3 wc1)
        (pp-solution wc1 t)(terpri)
        (pp-selected-clients-array wc1) (terpri)


        (format t "Let's undo ~a~%" ops3)
        (undo-neighborhood-operation ops3 wc1)
        (pp-solution wc1 t) (terpri)
        (pp-selected-clients-array wc1) (terpri)


        (format t "Let's undo ~a~%" ops2)
        (undo-neighborhood-operation ops2 wc1)
        (pp-solution wc1 t) (terpri)
        (pp-selected-clients-array wc1) (terpri)

        (format t "Let's undo ~a~%" ops1)
        (undo-neighborhood-operation ops1 wc1)
        (pp-solution wc1 t) (terpri)
        (pp-selected-clients-array wc1) (terpri)

        ))
    #+END_SRC

    It looks like it worked!!!



* Apply neighborhood operation
** description
   In this section we add the methods needed to apply a set of operations to a solution (working-copy).  To do this we are going to need some place to store the selected clients during the application of the operation.  That place will be a slot in the basic-working-copy.

   The function apply-operation-to-solution will be a generic function.

   Here we'll have three main functions:
     - apply-neighborhood-operation,
     - finish-apply-neighborhood-operations, and
     - apply-set-of-operations.

   The generic function `apply-neighborhood-operation' will apply one simple operation to a working-copy.  When we want to add a new operation (or a new working-copy) we need to specialize this function for the new classes.

   The (generic) function finish-apply-neighborhood-operations should be called after all the single neighborhood-operations.  For instance, in that function we can remove empty routes.

   The (generic) function `apply-set-of-operations' receives a list and a working-copy and applies all the operations in the list.

** help functions
*** initialize-selected-clients-during-apply
**** description
     This function initializes the selected-clients-during-apply slot in the given solution to store the info related to the selections during the apply.
**** generic-function
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defgeneric initialize-selected-clients-during-apply
          (length working-copy)
        (:documentation "Initializes the selected-clients-during-apply slot in the given working-copy."))
      #+END_SRC
**** method (number basic-working-copy)
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod initialize-selected-clients-during-apply
         ((length number) (solution basic-working-copy))
       "Initializes the selected-clients-during-apply slot in the given working-copy."
       (setf  (selected-clients-during-apply solution)
              (make-array (1+ length) :initial-element nil)))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2) (3 4)))
         (let* ((wc (basic-working-copy s1)))
      
           (bformat t "Testing initialize-selected-clients-during-apply")
      
           (prepare-solution-for-neighborhood-exploration wc)

           (check-nil (selected-clients-during-apply wc))
      
           (initialize-selected-clients-during-apply 2 wc)

           (check-obj= #(nil nil nil) (selected-clients-during-apply wc))
      
           ))
     #+END_SRC

     #+RESULTS:
     : Selected clients: #(<c:2> <c:3> NIL NIL NIL)
    
*** store-client-selected-during-apply
**** description
     This function stores the info related to the selected client during the application of an operation to a given working-copy.
**** generic-function
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defgeneric store-client-selected-during-apply
          (index client working-copy)
        (:documentation "Stores the information about the client selected at op index in the working-copy, during the application of the operation."))
      #+END_SRC
**** method (t t basic-working-copy)
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod store-client-selected-during-apply
         (index client (solution basic-working-copy))
       "Stores the given client in the given position."
       (setf 
        (aref (selected-clients-during-apply solution) index)
        (list client)))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-clients (2 3)
       (with-basic-solution (s1 ((1 2) (3 4)))
         (let* ((wc (basic-working-copy s1)))
           (prepare-solution-for-neighborhood-exploration wc)

           (initialize-selected-clients-during-apply 2 wc)
      
           (store-client-selected-during-apply 0 c2 wc)
           (store-client-selected-during-apply 1 c3 wc)

           (check-obj= (list c2) (aref (selected-clients-during-apply wc) 0))
           (check-obj= (list c3) (aref (selected-clients-during-apply wc) 1))
           (check-nil (obj= (list c3)
                      (aref (selected-clients-during-apply wc) 0))))))
     #+END_SRC

     #+RESULTS:
     : Selected clients: #(<c:2> <c:3> NIL NIL NIL)
    
*** retrieve-client-selected-during-apply
**** description
     This function retrieves the info related to the selected client during the application of an operation to a given working-copy.
**** generic-function
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defgeneric retrieve-client-selected-during-apply
          (index working-copy)
        (:documentation "Retrieves the stored information about the client selected at op index in the working-copy, during the application of the operation."))
      #+END_SRC
**** method (number basic-working-copy)
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmethod retrieve-client-selected-during-apply
         ((index number) (solution basic-working-copy))
       "Retrieves the client stored at the given index."
       (first (aref (selected-clients-during-apply solution) index)))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-clients (2 3)
       (with-basic-solution (s1 ((1 2) (3 4)))
         (let* ((wc (basic-working-copy s1)))

           (bformat t "Testing retrieve-client-selected-during-apply")
           (prepare-solution-for-neighborhood-exploration wc)

           (initialize-selected-clients-during-apply 2 wc)

           (store-client-selected-during-apply 0 c2 wc)
           (store-client-selected-during-apply 1 c3 wc)

           (check-obj= c2 (retrieve-client-selected-during-apply 0 wc))
           (check-obj= c3 (retrieve-client-selected-during-apply 1 wc))
           (check-nil (obj= c3 (retrieve-client-selected-during-apply 0 wc))))))
     #+END_SRC

     #+RESULTS:
     : Selected clients: #(<c:2> <c:3> NIL NIL NIL)
    
** apply-neighborhood-operation
*** description
    This function applies a single operation to a working-copy.  Everytime we want to add a new function or a new working-copy, we should specialize this function for those new classes.   
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric apply-neighborhood-operation
         (op working-copy)
       (:documentation "Applies the operation to the given working copy.  Destructively modifies the solution."))
     #+END_SRC
*** method (select-client basic-working-copy)
**** description
     Physically removes the client from the given coordinate in the working-copy.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (defbehavior apply-neighborhood-operation
       ((operation operation-select-client)
        (working-copy basic-working-copy))
     :log-str "Removing selected client"

     "Physically modifies the solution to remove the client specified by the operation.  It also stores the selected client."
     (let* ((route-id (route operation))
            (pos (pos operation))
            (route (get-route-with-id route-id (solution working-copy)))
            (clients (clients route))
            (index (operand operation)))
       ;; now let's remove the client

       ;; (format t "debug: inside apply-op. Route:~%~a~%"
       ;;         route)
       (cond
         ;; if pos is 0 then set the route to the rest of it
         ((= pos 1)
          (setf (clients route) (rest (clients route)))
          (store-client-selected-during-apply
           index (first clients) working-copy))
         ;; else traverse the route collecting
         ;; all the clients except the one in the
         ;; selected pos.
         (t (setf (clients route)
                  (loop for c in clients
                        for i from 1
                        if (= i pos)
                           do (store-client-selected-during-apply
                               index c working-copy)
                        else
                           collect c
                        end))))
       ))
    #+END_SRC
**** tests
***** tests for select-client
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5) (6 7 8)) 0)
       (let* ((wc (basic-working-copy s1))
              op1
              ;; op2
              ;; ops1
              ;; ops2
              )

         (prepare-solution-for-neighborhood-exploration wc)
         (initialize-selected-clients-during-apply 3 wc)

         (bformat t "Testing apply-neighborhood-operation")

         (format t "Before any operation:~%")
         (pp-solution wc t) (terpri)

         ;; select from (1 3)
         (setf op1 (op-select-client 1 3 0))
         (apply-neighborhood-operation op1 wc)
         (format t "After select c3 the solution is:~%")
         (pp-solution (solution wc) t) (terpri)

         ;; select from (1 1)
         (setf op2 (op-select-client 1 1 1))
         (apply-neighborhood-operation op2 wc)
         (format t "After select c1 the solution is:~%")
         (pp-solution (solution wc) t) (terpri)
    
         ;; select from (2 3)
         (setf op3 (op-select-client 2 3 2))
         (apply-neighborhood-operation op3 wc)
         (format t "After select c1 the solution is:~%")
         (pp-solution (solution wc) t) (terpri)

         (format t "selected-clients-during-apply: ~a~%"
                 (selected-clients-during-apply wc))
         ))
     #+END_SRC

***** test with several selections from the same position
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5)))
       (let* ((wc1 (basic-working-copy s1))
              (c1 0) (c2 1) (c3 2)
              ops1 ops2 ops3)

         (prepare-solution-for-neighborhood-exploration wc1)

         (format t "Before any operation:~%")
         (pp-solution wc1 t) (terpri)

         (format t "insertions-made: ~a~%" (insertions-made wc1))

         (format t "After selecting c4 at (1 4):~%")
         (setf ops1 (op-select-client 1 4 c1))
         (simulate-neighborhood-operation ops1 wc1)
         (pp-solution wc1 t) (terpri)
         (format t "insertions-made: ~a~%" (insertions-made wc1))
         (pp-selected-clients-array wc1) (terpri)


         (format t "After selecting c2 at (1 2):~%")
         (setf ops2 (op-select-client 1 2 c2))
         (simulate-neighborhood-operation ops2 wc1)
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)

         (format t "After selecting c3 at (1 2):~%")
         (setf ops3 (op-select-client 1 2 c3))
         (simulate-neighborhood-operation ops3 wc1)
         (pp-solution wc1 t)(terpri)
         (pp-selected-clients-array wc1) (terpri)


         (format t "Let's undo ~a~%" ops3)
         (undo-neighborhood-operation ops3 wc1)
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)


         (format t "Let's undo ~a~%" ops2)
         (undo-neighborhood-operation ops2 wc1)
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)

         (format t "Let's undo ~a~%" ops1)
         (undo-neighborhood-operation ops1 wc1)
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)

         ))
     #+END_SRC

     It looks like it worked!!!
*** method (insert-client basic-working-copy)
**** description
     Physically inserts the client at the given coordinate in the working-copy.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defbehavior apply-neighborhood-operation
        ((operation operation-insert-client)
         (wc basic-working-copy))
      :log-str "Applying op insert-client"

      "Physically modifies the solution to insert the client specified by the operation.  It uses the stored client."
      (let* ((solution (solution wc))
             (route-id (route operation))
             (pos (pos operation))
             (route (get-route-with-id route-id solution))
             (index (operand operation))
             (client (retrieve-client-selected-during-apply
                      index wc))
             (clients (clients route))
             (length (length clients)))
        ;; ;; now let's insert the client into the route
        (setf (clients route)
              (cond
                ((= pos 1) ;; the position is the first
                 ;; just append the clients to the selected one
                 (append (list client) clients)
                 )
                ((> pos length) ;; insert it at the end
                 ;; append the client to the clients
                 (append clients (list client)))
                (t ;; insert it in the middle
                 ;; :-/, traverse the list and insert it
                 ;; where it should be.
                 (loop for c in (clients route)
                       for i from 1
                       if (= i pos) collect client
                       collect c))))))
     #+END_SRC
**** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
    (with-basic-solution (s1 ((1 2 3 4) (5 6 7)) 0)
      (let* ((wc (basic-working-copy s1))
             op1 (c3 0)
             op2 (c1 1)
             op3 (c7 2)
             op4 op5 op6
             ) 

        (prepare-solution-for-neighborhood-exploration wc)
        (initialize-selected-clients-during-apply 3 wc)

        (bformat t "Testing apply-neighborhood-operation")

        (format t "Before any operation:~%")
        (pp-solution wc t) (terpri)

        ;; select from (1 3)
        (setf op1 (op-select-client 1 3 c3))
        (apply-neighborhood-operation op1 wc)
        (format t "After selecting c3 the solution is:~%")
        (pp-solution (solution wc) t) (terpri)

        ;; select from (1 1)
        (setf op2 (op-select-client 1 1 c1))
        (apply-neighborhood-operation op2 wc)
        (format t "After selecting c2 the solution is:~%")
        (pp-solution (solution wc) t) (terpri)

        ;; select from (2 3)
        (setf op3 (op-select-client 2 3 c7))
        (apply-neighborhood-operation op3 wc)
        (format t "After selecting c7 the solution is:~%")
        (pp-solution (solution wc) t) (terpri)

        (setf op4 (op-insert-client 1 1 c3))
        (apply-neighborhood-operation op4 wc)
        (format t "After inserting c3 at (1 1) the solution is:~%")
        (pp-solution (solution wc) t) (terpri)

        (setf op5 (op-insert-client 2 3 c1))
        (apply-neighborhood-operation op5 wc)
        (format t "After inserting c1 at (2 3) the solution is:~%")
        (pp-solution (solution wc) t) (terpri)

        (setf op6 (op-insert-client 2 3 c7))
        (apply-neighborhood-operation op6 wc)
        (format t "After inserting c2 at (2 3) the solution is:~%")
        (pp-solution (solution wc) t) (terpri)
    
        ))
    #+END_SRC
** finish-apply-neighborhood-operations
*** description
    This method is similar to the finish-delta-cost-computation in the sense that this method should be called after all the basic apply-neighborhood operations have been made.

    It is in this function where we should remove the unused routes and stuff like that, that can only be done after all the ops have been applied.

    So far, we should only remove the empty routes if we have inifinite-fleet.  Otherwise don't do anything.
    
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric finish-apply-neighborhood-operations
         (working-copy)
       (:documentation "Does everything that should be done after all the neighborhood operations have been applied to the working-copy."))
     #+END_SRC
*** method (basic-working-copy)
**** description
     In this primary method we don't do anything.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defbehavior finish-apply-neighborhood-operations
        ((working-copy basic-working-copy))
      :log-str "Do nothing.  Wait for after methods."

      "Do nothing.  Wait for after methods."
      nil)
    #+END_SRC
**** tests
***** tests for select-client
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4) (5) (6 7 8)) 0)
       (let* ((wc (basic-working-copy s1))
              op1
              op2
              )

         (prepare-solution-for-neighborhood-exploration wc)
         (initialize-selected-clients-during-apply 3 wc)

         (bformat t "Testing apply-neighborhood-operation")

         (format t "Before any operation:~%")
         (pp-solution wc t) (terpri)

         ;; select from (1 3)
         (setf op1 (op-select-client 2 1 0))
         (apply-neighborhood-operation op1 wc)
         (format t "After select c5 the solution is:~%")
         (pp-solution (solution wc) t) (terpri)


         (setf op2 (op-insert-client 3 1 0))
         (apply-neighborhood-operation op2 wc)
         (format t "After inserting c5 the solution is:~%")
         (pp-solution (solution wc) t) (terpri)


         (format t "After finish-apply-neighborhood-operations:~%")
         (finish-apply-neighborhood-operations wc)
         (pp-solution (solution wc) t) (terpri)


         ))
     #+END_SRC

***** test with several selections from the same position
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5)))
       (let* ((wc1 (basic-working-copy s1))
              (c1 0) (c2 1) (c3 2)
              ops1 ops2 ops3)

         (prepare-solution-for-neighborhood-exploration wc1)

         (format t "Before any operation:~%")
         (pp-solution wc1 t) (terpri)

         (format t "insertions-made: ~a~%" (insertions-made wc1))

         (format t "After selecting c4 at (1 4):~%")
         (setf ops1 (op-select-client 1 4 c1))
         (simulate-neighborhood-operation ops1 wc1)
         (pp-solution wc1 t) (terpri)
         (format t "insertions-made: ~a~%" (insertions-made wc1))
         (pp-selected-clients-array wc1) (terpri)


         (format t "After selecting c2 at (1 2):~%")
         (setf ops2 (op-select-client 1 2 c2))
         (simulate-neighborhood-operation ops2 wc1)
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)

         (format t "After selecting c3 at (1 2):~%")
         (setf ops3 (op-select-client 1 2 c3))
         (simulate-neighborhood-operation ops3 wc1)
         (pp-solution wc1 t)(terpri)
         (pp-selected-clients-array wc1) (terpri)


         (format t "Let's undo ~a~%" ops3)
         (undo-neighborhood-operation ops3 wc1)
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)


         (format t "Let's undo ~a~%" ops2)
         (undo-neighborhood-operation ops2 wc1)
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)

         (format t "Let's undo ~a~%" ops1)
         (undo-neighborhood-operation ops1 wc1)
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)

         ))
     #+END_SRC

     It looks like it worked!!!

*** method (has-inifite-fleet)
**** description
     After we have applied all the operations, if we have inifite fleet, we remove all the empty routes and renumber the remaining ones.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defbehavior finish-apply-neighborhood-operations :after 
        ((working-copy has-infinite-fleet))
      :log-str "Removing empty routes."

      "Physically removes all the empty routes and renumber the remaining ones."
      (let* ((solution (solution working-copy))
             (new-routes nil)
             (new-id 1))
        ;; now let's remove the client

        ;; (format t "debug: inside finish-apply-op. Route:~%~a~%"
        ;;         route)
        (loop for route in (routes solution)
              when (clients route)
              ;; when the route is non empty
              ;; that is, it has clients
              do (progn
                   ;; first we push the route
                   (push route new-routes)
                   ;; then, we change the id
                   (setf (id (first new-routes)) new-id)
                   ;; and finally we incf the new-id
                   (incf new-id)))
        ;; now set the routes of the solution
        ;; as the new-routes reversed
        ;; (because they were pushed)
        (setf (routes solution) (reverse new-routes))))
    #+END_SRC
**** tests
***** tests for select-client
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4) (5) (6 7 8)) 0)
       (let* ((wc (basic-working-copy s1))
              op1
              op2
              )

         (prepare-solution-for-neighborhood-exploration wc)
         (initialize-selected-clients-during-apply 3 wc)

         (bformat t "Testing apply-neighborhood-operation")

         (format t "Before any operation:~%")
         (pp-solution wc t) (terpri)

         ;; select from (1 3)
         (setf op1 (op-select-client 2 1 0))
         (apply-neighborhood-operation op1 wc)
         (format t "After select c5 the solution is:~%")
         (pp-solution (solution wc) t) (terpri)


         (setf op2 (op-insert-client 3 1 0))
         (apply-neighborhood-operation op2 wc)
         (format t "After inserting c5 the solution is:~%")
         (pp-solution (solution wc) t) (terpri)

    
         (format t "After finish-apply-neighborhood-operations:~%")
         (finish-apply-neighborhood-operations wc)
         (pp-solution (solution wc) t) (terpri)


         ))
     #+END_SRC

***** test with several selections from the same position
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4 5)))
       (let* ((wc1 (basic-working-copy s1))
              (c1 0) (c2 1) (c3 2)
              ops1 ops2 ops3)

         (prepare-solution-for-neighborhood-exploration wc1)

         (format t "Before any operation:~%")
         (pp-solution wc1 t) (terpri)

         (format t "insertions-made: ~a~%" (insertions-made wc1))

         (format t "After selecting c4 at (1 4):~%")
         (setf ops1 (op-select-client 1 4 c1))
         (simulate-neighborhood-operation ops1 wc1)
         (pp-solution wc1 t) (terpri)
         (format t "insertions-made: ~a~%" (insertions-made wc1))
         (pp-selected-clients-array wc1) (terpri)


         (format t "After selecting c2 at (1 2):~%")
         (setf ops2 (op-select-client 1 2 c2))
         (simulate-neighborhood-operation ops2 wc1)
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)

         (format t "After selecting c3 at (1 2):~%")
         (setf ops3 (op-select-client 1 2 c3))
         (simulate-neighborhood-operation ops3 wc1)
         (pp-solution wc1 t)(terpri)
         (pp-selected-clients-array wc1) (terpri)


         (format t "Let's undo ~a~%" ops3)
         (undo-neighborhood-operation ops3 wc1)
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)


         (format t "Let's undo ~a~%" ops2)
         (undo-neighborhood-operation ops2 wc1)
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)

         (format t "Let's undo ~a~%" ops1)
         (undo-neighborhood-operation ops1 wc1)
         (pp-solution wc1 t) (terpri)
         (pp-selected-clients-array wc1) (terpri)

         ))
     #+END_SRC

     It looks like it worked!!!

** apply-set-of-operations
*** description
    This function receives a "working copy" and a set of operations, and returns a new solution (working copy), where the operations in the set of operations have been applied.  
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defgeneric apply-set-of-operations
         (operations working-copy)
       (:documentation "Applies the set of operations to the given solution.  It destructively modifies the working-copy."))
     #+END_SRC
*** method (list basic-working-copy)
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      ;;; A generic function to apply a set of operations
      (defmethod apply-set-of-operations
          ((set-of-operations list)
           (wc basic-working-copy))
        "Applies the set of operations to the given basic-working-copy. It destructively modifies the working-copy."

        ;; initialize the slot selected-clients-for-apply
        (initialize-selected-clients-during-apply (length set-of-operations) wc)

        ;; apply each of the operations
        (loop for op in set-of-operations
                do (apply-neighborhood-operation op wc))
        ;; finally, finish-apply-neighborhood-operations
        (finish-apply-neighborhood-operations wc))
      #+END_SRC
**** tests
***** basic test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4) (5 6 7)) 0)
       (let* ((wc (basic-working-copy s1))
              (wc1 (basic-working-copy (clone s1)))
              op1 (c3 0)
              op2 (c1 1)
              op3 (c7 2)
              op4 op5 op6
              ) 

         (prepare-solution-for-neighborhood-exploration wc)
         (prepare-solution-for-neighborhood-exploration wc1)

         (initialize-selected-clients-during-apply 6 wc)

         (bformat t "Testing apply-neighborhood-operation")

         (format t "Before any operation:~%")
         (pp-solution wc t) (terpri)

         ;; let's apply the ops one by one
         (setf op1 (op-select-client 1 3 c3))
         (apply-neighborhood-operation op1 wc)
         (setf op2 (op-select-client 1 1 c1))
         (apply-neighborhood-operation op2 wc)
         (setf op3 (op-select-client 2 3 c7))
         (apply-neighborhood-operation op3 wc)
         (setf op4 (op-insert-client 1 1 c3))
         (apply-neighborhood-operation op4 wc)
         (setf op5 (op-insert-client 2 3 c1))
         (apply-neighborhood-operation op5 wc)
         (setf op6 (op-insert-client 2 3 c7))
         (apply-neighborhood-operation op6 wc)

         ;; let's call the method

         (apply-set-of-operations
          (list op1 op2 op3 op4 op5 op6)
          wc1)

         (format t "Handmade:~%")
         (pp-solution (solution wc) t)

         (format t "After apply-set-of-operations:~%")
         (pp-solution (solution wc1) t)

         (check-obj= wc1 wc)

         ))
     #+END_SRC
***** testing the removal of empty routes
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3) (4 5) (6) (7 8)) 0)
       (let* ((wc (basic-working-copy s1))
              (wc1 (basic-working-copy (clone s1)))
              op1 (c4 0)
              op2 (c5 1)
              op3 (c6 2)
              op4 op5 op6
              (*vrp-unit-testing-display-output* nil)
              ) 

         (prepare-solution-for-neighborhood-exploration wc)
         (prepare-solution-for-neighborhood-exploration wc1)

         (initialize-selected-clients-during-apply 8 wc)

         (bformat t "Testing apply-neighborhood-operation")

         (format t "Before any operation:~%")
         (pp-solution wc t) (terpri)

         ;; let's apply the ops one by one
         (setf op1 (op-select-client 2 1 c4))
         (apply-neighborhood-operation op1 wc)
         (setf op2 (op-select-client 2 1 c5))
         (apply-neighborhood-operation op2 wc)
         (setf op3 (op-select-client 3 1 c6))
         (apply-neighborhood-operation op3 wc)
         (setf op4 (op-insert-client 1 4 c4))
         (apply-neighborhood-operation op4 wc)
         (setf op5 (op-insert-client 1 5 c5))
         (apply-neighborhood-operation op5 wc)
         (setf op6 (op-insert-client 4 1 c6))
         (apply-neighborhood-operation op6 wc)

         (finish-apply-neighborhood-operations wc)

         ;; let's call the method

         (apply-set-of-operations
          (list op1 op2 op3 op4 op5 op6)
          wc1)

         (format t "Handmade:~%")
         (pp-solution (solution wc) t)

         (format t "After apply-set-of-operations:~%")
         (pp-solution (solution wc1) t)

         (check-obj= (solution wc1) (solution wc))

         ))
     #+END_SRC



* do neighborhood macros
** description
*** general description
    In this section we'll add the macros to exahustively explore a neighborhood.  This macros will create the correponding operation, simulate them, give control to the user, and then undo the operations in the reverse order.

    The operations are always undone in the reversed order that they were done.

    This macros are supposed to be executed in an environment where the following variables are set:

    - ops-list :: a list with all the operations that were simulated.  The operations are pushed into this list, so when it is given to the user, it should be reversed.
    - *vrp-stop-neighborhood-search* :: a variable that indicates if we should stop the neighborhood exploration or not.

    Probably the costruction of these macros could be abstracted away in a macro that hides all the repetitive stuff.  I'll deal with that after I have written several of these do-something macros.

    Usually the syntax of these macros is:

    =(do-something (arg1 arg2 ...  working-copy)
       code here.)=

    Using several of these macros in sucesion should lead to nested calls to this macros.

    The macros implemented here are:
     - doselect-route
     - doselect-client
     - doinsert-client

*** about the macro for the macros
    The macros doselect-client and doinsert-client have the same structure:
     - iterate through some structure (usually positions in a route)
     - the creation of the instance with the current op
     - add the op to the ops-list
     - the simulation of the op
     - execute the user code
     - undo the op
      
    Even when we create new operations such as the swap op or select/insert subroutes, the structure is the same, with the only difference that instead of simulating one op, we have to simulate all the basic op that correspond to the give op.  For instance, in the case of simulate swap, we need to simulate the two insertions, and in the case of the subroutes, we need to simulate all the insertions or selections.

    All these ideas can be abstracted in a macro.  
    
*** adding constraints to the macros
**** description

     The next step should be to include constraints to the macros.  These constraints may take the form of `from where to where to iterate', `to exclude some positions' and things like that that.

     The idea is that these constraints can help to reduce the number of repeated neighbors that are visited during the exploration of a neighborhood.

     For instance, we could have something like:

     #+BEGIN_EXAMPLE
     (doselect-route (r1 wc :gt 2)
        ...  code here)
     #+END_EXAMPLE

     and this will iterate through all the routes in the working-copy wc, but will only consider the routes with id greater-than 2.

     The possible constraints are:

     - gt :: greater-than
     - ge :: greater or equal to
     - lt :: less than
     - le :: less or equal to
     - dt :: different to
     - ex :: exclude
             generalizes dt and can be a list of coordinates.
     - ex-cond :: is a list with code, and the idea is to exclude the current neighbor if these conditions return non nil.


     For instance, in the following snippet

     #+BEGIN_EXAMPLE
     (doselect-route (r1 wc)
        (doselect-route (r2 wc :ge r1)
           ...  code here))
     #+END_EXAMPLE

     r1 will iterate through all the possible routes, and r2 will iterate through all the routes that have an id greater or equal to r1.

     In the following example
     #+BEGIN_EXAMPLE
     (doselect-route (r1 wc)
        (doselect-client (c1 r1 wc)
           (doselect-route (r2 wc)
               (doselect-client (c2 r2 wc :ge (list r1 c1.select.position))
                   ...  code here)))
     #+END_EXAMPLE

     The client c2 will only be selected from a coord that is after the selection coordinate of c1.o
     
** variables and functions to stop the neighborhood search
*** variable *vrp-stop-neighborhood-search*
**** description
     When set to T, this variable stops the exploration of the neighborhood.  So, if you are  inside one of the do-neighborhood macros and you want to stop the exploration, the only thing you need to do is set this variable to T.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defparameter *vrp-stop-neighborhood-search* nil
       "A variable to decide whether or not to stop the neighborhood search.")
     #+END_SRC

*** function stop-neighborhood-search
**** description
     This function stops the exploration of a neighborhood by setting the variable *vrp-stop-neighborhood-search* to T.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defun stop-neighborhood-search ()
       "Stops the exploration of a neighborhood by setting the variable *vrp-stop-neighborhood-search* to T."
       (declare (special *vrp-stop-neighborhood-search*))
       (setf *vrp-stop-neighborhood-search* T))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((*vrp-stop-neighborhood-search* nil))

       (bformat t "Testing stop-neighborhood-search")

       (check-nil *vrp-stop-neighborhood-search*)
       (stop-neighborhood-search)
       (check-t *vrp-stop-neighborhood-search*))
     #+END_SRC
*** variable *vrp-max-route-length*
**** description
     This is a bound in the length of the route.  It should be a large value.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defparameter *vrp-max-route-length* 20000
       "A value so big that no route should have that number of clients.")
     #+END_SRC
     
** variables for the constraints in the macros
*** description
    This variable contains the symbol of all the constraints that can be added to a do-neighborhood macro.

    The meaning of the symbols is the following:
     - ge :: greater or equal to (route pos) or (pos)
     - gt :: greater than (route pos) or (pos)
     - le :: less or equal to (route pos) or (pos) 
     - lt :: less than (route pos) or (pos)
     - dt :: different to (route pos) or (pos)
     - ex :: exclude (route pos) or (pos)
     - ex-cond :: exclude this coord if this code returns non-nil 
    
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (defparameter *vrp-do-macros-constraint-symbols*
      `(ge ;; greater or equal to (route pos) or (pos)
        gt ;; greater than (route pos) or (pos)
        le ;; less or equal to (route pos) or (pos) 
        lt ;; less than (route pos) or (pos)
        dt ;; different to (route pos) or (pos)
        ex ;; exclude (route pos) or (pos)
        ex-cond ;; exclude the current coord if this code
                ;; returns non nil
        )
      "A variable with the symbols that can be used as keyword arguments in a do-neighborhood macro.")
    #+END_SRC
** WIP macro do-neighborhood-operation-macro
*** description
    The macros doselect-client and doinsert-client have the same structure:

     - an initialization
     - the creation of the instance with the current op
     - add the op to the ops-list
     - the simulation of the op
     - execute the user code
     - undo the op
      
    Even when we create new operations such as the swap op or select/insert subroutes, the structure is the same, with the only difference that instead of simulating one op, we have to simulate all the basic op that correspond to the give op.  For instance, in the case of simulate swap, we need to simulate the two insertions, and in the caso of the subroute, we need to simulate all the insertions or selections.

    All these ideas can be abstracted in this macro.

    Actually, I'm going to make two macros: one for the insertions and the other for the selections.  At least until I can abstract that pattern into a more general one.

    In these macros, we create some variables that the user can refer to.

    In the case of the selection, such as
    (doselect-SOMETHING (c1 r1 wc)
       code-here)
    these variables are:
    - c1.position :: the static position where the something was selected from.  Static means that it won't be updated after other selections or insertions.
    - c1.select.position :: the dynamic position where the something was selected from.  Dynamic means that this position is updated after other selections or insertions are made to the same route.
    - c1.select.route :: the route where the client was selected from.
    - c1.select.coord :: a list of the form (r p) where r is the selection route and p is the position.

    In the case of an insertion, such as
    (doinsert-SOMETHING (c1 r1 wc)
       code-here)
    these variables are:
    - c1.ins.pos :: the static position where the something was inserted.  Static means that it won't be updated after other selections or insertions.
    - c1.insert.position :: the dynamic position where the something was inserted from.  Dynamic means that this position is updated after other selections or insertions are made to the same route.
    - c1.insert.route :: the route where the client was selected from.
    - c1.insert.coord :: a list of the form (r p) where r is the selection route and p is the position.
*** WIP code for the selections macro
**** description
     In this macro we receive a route, a symbol to store the selections-count corresponding to this operation, and a working copy.  We also need to create the ops with an operand 1+ the selections-count of the working-copy.  The macro receives the name of the operation that should instantiate and the parameters it receives.

     Let's give it a first approach.

     In the first approach I just changed the heading, but the code is just the same as in the doselect-client.  It worked well, at least it passed the 
tests :-/.

     In the 2nd approach I will change the call of the operation.  It worked!

     Now I want this to be really generic.  Some neighborhood operations can be decomposed into several simpler operations.  For instance, a swap can be decomposed into two insertions, and a select-subroute can be decomposed into several client-selections.

     In order for the macros to be able to handle that situation, instead of automatically simulating the operation, we'll call a generic function to get a list with all the simpler operations from a given one.  In the case of the operations select-client and insert-client, this function should return a list with the same operations.  Then, in the macro, what we'll do is simulate all the elements in the list and also push them into the ops-list.  This is what we'll do in the 3rd approach.

     To implement the idea in the 3rd approach we need the generic-function =get-simpler-operations-from=.  I'm going to implement that now.

     To make this macro really extensible, I think that I need to specify as a parameter the last-position in route to select from.  That's what right now prevents me from using it with the doselect-subroute.

     I also think that we can abstract what happens from the simulation of the simpler-operations to the end of the macro, because that's the same in all of the macros I have seen so far.
**** other approaches
***** +9th approach testing the macros for the loop intitializations+
     #+BEGIN_SRC lisp +n -r :results none :exports code 
     (defmacro make-do-neighborhood-route-selection% (macro-name
                                                      (&rest args)
                                                      &key
                                                        op-name
                                                        op-params
                                                        example-str)
        ;;{{{ documentation
        "Creates a do-neighborhood macro for a selection. The created macro searches the neighborhood in an exhaustive way.

         There will always be a gensym named `pos' that will iterate through all the positions in the route. One of the parameter passed by the user should be named `route'.

         The arguments are:

            - macro-name :: the name of the macro.
            - args :: the args that the created macro will receive.
                      Apparently we'll always need parameters named `cname',
                      `route', and `working-copy'.
                       - `cname' should be a symbol that will be bound to
                         (1+ (selections-count working-copy).
                       - `route' should be a number with the id of a route
                          in the working-copy, where the selections should
                          take place.
            - op-name :: the constructor of the neighborhood operation to use.
            - op-params :: the params that should be passed to the constructor
                           of the operation.
            - example-str ::  this is a string to add to the description of the macro with an intended usage example." ;;;}}}

        (let* ((comment-str (format nil "Iterates through each position in the given route, creates an instance of ~a, pushes it int ops-lists, simulates it, do whatever the users wants to do, and finally restores everything to the previous state.

      The user can control what clients to select with the keyword args `le', `lt', `ge', `gt', and `dt'.
         Example:
            ~a" op-name example-str))

               (actual-args (append
                             args
                             `(&key 
                               ,@*vrp-do-macros-constraint-symbols*))))
          `(defmacro ,macro-name (,actual-args &body body)
             ,comment-str


             (let* ((pos (symb cname ".position"))
                    (cname.route (symb cname ".route"))
                    (cname.client (symb cname ".client"))
                    (cname.position (symb cname ".select.position"))
                    (cname.coord (symb cname ".select.coord"))
                    (cname.prev.coord (symb cname ".prev.insert.coord"))
                    )

               (with-gensyms (op
                              simpler-ops
                              initial-pos
                              final-pos
                              initial-target-route
                              final-target-route
                              exclude-target-route
                              exclude-pos
                              default-final-position)
                 `(symbol-macrolet ((,cname.position
                                     (pos-of-client-selected-at-operation
                                      ,cname ,working-copy))
                                    (,cname.route
                                     (route-of-client-selected-at-operation
                                      ,cname ,working-copy))
                                    (,cname.client
                                     (client-selected-at-operation
                                      ,cname ,working-copy))
                                    (,cname.coord
                                     (info-of-client-selected-at-operation
                                      ,cname ,working-copy))
                                    (,cname.prev.coord
                                     (let* ()
                                       (cond
                                         ((> ,cname.position 1)
                                          (list ,cname.route
                                                (1- ,cname.position)))
                                         ;; we are in (1 1)
                                         ;; so there is not previous
                                         ((= ,route 1)
                                          (list 1 -1))
                                         ;; otherwise the previous
                                         ;; is the last of the
                                         ;; previous route
                                         (t
                                          (list (1- ,route)
                                                (1+
                                                 (route-length
                                                  (1- ,route)
                                                  ,working-copy)))))))
                                    )
                      (with-variables-for-constraints-for-selection
                         (,initial-pos ,ge ,gt
                          ,final-pos ,le ,lt
                          ,route ,working-copy
                          ,initial-target-route
                          ,final-target-route
                          ,exclude-target-route
                          ,exclude-pos
                          ,dt) 

                        (let* ((,cname.route ,route)
                               (,default-final-position
                                (route-length ,route ,working-copy)))

                          (declare (ignorable ,cname.route))

                          (loop for ,pos from
                                ;; in the initial pos we'll
                                ;; take into account
                                ;; the target route
                                (initial-for-value-in-all-macros
                                 ,initial-target-route
                                 ,route
                                 ,initial-pos)
                                to ;; ;; let's set the final pos
                                ;; ;; according to the arguments
                                (final-value-for-loop-in-route-operation-macro
                                     ,final-target-route
                                     ,route
                                     ,final-pos
                                     ,default-final-position)
                                ;; the following line allows the final user
                                ;; to stop the iteration by setting that
                                ;; variable to t
                                while (not *vrp-stop-neighborhood-search*)

                                do ;; let's execute the body if
                                ;; we are not in a forbidden coord
                                (unless-forbidden-coord
                                    (,ex
                                     ,route
                                     ,pos
                                     ,dt
                                     ,exclude-target-route ,exclude-pos)
                                  (let* ((,cname
                                          (1+ (selections-count ,working-copy)))
                                         (,op
                                          (,',op-name ,,@op-params))
                                         (,simpler-ops
                                          (get-simpler-operations-from
                                           ,op ,working-copy)))


                                    ;; here I want to add some code to execute it
                                    ;; before the simulation of the operation
                                    ;; but I'm not yet sure about how
                                    ;; to do it right :-/

                                    ;; now the simulation
                                    (simulate-simpler-ops-macro
                                     ,simpler-ops ,working-copy)

                                    ;; let's do what the user wants
                                    (progn ,@body)

                                    ;; now the clean up
                                    (undo-simpler-ops-macro
                                     ,simpler-ops ,working-copy))))))))))))
     #+END_SRC
***** +testing the macros for the loop initialization+
****** testing the initial value for the loop
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection%
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2 3 4 5)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil)
                 (l1 (list 1 5)))

            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing doselect-route with ge with list (2 2)")
            (doselect-client2 (c1 1 wc :ge l1)
              (format t "Selected client: ~a from (~a ~a).~%"
                      (client-selected-at-operation c1 wc)
                      c1.route
                      c1.select.position)
              (pp-solution wc t) (terpri)))))
       #+END_SRC
***** +10th approach testing the constraint unless-forbidden-condition+
****** code
      #+BEGIN_SRC lisp +n -r :results none :exports code 
      (defmacro make-do-neighborhood-route-selection% (macro-name
                                                       (&rest args)
                                                       &key
                                                         op-name
                                                         op-params
                                                         example-str)
         ;;{{{ documentation
         "Creates a do-neighborhood macro for a selection. The created macro searches the neighborhood in an exhaustive way.

          There will always be a gensym named `pos' that will iterate through all the positions in the route. One of the parameter passed by the user should be named `route'.

          The arguments are:

             - macro-name :: the name of the macro.
             - args :: the args that the created macro will receive.
                       Apparently we'll always need parameters named `cname',
                       `route', and `working-copy'.
                        - `cname' should be a symbol that will be bound to
                          (1+ (selections-count working-copy).
                        - `route' should be a number with the id of a route
                           in the working-copy, where the selections should
                           take place.
             - op-name :: the constructor of the neighborhood operation to use.
             - op-params :: the params that should be passed to the constructor
                            of the operation.
             - example-str ::  this is a string to add to the description of the macro with an intended usage example." ;;;}}}

         (let* ((comment-str (format nil "Iterates through each position in the given route, creates an instance of ~a, pushes it int ops-lists, simulates it, do whatever the users wants to do, and finally restores everything to the previous state.

       The user can control what clients to select with the keyword args `le', `lt', `ge', `gt', and `dt'.
          Example:
             ~a" op-name example-str))

                (actual-args (append
                              args
                              `(&key 
                                ,@*vrp-do-macros-constraint-symbols*))))
           `(defmacro ,macro-name (,actual-args &body body)
              ,comment-str


              (let* ((pos (symb cname ".position"))
                     (cname.route (symb cname ".route"))
                     (cname.client (symb cname ".client"))
                     (cname.position (symb cname ".select.position"))
                     (cname.coord (symb cname ".select.coord"))
                     (cname.prev.coord (symb cname ".prev.insert.coord"))
                     )

                (with-gensyms (op
                               simpler-ops
                               initial-pos
                               final-pos
                               initial-target-route
                               final-target-route
                               exclude-target-route
                               exclude-pos
                               default-final-position)
                  `(symbol-macrolet ((,cname.position
                                      (pos-of-client-selected-at-operation
                                       ,cname ,working-copy))
                                     (,cname.route
                                      (route-of-client-selected-at-operation
                                       ,cname ,working-copy))
                                     (,cname.client
                                      (client-selected-at-operation
                                       ,cname ,working-copy))
                                     (,cname.coord
                                      (info-of-client-selected-at-operation
                                       ,cname ,working-copy))
                                     (,cname.prev.coord
                                      (let* ()
                                        (cond
                                          ((> ,cname.position 1)
                                           (list ,cname.route
                                                 (1- ,cname.position)))
                                          ;; we are in (1 1)
                                          ;; so there is not previous
                                          ((= ,route 1)
                                           (list 1 -1))
                                          ;; otherwise the previous
                                          ;; is the last of the
                                          ;; previous route
                                          (t
                                           (list (1- ,route)
                                                 (1+
                                                  (route-length
                                                   (1- ,route)
                                                   ,working-copy)))))))
                                     )
                       (with-variables-for-constraints-for-selection
                          (,initial-pos ,ge ,gt
                           ,final-pos ,le ,lt
                           ,route ,working-copy
                           ,initial-target-route
                           ,final-target-route
                           ,exclude-target-route
                           ,exclude-pos
                           ,dt) 

                         (let* ((,cname.route ,route)
                                (,default-final-position
                                 (route-length ,route ,working-copy)))

                           (declare (ignorable ,cname.route))

                           (loop for ,pos from
                                 ;; in the initial pos we'll
                                 ;; take into account
                                 ;; the target route
                                 (initial-for-value-in-all-macros
                                  ,initial-target-route
                                  ,route
                                  ,initial-pos)
                                 to ;; ;; let's set the final pos
                                 ;; ;; according to the arguments
                                 (final-value-for-loop-in-route-operation-macro
                                      ,final-target-route
                                      ,route
                                      ,final-pos
                                      ,default-final-position)
                                 ;; the following line allows the final user
                                 ;; to stop the iteration by setting that
                                 ;; variable to t
                                 while (not *vrp-stop-neighborhood-search*)

                                 do ;; let's execute the body if
                                 ;; we are not in a forbidden coord
                                 (unless-forbidden-condition (,ex-cond)
                                   (unless-forbidden-coord
                                    (,ex
                                     ,route
                                     ,pos
                                     ,dt
                                     ,exclude-target-route ,exclude-pos)
                                    (let* ((,cname
                                            (1+ (selections-count ,working-copy)))
                                           (,op
                                            (,',op-name ,,@op-params))
                                           (,simpler-ops
                                            (get-simpler-operations-from
                                             ,op ,working-copy)))


                                      ;; here I want to add some code to be
                                      ;; executed before the simulation of
                                      ;; the operation but I'm not yet sure
                                      ;; about how to do it right :-/

                                      ;; now the simulation
                                      (simulate-simpler-ops-macro
                                       ,simpler-ops ,working-copy)

                                      ;; let's do what the user wants
                                      (progn ,@body)

                                      ;; now the clean up
                                      (undo-simpler-ops-macro
                                       ,simpler-ops ,working-copy)))))))))))))
      #+END_SRC
****** testing the 10th approach
******* testing the ex-cond
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
        (progn

          (bformat t "Testing ex-cond")
  
          (make-do-neighborhood-route-selection%
           doselect-client2
           (cname route working-copy)
           :op-name op-select-client
           :op-params (route pos cname)
           :example-str "(doselect-client (c1 r1 wc1)
                   (format t \"Selecting client ~a from route ~a~%\"
                    (client-selected-at-operation c1)
                    (get-route-with-id r1 wc1)))")

         (with-basic-solution (s1 ((1 2 3 4 5)))
           (let* ((wc (basic-working-copy s1))
                  (ops-list nil)
                  (l1 (list 1 2))
                  )

             (prepare-solution-for-neighborhood-exploration wc)

             (doselect-client2 (c1 1 wc
                                   :ex-cond (= c1.position 4)
                                   :dt l1
                                   )
               (format t "Selected client: ~a from (~a ~a).~%"
                       (client-selected-at-operation c1 wc)
                       c1.route
                       c1.select.position)
               (pp-solution wc t) (terpri)))))
        #+END_SRC
***** 11th approach: adding a generic simulate-operations
****** description
       In this new approach, I'll add the option to pass a different macros instead of =simulate-simpler-ops-macro= and =undo-simpler-ops-macro=.  As options for these new macros, I'll add the =simulate-simpler-ops-macro*= and =undo-simpler-ops-macro*=, that will also compute the delta-cost after each operation is simulated, and then undoes that computation :-o.
****** code
      #+BEGIN_SRC lisp +n -r :results none :exports code 
      (defmacro make-do-neighborhood-route-selection% (macro-name
                                                       (&rest args)
                                                       &key
                                                         op-name
                                                         op-params
                                                         example-str
                                                         (simpler-ops-macro 'simulate-simpler-ops-macro)
                                                         (undo-simpler-ops-macro 'undo-simpler-ops-macro))
         ;;{{{ documentation
         "Creates a do-neighborhood macro for a selection. The created macro searches the neighborhood in an exhaustive way.

          There will always be a gensym named `pos' that will iterate through all the positions in the route. One of the parameter passed by the user should be named `route'.

          The arguments are:

             - macro-name :: the name of the macro.
             - args :: the args that the created macro will receive.
                       Apparently we'll always need parameters named `cname',
                       `route', and `working-copy'.
                        - `cname' should be a symbol that will be bound to
                          (1+ (selections-count working-copy)).
                        - `route' should be a number with the id of a route
                           in the working-copy, where the selections should
                           take place.
             - op-name :: the constructor of the neighborhood operation to use.
             - op-params :: the params that should be passed to the constructor
                            of the operation.
             - example-str ::  this is a string to add to the description of the macro with an intended usage example." ;;;}}}

         (let* ((comment-str (format nil "Iterates through each position in the given route, creates an instance of ~a, pushes it int ops-lists, simulates it, do whatever the users wants to do, and finally restores everything to the previous state.

       The user can control what clients to select with the keyword args `le', `lt', `ge', `gt', and `dt'.
          Example:
             ~a" op-name example-str))

                (actual-args (append
                              args
                              `(&key 
                                ,@*vrp-do-macros-constraint-symbols*))))
           `(defmacro ,macro-name (,actual-args &body body)
              ,comment-str


              (let* ((pos (symb cname ".position"))
                     (cname.route (symb cname ".route"))
                     (cname.client (symb cname ".client"))
                     (cname.position (symb cname ".select.position"))
                     (cname.coord (symb cname ".select.coord"))
                     (cname.prev.coord (symb cname ".prev.insert.coord"))
                     )

                (with-gensyms (op
                               simpler-ops
                               initial-pos
                               final-pos
                               initial-target-route
                               final-target-route
                               exclude-target-route
                               exclude-pos
                               default-final-position)
                  `(symbol-macrolet ((,cname.position
                                      (pos-of-client-selected-at-operation
                                       ,cname ,working-copy))
                                     (,cname.route
                                      (route-of-client-selected-at-operation
                                       ,cname ,working-copy))
                                     (,cname.client
                                      (client-selected-at-operation
                                       ,cname ,working-copy))
                                     (,cname.coord
                                      (info-of-client-selected-at-operation
                                       ,cname ,working-copy))
                                     (,cname.prev.coord
                                      (let* ()
                                        (cond
                                          ((> ,cname.position 1)
                                           (list ,cname.route
                                                 (1- ,cname.position)))
                                          ;; we are in (1 1)
                                          ;; so there is not previous
                                          ((= ,route 1)
                                           (list 1 -1))
                                          ;; otherwise the previous
                                          ;; is the last of the
                                          ;; previous route
                                          (t
                                           (list (1- ,route)
                                                 (1+
                                                  (route-length
                                                   (1- ,route)
                                                   ,working-copy)))))))
                                     )
                       (with-variables-for-constraints-for-selection
                          (,initial-pos ,ge ,gt
                           ,final-pos ,le ,lt
                           ,route ,working-copy
                           ,initial-target-route
                           ,final-target-route
                           ,exclude-target-route
                           ,exclude-pos
                           ,dt) 

                         (let* ((,cname.route ,route)
                                (,default-final-position
                                 (route-length ,route ,working-copy)))

                           (declare (ignorable ,cname.route))

                           (loop for ,pos from
                                 ;; in the initial pos we'll
                                 ;; take into account
                                 ;; the target route
                                 (initial-for-value-in-all-macros
                                  ,initial-target-route
                                  ,route
                                  ,initial-pos)
                                 to ;; ;; let's set the final pos
                                 ;; ;; according to the arguments
                                 (final-value-for-loop-in-route-operation-macro
                                      ,final-target-route
                                      ,route
                                      ,final-pos
                                      ,default-final-position)
                                 ;; the following line allows the final user
                                 ;; to stop the iteration by setting that
                                 ;; variable to t
                                 while (not *vrp-stop-neighborhood-search*)

                                 do ;; let's execute the body if
                                 ;; we are not in a forbidden coord
                                 (unless-forbidden-condition (,ex-cond)
                                   (unless-forbidden-coord
                                    (,ex
                                     ,route
                                     ,pos
                                     ,dt
                                     ,exclude-target-route ,exclude-pos)
                                    (let* ((,cname
                                            (1+ (selections-count ,working-copy)))
                                           (,op
                                            (,',op-name ,,@op-params))
                                           (,simpler-ops
                                            (get-simpler-operations-from
                                             ,op ,working-copy)))


                                      ;; here I want to add some code to be
                                      ;; executed before the simulation of
                                      ;; the operation but I'm not yet sure
                                      ;; about how to do it right :-/

                                      ;; now the simulation
                                      (,',simpler-ops-macro
                                       ,simpler-ops ,working-copy)

                                      ;; let's do what the user wants
                                      (progn ,@body)

                                      ;; now the clean up
                                      (,',undo-simpler-ops-macro
                                       ,simpler-ops ,working-copy)))))))))))))
      #+END_SRC
****** tests
******* testing params: simpler-ops-macro and undo-simpler-ops-macro
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
        (progn

          (bformat t "Testing passing new args to the macro")

          (make-do-neighborhood-route-selection%
           doselect-client2
           (cname route working-copy)
           :op-name op-select-client
           :op-params (route pos cname)
           :example-str "(doselect-client (c1 r1 wc1)
                   (format t \"Selecting client ~a from route ~a~%\"
                    (client-selected-at-operation c1)
                    (get-route-with-id r1 wc1)))"
           :simpler-ops-macro simulate-simpler-ops-macro*
           :undo-simpler-ops-macro undo-simpler-ops-macro*)

         (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                                      (5 0 6 7 2 4 2 3 4)  ;1
                                                      (1 8 0 3 9 1 2 4 5)  ;2
                                                      (4 5 1 0 5 7 1 9 5)  ;3
                                                      (4 5 1 5 0 6 2 8 2)  ;4
                                                      (1 5 7 6 9 0 1 6 7)  ;5
                                                      (4 5 1 3 5 7 0 9 5)  ;6
                                                      (4 6 2 8 2 3 8 0 1)  ;7
                                                      (4 5 3 4 1 6 2 8 0)  ;8
                                                      )
                                                      ;0 1 2 3 4 5 6 7 8
                                        :demands '(20 10 15 40 30 20 10 30)
                                        :capacity 30)
               (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6 7 8)) problem)
                 (let* ((wc (basic-working-copy s1))
                        (ops-list nil)
                        (action (delta-cvrp-action*)))

                   (prepare-solution-for-neighborhood-exploration wc)
                   (initialize-action-for-delta-cost-computation wc problem action)

                   (bformat t "Testing doselect-route")
                   (doselect-client2 (c1 1 wc)
                      (format t "Selected client: ~a~%"
                              (client-selected-at-operation c1 wc))
                      (pp-solution wc t) (terpri)
                      (format t "Delta distance after op: ~a~%"
                              (delta-distance action))
                      (format t "Route feasibility after op: ~a~%"
                              (delta-routes-feasibility action)))))))
        #+END_SRC
**** official code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (defmacro make-do-neighborhood-route-selection
        (macro-name
         (&rest args)
         &key
           op-name
           op-params
           example-str
           (simpler-ops-macro
            'simulate-simpler-ops-macro)
           (undo-simpler-ops-macro
            'undo-simpler-ops-macro))
         ;;{{{ documentation
         "Creates a do-neighborhood macro for a selection. The created macro searches the neighborhood in an exhaustive way.

          There will always be a gensym named `pos' that will iterate through all the positions in the route. One of the parameter passed by the user should be named `route'.

          The arguments are:

             - macro-name :: the name of the macro.
             - args :: the args that the created macro will receive.
                       Apparently we'll always need parameters named `cname',
                       `route', and `working-copy'.
                        - `cname' should be a symbol that will be bound to
                          (1+ (selections-count working-copy)).
                        - `route' should be a number with the id of a route
                           in the working-copy, where the selections should
                           take place.
             - op-name :: the constructor of the neighborhood operation to use.
             - op-params :: the params that should be passed to the constructor
                            of the operation.
             - example-str ::  this is a string to add to the description of the macro with an intended usage example.
             - simpler-ops-macro :: is the name of a macro to be used to simulate the simpler-ops. It defaults to simulate-simpler-ops-macro.
             - undo-simpler-ops-macro :: is the name of a macro to be used to undo the simulation of the simpler-ops. It defaults to undo-simpler-ops-macro."

    ;;;}}}

         (let* ((comment-str (format nil "Iterates through each position in the given route, creates an instance of ~a, pushes it int ops-lists, simulates it, do whatever the users wants to do, and finally restores everything to the previous state.

       The user can control what clients to select with the keyword args `le', `lt', `ge', `gt', and `dt'.
          Example:
             ~a" op-name example-str))

                (actual-args (append
                              args
                              `(&key 
                                ,@*vrp-do-macros-constraint-symbols*))))
           `(defmacro ,macro-name (,actual-args &body body)
              ,comment-str


              (let* ((pos (symb cname ".position"))
                     (cname.route (symb cname ".route"))
                     (cname.client (symb cname ".client"))
                     (cname.position (symb cname ".select.position"))
                     (cname.coord (symb cname ".select.coord"))
                     (cname.prev.coord (symb cname ".prev.insert.coord"))
                     )

                (with-gensyms (op
                               simpler-ops
                               initial-pos
                               final-pos
                               initial-target-route
                               final-target-route
                               exclude-target-route
                               exclude-pos
                               default-final-position)
                  `(symbol-macrolet ((,cname.position
                                      (pos-of-client-selected-at-operation
                                       ,cname ,working-copy))
                                     (,cname.route
                                      (route-of-client-selected-at-operation
                                       ,cname ,working-copy))
                                     (,cname.client
                                      (client-selected-at-operation
                                       ,cname ,working-copy))
                                     (,cname.coord
                                      (info-of-client-selected-at-operation
                                       ,cname ,working-copy))
                                     (,cname.prev.coord
                                      (let* ()
                                        (cond
                                          ((> ,cname.position 1)
                                           (list ,cname.route
                                                 (1- ,cname.position)))
                                          ;; we are in (1 1)
                                          ;; so there is not previous
                                          ((= ,route 1)
                                           (list 1 -1))
                                          ;; otherwise the previous
                                          ;; is the last of the
                                          ;; previous route
                                          (t
                                           (list (1- ,route)
                                                 (1+
                                                  (route-length
                                                   (1- ,route)
                                                   ,working-copy)))))))
                                     )
                       (with-variables-for-constraints-for-selection
                          (,initial-pos ,ge ,gt
                           ,final-pos ,le ,lt
                           ,route ,working-copy
                           ,initial-target-route
                           ,final-target-route
                           ,exclude-target-route
                           ,exclude-pos
                           ,dt) 

                         (let* ((,cname.route ,route)
                                (,default-final-position
                                 (route-length ,route ,working-copy)))

                           (declare (ignorable ,cname.route))

                           (loop for ,pos from
                                 ;; in the initial pos we'll
                                 ;; take into account
                                 ;; the target route
                                 (initial-for-value-in-all-macros
                                  ,initial-target-route
                                  ,route
                                  ,initial-pos)
                                 to ;; ;; let's set the final pos
                                 ;; ;; according to the arguments
                                 (final-value-for-loop-in-route-operation-macro
                                      ,final-target-route
                                      ,route
                                      ,final-pos
                                      ,default-final-position)
                                 ;; the following line allows the final user
                                 ;; to stop the iteration by setting that
                                 ;; variable to t
                                 while (not *vrp-stop-neighborhood-search*)

                                 do ;; let's execute the body if
                                 ;; we are not in a forbidden coord
                                 (unless-forbidden-condition (,ex-cond)
                                   (unless-forbidden-coord
                                    (,ex
                                     ,route
                                     ,pos
                                     ,dt
                                     ,exclude-target-route ,exclude-pos)
                                    (let* ((,cname
                                            (1+ (selections-count ,working-copy)))
                                           (,op
                                            (,',op-name ,,@op-params))
                                           (,simpler-ops
                                            (get-simpler-operations-from
                                             ,op ,working-copy)))


                                      ;; here I want to add some code to be
                                      ;; executed before the simulation of
                                      ;; the operation but I'm not yet sure
                                      ;; about how to do it right :-/

                                      ;; now the simulation
                                      (,',simpler-ops-macro
                                       ,simpler-ops ,working-copy)

                                      ;; let's do what the user wants
                                      (progn ,@body)

                                      ;; now the clean up
                                      (,',undo-simpler-ops-macro
                                       ,simpler-ops
                                       ,working-copy)))))))))))))
    #+END_SRC
**** +old-official code (backup)+
    #+BEGIN_SRC lisp +n -r :results none :exports code
    (defmacro make-do-neighborhood-route-selection (macro-name
                                                    (&rest args)
                                                    &key
                                                      op-name
                                                      op-params
                                                      example-str)
      ;;{{{ documentation
      "Creates a do-neighborhood macro for a selection. The created macro searches the neighborhood in an exhaustive way.

         There will always be a gensym named `pos' that will iterate through all the positions in the route. One of the parameter passed by the user should be named `route'.

         The arguments are:

            - macro-name :: the name of the macro.
            - args :: the args that the created macro will receive.
                      Apparently we'll always need parameters named `cname',
                      `route', and `working-copy'.
                       - `cname' should be a symbol that will be bound to
                         (1+ (selections-count working-copy).
                       - `route' should be a number with the id of a route
                          in the working-copy, where the selections should
                          take place.
            - op-name :: the constructor of the neighborhood operation to use.
            - op-params :: the params that should be passed to the constructor
                           of the operation.
            - example-str ::  this is a string to add to the description of the macro with an intended usage example." ;;;}}}

      (let* ((comment-str (format nil "Iterates through each position in the given route, creates an instance of ~a, pushes it int ops-lists, simulates it, do whatever the users wants to do, and finally restores everything to the previous state.

      The user can control what clients to select with the keyword args `le', `lt', `ge', `gt', and `dt'.
         Example:
            ~a" op-name example-str))

             (actual-args (append
                           args
                           `(&key 
                             ,@*vrp-do-macros-constraint-symbols*))))
        `(defmacro ,macro-name (,actual-args &body body)
           ,comment-str


           (let* ((pos (symb cname ".position"))
                  (cname.route (symb cname ".route"))
                  (cname.client (symb cname ".client"))
                  (cname.position (symb cname ".select.position"))
                  (cname.coord (symb cname ".select.coord"))
                  (cname.prev.coord (symb cname ".prev.select.coord"))
                  )

             (with-gensyms (op
                            simpler-ops
                            initial-pos
                            final-pos
                            initial-target-route
                            final-target-route
                            exclude-target-route
                            exclude-pos
                            default-final-position)
               `(symbol-macrolet ((,cname.position
                                   (pos-of-client-selected-at-operation
                                    ,cname ,working-copy))
                                  (,cname.route
                                   (route-of-client-selected-at-operation
                                    ,cname ,working-copy))
                                  (,cname.client
                                   (client-selected-at-operation
                                    ,cname ,working-copy))
                                  (,cname.coord
                                   (info-of-client-selected-at-operation
                                    ,cname ,working-copy))
                                  (,cname.prev.coord
                                   (let* ()
                                     (cond
                                       ((> ,cname.position 1)
                                        (list ,cname.route
                                              (1- ,cname.position)))
                                       ;; we are in (1 1)
                                       ;; so there is not previous
                                       ((= ,route 1)
                                        (list 1 -1))
                                       ;; otherwise the previous
                                       ;; is the last of the
                                       ;; previous route
                                       (t
                                        (list (1- ,route)
                                              (1+
                                               (route-length
                                                (1- ,route)
                                                ,working-copy)))))))
                                  )
                  (with-variables-for-constraints-for-selection
                      (,initial-pos ,ge ,gt
                                    ,final-pos ,le ,lt
                                    ,route ,working-copy
                                    ,initial-target-route
                                    ,final-target-route
                                    ,exclude-target-route
                                    ,exclude-pos
                                    ,dt) 

                    (let* ((,cname.route ,route)
                           (,default-final-position
                            (route-length ,route ,working-copy)))

                      (declare (ignorable ,cname.route))

                      (loop for ,pos from
                            ;; in the initial pos we'll
                            ;; take into account
                            ;; the target route
                            (initial-for-value-in-all-macros
                             ,initial-target-route
                             ,route
                             ,initial-pos)
                            to ;; ;; let's set the final pos
                            ;; ;; according to the arguments
                            (final-value-for-loop-in-route-operation-macro
                             ,final-target-route
                             ,route
                             ,final-pos
                             ,default-final-position)
                            ;; the following line allows the final user
                            ;; to stop the iteration by setting that
                            ;; variable to t
                            while (not *vrp-stop-neighborhood-search*)

                            do ;; let's execute the body if
                            ;; we are not in a forbidden coord
                            (unless-forbidden-coord
                                (,ex
                                 ,route
                                 ,pos
                                 ,dt
                                 ,exclude-target-route
                                 ,exclude-pos
                                 ,ex-cond)
                              (let* ((,cname
                                      (1+ (selections-count ,working-copy)))
                                     (,op
                                      (,',op-name ,,@op-params))
                                     (,simpler-ops
                                      (get-simpler-operations-from
                                       ,op ,working-copy)))


                                ;; here I want to add some code to be
                                ;; executed before the simulation of
                                ;; the operation but I'm not yet sure
                                ;; about how to do it right :-/

                                ;; now the simulation
                                (simulate-simpler-ops-macro
                                 ,simpler-ops ,working-copy)

                                ;; let's do what the user wants
                                (progn ,@body)

                                ;; now the clean up
                                (undo-simpler-ops-macro
                                 ,simpler-ops ,working-copy))))))))))))
    #+END_SRC
**** +old-old-official code (backup)+
    #+BEGIN_SRC lisp +n -r :results none :exports code
    (defmacro make-do-neighborhood-route-selection (macro-name
                                                          (&rest args)
                                                          &key
                                                            op-name
                                                            op-params
                                                            example-str)
      ;;{{{ documentation
      "Creates a do-neighborhood macro for a selection. The created macro searches the neighborhood in an exhaustive way.

             There will always be a gensym named `pos' that will iterate through all the positions in the route. One of the parameter passed by the user should be named `route'.

             The arguments are:

                - macro-name :: the name of the macro.
                - args :: the args that the created macro will receive.
                          Apparently we'll always need parameters named `cname',
                          `route', and `working-copy'.
                           - `cname' should be a symbol that will be bound to
                             (1+ (selections-count working-copy).
                           - `route' should be a number with the id of a route
                              in the working-copy, where the selections should
                              take place.
                - op-name :: the constructor of the neighborhood operation to use.
                - op-params :: the params that should be passed to the constructor
                               of the operation.
                - example-str ::  this is a string to add to the description of the macro with an intended usage example."
      ;;}}}

      (let* ((comment-str (format nil "Iterates through each position in the given route, creates an instance of ~a, pushes it int ops-lists, simulates it, do whatever the users wants to do, and finally restores everything to the previous state.

          The user can control what clients to select with the keyword args `le', `lt', `ge', `gt', and `dt'.
             Example:
                ~a" op-name example-str))

             (actual-args (append
                           args
                           `(&key 
                             ,@*vrp-do-macros-constraint-symbols*))))
        `(defmacro ,macro-name (,actual-args &body body)
           ,comment-str


           (let* ((pos (symb cname ".position"))
                  (cname.route (symb cname ".route"))
                  (cname.client (symb cname ".client"))
                  (cname.position (symb cname ".select.position"))
                  (cname.coord (symb cname ".select.coord"))
                  (cname.prev.coord (symb cname ".prev.insert.coord"))
                  )

             (with-gensyms (op
                            simpler-ops
                            initial-pos
                            final-pos
                            initial-target-route
                            final-target-route
                            exclude-target-route
                            exclude-pos
                            default-final-position)
               `(symbol-macrolet ((,cname.position
                                   (pos-of-client-selected-at-operation
                                    ,cname ,working-copy))
                                  (,cname.route
                                   (route-of-client-selected-at-operation
                                    ,cname ,working-copy))
                                  (,cname.client
                                   (client-selected-at-operation
                                    ,cname ,working-copy))
                                  (,cname.coord
                                   (info-of-client-selected-at-operation
                                    ,cname ,working-copy))
                                  (,cname.prev.coord
                                   (let* ()
                                     (cond
                                       ((> ,cname.position 1)
                                        (list ,cname.route
                                              (1- ,cname.position)))
                                       ;; we are in (1 1)
                                       ;; so there is not previous
                                       ((= ,route 1)
                                        (list 1 -1))
                                       ;; otherwise the previous
                                       ;; is the last of the
                                       ;; previous route
                                       (t
                                        (list (1- ,route)
                                              (1+
                                               (route-length
                                                (1- ,route)
                                                ,working-copy)))))))
                                  )
                  (with-variables-for-constraints-for-selection
                      (,initial-pos
                       ,ge ,gt
                       ,final-pos ,le ,lt
                       ,route ,working-copy
                       ,initial-target-route
                       ,final-target-route
                       ,exclude-target-route
                       ,exclude-pos
                       ,dt) 

                    (let* ((,cname.route ,route)
                           (,default-final-position
                            (route-length ,route ,working-copy)))

                      (declare (ignorable ,cname.route))

                      (loop for ,pos from
                            ;; in the initial pos we'll
                            ;; take into account
                            ;; the target route
                            (initial-for-value-in-all-macros
                             ,initial-target-route
                             ,route
                             ,initial-pos)
                            to ;; ;; let's set the final pos
                            ;; ;; according to the arguments
                            (final-value-for-loop-in-route-operation-macro
                             ,final-target-route
                             ,route
                             ,final-pos
                             ,default-final-position)
                            ;; the following line allows the final user
                            ;; to stop the iteration by setting that
                            ;; variable to t
                            while (not *vrp-stop-neighborhood-search*)

                            do ;; let's execute the body if
                            ;; we are not in a forbidden coord
                            (unless-forbidden-coord
                                (,ex
                                 ,route
                                 ,pos
                                 ,dt
                                 ,exclude-target-route ,exclude-pos)
                              (let* ((,cname
                                      (1+ (selections-count ,working-copy)))
                                     (,op
                                      (,',op-name ,,@op-params))
                                     (,simpler-ops
                                      (get-simpler-operations-from
                                       ,op ,working-copy)))


                                ;; here I want to add some code to execute it
                                ;; before the simulation of the operation
                                ;; but I'm not yet sure about how
                                ;; to do it right :-/

                                ;; now the simulation
                                (simulate-simpler-ops-macro
                                 ,simpler-ops ,working-copy)

                                ;; let's do what the user wants
                                (progn ,@body)

                                ;; now the clean up
                                (undo-simpler-ops-macro
                                 ,simpler-ops ,working-copy))))))))))))
    #+END_SRC
**** oficial tests
***** testing macroexpansion
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (format-boxed t "Testing make-do-neighborhood-selection")

      (pp-expand (make-do-neighborhood-route-selection
                  doselect-client
                  (cname route working-copy)
                  :op-name op-select-client
                  :op-params (route pos cname working-copy)
                  :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))"))
      #+END_SRC
***** testing code
****** first example from hand-made doselect-client
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
         doselect-client2
         (cname route working-copy)
         :op-name op-select-client
         :op-params (route pos cname)
         :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (format-boxed t "Testing doselect-route2 with simpler-ops")
            (doselect-client2 (c1 1 wc)
              (format t "Selected client: ~a~%"
                      c1.client)
              (pp-solution wc t) (terpri)))))
       #+END_SRC

****** testing c1.select.position
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (format-boxed t "Testing doselect-route2 with simpler-ops")
            (doselect-client2 (c1 1 wc)
              (format t "Selected client: ~a at pos ~a.~%"
                      (client-selected-at-operation c1 wc)
                      c1.select.position)
              (pp-solution wc t) (terpri)))))
       #+END_SRC

****** testing c1.select.position after modifications
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2 3 4)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (format-boxed t "Testing doselect-route2 with simpler-ops")
            (doselect-client2 (c1 1 wc)
              (format t "==============~%New value for c1~%==============~%")
              (format t "Before c2, c1 is: ~a at (~a ~a).~%"
                       c1.client c1.route
                       c1.select.position)
              (doselect-client2 (c2 1 wc)
                (format t "After c2, c1 is: ~a at (~a ~a).~%"
                       c1.client c1.route
                       c1.select.position)
               (pp-solution wc t) (terpri))))))
       #+END_SRC

****** testing c1.route
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2) (3 4) (5 6) (7 8)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (format-boxed t "Testing doselect-route2 with c1.route")
            (doselect-route (r1 wc)
              (doselect-client2 (c1 r1 wc)
                (format t "Selected client: ~a from (~a ~a).~%"
                        (client-selected-at-operation c1 wc)
                        c1.route
                        c1.select.position)
                (pp-solution wc t) (terpri))))))
       #+END_SRC

****** first example with two selections
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

         (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
           (let* ((wc (basic-working-copy s1))
                  (ops-list nil))

             (prepare-solution-for-neighborhood-exploration wc)

             (format-boxed t "Testing doselect-route2")
             (doselect-client2 (c1 1 wc)
               (doselect-client2 (c2 1 wc)
                 (format t "Selected clients: ~a and ~a~%"
                         (client-selected-at-operation c1 wc)
                         (client-selected-at-operation c2 wc))
                 (pp-solution wc t) (terpri))))))
       #+END_SRC

****** testing ge
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing doselect-route with ge")
            (doselect-client2 (c1 1 wc :ge 3)
              (format t "Selected client: ~a at pos ~a.~%"
                      (client-selected-at-operation c1 wc)
                      c1.select.position)
              (pp-solution wc t) (terpri)))))
       #+END_SRC

****** testing gt
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2 3) (4 5 6 7 8)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing doselect-route with gt")
            (doselect-route (r1 wc)
              (doselect-client2 (c1 r1 wc :gt 2)
                (format t "Selected client: ~a at pos ~a.~%"
                        (client-selected-at-operation c1 wc)
                        c1.select.position)
                (pp-solution wc t) (terpri))))))
       #+END_SRC

****** testing le
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing doselect-route with le")
            (doselect-client2 (c1 1 wc :le 4)
              (format t "Selected client: ~a at pos ~a.~%"
                      (client-selected-at-operation c1 wc)
                      c1.select.position)
              (pp-solution wc t) (terpri)))))
       #+END_SRC

****** testing lt
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing doselect-route with lt")
            (doselect-client2 (c1 1 wc :lt 4)
              (format t "Selected client: ~a at pos ~a.~%"
                      (client-selected-at-operation c1 wc)
                      c1.select.position)
              (pp-solution wc t) (terpri)))))
       #+END_SRC
****** testing dt
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing doselect-route with dt 4")
            (doselect-client2 (c1 1 wc :dt 4)
              (format t "Selected client: ~a at pos ~a.~%"
                      (client-selected-at-operation c1 wc)
                      c1.select.position)
              (pp-solution wc t) (terpri)))))
       #+END_SRC

****** testing ge with list
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2) (3 4 5 6) (7 8)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing doselect-route with ge with list (2 2)")
            (doselect-route (r1 wc)
              (doselect-client2 (c1 r1 wc :ge `(2 2) :le 3)
                (format t "Selected client: ~a at pos ~a from route ~a.~%"
                        (client-selected-at-operation c1 wc)
                        c1.select.position
                        c1.route)
                (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing gt with list
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2) (3 4 5 6) (7 8 9 10)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing doselect-route with gt with list")
            (doselect-route (r1 wc)
              (doselect-client2 (c1 r1 wc :gt `(2 2) :le 3)
                (format t "Selected client: ~a at pos ~a from route ~a.~%"
                        (client-selected-at-operation c1 wc)
                        c1.select.position
                        c1.route)
                (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing le with list
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2 3) (4 5 6) (7 8)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing doselect-route with le with list (2 3)")
            (doselect-route (r1 wc)
              (doselect-client2 (c1 r1 wc :le `(2 2))
                (format t "Selected client: ~a at pos ~a from route ~a.~%"
                        (client-selected-at-operation c1 wc)
                        c1.select.position
                        c1.route)
                (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing lt with list
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2 3) (4 5 6) (7 8)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing doselect-route with lt with list (2 2)")
            (doselect-route (r1 wc)
              (doselect-client2 (c1 r1 wc :lt `(2 2))
                (format t "Selected client: ~a from (~a ~a).~%"
                        (client-selected-at-operation c1 wc)
                        c1.route
                        c1.select.position)
                (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing lt and ge with lists
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2 3) (4 5 6 7 8) (9 10 11)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing doselect-route with lt with list (2 2)")
            (doselect-route (r1 wc)
              (doselect-client2 (c1 r1 wc :ge `(2 2) :lt `(2 4))
                (format t "Selected client: ~a from (~a ~a)~%"
                        (client-selected-at-operation c1 wc)
                        c1.route
                        c1.select.position)
                (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing dt with list
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8 9)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing doselect-route with dt with list (2 3)")
            (doselect-route (r1 wc)
              (doselect-client2 (c1 r1 wc :dt `(2 3))
                (format t "Selected client: ~a from (~a ~a).~%"
                        (client-selected-at-operation c1 wc)
                        c1.route c1.select.position)
                (pp-solution wc t) (terpri))))))
       #+END_SRC

****** testing lt and ge and dt with lists
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2 3) (4 5 6 7 8) (9 10 11)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing doselect-route with lt, ge, dt with lists")
            (doselect-route (r1 wc)
              (doselect-client2 (c1 r1 wc :ge `(2 2) :le `(2 4) :dt `(2 3))
                (format t "Selected client: ~a from (~a ~a)~%"
                        (client-selected-at-operation c1 wc)
                        c1.route
                        c1.select.position)
                (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing ex
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing doselect-route with ex ((1 1) (1 2))")
            (doselect-client2 (c1 1 wc  :ex `((1 1) (1 2)))
              (format t "Selected client: ~a from (~a ~a).~%"
                      (client-selected-at-operation c1 wc)
                      c1.route
                      c1.select.position)
              (pp-solution wc t) (terpri)))))
       #+END_SRC

       #+RESULTS:
       #+begin_example
       ==============================================
        Testing doselect-route with ex ((1 1) (1 2))
       ==============================================

       Selected client: <c:3> from (1 3).
       S1:
           R1: (1, 2, 4, 5, 6)
           R2: (7, 8)

       Selected client: <c:4> from (1 4).
       S1:
           R1: (1, 2, 3, 5, 6)
           R2: (7, 8)

       Selected client: <c:5> from (1 5).
       S1:
           R1: (1, 2, 3, 4, 6)
           R2: (7, 8)

       Selected client: <c:6> from (1 6).
       S1:
           R1: (1, 2, 3, 4, 5)
           R2: (7, 8)

       #+end_example

****** testing ex-cond
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn

         (make-do-neighborhood-route-selection
          doselect-client2
          (cname route working-copy)
          :op-name op-select-client
          :op-params (route pos cname)
          :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")

        (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8)))
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing doselect-route with ex ((1 1) (1 2))")
            (doselect-client2 (c1 1 wc
                                  :ex `((1 1) (1 2))
                                  :ex-cond (= c1.position 4))
              (format t "Selected client: ~a from (~a ~a).~%"
                      (client-selected-at-operation c1 wc)
                      c1.route
                      c1.select.position)
              (pp-solution wc t) (terpri)))))
       #+END_SRC
*** WIP code for insertions macro
***** description
      In this macro we receive a route, a number with the selected-client that should be inserted in the operation and a working copy. 

      We'll use the function get-simpler-operations-from to make the code as generic as possible.
***** other approaches
****** +adding constraints+
******* code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
      (defmacro make-do-neighborhood-route-insertion% (macro-name
                                                       (&rest args)
                                                       &key
                                                         op-name
                                                         op-params
                                                         example-str)
          ;;{{{ documentation
          "Creates a do-neighborhood macro for a insertion. The created macro searches the neighborhood in an exhaustive way.

       There will always be a gensym named `pos' that will iterate through all the positions in the route. One of the parameter passed by the user should be named `route'.

       The arguments are:

          - macro-name :: the name of the macro.
          - args :: the args that the created macro will receive.
                    Apparently we'll always need parameters named `cname',
                    `route', and `working-copy'.
                     - `cname' should be a symbol that will be bound to
                       (1+ (selections-count working-copy).
                     - `route' should be a number with the id of a route
                        in the working-copy, where the selections should
                        take place.
          - op-name :: the constructor of the neighborhood operation to use.
          - op-params :: the params that should be passed to the constructor
                         of the operation.
          - example-str ::  this is a string to add to the description of the macro with an intended usage example." ;;;}}}

          (let* ((comment-str (format nil "Iterates through each position in the given route, creates an instance of ~a, pushes it int ops-lists, simulates it, do whatever the users wants to do, and finally restores everything to the previous state.
       Example:
          ~a" op-name example-str))
                 (actual-args (append
                              args
                              `(&key 
                                ,@*vrp-do-macros-constraint-symbols*)))
                 )
            `(defmacro ,macro-name (,actual-args &body body)
               ,comment-str

               (let* ((pos (symb cname ".ins.pos"))
                      (cname.ins.route (symb cname ".insert.route"))
                      (cname.ins.position (symb cname ".insert.position")))
                 (with-gensyms (op
                                simpler-ops
                                initial-pos
                                final-pos
                                initial-target-route
                                final-target-route
                                exclude-target-route
                                exclude-pos)
                   `(symbol-macrolet ((,cname.ins.position
                                       (get-inserted-client-pos
                                           ,cname ,working-copy))
                                         (,cname.ins.route
                                          (get-inserted-client-route
                                           ,cname ,working-copy)))
                      ;; here compute the appropriate
                      ;; values for the variables
                      ;; related to the constraints
                      (with-variables-for-constraints-for-insertion
                          (,initial-pos ,ge ,gt
                           ,final-pos ,le ,lt
                           ,route ,working-copy
                           ,initial-target-route
                           ,final-target-route
                           ,exclude-target-route
                           ,exclude-pos
                           ,dt)
                  

                         ;; for this point we start the insertions
                         (loop for ,pos from
                               ;; in the initial pos we'll take into account
                               ;; the target route
                               (if ,initial-target-route
                                   (then ;; select the appropriate initial-pos
                                     (cond
                                       ((= ,initial-target-route ,route)
                                        ,initial-pos)
                                       ((< ,route ,initial-target-route)
                                        ,,*vrp-max-route-length*)
                                       (t 1)))
                                   (else ;; set pos to initial-pos
                                     ;; because we apply the
                                     ;; constraint to all the routes
                                     ,initial-pos))

                               to ;; ;; let's set the final pos
                               ;; ;; according to the constraints
                               (if ,final-target-route
                                (then ;; select the appropriate final-pos
                                  (cond
                                    ((= ,final-target-route ,route)
                                     (min ,final-pos
                                          (1+ (route-length ,route wc))))
                                    ((> ,route ,final-target-route)
                                     ;; don't iterate through this route
                                     ;; so set the final pos to
                                     -1)
                                    (t ;; we are in a route before
                                     ;; the final-target-route
                                     ;; so we can iterate through all the route
                                     (1+ (route-length ,route ,working-copy)))))
                                (else
                                  (min ,final-pos
                                       (1+ (route-length ,route wc)))))

                               ;; the following line allows the final user
                               ;; to stop the iteration by setting that
                               ;; variable to t
                               while (not *vrp-stop-neighborhood-search*)

                               ;; let's execute the body if
                               ;; we are not in a forbidden coord
                               do (unless (or ;; we have two scenarios
                                           ;; in one...
                                           (and ,dt ;; we have a different to
                                                ;; with a route
                                                ,exclude-target-route
                                                ;; and we are in that route
                                                (= ,exclude-target-route ,route)
                                                ;; and that position
                                                (= ,exclude-pos ,pos)
                                                ;; so don't do anything
                                                )
                                           ;; in the other scenario
                                           (and ,dt ;; we have a different to
                                                ;; but we don't have a route
                                                (null ,exclude-target-route)
                                                ;; so, if we are in that
                                                ;; forbidden position,
                                                ;; don't do anything
                                                (= ,exclude-pos ,pos)))
                                    ;; if we are here, it means that
                                    ;; we are not in the forbidden coord
                                    ;; so let's do our thing
                                    (let* ((,op (,',op-name ,,@op-params))
                                           ;; get the simpler operations
                                           (,simpler-ops
                                            (get-simpler-operations-from
                                             ,op ,working-copy)))


                                      ;; now the simulation
                                      (simulate-simpler-ops-macro
                                       ,simpler-ops ,working-copy)

                                      ;; let's do what the user wants
                                      (progn ,@body)

                                      ;; now the clean up
                                      (undo-simpler-ops-macro
                                       ,simpler-ops ,working-copy)))))))))))
      #+END_SRC
******* +tests for adding constraints+
******** simple tests
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (make-do-neighborhood-route-insertion%
                           doinsert-client2
                           (cname route working-copy)
                           :op-name op-insert-client
                           :op-params (route pos cname)
                           :example-str "(doinsert-client (c1 r1 wc1)
                      (format t \"Inserting client ~a.~%\"
                       (client-selected-at-operation c1 wc1)))

                 c1   is the index of the client that we want to insert
                      (actually it should be the selections-count corresponding
                      to its selection)
                 r1  is the id of the route we want to make the insertion in
                 wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
            (let* ((wc (basic-working-copy s1))
                   (op1 (op-select-client 2 1 0))
                   (c1 0)
                   (ops-list nil))

              (prepare-solution-for-neighborhood-exploration wc)

              ;; simulate the first selection
              (simulate-neighborhood-operation op1 wc)

              (bformat t "Testing doinsert-client")
              (doinsert-client2 (c1 1 wc)
                (format t "Inserting ~a at (~a ~a)~%"
                        (client-selected-at-operation c1 wc)
                        c1.insert.route c1.insert.position)
                (pp-solution wc t) (terpri)))))
         #+END_SRC
   
******** testing cname.insert.position
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (make-do-neighborhood-route-insertion%
                           doinsert-client2
                           (cname route working-copy)
                           :op-name op-insert-client
                           :op-params (route pos cname)
                           :example-str "(doinsert-client (c1 r1 wc1)
                      (format t \"Inserting client ~a.~%\"
                       (client-selected-at-operation c1 wc1)))

                 c1   is the index of the client that we want to insert
                      (actually it should be the selections-count corresponding
                      to its selection)
                 r1  is the id of the route we want to make the insertion in
                 wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
            (let* ((wc (basic-working-copy s1))
                   (op1 (op-select-client 2 1 0))
                   (c1 0)
                   (ops-list nil))

              (prepare-solution-for-neighborhood-exploration wc)

              ;; simulate the first selection
              (simulate-neighborhood-operation op1 wc)

              (bformat t "Testing doinsert-client")
              (doinsert-client2 (c1 1 wc)
                (format t "Inserting client: ~a at pos ~a~%"
                        (client-selected-at-operation c1 wc)
                        c1.insert.position)
                (pp-solution wc t) (terpri)))))
         #+END_SRC
   
******** simple tests with two insertions
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (make-do-neighborhood-route-insertion%
                                 doinsert-client2
                                 (cname route working-copy)
                                 :op-name op-insert-client
                                 :op-params (route pos cname)
                                 :example-str "(doinsert-client (c1 r1 wc1)
                            (format t \"Inserting client ~a.~%\"
                             (client-selected-at-operation c1 wc1)))

                       c1   is the index of the client that we want to insert
                            (actually it should be the selections-count corresponding
                            to its selection)
                       r1  is the id of the route we want to make the insertion in
                       wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
            (let* ((wc (basic-working-copy s1))
                   (c1 0) (c2 1)
                   (op1 (op-select-client 2 1 c1))
                   (op2 (op-select-client 2 3 c2))         
                   (ops-list nil))

              (prepare-solution-for-neighborhood-exploration wc)

              ;; simulate the first selection
              (simulate-neighborhood-operation op1 wc)
              (simulate-neighborhood-operation op2 wc)

              (bformat t "Testing doinsert-client")
              (doinsert-client2 (c1 1 wc)
                (doinsert-client2 (c2 1 wc)
                  (format t "Selected clients: ~a and ~a~%"
                          (client-selected-at-operation c1 wc)
                          (client-selected-at-operation c2 wc))
                  (pp-solution wc t) (terpri))))))
         #+END_SRC
   
******** simple test with a doselect-route
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (make-do-neighborhood-route-insertion%
                                       doinsert-client2
                                       (cname route working-copy)
                                       :op-name op-insert-client
                                       :op-params (route pos cname)
                                       :example-str "(doinsert-client (c1 r1 wc1)
                                  (format t \"Inserting client ~a.~%\"
                                   (client-selected-at-operation c1 wc1)))

                             c1   is the index of the client that we want to insert
                                  (actually it should be the selections-count corresponding
                                  to its selection)
                             r1  is the id of the route we want to make the insertion in
                             wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
             (let* ((wc (basic-working-copy s1))
                    (c1 0)
                    (op1 (op-select-client 2 1 c1))

                    (ops-list nil))

               (prepare-solution-for-neighborhood-exploration wc)
               (simulate-neighborhood-operation op1 wc)

               (format t "Testing doselect-client")
               (doselect-route (r1 wc)
                 (doinsert-client2 (c1 r1 wc)
                   (format t "Inserting in route with id ~a:~%" r1
                           (client-selected-at-operation c1 wc))
                   (pp-solution wc t) (terpri))))))
         #+END_SRC
******** testing ge
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (make-do-neighborhood-route-insertion%
                                       doinsert-client2
                                       (cname route working-copy)
                                       :op-name op-insert-client
                                       :op-params (route pos cname)
                                       :example-str "(doinsert-client (c1 r1 wc1)
                                  (format t \"Inserting client ~a.~%\"
                                   (client-selected-at-operation c1 wc1)))

                             c1   is the index of the client that we want to insert
                                  (actually it should be the selections-count corresponding
                                  to its selection)
                             r1  is the id of the route we want to make the insertion in
                             wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
             (let* ((wc (basic-working-copy s1))
                    (c1 0)
                    (op1 (op-select-client 2 1 c1))

                    (ops-list nil))

               (prepare-solution-for-neighborhood-exploration wc)
               (simulate-neighborhood-operation op1 wc)

               (bformat t "Testing doinsert-client with ge 3 [no list]")
               (doselect-route (r1 wc)
                 (doinsert-client2 (c1 r1 wc :ge 3)
                   (format t "Inserting ~a at pos (~a ~a):~%"
                           (client-selected-at-operation c1 wc)
                           c1.insert.route c1.insert.position)
                   (pp-solution wc t) (terpri))))))
         #+END_SRC
******** testing gt
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (make-do-neighborhood-route-insertion%
                                       doinsert-client2
                                       (cname route working-copy)
                                       :op-name op-insert-client
                                       :op-params (route pos cname)
                                       :example-str "(doinsert-client (c1 r1 wc1)
                                  (format t \"Inserting client ~a.~%\"
                                   (client-selected-at-operation c1 wc1)))

                             c1   is the index of the client that we want to insert
                                  (actually it should be the selections-count corresponding
                                  to its selection)
                             r1  is the id of the route we want to make the insertion in
                             wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
             (let* ((wc (basic-working-copy s1))
                    (c1 0)
                    (op1 (op-select-client 2 1 c1))

                    (ops-list nil))

               (prepare-solution-for-neighborhood-exploration wc)
               (simulate-neighborhood-operation op1 wc)

               (bformat t "Testing doinsert-client with gt [no list]")
               (doselect-route (r1 wc)
                 (doinsert-client2 (c1 r1 wc :gt 3)
                   (format t "Inserting ~a at pos (~a ~a):~%"
                           (client-selected-at-operation c1 wc)
                           c1.insert.route c1.insert.position)
                   (pp-solution wc t) (terpri))))))
         #+END_SRC
******** testing le
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (make-do-neighborhood-route-insertion%
                                       doinsert-client2
                                       (cname route working-copy)
                                       :op-name op-insert-client
                                       :op-params (route pos cname)
                                       :example-str "(doinsert-client (c1 r1 wc1)
                                  (format t \"Inserting client ~a.~%\"
                                   (client-selected-at-operation c1 wc1)))

                             c1   is the index of the client that we want to insert
                                  (actually it should be the selections-count corresponding
                                  to its selection)
                             r1  is the id of the route we want to make the insertion in
                             wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
             (let* ((wc (basic-working-copy s1))
                    (c1 0)
                    (op1 (op-select-client 2 1 c1))

                    (ops-list nil))

               (prepare-solution-for-neighborhood-exploration wc)
               (simulate-neighborhood-operation op1 wc)

               (bformat t "Testing doinsert-client with le 3 [no list]")
               (doselect-route (r1 wc)
                 (doinsert-client2 (c1 r1 wc :le 3)
                   (format t "Inserting ~a at pos (~a ~a):~%"
                           (client-selected-at-operation c1 wc)
                           c1.insert.route c1.insert.position)
                   (pp-solution wc t) (terpri))))))
         #+END_SRC
******** testing lt
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (make-do-neighborhood-route-insertion%
                                       doinsert-client2
                                       (cname route working-copy)
                                       :op-name op-insert-client
                                       :op-params (route pos cname)
                                       :example-str "(doinsert-client (c1 r1 wc1)
                                  (format t \"Inserting client ~a.~%\"
                                   (client-selected-at-operation c1 wc1)))

                             c1   is the index of the client that we want to insert
                                  (actually it should be the selections-count corresponding
                                  to its selection)
                             r1  is the id of the route we want to make the insertion in
                             wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
             (let* ((wc (basic-working-copy s1))
                    (c1 0)
                    (op1 (op-select-client 2 1 c1))

                    (ops-list nil))

               (prepare-solution-for-neighborhood-exploration wc)
               (simulate-neighborhood-operation op1 wc)

               (bformat t "Testing doinsert-client with lt 3 [no list]")
               (doselect-route (r1 wc)
                 (doinsert-client2 (c1 r1 wc :lt 3)
                   (format t "Inserting ~a at pos (~a ~a):~%"
                           (client-selected-at-operation c1 wc)
                           c1.insert.route c1.insert.position)
                   (pp-solution wc t) (terpri))))))
         #+END_SRC
******** testing ge with list
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (make-do-neighborhood-route-insertion%
                                       doinsert-client2
                                       (cname route working-copy)
                                       :op-name op-insert-client
                                       :op-params (route pos cname)
                                       :example-str "(doinsert-client (c1 r1 wc1)
                                  (format t \"Inserting client ~a.~%\"
                                   (client-selected-at-operation c1 wc1)))

                             c1   is the index of the client that we want to insert
                                  (actually it should be the selections-count corresponding
                                  to its selection)
                             r1  is the id of the route we want to make the insertion in
                             wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
             (let* ((wc (basic-working-copy s1))
                    (c1 0)
                    (op1 (op-select-client 2 1 c1))

                    (ops-list nil))

               (prepare-solution-for-neighborhood-exploration wc)
               (simulate-neighborhood-operation op1 wc)

               (bformat t "Testing doinsert-client with ge 3 [with list]")
               (doselect-route (r1 wc)
                 (doinsert-client2 (c1 r1 wc :ge `(2 3))
                   (format t "Inserting ~a at pos (~a ~a):~%"
                           (client-selected-at-operation c1 wc)
                           c1.insert.route c1.insert.position)
                   (pp-solution wc t) (terpri))))))
         #+END_SRC
******** testing gt with list
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (make-do-neighborhood-route-insertion%
                                       doinsert-client2
                                       (cname route working-copy)
                                       :op-name op-insert-client
                                       :op-params (route pos cname)
                                       :example-str "(doinsert-client (c1 r1 wc1)
                                  (format t \"Inserting client ~a.~%\"
                                   (client-selected-at-operation c1 wc1)))

                             c1   is the index of the client that we want to insert
                                  (actually it should be the selections-count corresponding
                                  to its selection)
                             r1  is the id of the route we want to make the insertion in
                             wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
             (let* ((wc (basic-working-copy s1))
                    (c1 0)
                    (op1 (op-select-client 2 1 c1))

                    (ops-list nil))

               (prepare-solution-for-neighborhood-exploration wc)
               (simulate-neighborhood-operation op1 wc)

               (bformat t "Testing doinsert-client with gt 3 [with list]")
               (doselect-route (r1 wc)
                 (doinsert-client2 (c1 r1 wc :gt `(2 2))
                   (format t "Inserting ~a at pos (~a ~a):~%"
                           (client-selected-at-operation c1 wc)
                           c1.insert.route c1.insert.position)
                   (pp-solution wc t) (terpri))))))
         #+END_SRC
******** testing le with list
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (make-do-neighborhood-route-insertion%
                                       doinsert-client2
                                       (cname route working-copy)
                                       :op-name op-insert-client
                                       :op-params (route pos cname)
                                       :example-str "(doinsert-client (c1 r1 wc1)
                                  (format t \"Inserting client ~a.~%\"
                                   (client-selected-at-operation c1 wc1)))

                             c1   is the index of the client that we want to insert
                                  (actually it should be the selections-count corresponding
                                  to its selection)
                             r1  is the id of the route we want to make the insertion in
                             wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
             (let* ((wc (basic-working-copy s1))
                    (c1 0)
                    (op1 (op-select-client 2 1 c1))

                    (ops-list nil))

               (prepare-solution-for-neighborhood-exploration wc)
               (simulate-neighborhood-operation op1 wc)

               (bformat t "Testing doinsert-client with le 3 [no list]")
               (doselect-route (r1 wc)
                 (doinsert-client2 (c1 r1 wc :le `(1 3))
                   (format t "Inserting ~a at pos (~a ~a):~%"
                           (client-selected-at-operation c1 wc)
                           c1.insert.route c1.insert.position)
                   (pp-solution wc t) (terpri))))))
         #+END_SRC
******** testing lt with list
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (make-do-neighborhood-route-insertion%
                                       doinsert-client2
                                       (cname route working-copy)
                                       :op-name op-insert-client
                                       :op-params (route pos cname)
                                       :example-str "(doinsert-client (c1 r1 wc1)
                                  (format t \"Inserting client ~a.~%\"
                                   (client-selected-at-operation c1 wc1)))

                             c1   is the index of the client that we want to insert
                                  (actually it should be the selections-count corresponding
                                  to its selection)
                             r1  is the id of the route we want to make the insertion in
                             wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
             (let* ((wc (basic-working-copy s1))
                    (c1 0)
                    (op1 (op-select-client 2 1 c1))

                    (ops-list nil))

               (prepare-solution-for-neighborhood-exploration wc)
               (simulate-neighborhood-operation op1 wc)

               (bformat t "Testing doinsert-client with lt (1 3) [with list]")
               (doselect-route (r1 wc)
                 (doinsert-client2 (c1 r1 wc :lt `(1 3))
                   (format t "Inserting ~a at pos (~a ~a):~%"
                           (client-selected-at-operation c1 wc)
                           c1.insert.route c1.insert.position)
                   (pp-solution wc t) (terpri))))))
         #+END_SRC
******** testing dt
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (make-do-neighborhood-route-insertion%
                                       doinsert-client2
                                       (cname route working-copy)
                                       :op-name op-insert-client
                                       :op-params (route pos cname)
                                       :example-str "(doinsert-client (c1 r1 wc1)
                                  (format t \"Inserting client ~a.~%\"
                                   (client-selected-at-operation c1 wc1)))

                             c1   is the index of the client that we want to insert
                                  (actually it should be the selections-count corresponding
                                  to its selection)
                             r1  is the id of the route we want to make the insertion in
                             wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
             (let* ((wc (basic-working-copy s1))
                    (c1 0)
                    (op1 (op-select-client 2 1 c1))

                    (ops-list nil))

               (prepare-solution-for-neighborhood-exploration wc)
               (simulate-neighborhood-operation op1 wc)

               (bformat t "Testing doinsert-client with dt 3 [no list]")
               (doselect-route (r1 wc)
                 (doinsert-client2 (c1 r1 wc :dt 3)
                   (format t "Inserting ~a at pos (~a ~a):~%"
                           (client-selected-at-operation c1 wc)
                           c1.insert.route c1.insert.position)
                   (pp-solution wc t) (terpri))))))
         #+END_SRC
******** testing dt with list
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (make-do-neighborhood-route-insertion%
                                       doinsert-client2
                                       (cname route working-copy)
                                       :op-name op-insert-client
                                       :op-params (route pos cname)
                                       :example-str "(doinsert-client (c1 r1 wc1)
                                  (format t \"Inserting client ~a.~%\"
                                   (client-selected-at-operation c1 wc1)))

                             c1   is the index of the client that we want to insert
                                  (actually it should be the selections-count corresponding
                                  to its selection)
                             r1  is the id of the route we want to make the insertion in
                             wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
             (let* ((wc (basic-working-copy s1))
                    (c1 0)
                    (op1 (op-select-client 2 1 c1))

                    (ops-list nil))

               (prepare-solution-for-neighborhood-exploration wc)
               (simulate-neighborhood-operation op1 wc)

               (bformat t "Testing doinsert-client with lt (1 3) [with list]")
               (doselect-route (r1 wc)
                 (doinsert-client2 (c1 r1 wc :dt `(1 3))
                   (format t "Inserting ~a at pos (~a ~a):~%"
                           (client-selected-at-operation c1 wc)
                           c1.insert.route c1.insert.position)
                   (pp-solution wc t) (terpri))))))
         #+END_SRC
****** +adding macros for the for values in the loop+
******* code
        #+BEGIN_SRC lisp +n -r :results none :exports code
      (defmacro make-do-neighborhood-route-insertion% (macro-name
                                                       (&rest args)
                                                       &key
                                                         op-name
                                                         op-params
                                                         example-str)
          ;;{{{ documentation
          "Creates a do-neighborhood macro for a insertion. The created macro searches the neighborhood in an exhaustive way.

       There will always be a gensym named `pos' that will iterate through all the positions in the route. One of the parameter passed by the user should be named `route'.

       The arguments are:

          - macro-name :: the name of the macro.
          - args :: the args that the created macro will receive.
                    Apparently we'll always need parameters named `cname',
                    `route', and `working-copy'.
                     - `cname' should be a symbol that will be bound to
                       (1+ (selections-count working-copy).
                     - `route' should be a number with the id of a route
                        in the working-copy, where the selections should
                        take place.
          - op-name :: the constructor of the neighborhood operation to use.
          - op-params :: the params that should be passed to the constructor
                         of the operation.
          - example-str ::  this is a string to add to the description of the macro with an intended usage example."
       ;;;}}}

          (let* ((comment-str (format nil "Iterates through each position in the given route, creates an instance of ~a, pushes it int ops-lists, simulates it, do whatever the users wants to do, and finally restores everything to the previous state.
       Example:
          ~a" op-name example-str))
                 (actual-args (append
                              args
                              `(&key 
                                ,@*vrp-do-macros-constraint-symbols*)))
                 )
            `(defmacro ,macro-name (,actual-args &body body)
               ,comment-str

               (let* ((pos (symb cname ".ins.pos"))
                      (cname.ins.route (symb cname ".insert.route"))
                      (cname.ins.position (symb cname ".insert.position")))
                 (with-gensyms (op
                                simpler-ops
                                initial-pos
                                final-pos
                                initial-target-route
                                final-target-route
                                exclude-target-route
                                exclude-pos
                                default-final-position)
                   `(symbol-macrolet ((,cname.ins.position
                                       (get-inserted-client-pos
                                           ,cname ,working-copy))
                                         (,cname.ins.route
                                          (get-inserted-client-route
                                           ,cname ,working-copy)))
                      ;; here compute the appropriate
                      ;; values for the variables
                      ;; related to the constraints
                      (with-variables-for-constraints-for-insertion
                          (,initial-pos ,ge ,gt
                           ,final-pos ,le ,lt
                           ,route ,working-copy
                           ,initial-target-route
                           ,final-target-route
                           ,exclude-target-route
                           ,exclude-pos
                           ,dt)

                        ;; let's set the value for
                        ;; default-final-pos
                        ;; to (1+ (route-length ,route ,working-copy)).
                        ;; The 1+ is because we can insert at the
                        ;; end of the route.
                        (let* ((,default-final-position
                                (1+ (route-length ,route ,working-copy))))
                    
                          ;; for this point we start the insertions
                          (loop for ,pos from
                                ;; in the initial pos we'll take into account
                                ;; the target route
                                (initial-for-value-in-all-macros
                                 ,initial-target-route
                                 ,route
                                 ,initial-pos)

                                to ;; ;; let's set the final pos
                                ;; ;; according to the constraints
                                (final-value-for-loop-in-route-operation-macro
                                 ,final-target-route
                                 ,route
                                 ,final-pos
                                 ,default-final-position)

                                ;; the following line allows the final user
                                ;; to stop the iteration by setting that
                                ;; variable to t
                                while (not *vrp-stop-neighborhood-search*)

                                ;; let's execute the body if
                                ;; we are not in a forbidden coord
                                do
                                (unless-forbidden-coord
                                    (,ex
                                     ,route
                                     ,pos
                                     ,dt
                                     ,exclude-target-route ,exclude-pos)

                                  ;; if we are here, it means that
                                  ;; we are not in the forbidden coord
                                  ;; so let's do our thing
                                  (let* ((,op (,',op-name ,,@op-params))
                                         ;; get the simpler operations
                                         (,simpler-ops
                                          (get-simpler-operations-from
                                           ,op ,working-copy)))


                                    ;; now the simulation
                                    (simulate-simpler-ops-macro
                                     ,simpler-ops ,working-copy)

                                    ;; let's do what the user wants
                                    (progn ,@body)

                                    ;; now the clean up
                                    (undo-simpler-ops-macro
                                     ,simpler-ops ,working-copy))))))))))))
      #+END_SRC
******* tests for the initialization in the loop
******** simple test
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (bformat t "Testing macro initial-for-value-in-insertion-macro")

           (make-do-neighborhood-route-insertion%
                           doinsert-client3
                           (cname route working-copy)
                           :op-name op-insert-client
                           :op-params (route pos cname)
                           :example-str "(doinsert-client (c1 r1 wc1)
                      (format t \"Inserting client ~a.~%\"
                       (client-selected-at-operation c1 wc1)))

                 c1   is the index of the client that we want to insert
                      (actually it should be the selections-count corresponding
                      to its selection)
                 r1  is the id of the route we want to make the insertion in
                 wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4 5 6 7 8) (9)))
            (let* ((wc (basic-working-copy s1))
                   (op1 (op-select-client 2 1 0))
                   (c1 0)
                   (ops-list nil))

              (prepare-solution-for-neighborhood-exploration wc)

              ;; simulate the first selection
              (simulate-neighborhood-operation op1 wc)

              (bformat t "Testing doinsert-client")
              (doinsert-client3 (c1 1 wc
                                    :ge (list 1 2)
                                    :dt (list 1 4)
                                    :ex (list
                                         (list 1 6)
                                         (list 1 8)))
                (format t "Inserting ~a at (~a ~a)~%"
                        (client-selected-at-operation c1 wc)
                        c1.insert.route c1.insert.position)
                (pp-solution wc t) (terpri)))))
         #+END_SRC

******** testing a negative initial value
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (bformat t "Testing macro initial-for-value-in-insertion-macro")

           (make-do-neighborhood-route-insertion%
                           doinsert-client3
                           (cname route working-copy)
                           :op-name op-insert-client
                           :op-params (route pos cname)
                           :example-str "(doinsert-client (c1 r1 wc1)
                      (format t \"Inserting client ~a.~%\"
                       (client-selected-at-operation c1 wc1)))

                 c1   is the index of the client that we want to insert
                      (actually it should be the selections-count corresponding
                      to its selection)
                 r1  is the id of the route we want to make the insertion in
                 wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
            (let* ((wc (basic-working-copy s1))
                   (op1 (op-select-client 2 1 0))
                   (c1 0)
                   (ops-list nil))

              (prepare-solution-for-neighborhood-exploration wc)

              ;; simulate the first selection
              (simulate-neighborhood-operation op1 wc)

              (bformat t "Testing doinsert-client")
              (doinsert-client3 (c1 1 wc :gt (list 1 -4))
                (format t "Inserting ~a at (~a ~a)~%"
                        (client-selected-at-operation c1 wc)
                        c1.insert.route c1.insert.position)
                (pp-solution wc t) (terpri)))))
         #+END_SRC

****** adding a generic simulate simpler operations
******* code
        #+BEGIN_SRC lisp +n -r :results none :exports code
        (defmacro make-do-neighborhood-route-insertion% (macro-name
                                                         (&rest args)
                                                         &key
                                                           op-name
                                                           op-params
                                                           example-str
                                                           (simpler-ops-macro
                                                            'simulate-simpler-ops-macro)
                                                           (undo-simpler-ops-macro
                                                            'undo-simpler-ops-macro))
            ;;{{{ documentation
            "Creates a do-neighborhood macro for a insertion. The created macro searches the neighborhood in an exhaustive way.

         There will always be a gensym named `pos' that will iterate through all the positions in the route. One of the parameter passed by the user should be named `route'.

         The arguments are:

            - macro-name :: the name of the macro.
            - args :: the args that the created macro will receive.
                      Apparently we'll always need parameters named `cname',
                      `route', and `working-copy'.
                       - `cname' should be a symbol that will be bound to
                         (1+ (selections-count working-copy).
                       - `route' should be a number with the id of a route
                          in the working-copy, where the selections should
                          take place.
            - op-name :: the constructor of the neighborhood operation to use.
            - op-params :: the params that should be passed to the constructor
                           of the operation.
            - example-str ::  this is a string to add to the description of the macro with an intended usage example."
         ;;;}}}

            (let* ((comment-str (format nil "Iterates through each position in the given route, creates an instance of ~a, pushes it int ops-lists, simulates it, do whatever the users wants to do, and finally restores everything to the previous state.
         Example:
            ~a" op-name example-str))
                   (actual-args (append
                                args
                                `(&key 
                                  ,@*vrp-do-macros-constraint-symbols*)))
                   )
              `(defmacro ,macro-name (,actual-args &body body)
                 ,comment-str

                 (let* ((pos (symb cname ".ins.pos"))
                        (cname.ins.route (symb cname ".insert.route"))
                        (cname.ins.position (symb cname ".insert.position")))
                   (with-gensyms (op
                                  simpler-ops
                                  initial-pos
                                  final-pos
                                  initial-target-route
                                  final-target-route
                                  exclude-target-route
                                  exclude-pos
                                  default-final-position)
                     `(symbol-macrolet ((,cname.ins.position
                                         (get-inserted-client-pos
                                             ,cname ,working-copy))
                                           (,cname.ins.route
                                            (get-inserted-client-route
                                             ,cname ,working-copy)))
                        ;; here compute the appropriate
                        ;; values for the variables
                        ;; related to the constraints
                        (with-variables-for-constraints-for-insertion
                            (,initial-pos ,ge ,gt
                             ,final-pos ,le ,lt
                             ,route ,working-copy
                             ,initial-target-route
                             ,final-target-route
                             ,exclude-target-route
                             ,exclude-pos
                             ,dt)

                          ;; let's set the value for
                          ;; default-final-pos
                          ;; to (1+ (route-length ,route ,working-copy)).
                          ;; The 1+ is because we can insert at the
                          ;; end of the route.
                          (let* ((,default-final-position
                                  (1+ (route-length ,route ,working-copy))))

                            ;; for this point we start the insertions
                            (loop for ,pos from
                                  ;; in the initial pos we'll take into account
                                  ;; the target route
                                  (initial-for-value-in-all-macros
                                   ,initial-target-route
                                   ,route
                                   ,initial-pos)

                                  to ;; ;; let's set the final pos
                                  ;; ;; according to the constraints
                                  (final-value-for-loop-in-route-operation-macro
                                   ,final-target-route
                                   ,route
                                   ,final-pos
                                   ,default-final-position)

                                  ;; the following line allows the final user
                                  ;; to stop the iteration by setting that
                                  ;; variable to t
                                  while (not *vrp-stop-neighborhood-search*)

                                  ;; let's execute the body if
                                  ;; we are not in a forbidden coord
                                  do
                                  (unless-forbidden-coord
                                      (,ex
                                       ,route
                                       ,pos
                                       ,dt
                                       ,exclude-target-route
                                       ,exclude-pos
                                       ,ex-cond)

                                    ;; if we are here, it means that
                                    ;; we are not in the forbidden coord
                                    ;; so let's do our thing
                                    (let* ((,op (,',op-name ,,@op-params))
                                           ;; get the simpler operations
                                           (,simpler-ops
                                            (get-simpler-operations-from
                                             ,op ,working-copy)))


                                      ;; now the simulation
                                      (,',simpler-ops-macro
                                       ,simpler-ops ,working-copy)

                                      ;; let's do what the user wants
                                      (progn ,@body)

                                      ;; now the clean up
                                      (,',undo-simpler-ops-macro
                                         ,simpler-ops ,working-copy))))))))))))
      #+END_SRC
******* testing params: simpler-ops-macro and undo-simpler-ops-macro
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
        (progn

          (bformat t "Testing passing new args to the macro")

          (make-do-neighborhood-route-insertion%
           doinsert-client2
           (cname route working-copy)
           :op-name op-insert-client
           :op-params (route pos cname)
           :example-str "(doselect-client (c1 r1 wc1)
                   (format t \"Selecting client ~a from route ~a~%\"
                    (client-selected-at-operation c1)
                    (get-route-with-id r1 wc1)))"
           :simpler-ops-macro simulate-simpler-ops-macro*
           :undo-simpler-ops-macro undo-simpler-ops-macro*)

         (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                                      (5 0 6 7 2 4 2 3 4)  ;1
                                                      (1 8 0 3 9 1 2 4 5)  ;2
                                                      (4 5 1 0 5 7 1 9 5)  ;3
                                                      (4 5 1 5 0 6 2 8 2)  ;4
                                                      (1 5 7 6 9 0 1 6 7)  ;5
                                                      (4 5 1 3 5 7 0 9 5)  ;6
                                                      (4 6 2 8 2 3 8 0 1)  ;7
                                                      (4 5 3 4 1 6 2 8 0)  ;8
                                                      )
                                                      ;0 1 2 3 4 5 6 7 8
                                        :demands '(20 10 15 40 30 20 10 30)
                                        :capacity 30)
               (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6 7 8)) problem)
                 (let* ((wc (basic-working-copy s1))
                        (c1 0)
                        (op (op-select-client 1 1 c1))
                        (ops-list nil)
                        (action (delta-cvrp-action*)))

                   (prepare-solution-for-neighborhood-exploration wc)
                   (initialize-action-for-delta-cost-computation wc problem action)


                   (compute-delta-cost-after op wc problem action)
                   (format t "Delta distance after op: ~a~%"
                              (delta-distance action))
                   (format t "Route feasibility after op: ~a~%"
                              (delta-routes-feasibility action))

                   (simulate-neighborhood-operation op wc)
                   (format t "Selected client: ~a~%"
                           (client-selected-at-operation c1 wc))


                   (bformat t "Testing doinsert-client2")
                   (doinsert-client2 (c1 2 wc)
                      (pp-solution wc t) (terpri)
                      (format t "Delta distance after op: ~a~%"
                              (delta-distance action))
                      (format t "Route feasibility after op: ~a~%"
                              (delta-routes-feasibility action))
                      (format t "delta-distance-stack: ~a~%"
                              (delta-distance-stack action)))
                   ))))
        #+END_SRC
***** official code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmacro make-do-neighborhood-route-insertion (macro-name
                                                     (&rest args)
                                                     &key
                                                       op-name
                                                       op-params
                                                       example-str
                                                       (simpler-ops-macro 'simulate-simpler-ops-macro)
                                                       (undo-simpler-ops-macro 'undo-simpler-ops-macro))
            ;;{{{ documentation
            "Creates a do-neighborhood macro for a insertion. The created macro searches the neighborhood in an exhaustive way.

         There will always be a gensym named `pos' that will iterate through all the positions in the route. One of the parameter passed by the user should be named `route'.

         The arguments are:

            - macro-name :: the name of the macro.
            - args :: the args that the created macro will receive.
                      Apparently we'll always need parameters named `cname',
                      `route', and `working-copy'.
                       - `cname' should be a symbol that will be bound to
                         (1+ (selections-count working-copy).
                       - `route' should be a number with the id of a route
                          in the working-copy, where the selections should
                          take place.
            - op-name :: the constructor of the neighborhood operation to use.
            - op-params :: the params that should be passed to the constructor
                           of the operation.
            - example-str ::  this is a string to add to the description of the macro with an intended usage example."
         ;;;}}}

            (let* ((comment-str (format nil "Iterates through each position in the given route, creates an instance of ~a, pushes it int ops-lists, simulates it, do whatever the users wants to do, and finally restores everything to the previous state.
         Example:
            ~a" op-name example-str))
                   (actual-args (append
                                args
                                `(&key 
                                  ,@*vrp-do-macros-constraint-symbols*)))
                   )
              `(defmacro ,macro-name (,actual-args &body body)
                 ,comment-str

                 (let* ((pos (symb cname ".ins.pos"))
                        (cname.ins.route (symb cname ".insert.route"))
                        (cname.ins.position (symb cname ".insert.position")))
                   (with-gensyms (op
                                  simpler-ops
                                  initial-pos
                                  final-pos
                                  initial-target-route
                                  final-target-route
                                  exclude-target-route
                                  exclude-pos
                                  default-final-position)
                     `(symbol-macrolet ((,cname.ins.position
                                         (get-inserted-client-pos
                                             ,cname ,working-copy))
                                           (,cname.ins.route
                                            (get-inserted-client-route
                                             ,cname ,working-copy)))
                        ;; here compute the appropriate
                        ;; values for the variables
                        ;; related to the constraints
                        (with-variables-for-constraints-for-insertion
                            (,initial-pos ,ge ,gt
                             ,final-pos ,le ,lt
                             ,route ,working-copy
                             ,initial-target-route
                             ,final-target-route
                             ,exclude-target-route
                             ,exclude-pos
                             ,dt)

                          ;; let's set the value for
                          ;; default-final-pos
                          ;; to (1+ (route-length ,route ,working-copy)).
                          ;; The 1+ is because we can insert at the
                          ;; end of the route.
                          (let* ((,default-final-position
                                  (1+ (route-length ,route ,working-copy))))

                            ;; for this point we start the insertions
                            (loop for ,pos from
                                  ;; in the initial pos we'll take into account
                                  ;; the target route
                                  (initial-for-value-in-all-macros
                                   ,initial-target-route
                                   ,route
                                   ,initial-pos)

                                  to ;; ;; let's set the final pos
                                  ;; ;; according to the constraints
                                  (final-value-for-loop-in-route-operation-macro
                                   ,final-target-route
                                   ,route
                                   ,final-pos
                                   ,default-final-position)

                                  ;; the following line allows the final user
                                  ;; to stop the iteration by setting that
                                  ;; variable to t
                                  while (not *vrp-stop-neighborhood-search*)

                                  ;; let's execute the body if
                                  ;; we are not in a forbidden coord
                                  do
                                  (unless-forbidden-coord
                                      (,ex
                                       ,route
                                       ,pos
                                       ,dt
                                       ,exclude-target-route
                                       ,exclude-pos
                                       ,ex-cond)

                                    ;; if we are here, it means that
                                    ;; we are not in the forbidden coord
                                    ;; so let's do our thing
                                    (let* ((,op (,',op-name ,,@op-params))
                                           ;; get the simpler operations
                                           (,simpler-ops
                                            (get-simpler-operations-from
                                             ,op ,working-copy)))


                                      ;; now the simulation
                                      (,',simpler-ops-macro
                                       ,simpler-ops ,working-copy)

                                      ;; let's do what the user wants
                                      (progn ,@body)

                                      ;; now the clean up
                                      (,',undo-simpler-ops-macro
                                         ,simpler-ops ,working-copy))))))))))))
     #+END_SRC
***** +old official code (backup)+
     #+BEGIN_SRC lisp +n -r :results none :exports code
     (defmacro make-do-neighborhood-route-insertion (macro-name
                                                     (&rest args)
                                                     &key
                                                       op-name
                                                       op-params
                                                       example-str)
         ;;{{{ documentation
         "Creates a do-neighborhood macro for a insertion. The created macro searches the neighborhood in an exhaustive way.

      There will always be a gensym named `pos' that will iterate through all the positions in the route. One of the parameter passed by the user should be named `route'.

      The arguments are:

         - macro-name :: the name of the macro.
         - args :: the args that the created macro will receive.
                   Apparently we'll always need parameters named `cname',
                   `route', and `working-copy'.
                    - `cname' should be a symbol that will be bound to
                      (1+ (selections-count working-copy).
                    - `route' should be a number with the id of a route
                       in the working-copy, where the selections should
                       take place.
         - op-name :: the constructor of the neighborhood operation to use.
         - op-params :: the params that should be passed to the constructor
                        of the operation.
         - example-str ::  this is a string to add to the description of the macro with an intended usage example."
      ;;;}}}



         (let* ((comment-str (format nil "Iterates through each position in the given route, creates an instance of ~a, pushes it int ops-lists, simulates it, do whatever the users wants to do, and finally restores everything to the previous state.
      Example:
         ~a" op-name example-str))
                (actual-args (append
                             args
                             `(&key 
                               ,@*vrp-do-macros-constraint-symbols*)))
                )
           `(defmacro ,macro-name (,actual-args &body body)
              ,comment-str

              (let* ((pos (symb cname ".ins.pos"))
                     (cname.ins.route (symb cname ".insert.route"))
                     (cname.ins.position (symb cname ".insert.position")))
                (with-gensyms (op
                               simpler-ops
                               initial-pos
                               final-pos
                               initial-target-route
                               final-target-route
                               exclude-target-route
                               exclude-pos
                               default-final-position)
                  `(symbol-macrolet ((,cname.ins.position
                                      (get-inserted-client-pos
                                          ,cname ,working-copy))
                                        (,cname.ins.route
                                         (get-inserted-client-route
                                          ,cname ,working-copy)))
                     ;; here compute the appropriate
                     ;; values for the variables
                     ;; related to the constraints
                     (with-variables-for-constraints-for-insertion
                         (,initial-pos ,ge ,gt
                          ,final-pos ,le ,lt
                          ,route ,working-copy
                          ,initial-target-route
                          ,final-target-route
                          ,exclude-target-route
                          ,exclude-pos
                          ,dt)

                       ;; let's set the value for
                       ;; default-final-pos
                       ;; to (1+ (route-length ,route ,working-copy)).
                       ;; The 1+ is because we can insert at the
                       ;; end of the route.
                       (let* ((,default-final-position
                               (1+ (route-length ,route ,working-copy))))

                         ;; for this point we start the insertions
                         (loop for ,pos from
                               ;; in the initial pos we'll take into account
                               ;; the target route
                               (initial-for-value-in-all-macros
                                ,initial-target-route
                                ,route
                                ,initial-pos)

                               to ;; ;; let's set the final pos
                               ;; ;; according to the constraints
                               (final-value-for-loop-in-route-operation-macro
                                ,final-target-route
                                ,route
                                ,final-pos
                                ,default-final-position)

                               ;; the following line allows the final user
                               ;; to stop the iteration by setting that
                               ;; variable to t
                               while (not *vrp-stop-neighborhood-search*)

                               ;; let's execute the body if
                               ;; we are not in a forbidden coord
                               do
                               (unless-forbidden-coord
                                   (,ex
                                    ,route
                                    ,pos
                                    ,dt
                                    ,exclude-target-route
                                    ,exclude-pos
                                    ,ex-cond)

                                 ;; if we are here, it means that
                                 ;; we are not in the forbidden coord
                                 ;; so let's do our thing
                                 (let* ((,op (,',op-name ,,@op-params))
                                        ;; get the simpler operations
                                        (,simpler-ops
                                         (get-simpler-operations-from
                                          ,op ,working-copy)))


                                   ;; now the simulation
                                   (simulate-simpler-ops-macro
                                    ,simpler-ops ,working-copy)

                                   ;; let's do what the user wants
                                   (progn ,@body)

                                   ;; now the clean up
                                   (undo-simpler-ops-macro
                                    ,simpler-ops ,working-copy))))))))))))
     #+END_SRC
***** tests with doinsert-client
****** simple tests
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-route-insertion
                         doinsert-client2
                         (cname route working-copy)
                         :op-name op-insert-client
                         :op-params (route pos cname)
                         :example-str "(doinsert-client (c1 r1 wc1)
                    (format t \"Inserting client ~a.~%\"
                     (client-selected-at-operation c1 wc1)))

               c1   is the index of the client that we want to insert
                    (actually it should be the selections-count corresponding
                    to its selection)
               r1  is the id of the route we want to make the insertion in
               wc1 is the working-copy where we are working.")

         (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
          (let* ((wc (basic-working-copy s1))
                 (op1 (op-select-client 2 1 0))
                 (c1 0)
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            ;; simulate the first selection
            (simulate-neighborhood-operation op1 wc)

            (bformat t "Testing doinsert-client")
            (doinsert-client2 (c1 1 wc :ge (list 1 -3))
              (format t "Inserting ~a at (~a ~a)~%"
                      (client-selected-at-operation c1 wc)
                      c1.insert.route c1.insert.position)
              (pp-solution wc t) (terpri)))))
       #+END_SRC
   
****** testing cname.insert.position
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-route-insertion
                         doinsert-client2
                         (cname route working-copy)
                         :op-name op-insert-client
                         :op-params (route pos cname)
                         :example-str "(doinsert-client (c1 r1 wc1)
                    (format t \"Inserting client ~a.~%\"
                     (client-selected-at-operation c1 wc1)))

               c1   is the index of the client that we want to insert
                    (actually it should be the selections-count corresponding
                    to its selection)
               r1  is the id of the route we want to make the insertion in
               wc1 is the working-copy where we are working.")

         (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
          (let* ((wc (basic-working-copy s1))
                 (op1 (op-select-client 2 1 0))
                 (c1 0)
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            ;; simulate the first selection
            (simulate-neighborhood-operation op1 wc)

            (bformat t "Testing doinsert-client")
            (doinsert-client2 (c1 1 wc)
              (format t "Inserting client: ~a at pos ~a~%"
                      (client-selected-at-operation c1 wc)
                      c1.insert.position)
              (pp-solution wc t) (terpri)))))
       #+END_SRC
   
****** simple tests with two insertions
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-route-insertion
                               doinsert-client2
                               (cname route working-copy)
                               :op-name op-insert-client
                               :op-params (route pos cname)
                               :example-str "(doinsert-client (c1 r1 wc1)
                          (format t \"Inserting client ~a.~%\"
                           (client-selected-at-operation c1 wc1)))

                     c1   is the index of the client that we want to insert
                          (actually it should be the selections-count corresponding
                          to its selection)
                     r1  is the id of the route we want to make the insertion in
                     wc1 is the working-copy where we are working.")

         (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
          (let* ((wc (basic-working-copy s1))
                 (c1 0) (c2 1)
                 (op1 (op-select-client 2 1 c1))
                 (op2 (op-select-client 2 3 c2))         
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc)

            ;; simulate the first selection
            (simulate-neighborhood-operation op1 wc)
            (simulate-neighborhood-operation op2 wc)

            (bformat t "Testing doinsert-client")
            (doinsert-client2 (c1 1 wc)
              (doinsert-client2 (c2 1 wc)
                (format t "Selected clients: ~a and ~a~%"
                        (client-selected-at-operation c1 wc)
                        (client-selected-at-operation c2 wc))
                (pp-solution wc t) (terpri))))))
       #+END_SRC
   
****** simple test with a doselect-route
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-route-insertion
                                     doinsert-client2
                                     (cname route working-copy)
                                     :op-name op-insert-client
                                     :op-params (route pos cname)
                                     :example-str "(doinsert-client (c1 r1 wc1)
                                (format t \"Inserting client ~a.~%\"
                                 (client-selected-at-operation c1 wc1)))

                           c1   is the index of the client that we want to insert
                                (actually it should be the selections-count corresponding
                                to its selection)
                           r1  is the id of the route we want to make the insertion in
                           wc1 is the working-copy where we are working.")

         (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
           (let* ((wc (basic-working-copy s1))
                  (c1 0)
                  (op1 (op-select-client 2 1 c1))

                  (ops-list nil))

             (prepare-solution-for-neighborhood-exploration wc)
             (simulate-neighborhood-operation op1 wc)

             (format t "Testing doselect-client")
             (doselect-route (r1 wc)
               (doinsert-client2 (c1 r1 wc)
                 (format t "Inserting in route with id ~a:~%" r1
                         (client-selected-at-operation c1 wc))
                 (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing ge
         #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
         (progn
           (make-do-neighborhood-route-insertion
                                       doinsert-client2
                                       (cname route working-copy)
                                       :op-name op-insert-client
                                       :op-params (route pos cname)
                                       :example-str "(doinsert-client (c1 r1 wc1)
                                  (format t \"Inserting client ~a.~%\"
                                   (client-selected-at-operation c1 wc1)))

                             c1   is the index of the client that we want to insert
                                  (actually it should be the selections-count corresponding
                                  to its selection)
                             r1  is the id of the route we want to make the insertion in
                             wc1 is the working-copy where we are working.")

           (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
             (let* ((wc (basic-working-copy s1))
                    (c1 0)
                    (op1 (op-select-client 2 1 c1))

                    (ops-list nil))

               (prepare-solution-for-neighborhood-exploration wc)
               (simulate-neighborhood-operation op1 wc)

               (bformat t "Testing doinsert-client with ge 3 [no list]")
               (doselect-route (r1 wc)
                 (doinsert-client2 (c1 r1 wc :ge 3)
                   (format t "Inserting ~a at pos (~a ~a):~%"
                           (client-selected-at-operation c1 wc)
                           c1.insert.route c1.insert.position)
                   (pp-solution wc t) (terpri))))))
         #+END_SRC
****** testing gt
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-route-insertion
                                     doinsert-client2
                                     (cname route working-copy)
                                     :op-name op-insert-client
                                     :op-params (route pos cname)
                                     :example-str "(doinsert-client (c1 r1 wc1)
                                (format t \"Inserting client ~a.~%\"
                                 (client-selected-at-operation c1 wc1)))

                           c1   is the index of the client that we want to insert
                                (actually it should be the selections-count corresponding
                                to its selection)
                           r1  is the id of the route we want to make the insertion in
                           wc1 is the working-copy where we are working.")

         (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
           (let* ((wc (basic-working-copy s1))
                  (c1 0)
                  (op1 (op-select-client 2 1 c1))

                  (ops-list nil))

             (prepare-solution-for-neighborhood-exploration wc)
             (simulate-neighborhood-operation op1 wc)

             (bformat t "Testing doinsert-client with gt 3 [no list]")
             (doselect-route (r1 wc)
               (doinsert-client2 (c1 r1 wc :gt 3)
                 (format t "Inserting ~a at pos (~a ~a):~%"
                         (client-selected-at-operation c1 wc)
                         c1.insert.route c1.insert.position)
                 (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing le
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-route-insertion
                                     doinsert-client2
                                     (cname route working-copy)
                                     :op-name op-insert-client
                                     :op-params (route pos cname)
                                     :example-str "(doinsert-client (c1 r1 wc1)
                                (format t \"Inserting client ~a.~%\"
                                 (client-selected-at-operation c1 wc1)))

                           c1   is the index of the client that we want to insert
                                (actually it should be the selections-count corresponding
                                to its selection)
                           r1  is the id of the route we want to make the insertion in
                           wc1 is the working-copy where we are working.")

         (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
           (let* ((wc (basic-working-copy s1))
                  (c1 0)
                  (op1 (op-select-client 2 1 c1))

                  (ops-list nil))

             (prepare-solution-for-neighborhood-exploration wc)
             (simulate-neighborhood-operation op1 wc)

             (bformat t "Testing doinsert-client with le 3 [no list]")
             (doselect-route (r1 wc)
               (doinsert-client2 (c1 r1 wc :le 3)
                 (format t "Inserting ~a at pos (~a ~a):~%"
                         (client-selected-at-operation c1 wc)
                         c1.insert.route c1.insert.position)
                 (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing lt
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-route-insertion
                                     doinsert-client2
                                     (cname route working-copy)
                                     :op-name op-insert-client
                                     :op-params (route pos cname)
                                     :example-str "(doinsert-client (c1 r1 wc1)
                                (format t \"Inserting client ~a.~%\"
                                 (client-selected-at-operation c1 wc1)))

                           c1   is the index of the client that we want to insert
                                (actually it should be the selections-count corresponding
                                to its selection)
                           r1  is the id of the route we want to make the insertion in
                           wc1 is the working-copy where we are working.")

         (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
           (let* ((wc (basic-working-copy s1))
                  (c1 0)
                  (op1 (op-select-client 2 1 c1))

                  (ops-list nil))

             (prepare-solution-for-neighborhood-exploration wc)
             (simulate-neighborhood-operation op1 wc)

             (bformat t "Testing doinsert-client with lt 3 [no list]")
             (doselect-route (r1 wc)
               (doinsert-client2 (c1 r1 wc :lt 3)
                 (format t "Inserting ~a at pos (~a ~a):~%"
                         (client-selected-at-operation c1 wc)
                         c1.insert.route c1.insert.position)
                 (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing ge with list
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-route-insertion
                                     doinsert-client2
                                     (cname route working-copy)
                                     :op-name op-insert-client
                                     :op-params (route pos cname)
                                     :example-str "(doinsert-client (c1 r1 wc1)
                                (format t \"Inserting client ~a.~%\"
                                 (client-selected-at-operation c1 wc1)))

                           c1   is the index of the client that we want to insert
                                (actually it should be the selections-count corresponding
                                to its selection)
                           r1  is the id of the route we want to make the insertion in
                           wc1 is the working-copy where we are working.")

         (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
           (let* ((wc (basic-working-copy s1))
                  (c1 0)
                  (op1 (op-select-client 2 1 c1))

                  (ops-list nil))

             (prepare-solution-for-neighborhood-exploration wc)
             (simulate-neighborhood-operation op1 wc)

             (bformat t "Testing doinsert-client with ge (2 3) [with list]")
             (doselect-route (r1 wc)
               (doinsert-client2 (c1 r1 wc :ge `(2 3))
                 (format t "Inserting ~a at pos (~a ~a):~%"
                         (client-selected-at-operation c1 wc)
                         c1.insert.route c1.insert.position)
                 (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing gt with list
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-route-insertion
                                     doinsert-client2
                                     (cname route working-copy)
                                     :op-name op-insert-client
                                     :op-params (route pos cname)
                                     :example-str "(doinsert-client (c1 r1 wc1)
                                (format t \"Inserting client ~a.~%\"
                                 (client-selected-at-operation c1 wc1)))

                           c1   is the index of the client that we want to insert
                                (actually it should be the selections-count corresponding
                                to its selection)
                           r1  is the id of the route we want to make the insertion in
                           wc1 is the working-copy where we are working.")

         (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
           (let* ((wc (basic-working-copy s1))
                  (c1 0)
                  (op1 (op-select-client 2 1 c1))

                  (ops-list nil))

             (prepare-solution-for-neighborhood-exploration wc)
             (simulate-neighborhood-operation op1 wc)

             (bformat t "Testing doinsert-client with gt (2 2) [with list]")
             (doselect-route (r1 wc)
               (doinsert-client2 (c1 r1 wc :gt `(2 2))
                 (format t "Inserting ~a at pos (~a ~a):~%"
                         (client-selected-at-operation c1 wc)
                         c1.insert.route c1.insert.position)
                 (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing le with list
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-route-insertion
                                     doinsert-client2
                                     (cname route working-copy)
                                     :op-name op-insert-client
                                     :op-params (route pos cname)
                                     :example-str "(doinsert-client (c1 r1 wc1)
                                (format t \"Inserting client ~a.~%\"
                                 (client-selected-at-operation c1 wc1)))

                           c1   is the index of the client that we want to insert
                                (actually it should be the selections-count corresponding
                                to its selection)
                           r1  is the id of the route we want to make the insertion in
                           wc1 is the working-copy where we are working.")

         (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
           (let* ((wc (basic-working-copy s1))
                  (c1 0)
                  (op1 (op-select-client 2 1 c1))

                  (ops-list nil))

             (prepare-solution-for-neighborhood-exploration wc)
             (simulate-neighborhood-operation op1 wc)

             (bformat t "Testing doinsert-client with le (1 3) [with list]")
             (doselect-route (r1 wc)
               (doinsert-client2 (c1 r1 wc :le `(1 3))
                 (format t "Inserting ~a at pos (~a ~a):~%"
                         (client-selected-at-operation c1 wc)
                         c1.insert.route c1.insert.position)
                 (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing lt with list
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-route-insertion
                                     doinsert-client2
                                     (cname route working-copy)
                                     :op-name op-insert-client
                                     :op-params (route pos cname)
                                     :example-str "(doinsert-client (c1 r1 wc1)
                                (format t \"Inserting client ~a.~%\"
                                 (client-selected-at-operation c1 wc1)))

                           c1   is the index of the client that we want to insert
                                (actually it should be the selections-count corresponding
                                to its selection)
                           r1  is the id of the route we want to make the insertion in
                           wc1 is the working-copy where we are working.")

         (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
           (let* ((wc (basic-working-copy s1))
                  (c1 0)
                  (op1 (op-select-client 2 1 c1))

                  (ops-list nil))

             (prepare-solution-for-neighborhood-exploration wc)
             (simulate-neighborhood-operation op1 wc)

             (bformat t "Testing doinsert-client with lt (1 3) [with list]")
             (doselect-route (r1 wc)
               (doinsert-client2 (c1 r1 wc :lt `(1 3))
                 (format t "Inserting ~a at pos (~a ~a):~%"
                         (client-selected-at-operation c1 wc)
                         c1.insert.route c1.insert.position)
                 (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing dt
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-route-insertion
                                     doinsert-client2
                                     (cname route working-copy)
                                     :op-name op-insert-client
                                     :op-params (route pos cname)
                                     :example-str "(doinsert-client (c1 r1 wc1)
                                (format t \"Inserting client ~a.~%\"
                                 (client-selected-at-operation c1 wc1)))

                           c1   is the index of the client that we want to insert
                                (actually it should be the selections-count corresponding
                                to its selection)
                           r1  is the id of the route we want to make the insertion in
                           wc1 is the working-copy where we are working.")

         (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
           (let* ((wc (basic-working-copy s1))
                  (c1 0)
                  (op1 (op-select-client 2 1 c1))

                  (ops-list nil))

             (prepare-solution-for-neighborhood-exploration wc)
             (simulate-neighborhood-operation op1 wc)

             (bformat t "Testing doinsert-client with dt 3 [no list]")
             (doselect-route (r1 wc)
               (doinsert-client2 (c1 r1 wc :dt 3)
                 (format t "Inserting ~a at pos (~a ~a):~%"
                         (client-selected-at-operation c1 wc)
                         c1.insert.route c1.insert.position)
                 (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing dt with list
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-route-insertion
                                     doinsert-client2
                                     (cname route working-copy)
                                     :op-name op-insert-client
                                     :op-params (route pos cname)
                                     :example-str "(doinsert-client (c1 r1 wc1)
                                (format t \"Inserting client ~a.~%\"
                                 (client-selected-at-operation c1 wc1)))

                           c1   is the index of the client that we want to insert
                                (actually it should be the selections-count corresponding
                                to its selection)
                           r1  is the id of the route we want to make the insertion in
                           wc1 is the working-copy where we are working.")

         (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
           (let* ((wc (basic-working-copy s1))
                  (c1 0)
                  (op1 (op-select-client 2 1 c1))

                  (ops-list nil))

             (prepare-solution-for-neighborhood-exploration wc)
             (simulate-neighborhood-operation op1 wc)

             (bformat t "Testing doinsert-client with lt (1 3) [with list]")
             (doselect-route (r1 wc)
               (doinsert-client2 (c1 r1 wc :dt `(1 3))
                 (format t "Inserting ~a at pos (~a ~a):~%"
                         (client-selected-at-operation c1 wc)
                         c1.insert.route c1.insert.position)
                 (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing ex
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-route-insertion
                                     doinsert-client2
                                     (cname route working-copy)
                                     :op-name op-insert-client
                                     :op-params (route pos cname)
                                     :example-str "(doinsert-client (c1 r1 wc1)
                                (format t \"Inserting client ~a.~%\"
                                 (client-selected-at-operation c1 wc1)))

                           c1   is the index of the client that we want to insert
                                (actually it should be the selections-count corresponding
                                to its selection)
                           r1  is the id of the route we want to make the insertion in
                           wc1 is the working-copy where we are working.")

         (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
           (let* ((wc (basic-working-copy s1))
                  (c1 0)
                  (op1 (op-select-client 2 1 c1))

                  (ops-list nil)
                  (ex-list `((1 1) (1 2) (1 4))))

             (prepare-solution-for-neighborhood-exploration wc)
             (simulate-neighborhood-operation op1 wc)

             (bformat t "Testing doinsert-client with ex  [no list]")
             (doselect-route (r1 wc)
               (doinsert-client2 (c1 r1 wc :ex ex-list)
                 (format t "Inserting ~a at pos (~a ~a):~%"
                         (client-selected-at-operation c1 wc)
                         c1.insert.route c1.insert.position)
                 (pp-solution wc t) (terpri))))))
       #+END_SRC
****** testing ex-cond
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-route-insertion
                                     doinsert-client2
                                     (cname route working-copy)
                                     :op-name op-insert-client
                                     :op-params (route pos cname)
                                     :example-str "(doinsert-client (c1 r1 wc1)
                                (format t \"Inserting client ~a.~%\"
                                 (client-selected-at-operation c1 wc1)))

                           c1   is the index of the client that we want to insert
                                (actually it should be the selections-count corresponding
                                to its selection)
                           r1  is the id of the route we want to make the insertion in
                           wc1 is the working-copy where we are working.")

         (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
           (let* ((wc (basic-working-copy s1))
                  (c1 0)
                  (op1 (op-select-client 2 1 c1))

                  (ops-list nil)
                  (ex-list `((1 1) (1 2) (1 4))))

             (prepare-solution-for-neighborhood-exploration wc)
             (simulate-neighborhood-operation op1 wc)

             (bformat t "Testing doinsert-client with ex-cond")
             (doselect-route (r1 wc)
               (doinsert-client2 (c1 r1 wc :ex ex-list
                                     :ex-cond (and (= r1 2)
                                                   (< c1.ins.pos 3)))
                 (format t "Inserting ~a at pos (~a ~a):~%"
                         (client-selected-at-operation c1 wc)
                         c1.insert.route c1.insert.position)
                 (pp-solution wc t) (terpri))))))
       #+END_SRC
*** code for static operations
**** description
     A static operation is an operation that, in an exhaustive search of the neighborhood, does not need to traverse a route.  Examples of these operations are the swap-something, and the reverse-subroute.  In this section we write a macro to create this kind of do-neighborhood operation macro such as doswap or doreverse-subroute.

     Actually, the only things that change in these macros from operation to operation, are the args, the comment, and how to instantiate the operation.

     I'm going to write a macro here that receives those 3 parameters and returns the corresponding macro.  It should be shomething like this:

     #+BEGIN_EXAMPLE 
     (make-do-neighborhood-static-macro
        (doswap-clients (client1 client2 working-copy)
        op-swap-clients (client1 client2)
        "description string here."
          ))
     #+END_EXAMPLE

     And that should expand into

     #+BEGIN_SRC lisp
     (defmacro doswap-clients ((client1 client2 working-copy) &body body)
      "description string here"
      (with-gensyms (op simple-op simpler-ops)
         ;; create the instance of the swap operation
        `(unless *stop-neighborhood-search*
           (let* ((,op (op-swap-clients ,client1 ,client2))
                  (,simpler-ops (get-simpler-operations-from
                                 ,op ,working-copy)))

              ;; do the automatic stuff
              ;; with the simpler-operations
              (progn
                (dolist (,simple-op ,simpler-ops)
                  ;; push the operations into the ops-list
                  (push ,simple-op ops-list)
                  ;; simulate the operations
                  (simulate-neighborhood-operation
                   ,simple-op ,working-copy)))

              ;; here I want to add some code to execute it
              ;; before the simulation of the operation
              ;; but now I'm not sure how to do it right :-/
              ;; I'm thinking about something like
              ;;  (:before-simulation
              ;;     user-code here)

              ;; let's do what the user wants
              (progn ,@body)

              ;; now the clean up
              (progn
                ;; traverse the list popping from the ops-list
                ;; and undoing the operation
                (loop for ,simple-op in (reverse ,simpler-ops)
                      do (pop ops-list)
                      do (undo-neighborhood-operation
                          ,simple-op ,working-copy)))))))
     #+END_SRC

**** code
***** version 2 (with the simulate-simpler-ops args)
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmacro make-do-neighborhood-static-macro
         (name 
          args
          constructor-name
          constructor-args
          doc-string
          &key
            (simpler-ops-macro
             'simulate-simpler-ops-macro)
            (undo-simpler-ops-macro
             'undo-simpler-ops-macro))
       "A static operation is an operation that, in an exhaustive search of the neighborhood, does not need to traverse a route.  Examples of these operations are the swap-something, and the reverse-subroute.  In this section we write a macro to create this kind of do-neighborhood operation macro such as doswap or doreverse-subroute.

              Actually, the only things that change in these macros from operation to operation, are the args, the comment, and how to instantiate the operation.

              I'm going to write a macro here that receives those 3 parameters and returns the corresponding macro.  It should be shomething like this:
              (make-do-neighborhood-static-macro
                 (doswap-clients (client1 client2 working-copy)
                 op-swap-clients (client1 client2)
                  \"This is the comment for the doswap-clients macro\"))"

       `(defmacro ,name (,args &body body)
          ,doc-string

          (with-gensyms (op simpler-ops)
            ;; create the instance of the swap operation
            `(unless *vrp-stop-neighborhood-search*
                     (let* ((,op (,',constructor-name ,,@constructor-args))
                            (,simpler-ops (get-simpler-operations-from
                                           ,op ,working-copy)))

                       ;; do the automatic stuff
                       ;; with the simpler-operations
                       ;; now the simulation
                       (,',simpler-ops-macro
                        ,simpler-ops ,working-copy)

                       ;; let's do what the user wants
                       (progn ,@body)

                       ;; now the clean up
                       (,',undo-simpler-ops-macro
                        ,simpler-ops
                        ,working-copy))))))

     #+END_SRC
***** +version 1+
     #+BEGIN_SRC lisp +n -r :results none :exports code
     (defmacro make-do-neighborhood-static-macro
         (name args constructor-name constructor-args doc-string)
       "A static operation is an operation that, in an exhaustive search of the neighborhood, does not need to traverse a route.  Examples of these operations are the swap-something, and the reverse-subroute.  In this section we write a macro to create this kind of do-neighborhood operation macro such as doswap or doreverse-subroute.

              Actually, the only things that change in these macros from operation to operation, are the args, the comment, and how to instantiate the operation.

              I'm going to write a macro here that receives those 3 parameters and returns the corresponding macro.  It should be shomething like this:
              (make-do-neighborhood-static-macro
                 (doswap-clients (client1 client2 working-copy)
                 op-swap-clients (client1 client2)
                  \"This is the comment for the doswap-clients macro\"))"

       `(defmacro ,name (,args &body body)
          ,doc-string

          (with-gensyms (op simpler-ops)
            ;; create the instance of the swap operation
            `(unless *vrp-stop-neighborhood-search*
                     (let* ((,op (,',constructor-name ,,@constructor-args))
                            (,simpler-ops (get-simpler-operations-from
                                           ,op ,working-copy)))

                       ;; do the automatic stuff
                       ;; with the simpler-operations
                       (progn
                         (simulate-simpler-ops-macro
                          ,simpler-ops ,working-copy))

                       ;; here I want to add some code to execute it
                       ;; before the simulation of the operation
                       ;; but now I'm not sure how to do it right :-/
                       ;; I'm thinking about something like
                       ;;  (:before-simulation
                       ;;     user-code here)

                       ;; let's do what the user wants
                       (progn ,@body)

                       ;; now the clean up
                       (progn
                         ;; traverse the list popping from the ops-list
                         ;; and undoing the operation
                         (undo-simpler-ops-macro
                          ,simpler-ops ,working-copy)))))))

     #+END_SRC
     
**** tests
***** testing macroexpansion
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (pp-expand (make-do-neighborhood-static-macro%
                  doswap-clients 
                  (client1 client2 working-copy)
                    op-swap-clients (client1 client2)
                    "description string here."))
      #+END_SRC
***** testing macroexpansion with simpler-ops*
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (pp-expand (make-do-neighborhood-static-macro%
                  doswap-clients% 
                  (client1 client2 working-copy)
                    op-swap-clients (client1 client2)
                    "description string here."
                    :simpler-ops-macro simulate-simpler-ops-macro*
                    :undo-simpler-ops-macro undo-simpler-ops-macro*))
      #+END_SRC
***** testing code
****** simple tests (no iterations)
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-static-macro%
          doswap%%% 
          (client1 client2 working-copy)
          op-swap-clients (client1 client2)
          "A swap to tests the make-do-neighborhood-static-macro.")

         (with-basic-solution (s1 ((1 2 3 4 5 6 7)))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil)
                 (c1 0) (c2 1)
                 (op1 (op-select-client 1 2 c1))
                 (op2 (op-select-client 1 3 c2))
                 )

            (prepare-solution-for-neighborhood-exploration wc1)


            (format t "The original solution:~%")
            (pp-solution wc1 t) (terpri)

            (dolist (op (list op1 op2))
              (simulate-neighborhood-operation op wc1))

            (format t "After the selections:~%")
            (pp-solution wc1 t) (terpri)

            (doswap%%% (c1 c2 wc1)
              (format t "Swapped!~%")
              (format t "After the swap the solution is:~%")
              (pp-solution wc1 t) (terpri))))

         (fmakunbound 'doswap%%%))
       #+END_SRC
     
****** tests (iterating through a route)
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn

         (make-do-neighborhood-static-macro%
                 doswap%%% 
                 (client1 client2 working-copy)
                 op-swap-clients (client1 client2)
                 "A swap to tests the make-do-neighborhood-static-macro.")

         (with-basic-solution (s1 ((1 2 3 4 ;; 5 6 7
                                      )))
          (let* ((wc1 (basic-working-copy s1))
                 (ops-list nil))

            (prepare-solution-for-neighborhood-exploration wc1)


            (format t "The original solution:~%")
            (pp-solution wc1 t) (terpri)



            (doselect-client (c1 1 wc1)
              (doselect-client (c2 1 wc1)
                (doswap%%% (c1 c2 wc1)
                  (format t "Swapping ~a and ~a:~%"
                          (id (client-selected-at-operation c1 wc1))
                          (id (client-selected-at-operation c2 wc1)))
                  (pp-solution wc1 t) (terpri))))))

         (fmakunbound 'doswap%%%))
       #+END_SRC
      
****** testing the actions*
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-static-macro%
          doswap*
          (client1 client2 working-copy)
          op-swap-clients (client1 client2)
          "A swap to tests the make-do-neighborhood-static-macro."
          :simpler-ops-macro simulate-simpler-ops-macro*
          :undo-simpler-ops-macro undo-simpler-ops-macro*
          )

         (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                              (5 0 6 7 2 4 2 3 4)  ;1
                                              (1 8 0 3 9 1 2 4 5)  ;2
                                              (4 5 1 0 5 7 1 9 5)  ;3
                                              (4 5 1 5 0 6 2 8 2)  ;4
                                              (1 5 7 6 9 0 1 6 7)  ;5
                                              (4 5 1 3 5 7 0 9 5)  ;6
                                              (4 6 2 8 2 3 8 0 1)  ;7
                                              (4 5 3 4 1 6 2 8 0)  ;8
                                              )
                                              ;0 1 2 3 4 5 6 7 8
                                :demands '(20 10 15 40 30 20 10 30)
                                :capacity 30)
           (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6 7 8)) problem)
             (let* ((wc (basic-working-copy s1))
                    (c1 0) (c2 1)
                    (op1 (op-select-client 1 1 c1))
                    (op2 (op-select-client 2 1 c2))
                    (ops-list nil)
                    (action (delta-cvrp-action*)))

               (prepare-solution-for-neighborhood-exploration wc)
               (initialize-action-for-delta-cost-computation wc problem action)


               ;; let's simulate compute the cost of these operations
               (dolist (op (list op1 op2))
                 (compute-delta-cost-after op wc problem action)
                 (simulate-neighborhood-operation op wc))

        
               (format t "Delta distance after ops: ~a~%"
                       (delta-distance action))
               (format t "Route feasibility after ops: ~a~%"
                       (delta-routes-feasibility action))

               (format t "Selected clients: ~a, ~a~%"
                       (client-selected-at-operation c1 wc)
                       (client-selected-at-operation c2 wc))

               (bformat t "Testing dosawp-clients*")
               (doswap* (c1 c2 wc)
                  (pp-solution wc t) (terpri)
                  (format t "Delta distance after op: ~a~%"
                          (delta-distance action))
                  (format t "Route feasibility after op: ~a~%"
                          (delta-routes-feasibility action))
                  (format t "delta-distance-stack: ~a~%"
                          (delta-distance-stack action)))
        
               (format t "Outside the doswap*~%")
        
               (format t "Delta distance after op: ~a~%"
                       (delta-distance action))
               (format t "Route feasibility after op: ~a~%"
                       (delta-routes-feasibility action))
               (format t "delta-distance-stack: ~a~%"
                       (delta-distance-stack action)))))

         (fmakunbound 'doswap%))
       #+END_SRC
     
****** testing with doselect-client*
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
       (progn
         (make-do-neighborhood-static-macro%
          doswap*
          (client1 client2 working-copy)
          op-swap-clients (client1 client2)
          "A swap to tests the make-do-neighborhood-static-macro."
          :simpler-ops-macro simulate-simpler-ops-macro*
          :undo-simpler-ops-macro undo-simpler-ops-macro*
          )

         (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                              (5 0 6 7 2 4 2 3 4)  ;1
                                              (1 8 0 3 9 1 2 4 5)  ;2
                                              (4 5 1 0 5 7 1 9 5)  ;3
                                              (4 5 1 5 0 6 2 8 2)  ;4
                                              (1 5 7 6 9 0 1 6 7)  ;5
                                              (4 5 1 3 5 7 0 9 5)  ;6
                                              (4 6 2 8 2 3 8 0 1)  ;7
                                              (4 5 3 4 1 6 2 8 0)  ;8
                                              )
                                              ;0 1 2 3 4 5 6 7 8
                                :demands '(20 10 15 40 30 20 10 30)
                                :capacity 30)
           (with-basic-cvrp-solution (s1 ((1 2 3) (4 5)) problem)
             (let* ((wc (basic-working-copy s1))
                    ;; (c1 0) (c2 1)
                    ;; (op1 (op-select-client 1 1 c1))
                    ;; (op2 (op-select-client 2 1 c2))
                    (ops-list nil)
                    (action (delta-cvrp-action*)))

               (prepare-solution-for-neighborhood-exploration wc)
               (initialize-action-for-delta-cost-computation wc problem action)


               (bformat t "Testing dosawp-clients*")
               (doselect-client* (c1 1 wc)
                 (doselect-client* (c2 2 wc)
                  (doswap* (c1 c2 wc)
                    (pp-solution wc t) (terpri)
                    (format t "Delta distance after op: ~a~%"
                            (delta-distance action))
                    (format t "Route feasibility after op: ~a~%"
                            (delta-routes-feasibility action))
                    (format t "delta-distance-stack: ~a~%"
                            (delta-distance-stack action)))))

               (format t "Outside the doswap*~%")

               (format t "Delta distance after op: ~a~%"
                       (delta-distance action))
               (format t "Route feasibility after op: ~a~%"
                       (delta-routes-feasibility action))
               (format t "delta-distance-stack: ~a~%"
                       (delta-distance-stack action)))))

         (fmakunbound 'doswap*))
       #+END_SRC
     
** doselect-route
*** description
    The idea with this macro is to bind the variable r and to iterate through all the possible routes in the working copy.
*** code v2 (with constraints)
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
     (defmacro doselect-route ((route-name
                                working-copy
                                &key gt ge lt le dt ex ex-cond)
                               &body body)
       "Iterates through each route in the working-copy passed as argument.  The symbol route-name is bound to the id of the current route.

          Example:
              (doselect-route (r1 wc1)
                 (format t \"Route ~a is ~a\" r1 (get-route-with-id r1 wc1)))

         The optional paramaters `gt', `ge', `lt', `le', `dt' control which are the routes than should be iterated through.

            In the following example:
              (doselect-route (r1 wc1 :ge 2)
                 (doselect-route (r2 wc1 :gt r1)
                     (format t \"Route ~a is ~a\" r1 (get-route-with-id r1 wc1)))

            r1 will iterate through all the routes greater or equal to 2, and r2 will iterate through all the routes greater than r1."

       (declare (ignorable ex))
       (let* ((initial-route
               ;; let's find out what is the starting route
                  (cond (ge ge)
                        (gt `(1+ ,gt))
                        (t 1)))
              (final-route
               ;; let's find out which should be the last route
                  (cond (le le)
                        (lt `(1- ,lt))
                        (t `(number-of-routes ,working-copy))))
              (exclude
               ;; let's find out which should be the last route
                  (if dt `(unless (= ,dt ,route-name) do)
                      ;; else
                      `(do))))
         `(loop for ,route-name from ,initial-route
                to ,final-route
                while (not *vrp-stop-neighborhood-search*)
                ,@exclude (unless ,ex-cond ,@body))))
     #+END_SRC
**** tests
***** no constraints
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4) (5 6) (7 8)))
        (let* ((wc (basic-working-copy s1)))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route")
          (doselect-route (r1 wc)
            (format t "current route: ~a: " r1)
            (pp-route r1 wc t) (terpri))))
      #+END_SRC


      OK.  It works.  Let's write the others macros.
    
***** testing ge
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4) (5 6) (7 8)))
        (let* ((wc (basic-working-copy s1)))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with ge")
          (doselect-route (r1 wc :ge 2)
            (format t "r1: ~a~%" r1)
            (doselect-route (r2 wc :ge (1+ r1))
              (format t "   r2: ~a~%" r2)))))
      #+END_SRC
***** testing gt
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4) (5 6) (7 8)))
        (let* ((wc (basic-working-copy s1)))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with gt")
          (doselect-route (r1 wc :gt 2)
            (format t "r1: ~a~%" r1)
            (doselect-route (r2 wc :gt r1)
              (format t "   r2: ~a~%" r2)))))
      #+END_SRC

***** testing le
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4) (5 6) (7 8)))
        (let* ((wc (basic-working-copy s1)))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with le")
          (doselect-route (r1 wc :le 3)
            (format t "r1: ~a~%" r1)
            (doselect-route (r2 wc :gt r1)
              (format t "   r2: ~a~%" r2)))))
      #+END_SRC

***** testing lt
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4) (5 6) (7 8)))
        (let* ((wc (basic-working-copy s1)))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with lt")
          (doselect-route (r1 wc :lt 3)
            (format t "r1: ~a~%" r1)
            (doselect-route (r2 wc :gt r1)
              (format t "   r2: ~a~%" r2)))))
      #+END_SRC

***** testing dt
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2) (3) (4) (5 6) (7 8)))
        (let* ((wc (basic-working-copy s1)))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with lt")
          (doselect-route (r1 wc :ge 2 :le 4)
            (format t "r1: ~a~%" r1)
            (doselect-route (r2 wc :ge r1 :dt 3)
              (format t "   r2: ~a~%" r2)))))
      #+END_SRC
***** testing ex-cond
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2) (3) (4) (5 6) (7 8)))
        (let* ((wc (basic-working-copy s1)))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with lt")
          (doselect-route (r1 wc
                              :ex-cond (> 2 r1))
            (format t "r~a: ~a~%" r1 (get-route-with-id r1 wc)))))
      #+END_SRC

***** basic test with stop-neighborhood-search
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4) (5 6) (7 8)))
        (let* ((wc (basic-working-copy s1))
               (*vrp-stop-neighborhood-search* nil))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with stop-neighborhood-search")

          (doselect-route (r1 wc :ge 2)
             (pp-route r1 wc t) (terpri)
             (if (= r1 3) (stop-neighborhood-search)))))
      #+END_SRC
*** +code v1 (without constraints)+
    #+BEGIN_SRC lisp +n -r :results none :exports code
    (defmacro doselect-route ((route-name working-copy) &body body)
       "Iterates through each route in the working-copy passed as argument.  The symbol route-name is bound to the id of the current route.
     Example:
         (doselect-route (r1 wc1)
            (format t \"Route ~a is ~a\" r1 (get-route-with-id r1 wc1)))"
       `(loop for ,route-name from 1 to (number-of-routes ,working-copy)
              while (not *vrp-stop-neighborhood-search*)
              do (progn ,@body)))
    #+END_SRC
**** tests
***** basic test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4) (5 6 7 8)))
        (let* ((wc (basic-working-copy s1)))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route")
          (doselect-route (r1 wc)
            (format t "current route: ~a: " r1)
            (pp-route r1 wc t) (terpri))))
      #+END_SRC


      OK.  It works.  Let's write the others macros.
    
***** basic test with stop-neighborhood-search
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4) (5 6 7 8)))
        (let* ((wc (basic-working-copy s1))
               (*vrp-stop-neighborhood-search* nil))

          (prepare-solution-for-neighborhood-exploration wc)

          (doselect-route (r1 wc)
             (pp-route r1 wc t) (terpri)
             (if (= r1 2) (stop-neighborhood-search)))))
      #+END_SRC
** doselect-route*
*** description
    In the * version of this macro there is nothing that we should do, so we'll bind the * version to the original version.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (setf (macro-function 'doselect-route*) 
          (macro-function 'doselect-route))
    #+END_SRC
*** tests
**** no constraints
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3) (4) (5 6) (7 8)))
       (let* ((wc (basic-working-copy s1)))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing doselect-route")
         (doselect-route* (r1 wc)
           (format t "current route: ~a: " r1)
           (pp-route r1 wc t) (terpri))))
     #+END_SRC


     OK.  It works.  Let's write the others macros.
    
** doselect-client
*** description
    Here we'll receive a symbol an a number (a route id) and we'll iterate through all the positions in the route creating an operation to simulate that selection.

    Inside the body of the macro:

    #+BEGIN_EXAMPLE
    (doselect-client (c1 r1 wc)
       ...  body)
    #+END_EXAMPLE

    we can refer to the symbols =c1.client=, =c1.select.position= and =c1.route= and they will return the client selected, the position from which it was selected and route, respectively.

*** +code without the macro+
    #+BEGIN_SRC lisp +n -r :results none :exports code
    (defmacro doselect-client ((cname route working-copy
                                      &key ge gt le lt dt) &body body)
       "Iterates through each position in the given route, creates an instance of op-select-client, pushes it int ops-lists, increment the op-counter, do whatever the users wants to do, and restores everything to the previous state.
     Example:
         (doselect-client (c1 r1 wc1)
            (format t \"Selecting client ~a from route ~a~%\"
             (client-selected-at-operation c1)
             (get-route-with-id r1 wc1)))"
   
       (with-gensyms (op simpler-ops
                         exclude
                      )
     
         (let* ((pos (symb cname ".select.position"))
                (route-coord (symb cname ".route")))
           `(let* ((,route-coord ,route)
                   ;; ;; ;; let's exclude
                   (,exclude
                    ;; let's remove the unwanted position
                    (if ,dt
                        `(unless (= ,',dt ,',pos) do)
                        `(do)
                        ))
                   )
              (declare (ignorable ,route-coord))
              (loop for ,pos from 1 to (route-length ,route ,working-copy)
                    ;; the following line allows the final user
                    ;; to stop the iteration by setting that
                    ;; variable to t
                    while (not *vrp-stop-neighborhood-search*)


                    do  (let* ((,op
                                         (op-select-client
                                          ,route ,pos
                                          (1+ (selections-count ,working-copy))))
                                        (,cname (1+ (selections-count ,working-copy)))
                                        (,simpler-ops
                                         (get-simpler-operations-from
                                          ,op ,working-copy))
                                        )

                                   ;; now the simulation
                                   (simulate-simpler-ops-macro
                                    ,simpler-ops ,working-copy)

                                   ;; let's do what the user wants
                                   (progn ,@body)

                                   ;; now the clean up
                                   (undo-simpler-ops-macro
                                    ,simpler-ops ,working-copy)

                                   ))
                    ;; now the simulation

                
                    )))))
    #+END_SRC
**** tests
***** simple tests
      #+BEGIN_SRC lisp +n -r :results output :exports both 
      (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
        (let* ((wc (basic-working-copy s1))
               (ops-list nil))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-client")
          (doselect-client (c1 1 wc)
            (format t "Selected client: ~a~%"
                    (client-selected-at-operation c1 wc))
            (pp-solution wc t) (terpri))))
      #+END_SRC
   
***** simple test with a doselect-route
      #+BEGIN_SRC lisp +n -r :results output :exports both 
      (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
        (let* ((wc (basic-working-copy s1))
               (ops-list nil))

          (prepare-solution-for-neighborhood-exploration wc)

          (format t "~2%=======================
      Testing doselect-client
      =======================~2%")
          (doselect-route (r1 wc)
            (doselect-client (c1 r1 wc)
              (format t "Selected client: ~a~%"
                      (client-selected-at-operation c1 wc))
              (pp-solution wc t) (terpri)))))
      #+END_SRC
***** simple test with two doselect-route
      #+BEGIN_SRC lisp +n -r :results output :exports both 
      (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
        (let* ((wc (basic-working-copy s1))
               (ops-list nil))

          (prepare-solution-for-neighborhood-exploration wc)

          (format t "~2%=======================
      Testing doselect-client
      =======================~2%")
          (doselect-client (c1 1 wc)
            (doselect-client (c2 1 wc)
              (format t "Selected clients: ~a and ~a~%"
                      (client-selected-at-operation c1 wc)
                      (client-selected-at-operation c2 wc))
              (pp-solution wc t) (terpri)))))
      #+END_SRC

*** code with the macro
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (make-do-neighborhood-route-selection
                  doselect-client
                  (cname route working-copy)
                  :op-name op-select-client
                  :op-params (route pos cname)
                  :example-str "(doselect-client (c1 r1 wc1)
                  (format t \"Selecting client ~a from route ~a~%\"
                   (client-selected-at-operation c1)
                   (get-route-with-id r1 wc1)))")
    #+END_SRC
*** tests
**** simple tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
       (let* ((wc (basic-working-copy s1))
              (ops-list nil))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing doselect-route")
         (doselect-client (c1 1 wc)
           (format t "Selected client: ~a~%"
                   (client-selected-at-operation c1 wc))
           (pp-solution wc t) (terpri))))
     #+END_SRC
   
**** simple test with a doselect-client
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
       (let* ((wc (basic-working-copy s1))
              (ops-list nil))

         (prepare-solution-for-neighborhood-exploration wc)

         (bformat t "Testing doselect-client")
         (doselect-route (r1 wc)
           (doselect-client (c1 r1 wc)
             (format t "Selected client: ~a~%"
                     (client-selected-at-operation c1 wc))
             (pp-solution wc t) (terpri)))))
     #+END_SRC
**** simple test with two doselect-client
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
       (let* ((wc (basic-working-copy s1))
              (ops-list nil))

         (prepare-solution-for-neighborhood-exploration wc)

         (format t "Testing doselect-client")
         (doselect-client (c1 1 wc)
           (doselect-client (c2 1 wc)
             (format t "Selected clients: ~a and ~a~%"
                     (client-selected-at-operation c1 wc)
                     (client-selected-at-operation c2 wc))
             (pp-solution wc t) (terpri)))))
     #+END_SRC

**** testing ge
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (progn
       (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8)))
         (let* ((wc (basic-working-copy s1))
                (ops-list nil))

           (prepare-solution-for-neighborhood-exploration wc)

           (bformat t "Testing doselect-client with ge")
           (doselect-client (c1 1 wc :ge 3)
             (format t "Selected client: ~a from (~a ~a).~%"
                     (client-selected-at-operation c1 wc)
                     c1.route
                     c1.select.position)
             (pp-solution wc t) (terpri)))))
     #+END_SRC

**** testing gt
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (progn
      (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8)))
        (let* ((wc (basic-working-copy s1))
               (ops-list nil))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with gt")
          (doselect-client (c1 1 wc :gt 4)
            (format t "Selected client: ~a at pos ~a.~%"
                    (client-selected-at-operation c1 wc)
                    c1.select.position)
            (pp-solution wc t) (terpri)))))
     #+END_SRC

**** testing le
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (progn
       (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8)))
         (let* ((wc (basic-working-copy s1))
                (ops-list nil))

           (prepare-solution-for-neighborhood-exploration wc)

           (bformat t "Testing doselect-route with le")
           (doselect-client (c1 1 wc :le 4)
             (format t "Selected client: ~a at pos ~a.~%"
                     (client-selected-at-operation c1 wc)
                     c1.select.position)
             (pp-solution wc t) (terpri)))))
     #+END_SRC
**** testing lt
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (progn
      (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8)))
        (let* ((wc (basic-working-copy s1))
               (ops-list nil))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with lt")
          (doselect-client (c1 1 wc :lt 4)
            (format t "Selected client: ~a at pos ~a.~%"
                    (client-selected-at-operation c1 wc)
                    c1.select.position)
            (pp-solution wc t) (terpri)))))
     #+END_SRC

**** testing dt
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (progn
      (with-basic-solution (s1 ((1 2 3 4 5 6) (7 8)))
        (let* ((wc (basic-working-copy s1))
               (ops-list nil))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with dt")
          (doselect-client (c1 1 wc :dt 4)
            (format t "Selected client: ~a at pos ~a.~%"
                    (client-selected-at-operation c1 wc)
                    c1.select.position)
            (pp-solution wc t) (terpri)))))
     #+END_SRC
**** testing ge with list
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (progn

      (with-basic-solution (s1 ((1 2) (3 4 5 6) (7 8)))
        (let* ((wc (basic-working-copy s1))
               (ops-list nil))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with ge with list (2 2)")
          (doselect-route (r1 wc)
            (doselect-client (c1 r1 wc :ge `(2 2) :le 3)
              (format t "Selected client: ~a at pos ~a from route ~a.~%"
                      (client-selected-at-operation c1 wc)
                      c1.select.position
                      c1.route)
              (pp-solution wc t) (terpri))))))
     #+END_SRC
**** testing gt with with le with list
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (progn
      (with-basic-solution (s1 ((1 2) (3 4 5 6) (7 8 9 10)))
        (let* ((wc (basic-working-copy s1))
               (ops-list nil))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with gt with list")
          (doselect-route (r1 wc)
            (doselect-client (c1 r1 wc :gt (2 2) :le 3)
              (format t "Selected client: ~a at pos ~a from route ~a.~%"
                      (client-selected-at-operation c1 wc)
                      c1.select.position
                      c1.route)
              (pp-solution wc t) (terpri))))))
     #+END_SRC
**** testing le with list
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (progn
      (with-basic-solution (s1 ((1 2 3) (4 5 6) (7 8)))
        (let* ((wc (basic-working-copy s1))
               (ops-list nil))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with le with list (2 2)")
          (doselect-route (r1 wc)
            (doselect-client (c1 r1 wc :le (2 2))
              (format t "Selected client: ~a at pos ~a from route ~a.~%"
                      (client-selected-at-operation c1 wc)
                      c1.select.position
                      c1.route)
              (pp-solution wc t) (terpri))))))
     #+END_SRC
**** testing lt with list
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (progn

      (with-basic-solution (s1 ((1 2 3) (4 5 6) (7 8)))
        (let* ((wc (basic-working-copy s1))
               (ops-list nil))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with lt with list (2 2)")
          (doselect-route (r1 wc)
            (doselect-client (c1 r1 wc :lt (2 2))
              (format t "Selected client: ~a from (~a ~a)~%"
                      (client-selected-at-operation c1 wc)
                      c1.route
                      c1.select.position)
              (pp-solution wc t) (terpri))))))
     #+END_SRC
**** testing lt and ge with lists
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (progn

      (with-basic-solution (s1 ((1 2 3) (4 5 6 7 8) (9 10 11)))
        (let* ((wc (basic-working-copy s1))
               (ops-list nil))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with ge (2 2) and lt (2 4)")
          (doselect-route (r1 wc)
            (doselect-client (c1 r1 wc :ge (2 2) :lt (2 4))
              (format t "Selected client: ~a from (~a ~a)~%"
                      (client-selected-at-operation c1 wc)
                      c1.route
                      c1.select.position)
              (pp-solution wc t) (terpri))))))
     #+END_SRC
**** testing dt with list
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (progn

      (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8 9)))
        (let* ((wc (basic-working-copy s1))
               (ops-list nil))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with dt with list (2 3)")
          (doselect-route (r1 wc)
            (doselect-client (c1 r1 wc :dt (2 3))
              (format t "Selected client: ~a from (~a ~a).~%"
                      (client-selected-at-operation c1 wc)
                      c1.route c1.select.position)
              (pp-solution wc t) (terpri))))))
     #+END_SRC

**** testing lt and ge and dt with lists
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (progn
      (with-basic-solution (s1 ((1 2 3) (4 5 6 7 8) (9 10 11)))
        (let* ((wc (basic-working-copy s1))
               (ops-list nil))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with lt, ge, dt with lists")
          (doselect-route (r1 wc)
            (doselect-client (c1 r1 wc
                                 :ge (list 2 2)
                                 :le (list 2 4)
                                 :dt (list 2 3))
              (format t "Selected client: ~a from (~a ~a)~%"
                      (client-selected-at-operation c1 wc)
                      c1.route
                      c1.select.position)
              (pp-solution wc t) (terpri))))))
     #+END_SRC
**** testing ex-cond
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (progn
      (with-basic-solution (s1 ((1 2 3) (4 5 6 7 8) (9 10 11)))
        (let* ((wc (basic-working-copy s1))
               (ops-list nil))

          (prepare-solution-for-neighborhood-exploration wc)

          (bformat t "Testing doselect-route with lt, ge, dt with lists")
          (doselect-route (r1 wc)
            (doselect-client (c1 r1 wc
                                 :ex-cond (or (< r1 2)
                                              (and
                                               (= r1 3)
                                               (< c1.position 2))))
              (format t "Selected client: ~a from (~a ~a)~%"
                      (client-selected-at-operation c1 wc)
                      c1.route
                      c1.select.position)
              (pp-solution wc t) (terpri))))))
     #+END_SRC
** doselect-client*
*** description
    Here we'll receive a symbol an a number (a route id) and we'll iterate through all the positions in the route creating an operation to simulate that selection.  This is smart version: everytime it simulates an operation, it also computes the delta-cost due to that operation.  We can do that using the macros simulate-simpler-ops-macro* and undo-simpler-ops-macro*.

    Inside the body of the macro:

    #+BEGIN_EXAMPLE
    (doselect-client (c1 r1 wc)
       ...  body)
    #+END_EXAMPLE

    we can refer to the symbols =c1.client=, =c1.select.position= and =c1.route= and they will return the client selected, the position from which it was selected and route, respectively.

*** code with the macro
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (make-do-neighborhood-route-selection
       doselect-client*
       (cname route working-copy)
       :op-name op-select-client
       :op-params (route pos cname)
       :example-str "(doselect-client (c1 r1 wc1)
       (format t \"Selecting client ~a from route ~a~%\"
       (client-selected-at-operation c1)
       (get-route-with-id r1 wc1)))"
       :simpler-ops-macro simulate-simpler-ops-macro*
       :undo-simpler-ops-macro undo-simpler-ops-macro*)
    #+END_SRC
*** tests
**** simple tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                              (5 0 6 7 2 4 2 3 4)  ;1
                                              (1 8 0 3 9 1 2 4 5)  ;2
                                              (4 5 1 0 5 7 1 9 5)  ;3
                                              (4 5 1 5 0 6 2 8 2)  ;4
                                              (1 5 7 6 9 0 1 6 7)  ;5
                                              (4 5 1 3 5 7 0 9 5)  ;6
                                              (4 6 2 8 2 3 8 0 1)  ;7
                                              (4 5 3 4 1 6 2 8 0)  ;8
                                              )
                                              ;0 1 2 3 4 5 6 7 8
                                :demands '(20 10 15 40 30 20 10 30)
                                :capacity 30)
       (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6 7 8)) problem)
         (let* ((wc (basic-working-copy s1))
                (ops-list nil)
                (action (delta-cvrp-action*)))

           (prepare-solution-for-neighborhood-exploration wc)
           (initialize-action-for-delta-cost-computation wc problem action)

           (bformat t "Testing doselect-route")
           (doselect-client* (c1 1 wc)
               (format t "Selected client: ~a~%"
                       (client-selected-at-operation c1 wc))
               (pp-solution wc t) (terpri)
               (format t "Delta distance after op: ~a~%"
                       (delta-distance action))
               (format t "Route feasibility after op: ~a~%"
                       (delta-routes-feasibility action))
               (format t "distance-stack: ~a, feasibility: ~a~%"
                       (delta-distance-stack action)
                       (delta-routes-feasibility-stack action))))))
     #+END_SRC
**** simple test with two doselect-client and a ge
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                              (5 0 6 7 2 4 2 3 4)  ;1
                                              (1 8 0 3 9 1 2 4 5)  ;2
                                              (4 5 1 0 5 7 1 9 5)  ;3
                                              (4 5 1 5 0 6 2 8 2)  ;4
                                              (1 5 7 6 9 0 1 6 7)  ;5
                                              (4 5 1 3 5 7 0 9 5)  ;6
                                              (4 6 2 8 2 3 8 0 1)  ;7
                                              (4 5 3 4 1 6 2 8 0)  ;8
                                              )
                                              ;0 1 2 3 4 5 6 7 8
                                :demands '(20 10 15 40 30 20 10 30)
                                :capacity 30)
       (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6 7 8)) problem)
         (let* ((wc (basic-working-copy s1))
                (ops-list nil)
                (action (delta-cvrp-action*)))

           (prepare-solution-for-neighborhood-exploration wc)
           (initialize-action-for-delta-cost-computation wc problem action)

           (bformat t "Testing doselect-route")
           (doselect-client* (c1 1 wc)
               (doselect-client* (c2 2 wc :ge 2)
              (format t "~%Selected clients: ~a, ~a~%"
                      (client-selected-at-operation c1 wc)
                      (client-selected-at-operation c2 wc))
              (pp-solution wc t) (terpri)
              (format t "Delta distance after op: ~a~%"
                      (delta-distance action))
              (format t "Route feasibility after op: ~a~%"
                      (delta-routes-feasibility action))
              (format t "distance-stack: ~a, feasibility: ~a~%"
                      (delta-distance-stack action)
                      (delta-routes-feasibility-stack action)))))))
     #+END_SRC
   
**** simple test with two doselect-client and a ex-cond
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)  ;0
                                              (5 0 6 7 2 4 2 3 4)  ;1
                                              (1 8 0 3 9 1 2 4 5)  ;2
                                              (4 5 1 0 5 7 1 9 5)  ;3
                                              (4 5 1 5 0 6 2 8 2)  ;4
                                              (1 5 7 6 9 0 1 6 7)  ;5
                                              (4 5 1 3 5 7 0 9 5)  ;6
                                              (4 6 2 8 2 3 8 0 1)  ;7
                                              (4 5 3 4 1 6 2 8 0)  ;8
                                              )
                                              ;0 1 2 3 4 5 6 7 8
                                :demands '(20 10 15 40 30 20 10 30)
                                :capacity 30)
       (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6 7 8)) problem)
         (let* ((wc (basic-working-copy s1))
                (ops-list nil)
                (action (delta-cvrp-action*)))

           (prepare-solution-for-neighborhood-exploration wc)
           (initialize-action-for-delta-cost-computation wc problem action)

           (bformat t "Testing doselect-route")
           (doselect-client* (c1 1 wc)
               (doselect-client* (c2 2 wc :ex-cond
                                     (and (> c1.position 2)
                                          (> c2.position 2)))
              (format t "~%Selected clients: ~a, ~a~%"
                      (client-selected-at-operation c1 wc)
                      (client-selected-at-operation c2 wc))
              (pp-solution wc t) (terpri)
              (format t "Delta distance after op: ~a~%"
                      (delta-distance action))
              (format t "Route feasibility after op: ~a~%"
                      (delta-routes-feasibility action))
              (format t "distance-stack: ~a, feasibility: ~a~%"
                      (delta-distance-stack action)
                      (delta-routes-feasibility-stack action)))))))
     #+END_SRC
   
** doinsert-client
*** description
    Here we'll receive a symbol an a number (a route id) and we'll iterate through all the positions in the route creating an operation to simulate the insertion of the client represented by the symbol in the current position of the route.
*** +code without the macro+
    #+BEGIN_SRC lisp +n -r :results none :exports code
    (defmacro doinsert-client ((clname route working-copy) &body body)
        "Iterates through each position in the given route, creates an instance of op-insert-client, pushes it int ops-lists, do whatever the users wants to do, and restores everything to the previous state.

      Example:
          (doinsert-client (c1 r1 wc1)
             (format t \"Inserting client ~a.~%\"
              (client-selected-at-operation c1 wc1)))

        c1   is the index of the client that we want to insert
             (actually it should be the *selections-count* corresponding
             to its selection)
        r1  is the id of the route we want to make the insertion in
        wc1 is the working-copy where we are working."
        (with-gensyms (pos op)
          `(loop for ,pos from 1 to (1+ (route-length ,route ,working-copy))
                 ;; we have to iterate to (1+ (route-length)) because
                 ;; we can insert after the last element
                 for ,op = (op-insert-client ,route ,pos ,clname)
                 ;; the following line allows the final user
                 ;; to stop the iteration by setting that
                 ;; variable to t
                 while (not *vrp-stop-neighborhood-search*)
                 ;; the automatic stuff
                 do (progn
                      ;; push the current op into the ops-list 
                      (push ,op ops-list))

                 ;; here I want to add some code to execute it
                 ;; before the simulation of the operation
                 ;; but I'm not sure how to do it right :-/

                 ;; simulate the operation
                 do (simulate-neighborhood-operation ,op ,working-copy)

                 ;; let's do what the user wants
                 do (progn ,@body)
                 ;; now the clean up
                 do (progn
                      ;; pop the op from the list of operations
                      (pop ops-list)
                      ;; undo the operation
                      (undo-neighborhood-operation ,op ,working-copy)))))
    #+END_SRC
    
*** code with the macro
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (make-do-neighborhood-route-insertion
     doinsert-client
     (cname route working-copy)
     :op-name op-insert-client
     :op-params (route pos cname)
     :example-str "(doinsert-client (c1 r1 wc1)
                         (format t \"Inserting client ~a.~%\"
                          (client-selected-at-operation c1 wc1)))

                    c1   is the index of the client that we want to insert
                         (actually it should be the selections-count corresponding
                         to its selection)
                    r1  is the id of the route we want to make the insertion in
                    wc1 is the working-copy where we are working.")
    #+END_SRC
    
*** tests
**** simple tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
       (let* ((wc (basic-working-copy s1))
              (op1 (op-select-client 2 1 0))
              (c1 0)
              (ops-list nil))

         (prepare-solution-for-neighborhood-exploration wc)

         ;; simulate the first selection
         (simulate-neighborhood-operation op1 wc)

         (bformat t "Testing doinsert-client")
         (doinsert-client (c1 1 wc)
           (format t "Selected client: ~a~%"
                   (client-selected-at-operation c1 wc))
           (pp-solution wc t) (terpri))))
     #+END_SRC
   
**** simple tests with two insertions
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
       (let* ((wc (basic-working-copy s1))
              (c1 0) (c2 1)
              (op1 (op-select-client 2 1 c1))
              (op2 (op-select-client 2 3 c2))         
              (ops-list nil))

         (prepare-solution-for-neighborhood-exploration wc)

         ;; simulate the first selection
         (simulate-neighborhood-operation op1 wc)
         (simulate-neighborhood-operation op2 wc)

         (bformat t "Testing doinsert-client")
         (doinsert-client (c1 1 wc)
           (doinsert-client (c2 1 wc)
            (format t "Selected clients: ~a and ~a~%"
                    (client-selected-at-operation c1 wc)
                    (client-selected-at-operation c2 wc))
            (pp-solution wc t) (terpri)))))
     #+END_SRC
   
**** simple test with a doselect-route
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-basic-solution (s1 ((1 2 3 4) (5 6 7 8)))
       (let* ((wc (basic-working-copy s1))
              (c1 0)
              (op1 (op-select-client 2 1 c1))

              (ops-list nil))

         (prepare-solution-for-neighborhood-exploration wc)
         (simulate-neighborhood-operation op1 wc)

         (bformat t "Testing doselect-client")
         (doselect-route (r1 wc)
           (doinsert-client (c1 r1 wc)
             (format t "Inserting in route with id ~a:~%" r1)
             (pp-solution wc t) (terpri)))))
     #+END_SRC
     
** doinsert-client*
*** description
    Here we'll receive a symbol an a number (a route id) and we'll iterate through all the positions in the route creating an operation to simulate the insertion of the client represented by the symbol in the current position of the route.
    Inside the body of the macro:

    #+BEGIN_EXAMPLE
    (doinsert-client* (c1 r1 wc)
       ...  body)
    #+END_EXAMPLE

    we can refer to the symbols =c1.client=, =c1.insert.position= and =c1.insert.route= and they will return the client selected at that operation, the position where it was inserted and the route, respectively.
*** code with the macro
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-neighborhood-simulation.lisp
    (make-do-neighborhood-route-insertion
       doinsert-client*
       (cname route working-copy)
     :op-name op-insert-client
     :op-params (route pos cname)
     :example-str "(doinsert-client (c1 r1 wc1)
       (format t \"Inserting client ~a.~%\"
          (client-selected-at-operation c1 wc1)))

          c1   is the index of the client that we want to insert
               (actually it should be the selections-count corresponding
               to its selection)
         r1  is the id of the route we want to make the insertion in
         wc1 is the working-copy where we are working."
       :simpler-ops-macro simulate-simpler-ops-macro*
       :undo-simpler-ops-macro undo-simpler-ops-macro*)
    #+END_SRC
*** tests
**** simple test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9) ;0
                                              (5 0 6 7 2 4 2 3 4) ;1
                                              (1 8 0 3 9 1 2 4 5) ;2
                                              (4 5 1 0 5 7 1 9 5) ;3
                                              (4 5 1 5 0 6 2 8 2) ;4
                                              (1 5 7 6 9 0 1 6 7) ;5
                                              (4 5 1 3 5 7 0 9 5) ;6
                                              (4 6 2 8 2 3 8 0 1) ;7
                                              (4 5 3 4 1 6 2 8 0) ;8
                                              )
                                              ;0 1 2 3 4 5 6 7 8
                                 :demands '(20 10 15 40 30 20 10 30)
                                 :capacity 30)
       (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6 7 8)) problem)
         (let* ((wc (basic-working-copy s1))
                (c1 0)
                (op (op-select-client 1 1 c1))
                (ops-list nil)
                (action (delta-cvrp-action*)))

           (prepare-solution-for-neighborhood-exploration wc)
           (initialize-action-for-delta-cost-computation wc problem action)


           (compute-delta-cost-after op wc problem action)
           (format t "Delta distance after op: ~a~%"
                   (delta-distance action))
           (format t "Route feasibility after op: ~a~%"
                   (delta-routes-feasibility action))

           (simulate-neighborhood-operation op wc)
           (format t "Selected client: ~a~%"
                   (client-selected-at-operation c1 wc))


           (bformat t "Testing doinsert-client2")
           (doinsert-client* (c1 2 wc)
             (pp-solution wc t) (terpri)
             (format t "Delta distance after op: ~a~%"
                     (delta-distance action))
             (format t "Route feasibility after op: ~a~%"
                     (delta-routes-feasibility action))
             (format t "delta-distance-stack: ~a~%"
                     (delta-distance-stack action))
             )
           )))
     #+END_SRC
**** test with two insertions
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9) ;0
                                              (5 0 6 7 2 4 2 3 4) ;1
                                              (1 8 0 3 9 1 2 4 5) ;2
                                              (4 5 1 0 5 7 1 9 5) ;3
                                              (4 5 1 5 0 6 2 8 2) ;4
                                              (1 5 7 6 9 0 1 6 7) ;5
                                              (4 5 1 3 5 7 0 9 5) ;6
                                              (4 6 2 8 2 3 8 0 1) ;7
                                              (4 5 3 4 1 6 2 8 0) ;8
                                              )
                                              ;0 1 2 3 4 5 6 7 8
                                 :demands '(20 10 15 40 30 20 10 30)
                                 :capacity 30)
       (with-basic-cvrp-solution (s1 ((1 2 3 4) (5 6 7 8)) problem)
         (let* ((wc (basic-working-copy s1))
                (c1 0) (c2 1)
                (op1 (op-select-client 1 1 c1))
                (op2 (op-select-client 1 1 c2))
                (ops-list nil)
                (action (delta-cvrp-action*)))

           (prepare-solution-for-neighborhood-exploration wc)
           (initialize-action-for-delta-cost-computation wc problem action)


           (dolist (op (list op1 op2))
             (compute-delta-cost-after op wc problem action)

             (simulate-neighborhood-operation op wc))

           (format t "Delta distance after ops: ~a~%"
                   (delta-distance action))
           (format t "Route feasibility after ops: ~a~%"
                   (delta-routes-feasibility action))


           (format t "Selected clients: ~a, ~a~%"
                   (client-selected-at-operation c1 wc)
                   (client-selected-at-operation c2 wc))


           (bformat t "Testing doinsert-client*")
           (doinsert-client* (c1 2 wc)
             (doinsert-client* (c2 2 wc :gt 4)
               (pp-solution wc t) (terpri)
               (format t "Delta distance after op: ~a~%"
                       (delta-distance action))
               (format t "Route feasibility after op: ~a~%"
                       (delta-routes-feasibility action))
               (format t "delta-distance-stack: ~a~%"
                       (delta-distance-stack action))
               ))
           )))
     #+END_SRC
