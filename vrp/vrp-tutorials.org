#+TITLE: VRP solver environment
#+AUTHOR: Fernando Rodriguez Flores
#+DATE 2019-02-14
#+TAGS: suite(s) classes(c) moments(m) data(d) algoritms(a) dcost(v)
#+TAGS: emacs(e) utils(u) strat(t) simul(i) vanny(o)
#+TODO: TODO | DONE
#+STARTUP: nologdone

* Description
  In this file we'll write all the tutorials explaining some feature of the vrp-suite.


* TODO Introduction to the system (2021-01-18)
** description
   In this tutorial, we'll write an introduction to the whole system.  It will have several subtutorials.
   - How to load the system
   - How to create a problem and a solution, and eval that solution
   - How to solve a problem with some of the existing algortihms
** Tutorial 0: How to load the system (vrp-suite) with emacs
   Here we'll assume that the user is using emacs.  
   1. Clone the git repo in the folder =vrp= to the working directory
      For the rest of the tutorial, we assume that the name of the working directory is tmp/vrp.

      In that folder /tmp/vrp/ there should be two folders:
      - vrp-suite
      - neighborhood-generation

      #+begin_src shell :export both :results output
      ls /tmp/vrp
      #+end_src

      #+RESULTS:
      : neighborhood-generation
      : vrp-suite
   2. In the working directory (vrp) create the following two folders
      - src/
      - data/

      Up to this point, in the working directory there should be 4 folder:
      #+begin_src shell :export both :results output
      ls /tmp/vrp
      #+end_src

      #+RESULTS:
      : data
      : neighborhood-generation
      : src
      : vrp-suite
   3. Tangle the file /tmp/vrp-suite/vrp-suite.org
      Open the file /tmp/vrp-suite/vrp-suite.org in emacs and do =M-x org-babel-tangle=
   4. After the tangle
      we should have one more file in the working directory: vrp-emacs-utils.el.

      #+begin_src shell :export both :results output
      ls /tmp/vrp
      #+end_src

      #+RESULTS:
      : data
      : neighborhood-generation
      : src
      : vrp-emacs-utils.el
      : vrp-suite
   5. Add the following lines to your file .emacs
      After 2022-03-26 this is no longer needed.

      #+BEGIN_SRC emacs-lisp :results none :exports code
      (define-key org-mode-map (kbd "M-m") (make-sparse-keymap))
      (define-key lisp-mode-map (kbd "M-m M-o") (make-sparse-keymap))
      #+END_SRC
      That's to avoid errors in the next step.
   6. From emacs load /tmp/vrp/vrp-emacs-utils.el
      =M-x load-file /tmp/vrp/vrp-emacs-utils.el=
   7. Tangle all the files in the vrp-suite
      To do that, in emacs, change the current directory to vrp-suite, and execute =M-x vrp-tangle-all-files=

      There is an alternative approach...  We can open each org file in the folder and in each of them execute =M-x org-babel-tangle=.  It will take longer, but it should also work.
   8. Tangle all the files in the neigh-suite
      To do this
      1. tangle the file
         /tmp/vrp/neighborhood-generation/neigh-suite.org
      2. in emacs load the file /tmp/vrp/src/neigh-emacs-utils.el
      3. Execute =M-x neigh-tangle-all-files=
   9. From emacs fire up slime (=M-x slime=)
   10. In Slime, change the current directory to the working directory
       (this can be done by typing =,= in the REPL and then =cd= <RETURN>, and navigate to the working directory)
   11. In slime load the file src/vrp-load-files
      #+BEGIN_SRC lisp +n -r :results none :exports code 
      (load "src/vrp-load-files.lisp")
      #+END_SRC
   12. Change to the package vrp
      #+BEGIN_SRC lisp +n -r :results none :exports code 
      (in-package :vrp)
      #+END_SRC
      
      From here on, we are ready to work with the system, and that's what we'll do in the following tutorials.
** Tutorial 1: basic elements of the suite
   In this tutorial we present the basic elements of a VRP: the clients, the vehicles, the routes, the solution and the problems.

   In the vrp-suite we have a class hierarchy for each of these elements.  And that's what we are going to present in the next section.

   The code for all these classes can be found in the file [[file:vrp-classes.org][vrp-classes.org]].

*** classes
**** clients
***** basic-client
      The most basic element in this hierarchy is the =basic-client=, that only has one id.  The constructor is =(basic-client id)= and it receives the id.

      In the following snippet, we create two basic-clients each with a different id, and we print them.

      #+begin_src lisp :export both :results output
      (let* ((c1 (basic-client 1))
             (c2 (basic-client 2)))
        (format t "Client 1: ~a~%" c1)
        (format t "Client 2: ~a~%" c2))
      #+end_src

      #+RESULTS:
      : Client 1: <c:1>
      : Client 2: <c:2>
     
***** basic-cvrp-client

      The =basic-cvrp-client= is a client that has an id and a demand.  It is the most basic client that can be used in CVRP problem.  The constructor receives two arguments: the id and the demand.

      #+begin_src lisp :export both :results output
      (let* ((c1 (basic-cvrp-client 1 10))
             (c2 (basic-cvrp-client 2 15)))
        (format t "Client 1: ~a, with demand: ~a~%" c1 (demand c1))
        (format t "Client 2: ~a, with demand: ~a~%" c2 (demand c2)))
      #+end_src

      #+RESULTS:
      : Client 1: <c1: 10>, with demand: 10
      : Client 2: <c2: 15>, with demand: 15
***** other clients
      The classes for other clients in the system can be found in this [[file:vrp-classes.org::*Clients][section]].

**** vehicles

     In the section [[file:vrp-classes.org::*Vehicles][Vehicles]] there are several classes for vehicles, but most of them are suppossed to become obsolete in a near future :-(, so let's just focus on the most basic ones, the basic vehicle and the cvrp-vehicle.

     
***** basic-vehicle
      Again, the basic vehicle is a vehicle that has only one id.  It's constructor receives a number that will be the id.

      #+begin_src lisp :export both :results output
      (let* ((v1 (basic-vehicle 1))
             (v2 (basic-vehicle 2)))
        (format t "Vehicle 1: ~a~%" v1)
        (format t "Vehicle 2: ~a~%" v2))
      #+end_src

      #+RESULTS:
      : Vehicle 1: <v:1>
      : Vehicle 2: <v:2>

***** cvrp-vehicle

      The =cvrp-vehicle= class also has a capacity, and a (current) cargo that should also be passed to the constructor.  The =cargo= argument in the constructor is optional and defaults to 0.

      #+begin_src lisp :export both :results output
      (let* ((v1 (cvrp-vehicle 1 10 5))
             (v2 (cvrp-vehicle 2 15)))
        (format t "Vehicle 1: ~a, with cargo ~a and capacity ~a~%"
                v1
                (cargo v1)
                (capacity v1))
        (format t "Vehicle 2: ~a, with cargo ~a and capacity ~a~%"
                v2
                (cargo v2)
                (capacity v2)))
      #+end_src

      #+RESULTS:
      : Vehicle 1: <cv:1. 5/10>, with capacity: 10
      : Vehicle 2: <cv:2. 0/15>, with capacity:: 15

      In the =print-object= method, we can see the =id= of the vehicle and the (current) =cargo= separated from the =capacity= by a slash.
**** depot
     The class =basic-depot= only has one id, that defaults to 0 if it is not passed as an argument to the constructor.
     
      #+begin_src lisp :export both :results output
      (let* ((d1 (basic-depot))
             (d2 (basic-depot 1)))
        (format t "depot 1 ~a, with id ~a~%" d1 (id d1))
        (format t "depot 2 ~a, with di ~a~%" d2 (id d2)))
      #+end_src


      #+RESULTS:
      : depot 1 <d:0>, with id 0
      : depot 2 <d:1>, with di 1

      You can verify in the previous code that we created the first depot without specifying the value of the id and it is set to 0, the default value.

      The classes for the depot can be found [[file:vrp-classes.org::*Depots][here]].
**** route
     The classes for the routes can be found [[file:vrp-classes.org::*Routes][here]].

     Here, we'll mention only the =basic-route= because we are only printing the objects.

     The class =basic-route= has a vehicle, a list with clients and a depot.  We can create a route by creating all the individual elements and putting them together in the basic-route class.

     The constructor for this class receives all the elements with named parameters.

     In the example, we'll create a route with 3 clients.

     #+begin_src lisp :export both :results output
     (let* ((d1 (basic-depot))
            (v1 (basic-vehicle 1))
            (c1 (basic-client 1))
            (c2 (basic-client 2))
            (c3 (basic-client 3))
            (r1 nil))
       ;; here we construct the route.
       (setf r1 (basic-route :id 1 :vehicle v1 :depot d1
                              :clients (list c1 c2 c3)))
       ;; and here we print it
       (format t "route 1 ~a~%" r1))
     #+end_src

     #+RESULTS:
     : route 1 <r1: <v:1> (<d:0>: (<c:1> <c:2> <c:3>))>

     In the next section we'll use several routes to create a solution.

**** solution
     The classes for the solution can be found in the section [[file:vrp-classes.org::*Solutions][Solutions]].
     
     Here, we'll mention only the =basic-solution= because we are only printing the objects.

     The class =basic-route= has an id, a list of routes and a cost, that right now we won't use. 

***** creating a basic-solution

      The constructor for this class receives all the elements with named parameters.  The cost argument defaults to 0.

      In the example, we'll create a solution with two routes.

      #+begin_src lisp :export both :results output
      (let* ((d1 (basic-depot))
             (v1 (basic-vehicle 1))
             (c1 (basic-client 1))
             (c2 (basic-client 2))
             (c3 (basic-client 3))
             (r1 (basic-route :id 1 :vehicle v1 :depot d1
                               :clients (list c1 c2)))
             (r2 (basic-route :id 2 :vehicle v1 :depot d1
                              :clients (list c3)))
             (s1 nil))
        ;; here we construct the solution.
        (setf s1 (basic-solution :id 1 :routes (list r1 r2)))
  
        ;; and here we print it
        (format t "solution: ~a~%" s1))
      #+end_src

      #+RESULTS:
      : solution: S1: (0)
      :   <r1: <v:1> (<d:0>: (<c:1> <c:2>))>
      :   <r2: <v:1> (<d:0>: (<c:3>))>
      :

      When we print the solution we can see it's id (after the S), the cost (in parentheses) after S1, and then each route on a line.

***** pretty-printing the solution
      In this section, we'll introduce a method to print a solution in a friendlier way.

      To do that we use the generic-function =pp-solution=.  This function receives a solution and a stream.  In this case, the stream will be t (the standard output stream).

      We'll use the solution from the previous section:
     
      #+begin_src lisp :export both :results output
      (let* ((d1 (basic-depot))
             (v1 (basic-vehicle 1))
             (c1 (basic-client 1))
             (c2 (basic-client 2))
             (c3 (basic-client 3))
             (r1 (basic-route :id 1 :vehicle v1 :depot d1
                               :clients (list c1 c2)))
             (r2 (basic-route :id 2 :vehicle v1 :depot d1
                              :clients (list c3)))
             (s1 nil))
        ;; here we construct the solution.
        (setf s1 (basic-solution :id 1 :routes (list r1 r2)))

        ;; and here we print it
        (format t "This is the printed-solution:~%~a~%" s1)

        (format t "and this is the pretty-print version:~%")
        (pp-solution s1 t))
      #+end_src

      #+RESULTS:
      : This is the printed-solution:
      : S1: (0)
      :   <r1: <v:1> (<d:0>: (<c:1> <c:2>))>
      :   <r2: <v:1> (<d:0>: (<c:3>))>
      : 
      : and this is the pretty-print version:
      : S1:
      :     R1: (1, 2)
      :     R2: (3)

**** problem

     In this section we present some problems.  All the problems currently in the suite can be found in the section [[file:vrp-classes.org::*Problems][Problems]].  Here we'll just present two problems: the basic-problem and the cvrp-problem.

     
***** basic-problem

      The basic problem has an id, a depot and a list with clients.  

      The constructor for this class receives all the elements with named parameters.  

      In the example, we'll create a problem with 3 clients.

      #+begin_src lisp :export both :results output
      (let* ((d1 (basic-depot))
             (c1 (basic-client 1))
             (c2 (basic-client 2))
             (c3 (basic-client 3))
             (p1 nil))
        ;; here we create the problem.
        (setf p1 (basic-problem :id 1
                                :clients (list c1 c2 c3)
                                :depot d1))

        ;; and here we print it
        (format t "Problem: ~a~%" p1))
      #+end_src

      #+RESULTS:
      : Problem: <P1.(<c:1> <c:2> <c:3>), <d:0>>

      This is a very basic problem and it is pretty useless.  In the next section we introduce the cvrp-problem.

***** cvrp-problem

      In the CVRP we have a set of clients a central depot, we know the distance between each pair of clients (and the depot), and we can assume an infinte number of vehicles, all of them with the same capacity.  Also, for each client we know its demand.

      The class cvrp-problem has an id, a list of clients (which should have a demand slot), a distance-matrix (with the distance between each pair of clients and the depot), and a capacity, that is the same for all the vehicles.

      The constructor for this class receives all the elements with named parameters.  

      In the example, we'll create a problem with 3 clients, all of them of type =basic-cvrp-client=

      #+begin_src lisp :export both :results output
      (let* ((d1 (basic-depot))
             (c1 (basic-cvrp-client 1 10))
             (c2 (basic-cvrp-client 2 20))
             (c3 (basic-cvrp-client 3 30))
             (distance-matrix #2a((0 1 2 3)
                                  (1 0 4 3)
                                  (2 1 0 6)
                                  (3 8 6 0)))
             (capacity 30)
             (p1 nil))
        ;; here we create the problem.
        (setf p1 (cvrp-problem :id 1
                               :clients (list c1 c2 c3)
                               :depot d1
                               :distance-matrix distance-matrix
                               :capacity capacity))

        ;; and here we print it
        (format t "Problem: ~a~%" p1))
      #+end_src

      #+RESULTS:
      : Problem: <CVRP 1: 3 clients, capacity 30>

      With this problem and a solution we can evaluate the cost of the solutions.  We'll do that on the [[*Tutorial 2: evaluating solutions][Tutorial 2: evaluating solutions]], but first we'll present a more convenient way to create clients, solutions and problems.  We'll do that in the next section.
      
*** macros to abstract the use of the classes
    In the vrp-suite there are some macros than can help us to quickly create instances of some of the classes in the suite.  Following the lisp convention, all those macros start with "with-NAME-OF-THE-INSTANCE". Let's see some examples.

    All the macros with the descrption and some examples can be found in the section:  [[file:vrp-classes.org::*Macros to deal with disposable instances][Macros to deal with disposable instances]].
    
**** with-basic-clients
     We can use this macro when we want to create some basic-clients.  It receives a list with integers and creates symbols of the form cn, for each n in the list of integers.  All those symbols are bound to an instance of a basic-client with id n.

     For example, the code we used [[*basic-client][in the introduction to basic-clients]]:

     #+begin_src lisp :export both :results output
     (let* ((c1 (basic-client 1))
            (c2 (basic-client 2)))
       (format t "Client 1: ~a~%" c1)
       (format t "Client 2: ~a~%" c2))
     #+end_src

     #+RESULTS:
     : Client 1: <c:1>
     : Client 2: <c:2>

     can be rewritten with this macro as:

      #+begin_src lisp :export both :results output
      (with-basic-clients (1 2)
        (format t "Client 1: ~a~%" c1)
        (format t "Client 2: ~a~%" c2))
      #+end_src

      #+RESULTS:
      : Client 1: <c:1>
      : Client 2: <c:2>

      And we get the same results.  Actually, the macro expansion of the macro is exactly the previous code :-o
     
      #+begin_src lisp :export both :results output
      (LET* ((C1 (BASIC-CLIENT 1)) (C2 (BASIC-CLIENT 2)))
        (FORMAT T "Client 1: ~a~%" C1)
        (FORMAT T "Client 2: ~a~%" C2))
      #+end_src

      So, any time we need a list of basic-clients, the 'elegant' way to do it is to use the macro =with-basic-client= ;-).
     
**** with-basic-solution
     We can also create basic-solutions very easily using the macro =with-basic-solution=.  This macro receives a symbol and list with lists of integers, where each inner list represent a route, and binds the symbol to a basic solution with the routes described by the inner lists.

     Maybe the easiest way to understand it is to see it in action.  (No.  The best way to understand it is to read a good description, but apparently I'm not able to do that now :-P, so let's stick to the example.)

     Once again, I'm going to rewrite a previous example using the macro.  This is the code from the [[*creating a basic-solution][section]] where we introduced the basic-solution:

      #+begin_src lisp :export both :results output
      (let* ((d1 (basic-depot))
             (v1 (basic-vehicle 1))
             (c1 (basic-client 1))
             (c2 (basic-client 2))
             (c3 (basic-client 3))
             (r1 (basic-route :id 1 :vehicle v1 :depot d1
                               :clients (list c1 c2)))
             (r2 (basic-route :id 2 :vehicle v1 :depot d1
                              :clients (list c3)))
             (s1 nil))
        ;; here we construct the solution.
        (setf s1 (basic-solution :id 1 :routes (list r1 r2)))
  
        ;; and here we print it
        (format t "solution: ~a~%" s1))
      #+end_src

      #+RESULTS:
      : solution: S1: (0)
      :   <r1: <v:1> (<d:0>: (<c:1> <c:2>))>
      :   <r2: <v:1> (<d:0>: (<c:3>))>
      :

      and this is the same code usith the macro =with-basic-solution=:

      #+begin_src lisp :export both :results output
      (with-basic-solution (s1 ((1 2) (3)))
        ;; let's print the solution
        (format t "solution: ~a~%" s1))
      #+end_src

      #+RESULTS:
      : solution: S1: (0)
      :   <r1: <v:1> (<d:0>: (<c:1> <c:2>))>
      :   <r2: <v:2> (<d:0>: (<c:3>))>
      : 
      
      Actually the macro =with-basic-solution= expands into a code that does exactly the same things that we did in the previous example, but it is a lot better when the computer writes the code for us :-P.

      As we said before, the basic-solution is not very useful to solve instances of the VRP, because we need more info.  However, it is useful to explore neighborhoods and analyze what happens in those neighborhoods, as long as we don't need to evaluate the solutions :-).

      The following macros help us to create problems and solutions than can be used to actually solve VRPs :-o.

**** with-basic-cvrp-problem
     In this section we present a macro to create instances of the class =cvrp-problem=.

     In the CVRP we have a distance-matrix, clients with demands and a capacity for all the vehicles.  There is a macro that allows us to create instances of this class very easily.  It receives a symbol, and the rest of the info required for the cvrp-problem, everything in the form of list.

     We'll rewrite the code in section [[*cvrp-problem][cvrp-problem]] using this macro.  The code in that section was:

      #+begin_src lisp :export both :results output
      (let* ((d1 (basic-depot))
             (c1 (basic-cvrp-client 1 10))
             (c2 (basic-cvrp-client 2 20))
             (c3 (basic-cvrp-client 3 30))
             (distance-matrix #2a((0 1 2 3)
                                  (1 0 4 3)
                                  (2 1 0 6)
                                  (3 8 6 0)))
             (capacity 30)
             (p1 nil))
        ;; here we create the problem.
        (setf p1 (cvrp-problem :id 1
                               :clients (list c1 c2 c3)
                               :depot d1
                               :distance-matrix distance-matrix
                               :capacity capacity))

        ;; and here we print it
        (format t "Problem: ~a~%" p1))
      #+end_src

      #+RESULTS:
      : Problem: <CVRP 1: 3 clients, capacity 30>

      If we use the macro, we would write:

      #+begin_src lisp :export both :results output
      (with-cvrp-problem (p1 :distances '((0 1 2 3)
                                          (1 0 4 3)
                                          (2 1 0 6)
                                          (3 8 6 0))
                             :demands '(10 20 30)
                             :capacity 30)

        ;; and here we print it
        (format t "Problem: ~a~%" p1)
        (format t "clients: ~a~%" (clients p1)))
      #+end_src

      #+RESULTS:
      : Problem: <CVRP 1: 3 clients, capacity 30>
      : clients: (<c1: 10> <c2: 20> <c3: 30>)

      
      In this case the distances is a list of lists and the demands is also a list.  This macro creates a depot with =id= 0, as many clients as the length of the =demands= list, named from c1 to cn, where n is the length of that list.  

**** with-basic-cvrp-solution

     In this section we create an instance of =basic-cvrp-solution=.  A cvrp-basic-solution is a solution that can be evaluated to compute its cost.  The difference with the basic-solution is that the clients are instances of =basic-cvrp-client= and the routes are instances of =route-for-simulation=.  

     But, thanks to the macro we can ignore those implementation details, as the macro takes care of them for us.

     The macro is similar to =with-basic-solution= in the sense that it receives a list of lists with the description of the routes, but it also receives an instance of =cvrp-problem=.

     Here is the example:

      #+begin_src lisp :export both :results output
      (with-cvrp-problem (p1 :distances '((0 1 2 3)
                                          (1 0 4 3)
                                          (2 1 0 6)
                                          (3 8 6 0))
                             :demands '(10 20 30)
                             :capacity 30)
        (with-basic-cvrp-solution (s1 ((1 2) (3)) p1)

         ;; and here we pretty print it
          (format t "Solution:~%")
          (pp-solution s1 t) (terpri)

          (format t "The raw solution:~%~a~%" s1)))
      #+end_src

      #+RESULTS:
      #+begin_example
      Solution:
      S1:
	  R1: (1, 2)
	  R2: (3)

      The raw solution:
      CVRP_S1: (0)
	<r1: <cv:1. 0/30> (<d:0>: (<c1: 10> <c2: 20>))>
	<r2: <cv:2. 0/30> (<d:0>: (<c3: 30>))>

      #+end_example
      
      The command =(terpri)= inserts a new line to the optional stream (that defaults to t).

      We can see in the raw solution the demand of each client, and the capacity of the vehicles.  Those values are taken from the problem passed as the third argument.

      The code and some documentation for this macro can be found [[file:vrp-classes.org::#macro:with-basic-cvrp-solution][here]].

      This is a simple introduction to the basic elements in the system.  In the next tutorial we'll show how to evaluate the solutions.

** Tutorial 2: evaluating solutions (using actions)
   In this tutorial we describe how to compute the cost of a solution for a given CVRP.  We assume that the reader is familiar with ideas from the previous tutorials, specifically the macros =with-basic-cvrp-solution= and =with-cvrp-problem=.

   Here, we'll create a problem, a solution and we'll compute the cost for that solution, but to do that we need the concept of action.  We'll present that in the next section.

   
*** actions
    The definition of the action classes can be found in the section [[file:vrp-classes.org::*Actions][Actions]].

    An action is an object designed to make some computations.  There are two types of actions.  The first type is used to compute the cost of a given solution and the second one is used the compute the delta-cost between a solution and a neighbor.

    In this section we'll deal with the first type.  We'll use the only action we have now in the system, and it computes the cost of a given solution for a given CVRP problem.

    The name of the class is =basic-cvrp-action= and it computes the total distance travelled by the vehicles plus a penalty due to excess of cargo in the vehicles on each route.  The penalty is computed as a the unfeasibility of the route times a factor that defaults to 1000.  The unfeasibility of a route is computed as the sum of the demands of the clients on that route minus the capacity of the vehicle, or zero if that value is negative:

    $\displaystyle \max\{0, \sum_{i\in r}{d_i} - C_v\}$,

    where $r$ is the route, $i$ is the clients of the route, $d_i$ is client $i$'s demand, and $C_v$ is the capacity of the vehicle.
    

    For instance if clients =c1=, =c2= and =c3= have demand 10 and vehicle's capacity is 20, then the unfeasibility of the route is 10.  However, if the capacity were 40, the unfeasibility would be 0.

    The constructor for this class is =basic-cvrp-action=, and receives 5 named parameters:
    - id, defaults to 1,
    - penalty-factor, defaults to 1000,
    - total-penalty, defaults to 0,
    - capacity-violation, defaults to 0 (this is the "unfeasibility"),
    - current-distance, defaults to 0, and
    - total-distance, also defaulting to 0.

    Of all those parameters, usually we only need to modify the penalty-factor in order to tune it to our current problem.

    The code for creating the action is the follwing:

     #+begin_src lisp :export both :results output
     (let* ((a1 (basic-cvrp-action))
            (a2 (basic-cvrp-action :id 2))
            (a3 (basic-cvrp-action :id 3 :penalty-factor 3000)))
       (format t "Action 1: ~a~%" a1)
       (format t "Action 2: ~a~%" a2)
       (format t "Action 3: ~a~%" a3))
     #+end_src

     #+RESULTS:
     : Action 1: <a_cvrp1. d: 0, p: 0>
     : Action 2: <a_cvrp2. d: 0, p: 0>
     : Action 3: <a_cvrp3. d: 0, p: 0>
    

    When we print the actions we only see the two values that we'll be interested in after the evaluation of a solution: the =total-distance= and the =total-penalty=.  As we just created the actions, they have the defaults values.

    Let's also print the =penalty-factor= for each of them:
   
     #+begin_src lisp :export both :results output
     (let* ((a1 (basic-cvrp-action))
            (a2 (basic-cvrp-action :id 2))
            (a3 (basic-cvrp-action :id 3 :penalty-factor 3000)))
       (format t "Action 1: ~a~%" a1)
       (format t "Action 2: ~a~%" a2)
       (format t "Action 3: ~a~%" a3)

       (terpri) ;; an empty line

       (format t "Penalty-factor in Action 1: ~a~%" (penalty-factor a1))
       (format t "Penalty-factor in Action 2: ~a~%" (penalty-factor a2))
       (format t "Penalty-factor in Action 3: ~a~%" (penalty-factor a3)))
     #+end_src

     #+RESULTS:
     : Action 1: <a_cvrp1. d: 0, p: 0>
     : Action 2: <a_cvrp2. d: 0, p: 0>
     : Action 3: <a_cvrp3. d: 0, p: 0>
     : 
     : Penalty-factor in Action 1: 1000
     : Penalty-factor in Action 2: 1000
     : Penalty-factor in Action 3: 3000

     As expected, =action1= and =action2= have =penalty-factor= 1000, and =action3= has =penalty-factor= 3000.

     Once we have created a action we can use to compute the cost of a solution for a given problem.  We'll do that in the next section.
*** using actions to evaluate solutions
    Once we have a solution, a problem and an action we should use the function =simulate-solution= that receives those parameters as shown in the next code:

     #+begin_src lisp :export both :results output
     (with-cvrp-problem (p1 :distances '((0 1 2 3 5)
                                         (1 0 4 5 6)
                                         (2 4 0 6 7)
                                         (3 5 6 0 8)
                                         (5 6 7 8 0))
                            :demands '(30 20 40 50)
                            :capacity 50)
       (with-basic-cvrp-solution (s1 ((1 2)
                                      (3 4))
                                     p1)

         (let* ((action (basic-cvrp-action)))

           (format t "~a~%"
                   (simulate-solution s1 p1 action)))))
     #+end_src

     #+RESULTS:
     : NIL
    
    If we execute that code we just get NIL because the method =simulate-solution= does not returns a value.  Actually, the results of the simulation are stored in the action's corresponding slots.  We can see them in the next code: 

     #+begin_src lisp :export both :results output
     (with-cvrp-problem (p1 :distances '((0 1 2 3 5)
                                         (1 0 4 5 6)
                                         (2 4 0 6 7)
                                         (3 5 6 0 8)
                                         (5 6 7 8 0))
                            :demands '(30 20 40 50)
                            :capacity 50)
       (with-basic-cvrp-solution (s1 ((1 2)
                                      (3 4))
                                     p1)

         (let* ((action (basic-cvrp-action)))

           (simulate-solution s1 p1 action)

           (format t "solution distance: ~a~%" (total-distance action))
           (format t "solution penalty: ~a~%" (total-penalty action)))))
     #+end_src

     #+RESULTS:
     : solution distance: 23
     : solution penalty: 40000

     Here we can see that the total distance is 23, but the the penalty is 40000, due to the demand excess in the second route.

     If we run that code with a diferent (and feasible) solution we get the following results:

     #+begin_src lisp :export both :results output
     (with-cvrp-problem (p1 :distances '((0 1 2 3 5)
                                         (1 0 4 5 6)
                                         (2 4 0 6 7)
                                         (3 5 6 0 8)
                                         (5 6 7 8 0))
                            :demands '(30 20 40 50)
                            :capacity 50)
       (with-basic-cvrp-solution (s1 ((1 2)
                                      (3)
                                      (4))
                                     p1)

         (let* ((action (basic-cvrp-action)))

           (simulate-solution s1 p1 action)

           (format t "solution distance: ~a~%" (total-distance action))
           (format t "solution penalty: ~a~%" (total-penalty action)))))
     #+end_src

     #+RESULTS:
     : solution distance: 23
     : solution penalty: 0

     In this case, the penalty is 0, and that means that the solution is feasible ;-).

     However, after we execute that code, the cost slot in the solution is not modified.  It is up to the user to update that value if that is desired.  This is shown in the next snippet.
     
     #+begin_src lisp :export both :results output
     (with-cvrp-problem (p1 :distances '((0 1 2 3 5)
                                         (1 0 4 5 6)
                                         (2 4 0 6 7)
                                         (3 5 6 0 8)
                                         (5 6 7 8 0))
                            :demands '(30 20 40 50)
                            :capacity 50)
       (with-basic-cvrp-solution (s1 ((1 2)
                                      (3)
                                      (4))
                                     p1)

         (let* ((action (basic-cvrp-action)))

           (simulate-solution s1 p1 action)

           (format t "After simulation but before setting the cost~%")
           (format t "solution cost: ~a.~%" (cost s1))
           ;; The cost is 0 because it has not been set, yet
      
           (setf (cost s1) (+ (total-distance action)
                              (total-penalty action)))
      
           (format t "After setting the cost~%")
           (format t "solution cost: ~a.~%" (cost s1)))))
     #+end_src

     #+RESULTS:
     : After simulation but before setting the cost
     : solution cost: 0.
     : After setting the cost
     : solution cost: 23.

*** rationale behind not setting the cost slot automatically
    The rationale behind not setting the cost slot automatically is that in some occasions, we could be interested in minimizing another metric, for instance, we could be just looking for a feasible solution, and in those cases the objective function could be only the penalty.

    In any case, do not worry too much about this, because in a near future, we'll be using a different method to compute the cost of a solution, but so far, this is the way to go ;-).
** TODO Tutorial 3: evaluating neighbor solutions
** TODO Tutorial 4: solving a cvrp using one of the existing algorithms
** TODO Tutorial 5: creating a new algorithm to solve a cvrp

   
* Tutorial for JJ how to use the do-neighborhood macros

** description

   In this section I'll add a tutorial for JJ on how to use the do-neighborhood macros.  We assume that the reader knows how to set up the system.  In any case the reader can check [[*Introduction to the system (2021-01-18)][this tutorial]].

   Here, we'll explain how to use the neighborhood macros.

   To do that, we,ll explore the neighborhood of a solution using several criteria.

** setting up what we'll always need
   In order to use the macros we'll always need the following

   - a problem
   - an initial-solution
   - a working-copy of the initial-solution
   - a variable named `ops-list' where we'll have the operations for the current neighbor.
*** the problem and the initial solution
    For the problem and the initial solution we'll use the corresponding macros.
    
      #+begin_src lisp :export both :results output
      (with-cvrp-problem (p1 :distances '((0 1 2 3)
                                          (1 0 4 3)
                                          (2 1 0 6)
                                          (3 8 6 0))
                             :demands '(10 20 30)
                             :capacity 30)
        (with-basic-cvrp-solution (s1 ((1 2) (3)) p1)


          ;; here we have a solution called s1
          ;; and a problem called p1.
          ;; with them we can do anything we want
          ;; for instance, we can print it.

         ;; and here we pretty print it
          (format t "Solution:~%")
          (pp-solution s1 t) (terpri)

          (format t "The raw solution:~%~a~%" s1)

          ))
      #+end_src

      #+RESULTS:
      #+begin_example
      Solution:
      S1:
	  R1: (1, 2)
	  R2: (3)

      The raw solution:
      CVRP_S1: (0)
	<r1: <cv:1. 0/30> (<d:0>: (<c1: 10> <c2: 20>))>
	<r2: <cv:2. 0/30> (<d:0>: (<c3: 30>))>

      #+end_example

*** the working-copy and the empty list
    Once we have the problem and the solution we can add a working-copy and an empty list, using a let.

    Before we can do anything with the working-copy we need to initialize it.  We must do that with the function  =prepare-solution-for-neighborhood-exploration=.
    
      #+begin_src lisp :export both :results output
      (with-cvrp-problem (p1 :distances '((0 1 2 3 4)
                                          (1 0 4 3 2)
                                          (2 1 0 6 1)
                                          (3 8 6 0 3)
                                          (4 2 1 3 0))
                             :demands '(10 20 30 10)
                             :capacity 30)
        (with-basic-cvrp-solution (s1 ((1 2) (3 4)) p1)


          ;; here we have a solution called s1
          ;; and a problem called p1.
          ;; with them we can do anything we want
          ;; for instance, we can print it.
          (let* ((working-copy (basic-working-copy s1))
                 (ops-list nil))

            ;; here we have a working-copy
            ;; and the ops-list variable


            ;; but before we can use any working-copy
            ;; we need to initialize it
            ;; we can de that with

            (prepare-solution-for-neighborhood-exploration working-copy)

            ;; now we can print it

            (pp-solution working-copy t) (terpri)

            ;; and the empty list:
            (format t "ops-list: ~a~%" ops-list)

            )))
      #+end_src

      #+RESULTS:
      : S1:
      :     R1: (1, 2)
      :     R2: (3, 4)
      : 
      : ops-list: NIL

      After that, we are ready to explore a neighborhood.

*** exploring the neighborhood rarb
    Once the working-copy is initialized, we can explore any neighborhood we want using the exploration macros.

    For this first example, we'll use the criterion rarb that means:

    - select route r1
    - select client c1 from r1
    - select route r2
    - insert client c1 into r2

    We can describe that criterion using the neighborhood macros:

    - doselect-route
    - doselect-client
    - doinsert-client

    Each of those macros receives the arguments it needs, and a working-copy:

    - doselect-route: r
      r is a symbol where we'll store the current route.
    - doselect-client: c, r
      With c will denote the client selected in this operation.
      r is the route from which we should select the client.
    - doinsert-client: c, r
      c is the client that should be inserted, and
      r is the route where we should insert it.

    Using these macros, we can describe any neighborhood we want.  In the case of rarb we should write it as:

    #+begin_src lisp
    (doselect-route (r1 working-copy)
      (doselect-client (c r1 working-copy)
        (doselect-route (r2 working-copy)
          (doinsert-client (c r2 working-copy)

            ))))
    #+end_src

    Each call to a macro is nested in the previous call to access all the variables and parameters used there.  Each of those macros pushes the corresponding operation to the variable =ops-list=, and all of them should be called after the working-copy has been initialized.

    Let's see them in action:

    
    #+begin_src lisp :export both :results output
    (with-cvrp-problem (p1 :distances '((0 1 2 3 4)
                                        (1 0 4 3 2)
                                        (2 1 0 6 1)
                                        (3 8 6 0 3)
                                        (4 2 1 3 0))
                           :demands '(10 20 30 10)
                           :capacity 30)
      (with-basic-cvrp-solution (s1 ((1 2) (3 4)) p1)


        ;; here we have a solution called s1
        ;; and a problem called p1.
        ;; with them we can do anything we want
        ;; for instance, we can print it.
        (let* ((working-copy (basic-working-copy s1))
               (ops-list nil))

          ;; here we have a working-copy
          ;; and the ops-list variable


          ;; but before we can use any working-copy
          ;; we need to initialize it
          ;; we can de that with

          (prepare-solution-for-neighborhood-exploration working-copy)

          ;; here we can use the macros

          (doselect-route (r1 working-copy)
            (doselect-client (c r1 working-copy)
              (doselect-route (r2 working-copy)
                (doinsert-client (c r2 working-copy)

                  ;; here, in the variable ops-list
                  ;; we have the operations that define
                  ;; the current neighbor, in reversed order
                  ;; let's print it
                  (format t "~%ops-list for current-neighbor: ~a~%" ops-list)
              
                  ;; let's print it reversed
                  (format t "reversed neighbor operations:  ~a~%" (reverse ops-list))

                  )))))))
    #+end_src

    #+RESULTS:
    #+begin_example

    ops-list for current-neighbor: (<op:b 1 1 0> <op:a 1 1 0>)
    reversed neighbor operations:  (<op:a 1 1 0> <op:b 1 1 0>)

    ops-list for current-neighbor: (<op:b 1 2 0> <op:a 1 1 0>)
    reversed neighbor operations:  (<op:a 1 1 0> <op:b 1 2 0>)

    ops-list for current-neighbor: (<op:b 2 1 0> <op:a 1 1 0>)
    reversed neighbor operations:  (<op:a 1 1 0> <op:b 2 1 0>)

    ops-list for current-neighbor: (<op:b 2 2 0> <op:a 1 1 0>)
    reversed neighbor operations:  (<op:a 1 1 0> <op:b 2 2 0>)

    ops-list for current-neighbor: (<op:b 2 3 0> <op:a 1 1 0>)
    reversed neighbor operations:  (<op:a 1 1 0> <op:b 2 3 0>)

    ops-list for current-neighbor: (<op:b 1 1 0> <op:a 1 2 0>)
    reversed neighbor operations:  (<op:a 1 2 0> <op:b 1 1 0>)

    ops-list for current-neighbor: (<op:b 1 2 0> <op:a 1 2 0>)
    reversed neighbor operations:  (<op:a 1 2 0> <op:b 1 2 0>)

    ops-list for current-neighbor: (<op:b 2 1 0> <op:a 1 2 0>)
    reversed neighbor operations:  (<op:a 1 2 0> <op:b 2 1 0>)

    ops-list for current-neighbor: (<op:b 2 2 0> <op:a 1 2 0>)
    reversed neighbor operations:  (<op:a 1 2 0> <op:b 2 2 0>)

    ops-list for current-neighbor: (<op:b 2 3 0> <op:a 1 2 0>)
    reversed neighbor operations:  (<op:a 1 2 0> <op:b 2 3 0>)

    ops-list for current-neighbor: (<op:b 1 1 0> <op:a 2 1 0>)
    reversed neighbor operations:  (<op:a 2 1 0> <op:b 1 1 0>)

    ops-list for current-neighbor: (<op:b 1 2 0> <op:a 2 1 0>)
    reversed neighbor operations:  (<op:a 2 1 0> <op:b 1 2 0>)

    ops-list for current-neighbor: (<op:b 1 3 0> <op:a 2 1 0>)
    reversed neighbor operations:  (<op:a 2 1 0> <op:b 1 3 0>)

    ops-list for current-neighbor: (<op:b 2 1 0> <op:a 2 1 0>)
    reversed neighbor operations:  (<op:a 2 1 0> <op:b 2 1 0>)

    ops-list for current-neighbor: (<op:b 2 2 0> <op:a 2 1 0>)
    reversed neighbor operations:  (<op:a 2 1 0> <op:b 2 2 0>)

    ops-list for current-neighbor: (<op:b 1 1 0> <op:a 2 2 0>)
    reversed neighbor operations:  (<op:a 2 2 0> <op:b 1 1 0>)

    ops-list for current-neighbor: (<op:b 1 2 0> <op:a 2 2 0>)
    reversed neighbor operations:  (<op:a 2 2 0> <op:b 1 2 0>)

    ops-list for current-neighbor: (<op:b 1 3 0> <op:a 2 2 0>)
    reversed neighbor operations:  (<op:a 2 2 0> <op:b 1 3 0>)

    ops-list for current-neighbor: (<op:b 2 1 0> <op:a 2 2 0>)
    reversed neighbor operations:  (<op:a 2 2 0> <op:b 2 1 0>)

    ops-list for current-neighbor: (<op:b 2 2 0> <op:a 2 2 0>)
    reversed neighbor operations:  (<op:a 2 2 0> <op:b 2 2 0>)
    #+end_example

      And this should be enough: to explore a neighborhood use the approriate macros and in the body of those macros, do whatever you want, for instance, evaluate the solutions.

      Here is a list of all the macros available in 2021-03-17.  In the following list, wc is the working copy, r is in the positions where a route is expected, c, c1 and c2 are in positions where clients are expected, s2 s1 and s2 are in positions where a subroute is expected.

      - doselect-route (r wc)
      - doselect-client (c r wc)
      - doinsert-client (c r wc)
      - doswap-clients (c1 c2 wc)
      - doselect-subroute (s r wc)
      - doinsert-subroute (s r wc)
      - doreverse-subroute (s wc)
      - doswap-subroutes (s1 s2 wc)

      The operation reverse-subroute should be used after the subroute has been selected, and before it is inserted.


* How to use the new smart strategies and actions (2019-01-09)
** Requirements
   It is assumed that the reader is familiar with the following ideas and concepts:
   - search-strategies
   - selection-strategies
   - delta-cost-actions


   Right now we have added the following new strategies:

   - *exhaustive-search-strategy*
   - *first-improvement*
   - *best-improvement*
   - *random-improvement*

   and a new action, that should be used with these strategies:

   - delta-cvrp-action*


   The main difference of these new strategies and action with the old ones is that when we use this ones, the computation of the delta-cost is optimized and runtime is reduced.

   In the current state, there are two ways to use them, in a VNS *without* shake and with shake.  I'll write a section for each case:
    
** VNS *without* shake

   To use these new strategies in a (I)VNS *without shake*, the only thing to do is to use them instead of the old ones.

   For instance, where we had something like:

   #+BEGIN_EXAMPLE
   (vns-code problem s1 criteria
       :search-strategy +exhaustive-search-strategy+
       :selection-strategy +random-improvement+
       :action (delta-cvrp-action))
   #+END_EXAMPLE

   we should have:

   #+BEGIN_EXAMPLE
   (vns-code problem s1 criteria
       :search-strategy *exhaustive-search-strategy*
       :selection-strategy *random-improvement*
       :action (delta-cvrp-action*))
   #+END_EXAMPLE
    
   In a lower level approach, the only significant difference is the following:
   In the code, where we called the function =make-neighborhood-criterion= with the older strategies:
    
  #+BEGIN_EXAMPLE
  (make-neighborhood-criterion
   criterion-code
   +exhaustive-search-strategy+
   +random-improvement+)
  #+END_EXAMPLE

  We should call them now with the *ed ones:

  #+BEGIN_EXAMPLE
  (make-neighborhood-criterion
   criterion-code
   *exhaustive-search-strategy*
   *random-improvement*)
  #+END_EXAMPLE
   
** VNS *with* shake

   When there is a shake in the VNS there is something else to take into account: the neighborhood-search used in the shake should not use these strategies or action, and we need to use the old ones.

   This means that when we are going to shake the solution, we should create the criterion as we did before:
   #+BEGIN_EXAMPLE
   (setf shake-function
         (make-neighborhood-criterion
          criterion-description
          +jump-around-strategy+
          +jump-around-return-last-neighbor+))
   #+END_EXAMPLE

   and when we call this function we should do it with a =delta-cvrp-action= instead of a =delta-cvrp-action*=.  The correct way to call this function should be something like:

   #+BEGIN_EXAMPLE
   (funcall shake-function
            current-solution
            problem
            (delta-cvrp-action))
   #+END_EXAMPLE

   Otherwise, we get a really ugly "heap exhausted" error, and none of us want that, right?

   The other call to the "inner-vns" can (and should) be done with the *ed strategies and actions.

   For more details and a working example, you can check the function =vns-shake-smart= and the test for it.


* Tutorial for Heidy (search and selection strategies)
** Description
   Here we'll describe how to use the classes and methods in the suite to explore a neighborhood.

   To do that, we'll need to understand solutions, problems, the operations that we can do with them, and the exploration macros.
** initialization of the system
*** Tutorial on 2019-02-13
    1. Copy the contents of the folders src/ and data/ to the folder lisptick.
    2. in the REPL,  (load "src/vrp-load-files.lisp")
    3. Write your code in a file tarea1.lisp
    4. save it and execute: (load "tarea1.lisp")
*** Tutorial from 2019-02-20 on
    1. Copy the contents of the folders src/ and data/ to the folder lisptick.
    2. Execute run.bat
    3. in the REPL,  (load "src/vrp-load-files.lisp")
    4. in the REPL, type (in-package :vrp)
    5. Write your code in a file tarea1.lisp, and save this file
    6. in the REPL type: (load "tarea1.lisp")
** Solutions: properties and pretty-printing them

   A basic solution has
   - an id
   - a list with routes
   - a cost

   The easiest way to use a solution is to use the macro =with-basic-solution= like this:

    #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
    (with-basic-solution (s1 ((1 2 3)
                              (4 5)
                              (6 7 8)))
      ;; code here
      ;; where you car reference a basic-solution s1
      ;; for instance, we can just print it
      (print s1))
    #+END_SRC

    #+RESULTS:
    : 
    : S1: (0)
    :   <r1: <v:1> (<d:0>: (<c:1> <c:2> <c:3>))>
    :   <r2: <v:2> (<d:0>: (<c:4> <c:5>))>
    :   <r3: <v:3> (<d:0>: (<c:6> <c:7> <c:8>))>
    :  

    What we got as the result of the evaluation of the previous code is the what the print-object method prints.

    In the next example, we'll print all the properties of the solution:

    #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
    (with-basic-solution (s1 ((1 2 3)
                              (4 5)
                              (6 7 8)))
      ;; code here
      ;; where you car reference a basic-solution s1
      ;; for instance, we can just print it
      (bformat t "Printing the properties of the solution")
  
      (format t "id: ~a~%" (id s1))
      (loop for r in (routes s1)
            for i from 1
            do (format t "route ~a: ~a~%" i r))
      (format t "costs: ~a~%" (cost s1)))
    #+END_SRC
     
    What we see in the print-object of the route: 

    <r1: <v:1> (<d:0>: (<c:1> <c:2> <c:3>))>

    - r1 :: r stands for route, and the 1 is the id.
    - <v:1> :: is the print-object of the basic vehicle.  v stand for vehicle and 1 is the id of the vehicle.
    - <d:0> :: is the depot (0 is the id)
    - <c:i> :: are the basic-clients.  the number is the id.

    Cost is 0 because that's the default value and we haven't changed that.

    There is a better way to print a solution using the function pp-solution:

    #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
       (with-basic-solution (s1 ((1 2 3)
                                 (4 5)
                                 (6 7 8)))
         ;; code here
         ;; where you car reference a basic-solution s1
         ;; for instance, we can just print it
         (bformat t "Pretty printing a solution")
         (pp-solution s1 t))
    #+END_SRC

    #+RESULTS:
    : ============================
    :  Pretty printing a solution
    : ============================
    : 
    : S1:
    :     R1: (1, 2, 3)
    :     R2: (4, 5)
    :     R3: (6, 7, 8)
     
    This is a (better?) way to print the solution, if you are not interested in other properties.
** Basic operations on solutions
   In this section we introduce the basic operations.
*** basic operations 
    A basic-operation is a class.  There are two very basic operations: select-client and insert-client, and they both inherit from neighborhood-operation.
**** neighborhood-operation
     This is a base class for the operations in a neighborhood.  It has a route and a position (this pair is called a coordinate) and a number identifying the client that should be operated.

     For example, we could have an instance of =neighborhood-operation= with following values:

     (neighborhood-operation r p index)

     And this means to "operate" the client in the route r, in the position p, and let's label it with the vaule index.

     For example, we could have the following:

     (select-client 2 1 0)

     And this means to select the client in the route 2, in the position 1 and we'll label this selection with the index 0.

     The index is important because later, when we want to insert the client selected in this operation, we can refer to it as the client selected at the operation 0.  Let's see this in action in each of the operations.

**** select-client
***** creating the operation
      The class select-client has the same slots as neighborhood-operation: route, position and index, and the constructor is: op-select-client.

      So we can make something like:

    #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
           (with-basic-solution (s1 ((1 2 3)
                                     (4 5)
                                     (6 7 8)))

             (let* ((op1 (op-select-client 1 2 0)))

               (bformat t "Creating a select-client-operation")

              (format t "operation: ~a~%" op1)))
     #+END_SRC

     #+RESULTS:
     : ====================================
     :  Creating a select-client-operation
     : ====================================
     : 
     : operation: <op:a 1 2 0>


     In this case, the output of the print-object method is:
     - a :: to represent the operation select-client
     - 1 :: is the route from where the selection should be made
     - 2 :: is the position in the route
     - 0 :: is the index of the operation.

     An so far, we have an operation, but we haven't done anything with it yet :-(.  In the next section we'll modify the solution :-o.

***** actually applying the operations to the solution

      Actually, we don't want to modify the solution, we want to simulate that modification, to make the exploration of the neighborhood faster.

      In order to simulate the operations we need to create an instance of basic-working-copy.  A working-copy is an objects that simulates the changes made to the solution without actually doing them.

      In the next section, we'll learn how to create a basic-working-copy.
****** the basic-working-copy

******* creating the basic-working-copy
        The constructor of the basic-working-copy is basic-working-copy and receives a solution.

     #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
     (with-basic-solution (s1 ((1 2 3)
                               (4 5)
                               (6 7 8)))
       (bformat t "Creating a basic-working-copy")
       (let* ((wc (basic-working-copy s1)
                ;; we just created the working-copy
                ))
         ;; let's print the solution
         (pp-solution s1 t)
         ;; let's print the working-copy
         ;; we can use again the function
         ;; pp-solution
         ;; but if we do that...
         (format t "Now the working-copy:~%")
         (pp-solution wc t)
         ;; it doesn't print anything
         ))
     #+END_SRC

******* initializing the basic-working-copy
        The pp-solution didn't work.  Why?  Because we haven't initialized it yet.  The working-copy needs an initialization that is called =prepare-solution-for-neighborhood-exploration=.  That function sets the value of all the slots and prepares itself for the simulation.

        This is done in the next snippet

     #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
     (with-basic-solution (s1 ((1 2 3)
                               (4 5)
                               (6 7 8)))
       (bformat t "Creating a basic-working-copy")
       (let* ((wc (basic-working-copy s1)
                ;; we just created the working-copy
                ))
         ;; let's print the solution
         (pp-solution s1 t)
         ;; let's print the working-copy
         ;; we can use again the function
         ;; pp-solution
         ;; but if we do that...
         (prepare-solution-for-neighborhood-exploration wc)
         (format t "Now the working-copy:~%")
         (pp-solution wc t)
         ;; and now it prints.
         ))
     #+END_SRC
     
     After we have initialized the working-copy we can start simulating the operations.

****** applying an operation to a working copy
       To do that, we can use the function =simulate-neighborhood-operation=.
       #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
       (with-basic-solution (s1 ((1 2 3)
                                 (4 5)
                                 (6 7 8)))
         (bformat t "Creating a basic-working-copy")
         (let* ((wc (basic-working-copy s1)
                  ;; we just created the working-copy
                  ))

           (let* ((op1 (op-select-client 1 2 0)))

            ;; let's print the working-copy
            ;; we can use the function
            ;; pp-solution
            (prepare-solution-for-neighborhood-exploration wc)
            (format t "Now the working-copy:~%")
            (pp-solution wc t)
            ;; let's simulate the solution
            (format t "Let's simulate the solution (check that the 2 is missing):~%")
            (simulate-neighborhood-operation op1 wc))
            (pp-solution wc t)
           ))
     #+END_SRC

**** insert-client
     To insert a client we need to create an operation for that, and simulate it on the working-copy.

***** creating the solution
      This class is very similar to the select-client operation and it has the same slots: route, position, and index.  In this case, the index indicates what client to insert (from the ones that were selected).

      We can create the operation with op-insert-client
       
      #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
      (with-basic-solution (s1 ((1 2 3)
                                (4 5)
                                (6 7 8)))

        (let* ((op1 (op-insert-client 1 2 0)))

          (bformat t "Creating a select-client-operation")

          (format t "operation: ~a~%" op1)))
     #+END_SRC

     #+RESULTS:
     : ====================================
     :  Creating a select-client-operation
     : ====================================
     : 
     : operation: <op:b 1 2 0>

     In this case, in the print-object of the operation we can also see the route, the position and the index, and the letter b, that represents the insert-client operation.  Important: to create the operation we don't need a solution, or a working-copy, or a previous select-client operation.  We can create as many operations as we want, but if we want to simulate them, we'll need all those things.

***** a complete example
      #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
      (with-basic-solution (s1 ((1 2 3)
                                (4 5)
                                (6 7 8)))
        (bformat t "Creating a basic-working-copy")
        (let* ((wc (basic-working-copy s1)
                 ;; we just created the working-copy
                 ))

          (let* ((op1 (op-select-client 1 2 0)) ;; the selection
                 (op2 (op-insert-client 2 3 0))) ;; the insertion

           ;; let's print the working-copy
           ;; we can use the function
           ;; pp-solution
           (prepare-solution-for-neighborhood-exploration wc)
           (format t "Now the working-copy:~%")
           (pp-solution wc t)
           ;; let's simulate the solution
           (format t "Let's simulate the solution (check that the 2 is missing):~%")
           (simulate-neighborhood-operation op1 wc)
           (pp-solution wc t)

           (format t "Now let's simulate the insertion:~%")
           (format t "Note that now the 2 is in the position (2 3)~%")
           ;; the simulation of the operation
           (simulate-neighborhood-operation op2 wc)
           (pp-solution wc t)
          )))
     #+END_SRC

*** more elaborate operations

    The operations select-client and insert-client are very basic operations.  There are more complex ones as the swap-clients or the select-subroute.

    The operation swap-clients receives two clients and swaps them, and the select-subroute receives a route, a position, a length, and an index.  route, position, and index have the same meaning as in neighborhood-operation.  The length slot means...  the length of the subroute.

    However, if we try to do what we did with op-select-client and op-insert-client with the swap clients, it won't work :-o.  Let's check that they don't work:
     
    #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
    (with-basic-solution (s1 ((1 2 3)
                              (4 5)
                              (6 7 8)))
      (bformat t "Creating a basic-working-copy")
      (let* ((wc (basic-working-copy s1)
               ;; we just created the working-copy
               ))

        (let* ((op1 (op-select-client 1 2 0)) ;; the selection
               (op2 (op-select-client 3 2 1)) ;; the insertion
               (op3 (op-swap-clients 0 1)) ;; the swap
               ;; it only receives the indices of the
               ;; selections that should be swapped
               )

         ;; let's print the working-copy
         ;; we can use the function
         ;; pp-solution
         (prepare-solution-for-neighborhood-exploration wc)
         (format t "Now the working-copy:~%")
         (pp-solution wc t)
         ;; let's simulate the solution
         (format t "Let's simulate the solution (check that the 2 is missing):~%")
         (simulate-neighborhood-operation op1 wc)
         (pp-solution wc t)

         (format t "Now let's simulate the second selection:~%")
         ;; the simulation of the operation
         (simulate-neighborhood-operation op2 wc)
         (pp-solution wc t)

         (format t "Now let's simulate the swap~%")
         (simulate-neighborhood-operation op3 wc)
         (pp-solution wc t)
        )))
     #+END_SRC

     There was a really ugly error somewhere, but it was expected.  The problem is that we can't simulate the operation swap-clients.  Because, that operation can be expressed as two insertions.  That means that the operation swap-clients can be decomposed into simpler operations.

**** get-simpler-operations-from
      There is a function called =get-simpler-operations-from= that receives a "compound operation" and returns a list with the basic-operations that form it.

      For example, let's see the simpler operations that we can get from the swap-clients operations.

     #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
     (with-basic-solution (s1 ((1 2 3)
                               (4 5)
                               (6 7 8)))
       (bformat t "Creating a basic-working-copy")
       (let* ((wc (basic-working-copy s1)
                ;; we just created the working-copy
                ))

         (let* ((op1 (op-select-client 1 2 0)) ;; the selection
                (op2 (op-select-client 3 2 1)) ;; the insertion
                (op3 (op-swap-clients 0 1)) ;; the swap
                ;; it only receives the indices of the
                ;; selections that should be swapped
                (simpler-ops-for-swap nil)
                )

          ;; let's print the working-copy
          ;; we can use the function
          ;; pp-solution
          (prepare-solution-for-neighborhood-exploration wc)
          (format t "Now the working-copy:~%")
          (pp-solution wc t)
          ;; let's simulate the first operation
          (format t "Let's simulate the first selection (check that the 2 is missing):~%")
          (simulate-neighborhood-operation op1 wc)
          (pp-solution wc t)

          (format t "Now let's simulate the second selection:~%")
          ;; the simulation of the second operation
          (simulate-neighborhood-operation op2 wc)
          (pp-solution wc t)

          (format t "Now let's simulate the swap~%")
          (setf simpler-ops-for-swap
                (get-simpler-operations-from op3 wc))
          ;; let's see those operations
          (format t "First insertion from swap: ~a~%"
                  (first simpler-ops-for-swap))
          (format t "Second insertion from swap: ~a~%"
                  (second simpler-ops-for-swap))
          ;; now that we have the simpler operations
          ;; let's simulate them
          ;; the first insertion
          (simulate-neighborhood-operation
           (first simpler-ops-for-swap) wc)
          ;; the second insertion
          (simulate-neighborhood-operation
           (second simpler-ops-for-swap) wc)

     
          (format t "Solution after the swap:~%")
          (pp-solution wc t)
         )))
      #+END_SRC

      #+RESULTS:
      #+begin_example
      ===============================
       Creating a basic-working-copy
      ===============================

      Now the working-copy:
      S1:
	  R1: (1, 2, 3)
	  R2: (4, 5)
	  R3: (6, 7, 8)
      Let's simulate the first operation (check that the 2 is missing):
      S1:
	  R1: (1, 3)
	  R2: (4, 5)
	  R3: (6, 7, 8)
      Now let's simulate the second operation:
      S1:
	  R1: (1, 3)
	  R2: (4, 5)
	  R3: (6, 8)
      Now let's simulate the swap
      First insertion from swap: <op:b 1 2 1>
      Second insertion from swap: <op:b 3 2 0>
      Solution after the swap:
      S1:
	  R1: (1, 7, 3)
	  R2: (4, 5)
	  R3: (6, 2, 8)
      #+end_example

      So, if we have a compound operation (that is, if we have a non basic operation) we need to call first the function =get-simpler-operations-from= and then simulate all the operations in that list.

      Then the question becomes: which operations are simple and which are not?  Because the simpler ones we just simulate them, and the compound ones, we need to decompose them first :-(.

      The good news is: it doesn't matter!  You can call the function =get-simpler-operations-from= even with the simpler operations.  In that case, that method returns the simpler operation.

      For instance, let's get the simpler-operations from a select-client and from a swap-clients.

      #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
      (with-basic-solution (s1 ((1 2 3)
                                (4 5)
                                (6 7 8)))
        (bformat t "Creating a basic-working-copy")
        (let* ((wc (basic-working-copy s1)
                 ;; we just created the working-copy
                    ))

          (let* ((op1 (op-select-client 1 2 0))
                 (op2 (op-select-client 3 2 1))
                 (op3 (op-swap-clients 0 1)))

            ;; let's initialize the working-copy
            (prepare-solution-for-neighborhood-exploration wc)

            (format t "Now let's get the simpler ops from select-client:~%")

            (format t "simpler-ops-from ~a:~%  ~a~2%"
                    op1 (get-simpler-operations-from op1 wc))

            (format t "Now let's get the simpler ops from swap-clients:~%")

            ;; to get the simpler operations from a swap
            ;; we need to simulate the previous operations

            (dolist (op (list op1 op2))
              (simulate-neighborhood-operation op wc))

            (format t "simpler-ops-from ~a:~%  ~a~%"
                    op3
                    (get-simpler-operations-from op3 wc))

      
            )))
      #+END_SRC

      #+RESULTS:
      #+begin_example
      ===============================
       Creating a basic-working-copy
      ===============================

      Now let's get the simpler ops from select-client:
      simpler-ops-from <op:a 1 2 0>:
	(<op:a 1 2 0>)

      Now let's get the simpler ops from swap-clients:
      simpler-ops-from <op:s 0 1>:
	(<op:b 1 2 1> <op:b 3 2 0>)
      #+end_example

**** the proper way to simulate any operation
     With the information we have so far, the proper way to simulate an operation op should be
     1. get all the simpler-operations for that op
     2. simulate all the simpler-ops

     That can be done like this:
     #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
     (with-basic-solution (s1 ((1 2 3)
                               (4 5)
                               (6 7 8)))
       (bformat t "Creating a basic-working-copy")
       (let* ((wc (basic-working-copy s1)
                ;; we just created the working-copy
                ))

         (let* ((op1 (op-select-client 1 2 0)) ;; the selection
                (op2 (op-select-client 3 2 1)) ;; the insertion
                (op3 (op-swap-clients 0 1)) ;; the swap
                ;; it only receives the indices of the
                ;; selections that should be swapped
                )

          ;; let's print the working-copy
          ;; we can use the function
          ;; pp-solution
          (prepare-solution-for-neighborhood-exploration wc)
          (format t "Now the working-copy:~%")
          (pp-solution wc t)
          ;; let's simulate the solution
          (format t "Let's simulate the solution (check that the 2 is missing):~%")
          ;; instead of simulating the operation
          ;; let's simulate all the simpler-ops
          (dolist (op (get-simpler-operations-from op1 wc))
            (simulate-neighborhood-operation op wc))
     
          (pp-solution wc t)

          (format t "Now let's simulate the second selection:~%")
          ;; the simulation of the operation
          (dolist (op (get-simpler-operations-from op2 wc))
            (simulate-neighborhood-operation op wc))
          (pp-solution wc t)

          (format t "Now let's simulate the swap~%")
          (dolist (op (get-simpler-operations-from op3 wc))
            (simulate-neighborhood-operation op wc))


          (format t "Solution after the swap:~%")
          (pp-solution wc t)
         )))
      #+END_SRC

      #+RESULTS:
      #+begin_example
      ===============================
       Creating a basic-working-copy
      ===============================

      Now the working-copy:
      S1:
          R1: (1, 2, 3)
          R2: (4, 5)
          R3: (6, 7, 8)
      Let's simulate the solution (check that the 2 is missing):
      S1:
          R1: (1, 3)
          R2: (4, 5)
          R3: (6, 7, 8)
      Now let's simulate the second selection:
      S1:
          R1: (1, 3)
          R2: (4, 5)
          R3: (6, 8)
      Now let's simulate the swap
      Solution after the swap:
      S1:
          R1: (1, 7, 3)
          R2: (4, 5)
          R3: (6, 2, 8)
      #+end_example
** Undoing an operation
   We also have a method to undo an operation.  To undo an operation means to restore the working-copy to the state it was before the simulation of the operation.  This function is called =undo-neighborhood-operation=.  Let's see how it works:

     #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
     (with-basic-solution (s1 ((1 2 3)
                               (4 5)
                               (6 7 8)))
       (bformat t "Creating a basic-working-copy")
       (let* ((wc (basic-working-copy s1)
                ;; we just created the working-copy
                ))

         (let* ((op1 (op-select-client 1 2 0)) ;; the selection
                )

          ;; let's print the working-copy
          ;; we can use the function
          ;; pp-solution
          (prepare-solution-for-neighborhood-exploration wc)
          (format t "Now the working-copy:~%")
          (pp-solution wc t)
          ;; let's simulate the operation
          (format t "Let's simulate the solution (check that the 2 is missing):~%")
          ;; instead of simulating the operation
          ;; let's simulate all the simpler-ops
          (dolist (op (get-simpler-operations-from op1 wc))
            (simulate-neighborhood-operation op wc))

          (pp-solution wc t)

          ;; now, let's undo that operation
          (undo-neighborhood-operation op1 wc)
          (format t "Solution after the undo:~%")
          (pp-solution wc t)
         )))
      #+END_SRC

      #+RESULTS:
      #+begin_example
      ===============================
       Creating a basic-working-copy
      ===============================

      Now the working-copy:
      S1:
          R1: (1, 2, 3)
          R2: (4, 5)
          R3: (6, 7, 8)
      Let's simulate the solution (check that the 2 is missing):
      S1:
          R1: (1, 3)
          R2: (4, 5)
          R3: (6, 7, 8)
      Solution after the undo:
      S1:
          R1: (1, 2, 3)
          R2: (4, 5)
          R3: (6, 7, 8)
      #+end_example

      *Important note: the operations should be undone in the reverse order as they were simulated, and that order is important.*

      Let's see that in the case of the swap-clients

     #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
     (with-basic-solution (s1 ((1 2 3)
                               (4 5)
                               (6 7 8)))
       (bformat t "Creating a basic-working-copy")
       (let* ((wc (basic-working-copy s1)
                ;; we just created the working-copy
                ))

         (let* ((op1 (op-select-client 1 2 0)) ;; the selection
                (op2 (op-select-client 3 2 1)) ;; the insertion
                (op3 (op-swap-clients 0 1)) ;; the swap
                ;; it only receives the indices of the
                ;; selections that should be swapped
                )

          ;; let's print the working-copy
          ;; we can use the function
          ;; pp-solution
          (prepare-solution-for-neighborhood-exploration wc)
          (format t "Now the working-copy:~%")
          (pp-solution wc t)
          ;; let's simulate the solution
          (format t "Let's simulate the solution (check that the 2 is missing):~%")
          ;; instead of simulating the operation
          ;; let's simulate all the simpler-ops
          (dolist (op (get-simpler-operations-from op1 wc))
            (simulate-neighborhood-operation op wc))

          (pp-solution wc t)

          (format t "Now let's simulate the second selection:~%")
          ;; the simulation of the operation
          (dolist (op (get-simpler-operations-from op2 wc))
            (simulate-neighborhood-operation op wc))
          (pp-solution wc t)

          (format t "Now let's simulate the swap~%")
          (dolist (op (get-simpler-operations-from op3 wc))
            (simulate-neighborhood-operation op wc))

          (format t "Solution after the swap:~%")
          (pp-solution wc t)

     
          (format t "Let's undo the swap~%")
          (dolist (op (reverse (get-simpler-operations-from op3 wc)))
            (undo-neighborhood-operation op wc))

          (format t "Solution after undoing the swap:~%")
          (pp-solution wc t)

          (format t "Let's undo the second selection~%")
          (dolist (op (reverse (get-simpler-operations-from op2 wc)))
            (undo-neighborhood-operation op wc))
          (format t "Solution after undoing the second selection:~%")
          (pp-solution wc t)


          (format t "Let's undo the first selection~%")
          (dolist (op (reverse (get-simpler-operations-from op1 wc)))
            (undo-neighborhood-operation op wc))
          (format t "Solution after undoing the first selection:~%")
          (pp-solution wc t)

     
         )))
      #+END_SRC

     #+RESULTS:
      #+begin_example
      ===============================
       Creating a basic-working-copy
      ===============================

      Now the working-copy:
      S1:
          R1: (1, 2, 3)
          R2: (4, 5)
          R3: (6, 7, 8)
      Let's simulate the solution (check that the 2 is missing):
      S1:
          R1: (1, 3)
          R2: (4, 5)
          R3: (6, 7, 8)
      Now let's simulate the second selection:
      S1:
          R1: (1, 3)
          R2: (4, 5)
          R3: (6, 8)
      Now let's simulate the swap
      Solution after the swap:
      S1:
          R1: (1, 7, 3)
          R2: (4, 5)
          R3: (6, 2, 8)
      Let's undo the swap
      Solution after undoing the swap:
      S1:
          R1: (1, 3)
          R2: (4, 5)
          R3: (6, 8)
      Let's undo the second selection
      Solution after undoing the second selection:
      S1:
          R1: (1, 3)
          R2: (4, 5)
          R3: (6, 7, 8)
      Let's undo the first selection
      Solution after undoing the first selection:
      S1:
          R1: (1, 2, 3)
          R2: (4, 5)
          R3: (6, 7, 8)
      #+end_example
** applying an operation
   So far we have just simulated the operations, but if we want, we can apply the operations to a working-copy and then we can obtain a new solution.

   Let's see that.
   #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
   (with-basic-solution (s1 ((1 2 3)
                             (4 5)
                             (6 7 8)))
     (bformat t "Creating a basic-working-copy")
     (let* ((wc (basic-working-copy s1)
              ;; we just created the working-copy
                 ))

       (let* ((op1 (op-select-client 1 2 0)) ;; the selection
              (op2 (op-select-client 3 2 1)) ;; the insertion
              (op3 (op-swap-clients 0 1)) ;; the swap
              ;; it only receives the indices of the
              ;; selections that should be swapped
              )

         ;; let's print the working-copy
         ;; we can use the function
         ;; pp-solution
         (prepare-solution-for-neighborhood-exploration wc)
         (format t "Now the working-copy:~%")
         (pp-solution wc t)
         ;; let's simulate the solution
         (format t "Let's simulate the solution (check that the 2 is missing):~%")
         ;; instead of simulating the operation
         ;; let's simulate all the simpler-ops
         (dolist (op (get-simpler-operations-from op1 wc))
           (simulate-neighborhood-operation op wc))

         (pp-solution wc t)

         (format t "Now let's simulate the second selection:~%")
         ;; the simulation of the operation
         (dolist (op (get-simpler-operations-from op2 wc))
           (simulate-neighborhood-operation op wc))
         (pp-solution wc t)

         (format t "Now let's simulate the swap~%")
         (dolist (op (get-simpler-operations-from op3 wc))
           (simulate-neighborhood-operation op wc))

         (format t "Solution after the swap:~%")
         (pp-solution wc t)

         ;; here we can get the solution from which
         ;; the working-copy was created.
         ;; We can do that with the =solution= method.
         (format t "And this was the original solution: ~%")
         (pp-solution (solution wc) t)

         )))
      #+END_SRC

      #+RESULTS:
      #+begin_example
      ===============================
       Creating a basic-working-copy
      ===============================

      Now the working-copy:
      S1:
	  R1: (1, 2, 3)
	  R2: (4, 5)
	  R3: (6, 7, 8)
      Let's simulate the solution (check that the 2 is missing):
      S1:
	  R1: (1, 3)
	  R2: (4, 5)
	  R3: (6, 7, 8)
      Now let's simulate the second selection:
      S1:
	  R1: (1, 3)
	  R2: (4, 5)
	  R3: (6, 8)
      Now let's simulate the swap
      Solution after the swap:
      S1:
	  R1: (1, 7, 3)
	  R2: (4, 5)
	  R3: (6, 2, 8)
      And this was the original solution: 
      S1:
	  R1: (1, 2, 3)
	  R2: (4, 5)
	  R3: (6, 7, 8)
      #+end_example
      
   Now, let's apply the operations so we can get a new solution.
   #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
   (with-basic-solution (s1 ((1 2 3)
                             (4 5)
                             (6 7 8)))
     (bformat t "Creating a basic-working-copy")
     (let* ((wc (basic-working-copy s1)
              ;; we just created the working-copy
                 ))

       (let* ((op1 (op-select-client 1 2 0)) ;; the selection
              (op2 (op-select-client 3 2 1)) ;; the insertion
              (op3 (op-swap-clients 0 1)) ;; the swap
              ;; it only receives the indices of the
              ;; selections that should be swapped
              (list-with-all-the-operations nil)
              )

         ;; let's print the working-copy
         ;; we can use the function
         ;; pp-solution
         (prepare-solution-for-neighborhood-exploration wc)
         (format t "Now the working-copy:~%")
         (pp-solution wc t)
         ;; let's simulate the solution
         (format t "Let's simulate the solution (check that the 2 is missing):~%")
         ;; instead of simulating the operation
         ;; let's simulate all the simpler-ops
         (dolist (op (get-simpler-operations-from op1 wc))
           (simulate-neighborhood-operation op wc)
           (push op list-with-all-the-operations))

         (pp-solution wc t)

         (format t "Now let's simulate the second selection:~%")
         ;; the simulation of the operation
         (dolist (op (get-simpler-operations-from op2 wc))
           (simulate-neighborhood-operation op wc)
           (push op list-with-all-the-operations))
         (pp-solution wc t)

         (format t "Now let's simulate the swap~%")
         (dolist (op (get-simpler-operations-from op3 wc))
           (simulate-neighborhood-operation op wc)
           (push op list-with-all-the-operations))

         (format t "Solution after the swap:~%")
         (pp-solution wc t)

         ;; here we can get the solution from which
         ;; the working-copy was created.
         ;; We can do that with the =solution= method.
         (format t "And this was the original solution: ~%")
         (pp-solution (solution wc) t)

         (format t "List with all the operations:~%~a~2%"
                 list-with-all-the-operations)


         (format t "Here we apply the operations...~%")
         ;; now let's apply the operations
         ;; for that we have a function:
         ;; apply-set-of-operations
         (apply-set-of-operations
          ;; we need to reverse the list-with-all-the-operations
          ;; because they were pushed instead
          ;; of appended
          (reverse list-with-all-the-operations)
          wc)

         (format t "And this is now the solution we have in the working-copy~%")
         (pp-solution (solution wc) t)



         )))
   #+END_SRC

   #+RESULTS:
   #+begin_example
   ===============================
    Creating a basic-working-copy
   ===============================

   Now the working-copy:
   S1:
       R1: (1, 2, 3)
       R2: (4, 5)
       R3: (6, 7, 8)
   Let's simulate the solution (check that the 2 is missing):
   S1:
       R1: (1, 3)
       R2: (4, 5)
       R3: (6, 7, 8)
   Now let's simulate the second selection:
   S1:
       R1: (1, 3)
       R2: (4, 5)
       R3: (6, 8)
   Now let's simulate the swap
   Solution after the swap:
   S1:
       R1: (1, 7, 3)
       R2: (4, 5)
       R3: (6, 2, 8)
   And this was the original solution: 
   S1:
       R1: (1, 2, 3)
       R2: (4, 5)
       R3: (6, 7, 8)
   List with all the operations:
   (<op:b 3 2 0> <op:b 1 2 1> <op:a 3 2 1> <op:a 1 2 0>)

   Here we apply the operations...
   And this is now the solution we have in the working-copy
   S1:
       R1: (1, 7, 3)
       R2: (4, 5)
       R3: (6, 2, 8)
   #+end_example

   We usually use this, when we have already found a new neighbor, or something like that.
** Let's explore several neighbors
   Let's write a code to select a client from the first route, but let's select from all the possible positions.

     #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
     (with-basic-solution (s1 ((1 2 3 4)
                               (5)
                               (6 7 8)))
       (bformat t "Selecting a client from the 1st route")
       (let* ((wc (basic-working-copy s1)
                ;; we just created the working-copy
                ))

         (let* () ;; we don't need any variable

          ;; let's print the working-copy
          ;; we can use the function
          ;; pp-solution
          (prepare-solution-for-neighborhood-exploration wc)
          (format t "This is the original solution:~%")
          (pp-solution wc t)

          (format t "Let's start the selections~2%")
          ;; let's iterate through all the possible
          ;; positions for the selection
          (loop for pos from 1 to 4
                ;; let's create the selection
                ;; from route 1 and position pos
                ;; and the index always 0
                for op = (op-select-client 1 pos 0)
                doing (progn 
                        ;; let's simulate the operation
                        (dolist (ops (get-simpler-operations-from
                                      op wc))
                          (simulate-neighborhood-operation ops wc))

                        (format t "Selecting client from position: ~a~%"
                                pos)
                        (pp-solution wc t)
                        ;; print a newline
                        (format t "~%"))

                ;; we need to undo the simulation :-o
                doing (progn
                        (dolist (ops
                                  (reverse
                                   (get-simpler-operations-from op wc)))
                          (undo-neighborhood-operation ops wc))))





         )))
      #+END_SRC

      #+RESULTS:
      #+begin_example
      =======================================
       Selecting a client from the 1st route
      =======================================

      This is the original solution:
      S1:
          R1: (1, 2, 3, 4)
          R2: (5)
          R3: (6, 7, 8)
      Let's start the selections

      Selecting client from position: 1
      S1:
          R1: (2, 3, 4)
          R2: (5)
          R3: (6, 7, 8)

      Selecting client from position: 2
      S1:
          R1: (1, 3, 4)
          R2: (5)
          R3: (6, 7, 8)

      Selecting client from position: 3
      S1:
          R1: (1, 2, 4)
          R2: (5)
          R3: (6, 7, 8)

      Selecting client from position: 4
      S1:
          R1: (1, 2, 3)
          R2: (5)
          R3: (6, 7, 8)

      #+end_example
** let's explore the neighborhood 1ab
   In this case, we need to select from the first route, and insert the selected-client into that first route.
     #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
     (with-basic-solution (s1 ((1 2 3 4)
                               (5)
                               (6 7 8)))
       (bformat t "Selecting a client from the 1st route")
       (let* ((wc (basic-working-copy s1)
                ;; we just created the working-copy
                ))

         (let* () ;; we don't need any variable

          ;; let's print the working-copy
          ;; we can use the function
          ;; pp-solution
          (prepare-solution-for-neighborhood-exploration wc)
          (format t "This is the original solution:~%")
          (pp-solution wc t)

          (format t "Let's start the selections~2%")
          ;; let's iterate through all the possible
          ;; positions for the selection
          (loop for pos from 1 to 4
                ;; let's create the selection
                ;; from route 1 and position pos
                ;; and the index always 0
                for op = (op-select-client 1 pos 0)
                doing (progn 
                        ;; let's simulate the operation
                        (dolist (ops (get-simpler-operations-from
                                      op wc))
                          (simulate-neighborhood-operation ops wc)))
           
                do (loop ;; over the posible insert positions
                         for insert-pos from 1 to 4
                         ;; creating an insertion
                         for ins-op = (op-insert-client 1 insert-pos 0)
                         do (progn 
                              ;; let's simulate the operation
                              (dolist (ops (get-simpler-operations-from
                                            ins-op wc))
                                (simulate-neighborhood-operation ops wc)))
                         ;; here we'll do what the user wants
                         ;; in this case, let's print the solution
                         do (progn
                              (format t "Selecting client from position: ~a
     and inserting it at pos ~a~%"
                                     pos insert-pos)
                             (pp-solution wc t)
                             ;; print a newline
                             (format t "~%"))
                         ;; let's undo the insertion
                         do (dolist (ops
                                      (reverse
                                       (get-simpler-operations-from
                                        ins-op wc)))
                              (undo-neighborhood-operation ops wc)))

                ;; we need to undo the simulation :-o
                doing (progn
                        (dolist (ops
                                  (reverse
                                   (get-simpler-operations-from op wc)))
                          (undo-neighborhood-operation ops wc)))))))
      #+END_SRC

      #+RESULTS:
      #+begin_example
      =======================================
       Selecting a client from the 1st route
      =======================================

      This is the original solution:
      S1:
	  R1: (1, 2, 3, 4)
	  R2: (5)
	  R3: (6, 7, 8)
      Let's start the selections

      Selecting client from position: 1
      and inserting it at pos 1
      S1:
	  R1: (1, 2, 3, 4)
	  R2: (5)
	  R3: (6, 7, 8)

      Selecting client from position: 1
      and inserting it at pos 2
      S1:
	  R1: (2, 1, 3, 4)
	  R2: (5)
	  R3: (6, 7, 8)

      Selecting client from position: 1
      and inserting it at pos 3
      S1:
	  R1: (2, 3, 1, 4)
	  R2: (5)
	  R3: (6, 7, 8)

      Selecting client from position: 1
      and inserting it at pos 4
      S1:
	  R1: (2, 3, 4, 1)
	  R2: (5)
	  R3: (6, 7, 8)

      Selecting client from position: 2
      and inserting it at pos 1
      S1:
	  R1: (2, 1, 3, 4)
	  R2: (5)
	  R3: (6, 7, 8)

      Selecting client from position: 2
      and inserting it at pos 2
      S1:
	  R1: (1, 2, 3, 4)
	  R2: (5)
	  R3: (6, 7, 8)

      Selecting client from position: 2
      and inserting it at pos 3
      S1:
	  R1: (1, 3, 2, 4)
	  R2: (5)
	  R3: (6, 7, 8)

      Selecting client from position: 2
      and inserting it at pos 4
      S1:
	  R1: (1, 3, 4, 2)
	  R2: (5)
	  R3: (6, 7, 8)

      Selecting client from position: 3
      and inserting it at pos 1
      S1:
	  R1: (3, 1, 2, 4)
	  R2: (5)
	  R3: (6, 7, 8)

      Selecting client from position: 3
      and inserting it at pos 2
      S1:
	  R1: (1, 3, 2, 4)
	  R2: (5)
	  R3: (6, 7, 8)

      Selecting client from position: 3
      and inserting it at pos 3
      S1:
	  R1: (1, 2, 3, 4)
	  R2: (5)
	  R3: (6, 7, 8)

      Selecting client from position: 3
      and inserting it at pos 4
      S1:
	  R1: (1, 2, 4, 3)
	  R2: (5)
	  R3: (6, 7, 8)

      Selecting client from position: 4
      and inserting it at pos 1
      S1:
	  R1: (4, 1, 2, 3)
	  R2: (5)
	  R3: (6, 7, 8)

      Selecting client from position: 4
      and inserting it at pos 2
      S1:
	  R1: (1, 4, 2, 3)
	  R2: (5)
	  R3: (6, 7, 8)

      Selecting client from position: 4
      and inserting it at pos 3
      S1:
	  R1: (1, 2, 4, 3)
	  R2: (5)
	  R3: (6, 7, 8)

      Selecting client from position: 4
      and inserting it at pos 4
      S1:
	  R1: (1, 2, 3, 4)
	  R2: (5)
	  R3: (6, 7, 8)

      #+end_example

** some notes
*** the class basic-route has a slot named id
    So when you want to iterate through a route, you can use that property.

    For instance, to print the id of the routes in a solution, we can do something like:
    #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
    (with-basic-solution (s1 ((1 2 3)
                              (4 5)
                              (6 7 8)))
      ;; code here
      ;; where you car reference a basic-solution s1
      ;; for instance, we can just print it
      (loop for r in (routes s1)
        ;; read the syntax for loop
            do (format t "route id: ~a~%" (id r))))
    #+END_SRC

    #+RESULTS:
    : route id: 1
    : route id: 2
    : route id: 3

    But we can use the power of the loop macro and do something like:

    #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
    (with-basic-solution (s1 ((1 2 3)
                              (4 5)
                              (6 7 8)))
      ;; code here
      ;; where you car reference a basic-solution s1
      ;; for instance, we can just print it
      (loop for r in (routes s1)
            for id = (id r)
            do (format t "route id: ~a~%" id)))
    #+END_SRC

    #+RESULTS:
    : route id: 1
    : route id: 2
    : route id: 3
*** the class basic-route doesn't have a property route-length
    So if we want to know how many elements are there in a route, we need to =(length (clients route))=.

    Let's check if that work.
    #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
    (with-basic-solution (s1 ((1 2 3)
                              (4 5)
                              (6 7 8)))
      ;; code here
      ;; where you car reference a basic-solution s1
      ;; for instance, we can just print it
      (loop for r in (routes s1)
        ;; read the syntax for loop
            do (format t "length of route ~a: ~a~%"
                       (id r) (length (clients r)))))
    #+END_SRC

    #+RESULTS:
    : length of route 1: 3
    : length of route 2: 2
    : length of route 3: 3
** the powerful macros
   There are some macros that hide all the complexity of the insertion, selection, and any other operations.  These are the =doneighborhood-macros=.

   Some of them are:

    - doselect-route
    - doselect-client
    - doinsert-client
    - doswap-clients

    They all receive the parameters required for the operation (in the case of a selection: the route and the position, for the swap, the two clients that should be swapped, and so on).

    This is how you can use it:
    #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
    (with-basic-solution (s1 ((1 2 3)
                              (4 5)
                              (6 7 8)))
      ;; code here
      ;; where you car reference a basic-solution s1
      ;; for instance, we can just print it
      (let* ((wc (basic-working-copy s1)))
        (prepare-solution-for-neighborhood-exploration wc)
        (doselect-route (r wc)
          (format t "Selecting route: ~a~%" r))))
    #+END_SRC

    Before using any macro (other than doselect-route) we need to initialize a variable called ops-list.

    Another example: this time will be the rab criterion.
    #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
    (with-basic-solution (s1 ((1 2 3)
                              (4 5)
                              (6 7 8)))
      ;; code here
      ;; where you car reference a basic-solution s1
      ;; for instance, we can just print it
      (let* ((wc (basic-working-copy s1))
             (ops-list nil))
        (prepare-solution-for-neighborhood-exploration wc)

        (bformat t "Testing rab with the macros.")
    
        (doselect-route (r wc)
          (doselect-client (c1 r wc)
            (doinsert-client (c1 r wc)
              (pp-solution wc t))))))
    #+END_SRC

    #+RESULTS:
    #+begin_example
    ==============================
     Testing rab with the macros.
    ==============================

    S1:
	R1: (1, 2, 3)
	R2: (4, 5)
	R3: (6, 7, 8)
    S1:
	R1: (2, 1, 3)
	R2: (4, 5)
	R3: (6, 7, 8)
    S1:
	R1: (2, 3, 1)
	R2: (4, 5)
	R3: (6, 7, 8)
    S1:
	R1: (2, 1, 3)
	R2: (4, 5)
	R3: (6, 7, 8)
    S1:
	R1: (1, 2, 3)
	R2: (4, 5)
	R3: (6, 7, 8)
    S1:
	R1: (1, 3, 2)
	R2: (4, 5)
	R3: (6, 7, 8)
    S1:
	R1: (3, 1, 2)
	R2: (4, 5)
	R3: (6, 7, 8)
    S1:
	R1: (1, 3, 2)
	R2: (4, 5)
	R3: (6, 7, 8)
    S1:
	R1: (1, 2, 3)
	R2: (4, 5)
	R3: (6, 7, 8)
    S1:
	R1: (1, 2, 3)
	R2: (4, 5)
	R3: (6, 7, 8)
    S1:
	R1: (1, 2, 3)
	R2: (5, 4)
	R3: (6, 7, 8)
    S1:
	R1: (1, 2, 3)
	R2: (5, 4)
	R3: (6, 7, 8)
    S1:
	R1: (1, 2, 3)
	R2: (4, 5)
	R3: (6, 7, 8)
    S1:
	R1: (1, 2, 3)
	R2: (4, 5)
	R3: (6, 7, 8)
    S1:
	R1: (1, 2, 3)
	R2: (4, 5)
	R3: (7, 6, 8)
    S1:
	R1: (1, 2, 3)
	R2: (4, 5)
	R3: (7, 8, 6)
    S1:
	R1: (1, 2, 3)
	R2: (4, 5)
	R3: (7, 6, 8)
    S1:
	R1: (1, 2, 3)
	R2: (4, 5)
	R3: (6, 7, 8)
    S1:
	R1: (1, 2, 3)
	R2: (4, 5)
	R3: (6, 8, 7)
    S1:
	R1: (1, 2, 3)
	R2: (4, 5)
	R3: (8, 6, 7)
    S1:
	R1: (1, 2, 3)
	R2: (4, 5)
	R3: (6, 8, 7)
    S1:
	R1: (1, 2, 3)
	R2: (4, 5)
	R3: (6, 7, 8)
    #+end_example

    There also are the random-neighborhood macros.  They are just like the =doneighborhood-macros=, but instead of iterating through all the possible neighbors, they just select a random one.

    #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
    (with-basic-solution (s1 ((1 2 3 4 5)
                              (6 7 8 9 10 11)))
      ;; code here
      ;; where you car reference a basic-solution s1
      ;; for instance, we can just print it
      (let* ((wc (basic-working-copy s1))
             (ops-list nil))
        (prepare-solution-for-neighborhood-exploration wc)

        (bformat t "Testing rab with the macros.")

        (random-select-route (r wc)
          (random-select-client (c1 r wc)
            (random-insert-client (c1 r wc)
              (pp-solution wc t))))))
    #+END_SRC
** The automatic code generation
   There was a very exhaustive conversation about the class hierarchies that allow us to automatically create the code for the exploration.

   If you know your way with these classes, then you could do something like:

   #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-basic-solution (s1 ((1 2 3) (4 5)))
        (let* ((action t)
               (neighborhood-description `((select-route r1)
                                           (select-client c1 from r1)
                                           (insert-client c1 into r1)))
               (bp (basic-strategy-blueprint))
               )

          (bformat t "Creating a criterion to explore the neighborhood")

          (progn ;; 

            ;; the following line sets up the blueprint
            ;; with the desired strategies
            (prepare-blueprint-for-code-generation 
             neighborhood-description
             +exhaustive-search-strategy+ 
             +search-with-a-basic-wc+
             bp)

            ;; in this case we just want to explore
            ;; with a basic solution, no cost calculation
            ;; not anything

            ;; when the blueprint is ready
            ;; we can call the function
            ;; write-neighborhood-exploration-code
            ;; that receives a blueprint
            ;; and optionally, the code that we
            ;; want to execute inside the macros
            ;; In the following example, that code is
            ;; to print the solution and to print a
            ;; newline.
            ;;
            ;; IMPORTANT: the instructions will be
            ;; added to a stack, so they should be
            ;; added in the reverse order.
            ;;
            ;; The following line writes the generated
            ;; code

            (format t "code: ~s~%"
                    (write-neighborhood-exploration-code
                     bp
                     :inside-macro `((terpri) (pp-solution wc t))
                     )))))
   #+END_SRC

   This is the result.

   #+RESULTS:
   #+begin_example
   ==================================================
    Creating a criterion to explore the neighborhood
   ==================================================

   code: (LAMBDA (SOLUTION PROBLEM ACTION &OPTIONAL (INITIAL-BEST-DELTA-COST 0))
           (DECLARE (IGNORABLE INITIAL-BEST-DELTA-COST SOLUTION PROBLEM ACTION))
           (LET* ((*VRP-STOP-NEIGHBORHOOD-SEARCH* NIL)
                  (OPS-LIST NIL)
                  (WC (BASIC-WORKING-COPY (CLONE SOLUTION))))
             (PREPARE-SOLUTION-FOR-NEIGHBORHOOD-EXPLORATION WC)
             (DOSELECT-ROUTE (R1 WC)
               (DOSELECT-CLIENT (C1 R1 WC)
                 (DOINSERT-CLIENT (C1 R1 WC)
                   (PP-SOLUTION WC T)
                   (TERPRI))))
             (VALUES)))
   #+end_example

   What if we want to do more things, such as computing delta-cost and things like that...  Then we use a different class as the second parameter to =prepare-blueprint-for-code-generation=.

   For example, let's compute the delta-cost inefficiently:

   
   #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
   (with-basic-solution (s1 ((1 2 3) (4 5)))
     (let* ((action t)
            (neighborhood-description `((select-route r1)
                                        (select-client c1 from r1)
                                        (insert-client c1 into r1)))
            (bp (basic-strategy-blueprint)))

       (bformat t "Creating a criterion to explore the neighborhood")

       (progn ;; 

         ;; the following line sets up the blueprint
         ;; with the desired strategies
         (prepare-blueprint-for-code-generation 
          neighborhood-description
          +exhaustive-search-strategy+ 
          (make-instance 'compute-delta-cost-inefficiently)
          bp)

         ;; in this case we just want to explore
         ;; with a basic solution, no cost calculation
         ;; not anything

         ;; when the blueprint is ready
         ;; we can call the function
         ;; write-neighborhood-exploration-code
         ;; that receives a blueprint
         ;; and optionally, the code that we
         ;; want to execute inside the macros
         ;; In the following example, that code is
         ;; to print the solution and to print a
         ;; newline.
         ;;
         ;; IMPORTANT: the instructions will be
         ;; added to a stack, so they should be
         ;; added in the reverse order.
         ;;
         ;; The following line writes the generated
         ;; code

         (format t "code: ~s~%"
                 (write-neighborhood-exploration-code
                  bp
                  :inside-macro `((terpri) (pp-solution wc t))
                  )))))
   #+END_SRC
   
   

    
** homework

*** <2019-02-14 jue> [2/2]
    1. [X] Write a code to explore the neighborhood rab
       This is just what we did, but you also need to iterate through all the routes.
    2. [X] Write a code to explore the neighborhood raac
       This: select-two clients from a route, and swap them.
*** <2019-02-20 mié> [2/2]
    1. [X] Fix raac
    2. [X] Add random exploration for rab and raac
*** <2019-02-25 lun> [3/3]
    1. [X] Implement the following criteria (exhaustive and random)
       - rarac
       - ref (insert subroute)
         - e :: select-subroute
         - f :: insert-subroute
         - g :: swap-subroutes

          *Note:*

          In the random version, use a parameter to call the random-neighborhood macros that number of times.  For instance, instead of writing
          #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
       (with-basic-solution (s1 ((1 2 3)
                                 (4 5)
                                 (6 7 8)))
         ;; code here
         ;; where you car reference a basic-solution s1
         ;; for instance, we can just print it
         (let* ((wc (basic-working-copy s1))
                (ops-list nil))
           (prepare-solution-for-neighborhood-exploration wc)

           (random-select-route (r wc)
             (random-select-client (c1 r wc)
               (random-insert-client (c1 r wc)
                 ;;;; your code here
                 )))))
       #+END_SRC

          use
       
          #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
       (with-basic-solution (s1 ((1 2 3)
                                 (4 5)
                                 (6 7 8)))
         ;; code here
         ;; where you car reference a basic-solution s1
         ;; for instance, we can just print it
         (let* ((wc (basic-working-copy s1))
                (ops-list nil))
           (prepare-solution-for-neighborhood-exploration wc)

           (dotimes (i 10)
             (random-select-route (r wc)
               (random-select-client (c1 r wc)
                 (random-insert-client (c1 r wc)
                   ;; your code here
                   ))))))
       #+END_SRC

              and that =10= is the number of random-neighbors that you'll explore. 
    2. [X] From an exhaustive search of rab, return the best neighbor.
       - read the examples from the looooong document.
    3. [X] From a random search of rab, return the best-neighbor.
*** <2019-03-14 jue> [0/3]
    1. [ ] Rewrite all the methods in the previous tasks using the classes and the automatic code generation mechanism.

       Los mismos que hiciste a mano, fijarte del tutorial anterior y llamar a la función =prepare-blueprint-for-code-generation= con las instancias de clases apropiadas.

    2. [ ] Crea nuevas clases que nos permitan agregar el contador.  Ese es el tutorial "bobito".  Para eso hacen falta varias cosas:
       a) Crear la clase apropiada (pueden ser más de una, pero no lo creo.)
       b) Agregar nuevos métodos a las funciones que actualizan al instancia del "blueprint" en cada una de sus partes, por ejemplo, estoy seguro de que hay que modificar:
          - las declaraciones en el let (para la inicialización)

          - dentro de los macros (para incrementar la variable)

          - los valores de retornos para devolverlo.

    3. [ ] Crea tres criterios de selección que devuelva:
       
       - un mejor vecino, de entre los k mejores de la vecindad
       - un mejor vecino, de entre k que sean mejores que la actual, (pero no necesariamente los k mejores)
       - un mejor vecino, que entra en la lista por ruleta, compitiendo con todos.
       - un mejor vecino de entre k que sean mejores que la actual (pueden ser cualquiera de las dos anteriores), pero que la probabilidad de ser seleccionado, sea proporcional a su calidad.


* Tutorial for Hector (How to evaluate the delta-cost) 

** description and preliminaries
   In this tutorial we'll add the code to evaluate the delta cost of a solution.

   We'll assume that the reader read the previous tutorial and understands the following code snippet:

    #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
    (with-basic-solution (s1 ((1 2 3)
                              (4 5)
                              (6 7 8)))
      ;; code here
      ;; where you can reference a basic-solution s1
      ;; for instance, we can just print it
      (let* ((wc (basic-working-copy s1))
             (ops-list nil))
        (prepare-solution-for-neighborhood-exploration wc)

        (bformat t "Testing rab with the macros.")

        (doselect-route (r wc)
          (doselect-client (c1 r wc)
            (doinsert-client (c1 r wc)
              (pp-solution wc t))))))
    #+END_SRC

** Introduction to the actions
   
   In this VRP suite there is something called actions.  The idea of the actions is that they do some specific "actions".  For instance, there is an action that compute the cost of a solution.  There is an action that computes the delta-cost, and so on.

   In our case, we want to compute the delta-cost of the current neighbor, for a CVRP problem, so we should use an instance of =delta-cvrp-action=. We can create an instance of =delta-cvrp-action= called =action=, inside the =let= with the following code:

   
    #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
    (with-basic-solution (s1 ((1 2 3)
                              (4 5)
                              (6 7 8)))
      ;; code here
      ;; where you car reference a basic-solution s1
      ;; for instance, we can just print it
      (let* ((wc (basic-working-copy s1))
             (ops-list nil)
             ;; here we create the instance of the action
             (action (delta-cvrp-action)))
        (prepare-solution-for-neighborhood-exploration wc)

        (bformat t "Testing rab with the macros.")

        (doselect-route (r wc)
          (doselect-client (c1 r wc)
            (doinsert-client (c1 r wc)
              (pp-solution wc t))))))
    #+END_SRC

    If we execute the previous code there is no change in the output with respect to the previous one, but right now we can compute the delta-cost of the neighbor solution, as we show in the next section.

** the cvrp-problem and the basic-cvrp-solution

   In the previous example, the do-neighborhood-macros are =doselect-route=, =doselect-client=, and =doinsert-client=.  With the action defined in the previous section, we can compute the delta-cost inside the body of these macros using the function =delta-cost=.

   The function =delta-cost= receives 4 arguments:

   - the operations that define the current neighbor
   - the working-copy in its current state
   - the problem that we are working with
   - and the action that should perform the calculations.

   In our example so far we already have the operations, the working copy and the action.

   The operations are stored in the variable =ops-list=.  (This is done automatically inside the do-neighborhood-macros.)  The state of the working-copy is also updated inside the do-neighborhood-macros.  Finally, the action is the one defined inside the let.  The only missing element to use the function is the problem.  We can create a problem with the macro =with-cvrp-problem=, or we can use a problem defined manually.  In the following example I'm going to use the macro.

   The macro =with-cvrp-problem= receives the name of the variable where we'll store the problem, and three =&key= arguments: distances, demands and capacity.

   In this example we just print the coordinates of the neighbor.   

     #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                                         :demands '(10 10 15 40 20)
                                         :capacity 40)
        (with-basic-cvrp-solution (s1 ((2 4 5) (3) (1)) p1)

          ;; code here
          ;; where you can reference a basic-cvrp-solution s1
          ;; and a cvrp-problem p1
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))
            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing rab with the macros.")

            (doselect-route (r wc)
              (doselect-client (c1 r wc)
                (doinsert-client (c1 r wc)
                  (format t "select from: (~a,~a) and insert in (~a, ~a)~%"
                          (route (cadr ops-list)) (pos (cadr ops-list))
                          (route (car ops-list)) (pos (car ops-list)))))))))
     #+END_SRC

** some extra info stored by the macros

   The do-neighborhood-macros store some useful information while they run.  For instance, we can refer to the selection-coordinates of a selected client as well as the insertion coordinates.  This is shown in the following example:
   
     #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                                         :demands '(10 10 15 40 20)
                                         :capacity 40)
        (with-basic-cvrp-solution (s1 ((2 4 5) (3) (1)) p1)

          ;; code here
          ;; where you can reference a basic-cvrp-solution s1
          ;; and a cvrp-problem p1
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil))
            (prepare-solution-for-neighborhood-exploration wc)

            (bformat t "Testing rab with the macros.")

            (doselect-route (r wc)
              (doselect-client (c1 r wc)
                (doinsert-client (c1 r wc)
                  (format t "select from: (~a,~a) and insert in (~a, ~a)~%"
                          c1.route c1.position
                          c1.insert.route c1.ins.pos)))))))
     #+END_SRC

     #+RESULTS:
     #+begin_example
     ==============================
      Testing rab with the macros.
     ==============================

     select from: (1,1) and insert in (1, 1)
     select from: (1,1) and insert in (1, 2)
     select from: (1,1) and insert in (1, 3)
     select from: (1,2) and insert in (1, 1)
     select from: (1,2) and insert in (1, 2)
     select from: (1,2) and insert in (1, 3)
     select from: (1,3) and insert in (1, 1)
     select from: (1,3) and insert in (1, 2)
     select from: (1,3) and insert in (1, 3)
     select from: (2,1) and insert in (2, 1)
     select from: (3,1) and insert in (3, 1)
     #+end_example

** let's compute the delta cost

   With all this info we can compute the delta cost.  Actually we could have computed some time ago, but I wanted to show the use of the extra info stored in the selected and inserted clients.

   In the following example we compute the delta cost of each neighbor.  To do that we use a variable =current-delta-cost=, we use a =delta-cvrp-action= and add a line to initialize the action for the delta-cost-computation.  That's the line added right before the first =bformat=.

   After all these initializations are done, we just need to call the function =delta-cost=.

     #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                                         :demands '(10 10 15 40 20)
                                         :capacity 40)
        (with-basic-cvrp-solution (s1 ((2 4 5) (3) (1)) p1)

          ;; code here
          ;; where you can reference a basic-cvrp-solution s1
          ;; and a cvrp-problem p1
          (let* ((wc (basic-working-copy s1))
                 (ops-list nil)
                 (current-delta-cost 0)
                 (action (delta-cvrp-action)))
            (prepare-solution-for-neighborhood-exploration wc)

            ;; this is the line added to be able
            ;; to compute the delta-cost.
            (initialize-action-for-delta-cost-computation wc p1 action)

            (bformat t "Testing rab with the macros.")

            (doselect-route (r wc)
              (doselect-client (c1 r wc)
                (doinsert-client (c1 r wc)

                  (setf current-delta-cost (delta-cost (reverse ops-list)
                                                       wc ;; the working-copy
                                                       p1 ;; the problem
                                                       action ;; the action
                                                       ))
             
                  (format t "select from: (~a,~a) and insert in (~a, ~a): ~a~%"
                          c1.route c1.position
                          c1.insert.route c1.ins.pos
                          current-delta-cost)))))))
     #+END_SRC
** Finally some code to collect data for R
   The code in this section returns a list where each element is a triplet (r1 r2 cost).  r1 is the route from where the client was selected, r2 is the route where the client was inserted and cost is the delta cost for that neighbor.

   This code is only valid for the criterion rab, but the code can be easily adapted to other criteria.

        #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
        (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                            (5 0 6 7 2 4)  ;1
                                            (1 8 0 3 9 1)  ;2
                                            (4 5 1 0 5 7)  ;3
                                            (4 5 1 5 0 6)  ;4
                                            (1 5 7 6 9 0)) ;5
                                            ;0 1 2 3 4 5 
                                            :demands '(10 10 15 40 20)
                                            :capacity 40)
           (with-basic-cvrp-solution (s1 ((2 4 5) (3 1)) p1)

             ;; code here
             ;; where you can reference a basic-cvrp-solution s1
             ;; and a cvrp-problem p1
             (let* ((wc (basic-working-copy s1))
                    (ops-list nil)
                    (current-delta-cost 0)
                    (action (delta-cvrp-action))
                    (list-with-data nil))
               (prepare-solution-for-neighborhood-exploration wc)

               ;; this is the line added to be able
               ;; to compute the delta-cost.
               (initialize-action-for-delta-cost-computation wc p1 action)

               (bformat t "Testing rab with the macros.")

               (doselect-route (r wc)
                 (doselect-client (c1 r wc)
                   (doinsert-client (c1 r wc)

                     (setf current-delta-cost (delta-cost (reverse ops-list)
                                                          wc ;; the working-copy
                                                          p1 ;; the problem
                                                          action ;; the action
                                                          ))

                     (push (list c1.route c1.insert.route current-delta-cost)
                           list-with-data)
                     )))
               ;; this is outside the macros
               ;; if you want you can return the list here.
               ;; I'll just print it.
               (format t "~{~a~%~}" list-with-data))))
     #+END_SRC
** *MACRO proportional-subroute-length (to collect data in R)*
   #+begin_src lisp +n -r :results none :exports both.lisp
   (defmacro proportional-subroute-length (subroute route)
     (let* ((z1.length (symb subroute ".length")))
       `(cond
          ;; small subroute
             ((< ,z1.length
                     (* 0.3 (route-length ,route wc)))
               0)
              ;; large subroute
              ((> ,z1.length
               (* 0.6 (route-length ,route wc)))
              2)
             ;; medium subroute
             (t 1))))
   #+end_src
   
** Data for R rarb f-n135-k7
In the system there are some larger scale previously defined problems, so instead of define a new small problem for your own you can use this problem and only define the actual solution for that specific problem.

Lets see how this work in code.

#+BEGIN_SRC lisp +n -r :results output :exports both.lisp
(let* ((p1 vrp::f-n135-k7-problem)
       (s1 (vrp::make-initial-solution-for-cvrp-random p1))
       (output-file "/tmp/rarb.dat"))

    ;; code here
    ;; where you can reference a basic-cvrp-solution s1
    ;; and a cvrp-problem p1
    (let* ((wc (vrp::basic-working-copy s1))
	   (ops-list nil)
	   (current-delta-cost 0)
	   (action (vrp::delta-cvrp-action))
           (cvrp-action (basic-cvrp-action))
	   ;; (list-with-data nil)
           )

      (simulate-solution s1 p1 cvrp-action)
      (setf (cost s1) (+ (total-distance cvrp-action)
                         (total-penalty cvrp-action)))
      
      (vrp::prepare-solution-for-neighborhood-exploration wc)

      ;; this is the line added to be able
      ;; to compute the delta-cost.
      (vrp::initialize-action-for-delta-cost-computation wc p1 action)

      (format t "Cost: ~a~%" (cost s1))
      (format t "Penalty: ~a~%" (total-penalty cvrp-action))
      (pp-solution wc t)

      (vrp::bformat t "Testing rab with the macros.")

      (with-open-file (f output-file
                         :direction :output
                         :if-exists :supersede)

        (format f "Cost: ~a~%" (cost s1))
        (format f "Penalty: ~a~%" (total-penalty cvrp-action))
        (pp-solution wc f)

         
        (vrp::doselect-route (r wc)
	  (vrp::doselect-client (c1 r wc)
            (vrp::doselect-route (r2 wc)
	      (vrp::doinsert-client (c1 r2 wc)

	        (setf current-delta-cost (vrp::delta-cost (reverse ops-list)
						          wc ;; the working-copy
						          p1 ;; the problem
						          action ;; the action
						          ))
                (format f "~a, ~a, ~a~%"
                        c1.route c1.insert.route current-delta-cost)
            

	        ;; (push (list c1.route c1.insert.route current-delta-cost)
	        ;;       list-with-data)
	        )))))
      (format t "Finished data collection for rarb 135.~%")
      ))
     #+END_SRC
** Data for R rerf f-n135-k7-problem
In the system there are some larger scale previously defined problems, so instead of define a new small problem for your own you can use this problem and only define the actual solution for that specific problem.

Lets see how this work in code.

#+BEGIN_SRC lisp +n -r :results output :exports both.lisp
(let* ((p1 f-n135-k7-problem)
       (s1 (make-initial-solution-for-cvrp-random p1))
       (output-file "/tmp/rerf.dat"))

     ;; code here
     ;; where you can reference a basic-cvrp-solution s1
     ;; and a cvrp-problem p1
     (let* ((wc (basic-working-copy s1))
	    (ops-list nil)
	    (current-delta-cost 0)
	    (action (delta-cvrp-action))
            (cvrp-action (basic-cvrp-action))
	    ;; (list-with-data nil)
            )

       (simulate-solution s1 p1 cvrp-action)
       (setf (cost s1) (+ (total-distance cvrp-action)
                          (total-penalty cvrp-action)))
      
       (prepare-solution-for-neighborhood-exploration wc)

       ;; this is the line added to be able
       ;; to compute the delta-cost.
       (initialize-action-for-delta-cost-computation wc p1 action)

       (format t "Cost: ~a~%" (cost s1))
       (format t "Penalty: ~a~%" (total-penalty cvrp-action))
       (pp-solution wc t)

       (with-open-file (f output-file
                          :direction :output
                          :if-exists :supersede)

         (format f "Cost: ~a~%" (cost s1))
         (format f "Penalty: ~a~%" (total-penalty cvrp-action))
         (pp-solution wc f)

       (bformat t "Collecting data with rerf.")

       (doselect-route (r1 wc)
	 (doselect-subroute (z1 r1 wc)
           (doselect-route (r2 wc)
             (doinsert-subroute (z1 r2 wc)

	       (setf current-delta-cost (delta-cost (reverse ops-list)
						    wc ;; the working-copy
						    p1 ;; the problem
						    action ;; the action
						    ))
               (format t "~a, ~a, ~a~%"
                       r1
                       (proportional-subroute-length z1 r1)
                       r2)
               (format f "~a, ~a, ~a, ~a~%"
                       r1
                       (proportional-subroute-length z1 r1)
                       r2
                       current-delta-cost)))))
       ;; this is outside the macros
       (format t "Finished data collection for rerf~%")
       )))
     #+END_SRC
** Data for R ref f-n135-k7-problem
In the system there are some larger scale previously defined problems, so instead of define a new small problem for your own you can use this problem and only define the actual solution for that specific problem.

Lets see how this work in code.

#+BEGIN_SRC lisp +n -r :results output :exports both.lisp
(let* ((p1 f-n135-k7-problem)
       (s1 (make-initial-solution-for-cvrp-random p1))
       (output-file "/tmp/ref.dat"))

  ;; code here
  ;; where you can reference a basic-cvrp-solution s1
  ;; and a cvrp-problem p1
  (let* ((wc (basic-working-copy s1))
	 (ops-list nil)
	 (current-delta-cost 0)
	 (action (delta-cvrp-action))
         (cvrp-action (basic-cvrp-action))
	 ;; (list-with-data nil)
         )

    (simulate-solution s1 p1 cvrp-action)
    (setf (cost s1) (+ (total-distance cvrp-action)
                       (total-penalty cvrp-action)))
      
    (prepare-solution-for-neighborhood-exploration wc)

    ;; this is the line added to be able
    ;; to compute the delta-cost.
    (initialize-action-for-delta-cost-computation wc p1 action)

    (format t "Cost: ~a~%" (cost s1))
    (format t "Penalty: ~a~%" (total-penalty cvrp-action))
    (pp-solution wc t)

    (with-open-file (f output-file
                       :direction :output
                       :if-exists :supersede)

      (format f "Cost: ~a~%" (cost s1))
      (format f "Penalty: ~a~%" (total-penalty cvrp-action))
      (pp-solution wc f)

      (bformat t "Collecting data with ref.")

      (doselect-route (r1 wc)
	(doselect-subroute (z1 r1 wc)
          (doinsert-subroute (z1 r1 wc)

	    (setf current-delta-cost (delta-cost (reverse ops-list)
						 wc ;; the working-copy
						 p1 ;; the problem
						 action ;; the action
						 ))
            (format t "~a, ~a~%" r1 z1.length)
            (format f "~a, ~a, ~a~%"
                    r1
                    ;; the length of the subroute z1
                    (cond
                      ;; small subroute
                      ((< z1.length
                          (* 0.3 (route-length r1 wc)))
                       0)
                      ;; large subroute
                      ((> z1.length
                          (* 0.6 (route-length r1 wc)))
                       2)
                      ;; medium subroute
                      (t 1))                     
                    current-delta-cost))))
      ;; this is outside the macros
      (format t "Finished data collection for ref~%")
      ))))
     #+END_SRC
** Data for R rab f-n135-k7-problem
In the system there are some larger scale previously defined problems, so instead of define a new small problem for your own you can use this problem and only define the actual solution for that specific problem.

Lets see how this work in code.

#+BEGIN_SRC lisp +n -r :results output :exports both.lisp
(let* ((p1 f-n135-k7-problem)
       (s1 (make-initial-solution-for-cvrp-random p1))
       (output-file "/tmp/rab.dat"))

     ;; code here
     ;; where you can reference a basic-cvrp-solution s1
     ;; and a cvrp-problem p1
     (let* ((wc (basic-working-copy s1))
	    (ops-list nil)
	    (current-delta-cost 0)
	    (action (delta-cvrp-action))
            (cvrp-action (basic-cvrp-action))
	    ;; (list-with-data nil)
            )

       (simulate-solution s1 p1 cvrp-action)
       (setf (cost s1) (+ (total-distance cvrp-action)
                          (total-penalty cvrp-action)))
      
       (prepare-solution-for-neighborhood-exploration wc)

       ;; this is the line added to be able
       ;; to compute the delta-cost.
       (initialize-action-for-delta-cost-computation wc p1 action)

       (format t "Cost: ~a~%" (cost s1))
       (format t "Penalty: ~a~%" (total-penalty cvrp-action))
       (pp-solution wc t)

       (with-open-file (f output-file
                          :direction :output
                          :if-exists :supersede)

         (format f "Cost: ~a~%" (cost s1))
         (format f "Penalty: ~a~%" (total-penalty cvrp-action))
         (pp-solution wc f)

       (bformat t "Collecting data with rab.")

       (doselect-route (r1 wc)
	 (doselect-client (z1 r1 wc)
           (doinsert-client (z1 r1 wc)

	     (setf current-delta-cost (delta-cost (reverse ops-list)
						  wc ;; the working-copy
						  p1 ;; the problem
						  action ;; the action
						  ))
             (format t "~a, ~a, ~a~%" r1 z1.position z1.ins.pos)
             (format f "~a, ~a~%"
                     r1
                     current-delta-cost))))
       ;; this is outside the macros
       (format t "Finished data collection for rab~%")
       ))))
     #+END_SRC
** Data for R rarac f-n135-k7-problem
In the system there are some larger scale previously defined problems, so instead of define a new small problem for your own you can use this problem and only define the actual solution for that specific problem.

Lets see how this work in code.

#+BEGIN_SRC lisp +n -r :results output :exports both.lisp
(let* ((p1 f-n135-k7-problem)
       (s1 (make-initial-solution-for-cvrp-random p1))
       (output-file "/tmp/rarac.dat"))

     ;; code here
     ;; where you can reference a basic-cvrp-solution s1
     ;; and a cvrp-problem p1
     (let* ((wc (basic-working-copy s1))
	    (ops-list nil)
	    (current-delta-cost 0)
	    (action (delta-cvrp-action))
            (cvrp-action (basic-cvrp-action))
	    ;; (list-with-data nil)
            )

       (simulate-solution s1 p1 cvrp-action)
       (setf (cost s1) (+ (total-distance cvrp-action)
                          (total-penalty cvrp-action)))
      
       (prepare-solution-for-neighborhood-exploration wc)

       ;; this is the line added to be able
       ;; to compute the delta-cost.
       (initialize-action-for-delta-cost-computation wc p1 action)

       (format t "Cost: ~a~%" (cost s1))
       (format t "Penalty: ~a~%" (total-penalty cvrp-action))
       (pp-solution wc t)

       (with-open-file (f output-file
                          :direction :output
                          :if-exists :supersede)

         (format f "Cost: ~a~%" (cost s1))
         (format f "Penalty: ~a~%" (total-penalty cvrp-action))
         (pp-solution wc f)

       (bformat t "Collecting data with rarac.")

       (doselect-route (r1 wc)
	 (doselect-client (c1 r1 wc)
           (doselect-route (r2 wc)
             (doselect-client (c2 r2 wc)
               (doswap-clients (c1 c2 wc)

	         (setf current-delta-cost (delta-cost (reverse ops-list)
						      wc ;; the working-copy
						      p1 ;; the problem
						      action ;; the action
						      ))
                 (format t "~a, ~a~%" r1 r2)
                 (format f "~a, ~a, ~a~%"
                         r1 r2
                         current-delta-cost))))))
       ;; this is outside the macros
       (format t "Finished data collection for rarac~%")
       ))))
     #+END_SRC
** Data for R rereg a-n32-k5
In the system there are some larger scale previously defined problems, so instead of define a new small problem for your own you can use this problem and only define the actual solution for that specific problem.

Lets see how this work in code.

#+BEGIN_SRC lisp +n -r :results output :exports both.lisp
(let* ((p1 a-n32-k5-problem)
          (s1 (make-initial-solution-for-cvrp-random p1))
          (output-file "/tmp/rereg.dat"))

     ;; code here
     ;; where you can reference a basic-cvrp-solution s1
     ;; and a cvrp-problem p1
     (let* ((wc (basic-working-copy s1))
	    (ops-list nil)
	    (current-delta-cost 0)
	    (action (delta-cvrp-action))
            (cvrp-action (basic-cvrp-action))
	    ;; (list-with-data nil)
            )

       (simulate-solution s1 p1 cvrp-action)
       (setf (cost s1) (+ (total-distance cvrp-action)
                          (total-penalty cvrp-action)))
      
       (prepare-solution-for-neighborhood-exploration wc)

       ;; this is the line added to be able
       ;; to compute the delta-cost.
       (initialize-action-for-delta-cost-computation wc p1 action)

       (format t "Cost: ~a~%" (cost s1))
       (format t "Penalty: ~a~%" (total-penalty cvrp-action))
       (pp-solution wc t)

       (with-open-file (f output-file
                          :direction :output
                          :if-exists :supersede)

         (format f "Cost: ~a~%" (cost s1))
         (format f "Penalty: ~a~%" (total-penalty cvrp-action))
         (pp-solution wc f)

       (bformat t "Testing rab with the macros.")

         (doselect-route (r1 wc)
	   (doselect-subroute (z1 r1 wc)
             (doselect-route (r2 wc)
	       (doselect-subroute (z2 r2 wc)
                 (doswap-subroutes (z1 z2 wc)

	           (setf current-delta-cost (delta-cost (reverse ops-list)
						        wc ;; the working-copy
						        p1 ;; the problem
						        action ;; the action
						        ))
                   (format t "~a, ~a~%" r1 r2)
                   (format f "~a, ~a, ~a, ~a, ~a~%"
                           r1
                           ;; the length of the subroute z1
                           (cond
                             ;; small subroute
                             ((< z1.length
                                 (* 0.3 (route-length r1 wc)))
                              0)
                             ;; large subroute
                             ((> z1.length
                                 (* 0.6 (route-length r1 wc)))
                              2)
                             ;; medium subroute
                             (t 1))
                           r2
                           ;; the length of the subroute z2
                           (cond
                             ;; small subroute
                             ((< z1.length
                                 (* 0.3 (route-length r2 wc)))
                              0)
                             ;; large subroute
                             ((> z1.length
                                 (* 0.6 (route-length r2 wc)))
                              2)
                             ;; medium subroute
                             (t 1))
                           current-delta-cost))
            

	         ;; (push (list c1.route c1.insert.route current-delta-cost)
	         ;;       list-with-data)
	         )))))
       ;; this is outside the macros
       (format t "Finished data collection for rereg~%")
       ))
     #+END_SRC


* (Tutorial for JJ) How to add a new problem for evaluation of a solution

** description
   In this section we'll add a tutorial on how to add a new problem and how to evaluate a solution for that problem.  We'll consider a problem with time windows where the service time for a client is fixed during all the process.

   To do that we need to:

   1. Initialize the system
   2. Add new classes
   3. Add new methods
   4. Test it all

   We'll go through these steps one by one.

** Initialize the system
   Here we'll assume that the user is "smart enough" to use emacs with slime and org-mode =:-P=.  With that, the steps are the following:

   1. Clone the git repo in the folder =vrp= to the working directory
   2. In the working directory create the folders
      - src/
      - data/
   3. Tangle the file vrp-suite.org
      Open the file vrp-suite.org and do =M-x org-babel-tangle=
   4. From emacs load vrp-emacs-utils.el
      =M-x load-file vrp-emacs-utils.el=
      To avoid errors while loading it, add the following to your .emacs
      #+BEGIN_SRC emacs-lisp :results none :exports code
      (define-key org-mode-map (kbd "M-m") (make-sparse-keymap))
      (define-key lisp-mode-map (kbd "M-m M-o") (make-sparse-keymap))
      #+END_SRC
   5. From emacs execute =vrp-tangle-all-files=
   6. From emacs fire up slime (=M-x slime=)
   7. In Slime, change the current directory to the working directory
      (this can be done by typing =,= in the REPL and then =cd= <RETURN>, and navigate to the working directory)
   8. In slime load the file vrp-load-files
     #+BEGIN_SRC lisp +n -r :results none :exports code 
     (load "src/vrp-load-files.lisp")
     #+END_SRC
   9. Change to the package vrp
     #+BEGIN_SRC lisp +n -r :results none :exports code 
     (in-package :vrp)
     #+END_SRC
** Let's add the new classes
*** description
    We want to simulate a VRP with time windows.  For that we need a new problem (with at least, the time between clients) and new clients with the time windows.  Let's add them.

    The required classes are: [8/8]
    - [X] time-windows-client (has a time windows)
    - [X] service-time-client (has a service time)
    - [X] time-windows-problem (has the time-between clients)
    - [X] route-with-time (has current-time and start-time)
    - [X] an actual route to test things,
    - [X] an actual problem, and
    - [X] an actual class for clients to test things too.
    - [X] An action to compute time

    We'll also need a function to compute the time required to move from one element to another.  That will be the function get-time-from-to.

    We are going to add all the subtrees as if this were the file =vrp-classes.org=.
*** time-windows-client (structural, abstract)
**** documentation
     This is a client that has two values representing the opening and closing time of the time windows.
**** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-time-windows-tutorial.lisp
    (def-vrp-class time-windows-client ()
      ((open-time) (closing-time))
      :documentation "A client with time windows.")
    #+END_SRC     
**** tests (no tests because it is abstract)
*** service-time-client (structural, abstract)
**** documentation
     This is a client that has a value representing the time required to attend it.
**** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-time-windows-tutorial.lisp
    (def-vrp-class service-time-client ()
      ((service-time))
      :documentation "A client with a service time.")
    #+END_SRC     
**** tests (no tests because it is abstract)
*** time-problem (structural, abstract)
**** documentation
     This is a problem with a matrix of time travel from one client to another.
**** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-time-windows-tutorial.lisp
    (def-vrp-class time-problem ()
      ((time-matrix))
      :documentation "A problem with a time matrix where each entry is the time required to go from one client to another.")
    #+END_SRC     
**** tests (no tests because it is abstract)
*** get-time-from-to
**** description
     This function receives two has-id instances and a time-problem and returns the distance from the first instance to the second in that problem.  It will be a generic-function because I want it to be as flexible as possible.  
**** code
***** generic-function
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
       (defgeneric get-time-from-to (from to problem)
         (:documentation "Returns the time from the first point to the second in the given problem."))
       #+END_SRC   
***** method (has-id has-id distance-problem)
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
       (defmethod get-time-from-to ((from has-id)
                                    (to has-id)
                                    (problem time-problem))
         "Returns the distance from the first point to the second in the given distance-problem."
         (aref (time-matrix problem) (id from) (id to)))
       #+END_SRC   

****** tests
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (let* ((distance #2A ((0 1 2 3)
                             (1 0 4 5)
                             (2 4 0 6)
                             (3 5 6 0)))
              (dp (make-instance 'time-problem
                                 :time-matrix distance))
              (d0 (basic-depot))
              (c1 (basic-client 1))
              (c2 (basic-client 2))
              (c3 (basic-client 3)))
         (bformat t "Testing get-distance-from-to:")
         (check-= 0 (get-time-from-to d0 d0 dp))
         (check-= 1 (get-time-from-to d0 c1 dp))
         (check-= 2 (get-time-from-to d0 c2 dp))
         (check-= 3 (get-time-from-to d0 c3 dp))
  
         (check-= 1 (get-time-from-to c1 d0 dp))
         (check-= 0 (get-time-from-to c1 c1 dp))
         (check-= 4 (get-time-from-to c1 c2 dp))
         (check-= 5 (get-time-from-to c1 c3 dp)))
       #+END_SRC
*** route-with-time (structural abstract)
**** documentation
     This is a route that has a =start-time= and a =current-time= slot.  This probably should be the base class for any route that implements some.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class route-with-time ()
       ((start-time :initform 0))
       :documentation "A route with a start time.  Good for time based simulations.")
     #+END_SRC
**** no tests because it is abstract
*** route-for-time-simulation (structural class)
**** documentation
     This is a route for simulation where we include time in the simulation.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class route-for-time-based-simulation
         (route-for-simulation
          route-with-time)
       ()
       :documentation "A route for a simulation that includes time."
       :constructor (route-for-time-based-simulation
                     (&key id vehicle depot clients
                           start-time))
       :slots-for-obj= (id vehicle depot clients previous-client
                            start-time)
       :slots-for-clone (id vehicle depot clients previous-client
                            start-time))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-clients (1 2 3 4 5 6)
       (let* ((v1 (basic-vehicle 1))
              (v2 (basic-vehicle 2))
              (d0 (basic-depot))
              (d1 (basic-depot 1))
              (r1 (route-for-time-based-simulation
                   :id 1 :vehicle v1 :depot d0
                   :clients (list c1 c2 c3)
                   :start-time 0))
              (r2 (route-for-time-based-simulation
                   :id 2 :vehicle v2 :depot d0
                   :clients (list c4 c5 c6)
                   :start-time 0))
              (r3 (route-for-time-based-simulation
                   :id 1 :vehicle v2 :depot d0
                   :clients (list c1 c2 c3)
                   :start-time 0))
              (r4 (clone r1))
              (r5 (clone r2))
              )

         (bformat t "Testing route-for-simulation...")

         (format t "Printing the objects:~%")
         (loop for e in (list r1 r2 r3 r4 r5)
               doing (format t "   route-for-time-based-simulation with id ~a: ~a~%"
                             (id e) e))

         (deftests "Testing obj="
           (check-t (obj= r1 r1))
           (check-t (obj= r1 r4))
           (check-t (obj= r2 r5))

           (check-nil (obj= r1 r2))
           (check-nil (obj= r1 r3))
           (check-nil (obj= r2 r4)))))
     #+END_SRC
*** basic-time-windows-problem
**** documentation
     This is a very basic (and elemetary) time-windows-problem with homogeneous fleet.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class basic-time-windows-problem
         (basic-problem
          distance-problem
          capacity-problem
          time-problem)
       ()
       :documentation "A distance-problem with a capacity for all the vehicles and with time between the clients."
       :constructor (basic-time-windows-problem
                     (&key id clients depot
                           distance-matrix
                           time-matrix
                           capacity))
       :slots-for-obj= (id clients depot
                           distance-matrix
                           time-matrix
                           capacity)
       :slots-for-clone (id clients depot
                            distance-matrix
                            time-matrix
                            capacity))

     (defmethod print-object ((obj basic-time-windows-problem) stream)
        (format stream "<VRPTW ~a: ~a clients, capacity ~a>"
                (id obj)
                (length (clients obj))
                (capacity obj)))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-clients (1 2 3)
       (let* ((d0 (basic-depot))
              (d1 (basic-depot 1))
              (p1 (basic-time-windows-problem
                   :id 1 :depot d0
                   :clients (list c1 c2 c3)
                   :capacity 40
                   :distance-matrix #2A((0 1 2 3)
                                        (1 0 4 6)
                                        (2 4 0 2)
                                        (3 6 2 0))
                   :time-matrix #2A((0 1 2 3)
                                    (1 0 4 6)
                                    (2 4 0 2)
                                    (3 6 2 0))))
              (p2 (basic-time-windows-problem
                   :id 2 :depot d0
                   :clients (list c1 c2 c3)
                   :capacity 40
                   :distance-matrix #2A((0 1 2 3)
                                        (1 0 4 6)
                                        (2 4 0 2)
                                        (3 6 2 0))
                   :time-matrix #2A((0 1 2 3)
                                    (1 0 4 6)
                                    (2 4 0 2)
                                    (3 6 2 0))))
              (p3 (basic-time-windows-problem
                   :id 2 :depot d0
                   :clients (list c1 c2 c3)
                   :capacity 40
                   :distance-matrix #2A((0 1 2 3)
                                        (1 0 4 6)
                                        (2 4 0 2)
                                        (3 6 2 0))
                   :time-matrix #2A((0 1 2 5)
                                    (1 0 4 6)
                                    (2 4 0 2)
                                    (3 6 2 0))))
              (p4 (clone p1))
              (p5 (clone p3))
              )

         (bformat t "Testing vrptw-problem...")

         (format t "Printing the objects:~%")
         (loop for e in (list p1 ;; p2 p3 p4 p5 p6
                              )
               doing (format t "   time-problem with id ~a:~% ~a~%"
                             (id e) e))

         (deftests "Testing obj="
           (check-t (obj= p1 p1))
           (check-t (obj= p1 p4))
           (check-t (obj= p3 p5))

           (check-nil (obj= p1 p2))
           (check-nil (obj= p1 p3))
           (check-nil (obj= p2 p4))
           (check-nil (obj= p2 p5))
           )))
     #+END_SRC
*** basic-tw-client (actual class)
**** documentation
     A client that can be used in the basic VRPTW.  It has an id, a demand, a time windows and a service time.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class basic-vrptw-client
         (basic-client
          demand-client
          time-windows-client
          service-time-client)
       ()
       :documentation "A client for the basic VRPTW with id, demand, time windows and service time."
       :constructor (basic-cvrptw-client (id
                                          demand
                                          open-time
                                          closing-time
                                          service-time))
       :print-object-string ("<twc~a: ~a, [~a, ~a], ~a>"
                             id demand open-time closing-time
                             service-time)
       :slots-for-obj= (id demand
                           open-time
                           closing-time
                           service-time)
       :slots-for-clone (id demand
                           open-time
                           closing-time
                           service-time))
     #+END_SRC   
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((c1 (basic-cvrptw-client 1 10 2 5 2))
            (c2 (basic-cvrptw-client 2 10 3 5 2))
            (c3 (clone c1))
            (c4 (clone c2)))
       (bformat t "Testing basic-vrptw-client...")

       (format t "Printing the objects:~%")
       (loop for e in (list c1 c2 c3 c4)
             doing (format t "   basic-vrptw-client with id ~a: ~a~%"
                           (id e) e))

       (deftests "Testing obj="
         (check-t (obj= c1 c1))
         (check-t (obj= c1 c3))
         (check-t (obj= c2 c4))

         (check-nil (obj= c1 c2))
         (check-nil (obj= c2 c3))))
     #+END_SRC
*** route-time-action
**** description
     This action computes the time elapsed in a route.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class route-time-action (has-id)
       ((current-time)
        (id :documentation "The id of the route this action is being used on."))
       :documentation "An action to compute the distance travelled by a vehicle in a route."
       :constructor (route-time-action (id &optional (current-time 0)))
       :print-object-string ("<a_rt: ~a ~a>" id current-time)
       :slots-for-obj= (id current-time)
       :slots-for-clone (id current-time))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((c1 (route-time-action 1 10))
            (c2 (route-time-action 2 10))
            (c3 (route-time-action 1 20))
            (c4 (clone c1))
            (c5 (clone c2)))
       (bformat t "Testing route-distance-action...")

       (format t "Printing the objects:~%")
       (loop for e in (list c1 c2 c3 c4 c5)
             doing (format t "   route-time-action with id ~a: ~a~%"
                           (id e) e))

       (deftests "Testing obj="
         (check-t (obj= c1 c1))
         (check-t (obj= c1 c4))
         (check-t (obj= c2 c5))

         (check-nil (obj= c1 c2))
         (check-nil (obj= c1 c3))
         (check-nil (obj= c2 c4))
         (check-nil (obj= c3 c5))))
     #+END_SRC

** Now let's add the moments for the evaluation of a solution :-o
*** documentation
    Now we need to add the methods to the appropriate moments to reflect the fact that we are dealing with time windows.

    The moments that are affected are: [2/4]
    - [X] when-route-begins
      initialize the current time and start-time.
    - [X] move-from-to
      We need to update the current time
    - [ ] unload (after, increment time)
      - Update time according to service time.
    - [ ] visit-client
      - We need to check the time windows and act accordingly
        - if early: wait (and penalize?)
        - if on-time: proceed
        - if late: PENALIZE
      - store the arrival time (probably a before method)
      - penalize (with a different action)
    - [ ] Create a problem and test everything
*** when-route-begins (:before route-distance-action)
**** description
     Here we initialize the route-time-action.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-moments.lisp
     (defbehavior when-route-begins :before
       (vehicle
        (route route-with-time)
        solution
        problem
        (action route-time-action))
       :log-str "Initializing current-time to start-time"
       (setf (current-time action) (start-time route)))
     #+END_SRC
**** tests
***** test without logging
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((c1 (basic-cvrp-client 1 30))
             (c2 (basic-cvrp-client 2 20))
             (v1 (cvrp-vehicle 1 60 60))
             (d0 (basic-depot))
             (r1 (route-for-time-based-simulation
                  :id 1 :vehicle v1 :depot d0 :clients (list c1 c2)
                  :start-time 5))
             (a1 (route-time-action 1 50))
             (*vrp-logging* 0))
        (format t "Testing when-route-begins for route-distance-action:~%")
        (check-= 50 (current-time a1))
        (when-route-begins v1 r1 t t a1)
        (check-= 5 (current-time a1)))
      #+END_SRC

***** test with logging
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((c1 (basic-cvrp-client 1 30))
             (c2 (basic-cvrp-client 2 20))
             (v1 (cvrp-vehicle 1 60 60))
             (d0 (basic-depot))
             (r1 (route-for-simulation :id 1 :vehicle v1
                                       :depot d0 :clients (list c1 c2)))
             (a1 (route-distance-action 1 50))
             (*vrp-logging* 1))
        (format t "Testing *logging* when-route-begins for route-distance-action:~%")
        (when-route-begins v1 r1 t t a1))
      #+END_SRC
*** move-from-to (:after method: to compute distance)
**** description
     In this method we update the time spent by the vehicle in this arc.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-moments.lisp
     (defbehavior move-from-to :after
       ((vehicle     t)
        (from-client t)
        (to-client   t)
        (route       t)
        (solution    t)
        (problem     time-problem)
        (action      route-time-action))

       :log-str "Updating distance"
       (incf (current-time action)
             (get-time-from-to from-client to-client problem)))
     #+END_SRC
**** tests
***** test without logging
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((c1 (basic-cvrp-client 1 30))
             (c2 (basic-cvrp-client 2 20))
             (c3 (basic-cvrp-client 3 30))
             (d0 (basic-depot))
             (list (list d0 c1 c2 c3))
             (time-matrix #2A ((0 1 2 3)
                               (1 0 4 5)
                               (2 4 0 6)
                               (3 5 6 0)))
             (problem (make-instance 'time-problem
                                     :time-matrix time-matrix))
             (a1 (route-time-action 0))
             (*vrp-logging* 0))
        (bformat t "Testing move-from-to with route-distance-action:")

        (check-= 0 (current-time a1))
        (move-from-to t d0 c1 t t problem a1)
        (check-= 1 (current-time a1))

        (setf (current-time a1) 0)
        (loop for previous-client in (butlast list)
              for current-client in (rest list)
              doing (move-from-to t previous-client current-client t t problem a1))
        (check-= 11 (current-time a1)))
      #+END_SRC
** TODO Assignment
   - add the slot arrival-time to the time-action
   - implement the missing methods
     - (including two different penalization strategies)


* (Tutorial for Gabriela) How to detect repeated elements in a Neighborhood
  Without using Emacs :'-(
  
** Copy everything
   Copy the folder src/ to wherever you want.

** Start a Lisp in the parent folder of src/

   >> clisp

** Load the system

   [1]> (load "src/vrp-load-files.lisp")

** Change to the package :vrp

   [2]> (in-package :vrp)

** Write a file with the following code and save as name.lisp
   
   (in-package :vrp)

   (with-basic-solution (s1 ((1 2 3 4 5)))
     (let* ((bp1 (basic-strategy-blueprint))
            (wc (basic-working-copy s1))
            (spot-repeated-clients-strat
             (make-instance 'repeated-solutions-search-strategy))
            (code1 rerehg)
            (explore-function nil)
            (repeated-clients nil)
            )

       (prepare-blueprint-for-code-generation
        code1
        +exhaustive-search-strategy+
        spot-repeated-clients-strat
        bp1)

       (prepare-solution-for-neighborhood-exploration wc)

       (setf explore-function (make-neighborhood-criterion
                               code1
                               +exhaustive-search-strategy+
                               spot-repeated-clients-strat))

       (bformat t "testing repeated clients")

       (setf repeated-clients (funcall
                               explore-function
                               s1
                               t
                               t))

       (format t "repeated-clients:~%~{~a~%~}~%"
               (reverse repeated-clients))))

** from the REPL load that file

   [3]> (load "name.lisp")

** And now to test different criteria modify the file

   (in-package :vrp)

   (with-basic-solution (s1 ((1 2 3 4 5)))
     (let* ((bp1 (basic-strategy-blueprint))
            (wc (basic-working-copy s1))
            (spot-repeated-clients-strat
             (make-instance 'repeated-solutions-search-strategy))
             
             ;; modify the criterion here
             ;;    |
             ;;    v
            (code1 `((select route r1)
                     (select-client c1 from r1)
                     (select route r2)
                     (insert-client c1 into r2)))
            (explore-function nil)
            (repeated-clients nil)
            )

       (prepare-blueprint-for-code-generation
        code1
        +exhaustive-search-strategy+
        spot-repeated-clients-strat
        bp1)

       (prepare-solution-for-neighborhood-exploration wc)

       (setf explore-function (make-neighborhood-criterion
                               code1
                               +exhaustive-search-strategy+
                               spot-repeated-clients-strat))

       (bformat t "testing repeated clients")

       (setf repeated-clients (funcall
                               explore-function
                               s1
                               t
                               t))

       (format t "repeated-clients:~%~{~a~%~}~%"
               (reverse repeated-clients))))


* Tutorial on how to count the number of better neighbors
*** description
    In this tutorial, we'll design a strategy to
    1. explore the neighborhood exhaustively
    2. select the best neighbor
    3. count the number of better neighbors
     
    In the following subsections, we'll do this, using the class system for the design of exploration and selection strategies.

*** Class to count the number of best neighbors
   To do what we want, we'll have to define some new classes.

   The first class is the one that allows us to count the number of best neighbors.  To do that we need to compute delta cost, and to add a counter with the number of better solutions.

   Here are the full requirements so far:

   - We'll use a basic-wc
     =search-with-a-basic-wc=.
   - We are computing delta-cost with smart macros
     =compute-delta-cost-with-smart-macros=.

   But we won't add them to the class as parents, to keep the system as orthogonal as possible.  

   #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-tests.lisp
   (def-vrp-class count-better-neighbors ()
          ()
         :documentation "A class to represent a search where we count the number of better neighbors and return a random better."
         :constructor (count-better-neighbors ())
         :print-object-string ("<count-better-neighbors>")
         :slots-for-obj= ()
         :slots-for-clone ())
   #+END_SRC

**** testing the generated code from the inheritance

    And here we can see the generated code so far, with an exhaustive-search.  As we want to use the smart-macros, we need to use the instance class =*exhaustive-search-strategy*=.

    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((*vrp-unit-testing-display-output* nil)
           (*vrp-unit-testing-display-results* t)
           (bp1 (basic-strategy-blueprint))
           (code1 `((select-route r1)
                    (select-client c1 from r1)
                    (insert-client c1 into r1)))
           )

      ;; let's populate the blueprint
      (prepare-blueprint-for-code-generation
       code1
       ,*exhaustive-search-strategy*
       (make-instance 'count-better-neighbors)
       bp1)

      (format t "the generated code:~%~a~%"
              (write-neighborhood-exploration-code bp1)))
    #+END_SRC

    #+RESULTS:
    #+begin_example
    the generated code:
    (LAMBDA (SOLUTION PROBLEM ACTION &OPTIONAL (INITIAL-BEST-DELTA-COST 0))
      (DECLARE (IGNORABLE INITIAL-BEST-DELTA-COST SOLUTION PROBLEM ACTION))
      (LET* ((*VRP-STOP-NEIGHBORHOOD-SEARCH* NIL) (OPS-LIST NIL))
        (PREPARE-SOLUTION-FOR-NEIGHBORHOOD-EXPLORATION WC)
        (INITIALIZE-ACTION-FOR-DELTA-COST-COMPUTATION WC PROBLEM ACTION)
        (DOSELECT-ROUTE* (R1 WC)
          (DOSELECT-CLIENT* (C1 R1 WC)
            (DOINSERT-CLIENT* (C1 R1 WC))))
        (VALUES)))
    #+end_example
*** Adding the required code snippets
    First, we need to add a new variable to count the number of better neighbors.  That can be done with a new method for =generate-inside-let-initializations=.

    Then we need to update the counter inside the macros.  That can be done with a method for =generate-code-inside-the-macros=.  Finally, we would want to return the value.  To do that, we add it to the return code.
**** adding the new variable to the let-initializations
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/tests.lisp 
    (defmethod generate-inside-let-initializations :after
        (description
         strategy
         (other-strategies count-better-neighbors)
         (where-to-store-it basic-neighborhood-strategy-blueprint))

      (push `(number-of-better-neighbors 0)
            (initializations-inside-the-let where-to-store-it)))
    #+END_SRC
***** testing the generated code so far
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((*vrp-unit-testing-display-output* nil)
           (*vrp-unit-testing-display-results* t)
           (bp1 (basic-strategy-blueprint))
           (code1 `((select-route r1)
                    (select-client c1 from r1)
                    (insert-client c1 into r1)))
           )

      (bformat t "Testing code-generation for count-neighbors")
      ;; let's populate the blueprint
      (prepare-blueprint-for-code-generation
       code1
       ,*exhaustive-search-strategy*
       (make-instance 'count-better-neighbors)
       bp1)

      (format t "the generated code:~%~a~%"
              (write-neighborhood-exploration-code bp1)))
    #+END_SRC
**** updating the value inside the macros
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/test.lisp 
    (defmethod generate-code-inside-macros :after
         (description
          strategy
          (other-strategies count-better-neighbors)
          (where-to-store-it basic-neighborhood-strategy-blueprint))

       (push `(if (< current-delta-cost 0)
                  ;; if it is
                  (then
                    ;; let's update the counter
                    (incf number-of-better-neighbors)))
             (code-inside-the-macros where-to-store-it))))


    #+END_SRC
***** testing the generated code so far
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((*vrp-unit-testing-display-output* nil)
           (*vrp-unit-testing-display-results* t)
           (bp1 (basic-strategy-blueprint))
           (code1 `((select-route r1)
                    (select-client c1 from r1)
                    (insert-client c1 into r1)))
           )

      (bformat t "Testing code-generation for count-neighbors")
      ;; let's populate the blueprint
      (prepare-blueprint-for-code-generation
       code1
       ,*exhaustive-search-strategy*
       (make-instance 'count-better-neighbors)
       bp1)

      (format t "the generated code:~%~a~%"
              (write-neighborhood-exploration-code bp1)))
    #+END_SRC
**** returning the number-of-better-neighbors
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-tests.lisp 
    (defmethod generate-return-code :after
        (description
         strategy
         (other-strategies count-better-neighbors)
         (where-to-store-it basic-neighborhood-strategy-blueprint))

      (push 'number-of-better-neighbors
            (return-code where-to-store-it)))
    #+END_SRC
***** testing the generated code so far
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((*vrp-unit-testing-display-output* nil)
           (*vrp-unit-testing-display-results* t)
           (bp1 (basic-strategy-blueprint))
           (code1 `((select-route r1)
                    (select-client c1 from r1)
                    (insert-client c1 into r1)))
           )

      (bformat t "Testing code-generation for count-neighbors")
      ;; let's populate the blueprint
      (prepare-blueprint-for-code-generation
       code1
       ,*exhaustive-search-strategy*
       (make-instance 'count-better-neighbors)
       bp1)

      (format t "the generated code:~%~a~%"
              (write-neighborhood-exploration-code bp1)))
    #+END_SRC
*** Mixing it with an existing code
    Here, we'll combine the existing code with a =best-improvement= strategy.  To do that we need to create a new class that inherits from both classes.  We want to also return the new delta-cost, so we also inherit from that class.

**** creating the new class that inherits from both classes
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (def-vrp-class best-improvement-counting-better-neighbors
          (count-better-neighbors
           return-best-delta-cost
           best-improvement-smart)
             ()
            :documentation "A class to represent a search where we count the number of better neighbors and return the best neighbor."
            :constructor (best-improvement-counting-better-neighbors ())
            :print-object-string ("<best-improvement-count-better-neighbors>")
            :slots-for-obj= ()
            :slots-for-clone ())
    #+END_SRC

    #+RESULTS:

      Let's see the generated code from this class.
****** testing the generated code so far
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (code1 `((select-route r1)
                     (select-client c1 from r1)
                     (insert-client c1 into r1)))
            )

       (bformat t "Testing code-generation for count-neighbors")
       ;; let's populate the blueprint
       (prepare-blueprint-for-code-generation
        code1
        ,*exhaustive-search-strategy*
        (make-instance 'best-improvement-counting-better-neighbors)
        bp1)

       (format t "the generated code:~%~a~%"
               (write-neighborhood-exploration-code bp1)))
     #+END_SRC
*** testing the generated code with one neighborhood exploration
    Here we explore only one neighborhood.

    To test the code, we need to keep in mind that, as we are using smart-macros, we have to use a "smart-action" for the delta-cost-action.
      
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((*vrp-unit-testing-display-output* nil)
           (*vrp-unit-testing-display-results* t)


           (code1 `((select-route r1)
                    (select-client c1 from r1)
                    (insert-client c1 into r1)))

           ;; the function to explore the neighborhood
           ;; (will be created later)
           (neighborhood-exploration-code nil)

           ;; the selection strategy we want to use
           (selection-strategy (make-instance
                                'best-improvement-counting-better-neighbors))

           ;; the problem we are working with
           (problem a-n33-k6-problem)

           ;; a deterministic initial solution
           (initial-solution
            (make-initial-solution-for-cvrp-deterministic problem))

           ;; the current-solution
           (current-solution nil)

           ;; the current delta cost
           (current-delta-cost nil)

           ;; the number of better neighbors
           (number-of-better-neighbors 0)

           ;; let's add the actions
           (delta-action (delta-cvrp-action*))
           (cvrp-action (basic-cvrp-action))
           )


      ;; let's create the function to explore the neighborhood
      (setf neighborhood-exploration-code
            (make-neighborhood-criterion
             code1
             ,*exhaustive-search-strategy*
             selection-strategy))

      ;; let's evaluate the initial solution
      (simulate-solution initial-solution problem cvrp-action)
      (setf (cost initial-solution) (+ (total-distance cvrp-action)
                                       (total-penalty cvrp-action)))

      (format t "Initial solution with cost: ~a~%"
              (cost initial-solution))
      (pp-solution initial-solution t)

      ;; let's explore the neighborhood
      (setf (values current-solution
                    current-delta-cost
                    number-of-better-neighbors)
            (funcall neighborhood-exploration-code
                     initial-solution
                     problem
                     delta-action))

      ;; let's print the results
      ;; (format t "best-delta-cost: ~a~%" current-delta-cost)
      (format t "number-of-better-neighbors: ~a~%" number-of-better-neighbors)
      (if current-solution
          (pp-solution current-solution t))


      )
    #+END_SRC
       
*** testing the generated code with a Neighborhood Descent Method
      
    Here we explore apply a Neighborhood Descent Method.

    We have to keep in mind that, as we are using smart-macros, we have to use a "smart-action" for the delta-cost-action.  That's why the constructor has a * behind it.
      
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
    (let* ((*vrp-unit-testing-display-output* nil)
           (*vrp-unit-testing-display-results* t)


           (code1 `((select-route r1)
                    (select-subroute s1 from r1)
                    (select-route r2)
                    (insert-subroute s1 into r2)))

           ;; the function to explore the neighborhood
           ;; (will be created later)
           (neighborhood-exploration-code nil)

           ;; the selection strategy we want to use
           (selection-strategy (make-instance
                                'best-improvement-counting-better-neighbors))

           ;; the problem we are working with
           (problem a-n33-k6-problem)

           ;; a deterministic initial solution
           (initial-solution
            (make-initial-solution-for-cvrp-deterministic problem))

           ;; the neighbor found by the algorithm
           ;; start with t to enter the while
           (better-neighbor t)

           ;; the current delta cost
           (current-delta-cost nil)

           ;; the number of better neighbors
           (number-of-better-neighbors 0)

           ;; let's add the actions
           (delta-action (delta-cvrp-action*))
           (cvrp-action (basic-cvrp-action))
           )


      (format t "~2%========================================~%")
      (format t "========================================~%")
      (format t "Testing criteria:~%~{  ~a~%~}" code1)
      (format t "========================================~%")
      (format t "========================================~2%")

      ;; let's create the function to explore the neighborhood
      (setf neighborhood-exploration-code
            (make-neighborhood-criterion
             code1
             ,*exhaustive-search-strategy*
             selection-strategy))

      ;; let's evaluate the initial solution
      (simulate-solution initial-solution problem cvrp-action)
      (setf (cost initial-solution) (+ (total-distance cvrp-action)
                                       (total-penalty cvrp-action)))


      (loop while better-neighbor
            for iteration from 1
            ;; let's explore the neighborhood
            do (setf (values better-neighbor
                             current-delta-cost
                             number-of-better-neighbors)
                     (funcall neighborhood-exploration-code
                              initial-solution
                              problem
                              delta-action))
            do (progn
                 (format t "At iter ~2d, number-of-better-neighbors: ~a~%"
                         iteration
                         number-of-better-neighbors)
                 (pp-solution initial-solution t)
                 (format t "========================================~%"))

            do (if better-neighbor
                   (setf initial-solution (clone better-neighbor))))


      (format t "Local minimum found with cost ~a~%" (cost initial-solution))



      )
    #+END_SRC
       

* Adding a finite fleet to the CVRP
  
** description
   In this section I'm going to log the process of adding a finite fleet to the CVRP.

   That should be relatively simple to solve: all the solutions are going to have as many routes as there are vehicles.  To keep that during all the algorithm we need to do two things:

   1. do not remove the empty routes in the solution
   2. do not create new routes

   The second point is as simple as not to consider that criterion.

   However, to do the first one, we need some refactoring, because there is a method =finish-apply-neighborhood-operations= that does precisely that :-(.  There is a simple solution for this, though.  We create a new class =solution-with-inifinite-fleet= (or something like that) and when a solution inherits from this class, then it executes that method.  Otherwise, it doesn't do anything.

   We'll do that in the following sections as a tutorial, and then, I'll add it to the appropriate files.

** steps to add the infinite fleet and keep everything the same
*** create a new class (with infinite fleet)
    We create the new class in the file [[file:vrp-classes.org::#class:has-infinite-fleet][vrp-classes.org]].

*** create the class basic-cvrp-solution
    Now we need to create a new solution class, let's call it =basic-cvrp-solution= that inherits from =basic-solution= and =has-inifinite-fleet=.  That is done [[file:vrp-classes.org::#class:basic-cvrp-solution][here]].

*** update the macro with-basic-cvrp-solution
    The next step is to make the macro =with-basic-cvrp-solution= return a =basic-cvrp-solution=.  To do that I changed [[file:vrp-classes.org::#macro:with-basic-cvrp-solution][this code]].

*** change the method finish-apply-neighborhood-operations

    The code it executes right now should only be done with classes than inherits from infinite-fleet.

    First let's prevent the primary method from doing anything.  DONE.
    Now, let's remove the empty routes only if we have inifinte fleet and let's make that an :after method.  DONE.

    But now I realized that to make that work I need a =working-copy= that inherits from =solution-with-infinite-fleet=.

    To do that I think that it is better if the =solution-with-infinite-fleet= does not have the word solution in it.  I'm going to change that.  DONE.  Now the name of the class is =has-infinite-fleet=.

    With this addition I'll create a =working-copy= that inherits from this class.

*** overload make-working-copy

    Now, it returns the appropriate instance of make-working-copy.

*** fix the generation of neighborhood-exploration routines

    to use =make-working-copy= instead of =basic-working-copy=.  That is done in the file vrp-search-strategies.

    Apparently, the only change we need to make is inside the let initializations.  I did that already.

*** change all the methods for the creation of initial-solutions
   
    I did that on the file vrp-algorithms.org.
*** here I'd like to test whether the algorithms are still working

    And yes.  They are working!!!  :-D.
** steps to add a finite fleet

*** description
    In this case, I think that we need to do more things, but not as many as one may initially think ;-).

    For instance, the only things we need are probably:

    - to be coherent I'll add a finite-fleet-cvrp class
      but I'm not sure, because that would only be a basic-solution :-o.
    - a new problem with a list of capacity for its vehicles
    - a macro to create a basic-solution from that problem
    - routines to create initial solutions for this problem

    and that should be all :-o

    Let's do that.

*** add the new problem

    Done.  It is added to the vrp-classes.org file.

    And also created a macro to create disposable instances of this type of problem.

*** add a macro to create a basic solution for this type of problem

    DONE.  It is also on the file vrp-classes.org.
   
*** create the functions to create the initial solutions

    I suppose that this is going to be located in the file vrp-algorithms.org, where the other initialization methods reside.

    DONE.  There they are :-D.
*** create some data for this type of problem

    To do that I'll need an instance of the finite-fleet-cvrp.  I'll make a modification of the a-n33-k6-problem.

    That's on the vrp-data.org file.
*** test the initial solutions methods with the actual data

    We can do that like this:

    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
    (let* ((s1 nil)
           (action (basic-cvrp-action)))

        (setf s1 (make-initial-solution-for-finite-fleet-cvrp-deterministic
                  ff-a-n33-k6-problem))
        (pp-solution s1 t) (terpri)
        ;; let's simulate the solution
        (simulate-solution s1 ff-a-n33-k6-problem action)
        (format t "Distance: ~a~%Penalty: ~a~%"
                (total-distance action)
                (total-penalty action)))
     #+END_SRC

     It works!!!

*** fix the make-feasibility-array

    Now that function is a generic function to adapt to several problems and solutions.

*** test the classicals algorithms with these solutions

    Tested VND in the file algorithms.org.
   
*** Now let's test a real VNS without the creation of new routes
   

* (Tutorial for JJ) About basic-neighborhood-operations

** description
   In this section I'll write a small tutorial for JJ on the subject of neighborhood-operations.  The idea is simple: he should receive a list with these operations and "apply" them to the tape (or whatever he's using).  Actually, I believe that the best "tutorial" is to read the section on the vrp-operations.  So, there is no tutorial :-P, just read the docs ;-).

   If there is any question, ask ;-).

   The section that should be read is [[file:vrp-classes.org::#sec:neighborhood-operations][this]]: section Neighborhood operations on file vrp-classes.org.

   After reading that, I can tell you that you'll receive a list of instances of classes like those.  So far only select and insert client, but in a future, there should be more.  The important thing is that you'll always receive "simpler-operations", that is, operations that can not be decomposed into simpler ops.  For instance, you'll never receive a swap, because a swap can be decomposed into 2 selections and 2 insertions.  You'll receive the 2 selections and the 2 insertions.  Well, at least it will be so, until you decide that you want "bigger" operations because you can handle them ;-).  But, for now, let's keep it this way.


* Adding routes with two depots
  
** description
   In this section I'm going to add problems where each route has two depots.  The first one is where the vehicle starts and the second is where the vehicle should end.

   Apparently, the only change required here is the function =client-at= that returns the depot when asked for a position that is smaller than 1 or greater than the number of clients in the route.

   The function =client-at= is a generic function, so it should be easy to extend it with the appropriate classes.

   Right now, I'm thinking about adding a route with and end depot.  But I already have had the experience of a bad CLOS design, so I'm adding 2 classes: the classical =has-one-depot= and the "new" one =has-an-end-depot=.  The basic (and classical) route-for-simulation will inherit from =has-one-depot=, and the new ones, from the one with the end depot.

   The one with the end-depot will have a new slot, and we'll override the generic function that accesses that slot for the case of standard routes, and in that case, we'll return the original depot.

   Those are the ideas so far.  Let's see how much do we have to change ;-).

   The steps should be

    - create the class has-one-depot
    - create the class has-an-end-depot
    - modify the current classes to inherit from the new ones
    - modify the existing code to use the new classes


** create the class has-one-depot
   The code for this class can be found [[file:vrp-classes.org::#class:has-one-depot][here]].  This is the class that has the slot depot.



** create the class has-an-end-depot
   This class adds the slot =end-depot=. The code for this class can be found [[file:vrp-classes.org::#class:has-an-end-depot][here]].



** modify the current classes to inherit from the new ones
   - [X] basic-route
   - [X] basic-problem



** modify the existing code to use the new classes

   First, we modify the function =client-at=, to return the depot or the end-depot appropriately.  That should be done [[file:vrp-neighborhood-simulation.org::#fun:client-at][here]].

   Now I want to run a VNS to check that everything is still working.

   It is working.  I had to add a method =end-depot= for the basic-working-copy, but other than that, it worked fine ;-).


** Let's check that everything works well
   To do that, I'm tangling everything and testing VNS with a-n33-k6-problem.
   Ok.  It does.



** TODO deal with route-for-simulation that inherits from basic-route

   And now I need to duplicate the information and functionalities of that route :-o, :-(.

   Maybe the solution is to add a new class that does everything this one does?

   What I'm doing now is to inherit from that class and adding the class =has-an-end-depot=.


** modify the route simulation methods to deal with an end-depot

     - when-route-begins: only in has-one-depot
     - when-route-ends: calls end-depot instead
     That should be easy.

     Actually I have a better idea.  I'll use the same code, but in the method =when-route-ends=, instead of moving to the =depot=, I'll call the =end-depot= method.  This should work because the classes with only one depot can also use the method =end-depot=.

     I'm making the change [[file:vrp-moments.org::#moment:when-route-ends-for-cvrp][here]].

     DONE.  It works.

     Now I want to create a route with an actual end-depot, and test the moment =when-route-ends=.

     But to do that, I'll need also to modify the get-distance-from-to :-o and that depends on the problem.  That's why I'm creating a problem with an end depot.
     


** create a problem with end-depot

   And all the related functionalities and macros :-(.

   - [X] create the class
   - [X] create the disposable macros



** Modify the get-distance-from-to when there is an end-depot

   what do we do in this case? :-o  Put the depot at the end?  Maybe that's the best solution.  Then...  ups.  I have to think about it.

   Maybe we just have to put the end-depot at the end of the matrix...
   
   Not so sure, because the method just receives a two instances of =has-id=, and I'm not sure...  Wait!  I know.  The id of the end depot is n + 1 where n is the number of clients and... Voila!  I think I solved this problem :-D.  We'll see tomorrow ;-).

   OK.  That idea seems to work, and then we don't have to change anything.


** add a macro to easily create instances of end-depot solutions

   The code to achieve this is in this [[file:vrp-classes.org::#macro:with-finite-fleet-end-depot-cvrp-solution][section]].

   DONE. The simulation of the solution works as it should.
   

** create a route with end-depot and test whether it works or not

   - [X] create the class
   - [X] test some of the methods
     - [X] test the simulate-route
     - [X] test the simulate solution
     - [X] test client-at
     - [X] test the evaluation of a neighbor :-o
       VND worked!!!  :-D.

   
** +add a working-copy with end-depot.  test the client-at+

   So far, we are going to use end-depots, but in a problem with finite-fleet.  The propossed solution is to work with a solution that always has as many routes as there are vehicles in the fleet, and never add new routes.  Because of that, when we call the =client-at= method on a working copy, there will always be an actual-route, and we will never have to call an end-depot on the working-copy.

   I'm going to check that anyway.

   Because of the way we are going to solve the problem with mu


**  run a VNS to check the that everything works

   +Probably with clients with coords to create a problem with known solution+

   The tiny example worked well!!!

   So, I assume that we can solve a CVRP with finite fleet and different depots for each route.

   To do that, we just have to add as many routes as there are vehicles...

   But wait!!!  I need to check what happens when there is an empty route in this case :-o.

   
* <2021-11-27 Sat> Tutorial for adding a new behavior (to count solution)
** description
   In this tutorial I'm going to describe how to add new elements to the system.  In this case, we are going to add a counting-solution that has a list of unused depots.

   This new class should inherit from counting-basic-solution (for the routes and the clients), and should add the behavior for the depots.

   To do that, we need two classes: one in the VRP ecosystem, and the other in the counting ecosystem.  To make both systems as flexible as possible, both classes should only add the minimum functionality and should work as mixins.

   The class in the VRP ecosystem will be:

    - has-multiple-depots

   The class in the counting ecosystem will be...  :-/...  the same?

   I believe that I'm going to experiment with using the same class in both worlds :-o.

   In the VRP system, the slot =depots= will be a list with the depots, and in the counting system it will be just a number.

   Note for Gabriela (2021-11-12): This can be done with your class =has-multi-depot=, but I'm going te define this one here.

   The steps to add a new element should be:

   1. [ ] Add the class to the VRP system
   2. [ ] Add the class to the counting system
   3. [ ] Add the method make-counting-solution-from for that class
   4. [ ] Add the :after method initialize-counting-solution-from

** Add the class to the VRP system
*** description
    Here we create a class named =has-multiple-depots=.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes-for-gaby.lisp
    (def-vrp-class has-multiple-depots ()
      ;; all the slots are defined in the base class
      ((depots))
      ;; the rest of the class elements
      :documentation "A class to represent a solution (or a counting-solution) that has a list of depots."
      ;; no constructor because it as an abstract class
      ;; no print-object because it as an abstract class
      ;; no obj= or clone because it as an abstract class
      )
    #+END_SRC
** Add the class to the counting system
*** description
    There is nothing to do here, because in the counting system, we'll use the same class, only that the slot =depots= now is a number instead of a list of depots.
** Add a test-actual-class in both systems to test everything
*** description
    To test the functionality we need an actual class that we can instantiate.
    In this section we create those test classes.
*** code class for vrp
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes-for-gaby.lisp
    (def-vrp-class test-mdvrp-solution (basic-solution
                                        has-multiple-depots)
      ;; no slots, everything is inherited
      ()
      :documentation "A test solution with multiple depots."
      :constructor (test-mdvrp-solution (&key id routes depots (cost 0)))
      :print-object-string ("T_md_S~a: (~a)~%~{  ~a~%~} depots: ~a"
                            id cost routes depots)
      :slots-for-obj= (id routes cost depots)
      :slots-for-clone (id routes cost depots)
    )
     #+END_SRC
*** test class for vrp
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-clients (1 2 3 4 5 6)
       (let* ((d1 (basic-depot 1))
              (d2 (basic-depot 2))
              (d3 (basic-depot 3))
              (v1 (basic-vehicle 1))
              (vrp-md-solution (test-mdvrp-solution
                                :id 1
                                :routes (list
                                         (basic-route :id 1
                                                      :vehicle v1
                                                      :depot d1
                                                      :clients (list c1 c2))
                                         (basic-route :id 2
                                                      :vehicle v1
                                                      :depot d1
                                                      :clients (list c3 c4 c5))
                                         (basic-route :id 3
                                                      :vehicle v1
                                                      :depot d2
                                                      :clients (list c6)))
                                :depots (list d1 d2 d3))))

         (bformat t "Testing test-mdvrp-solution")
         (format t "~a~%" vrp-md-solution)))
    #+END_SRC
*** code class for counting
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes-for-gaby.lisp
    (def-vrp-class test-mdvrp-counting-solution (counting-basic-solution
                                                 has-multiple-depots)
      ;; no slots, everything is inherited
      ()
      :documentation "A test counting solution with multiple depots."
      ;; no constructor because this class should be instantiated with
      ;; make-instance in make-counting-solution-from
  
      :print-object-string ("T_CS_S:~% clients: ~a~% routes: ~a~% depots: ~a~%"
                            num-clients routes depots)
      :slots-for-obj= (num-clients routes depots)
      :slots-for-clone (num-clients routes depots)
    )
     #+END_SRC
*** test class for counting
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((sol (make-instance 'test-mdvrp-counting-solution)))

       (setf (routes sol)      '(2 3 1)
             (num-clients sol) 6
             (depots sol)      3)

         (bformat t "Testing test-mdvrp-counting-solution")
         (format t "type: ~a~%" (type-of sol))
         (format t "test-counting-solution:~%~a~%" sol))
    #+END_SRC
** Add the :after method initialize-counting-solution-from for that class
*** description
    Here we update the =depots= slot in the class.
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes-for-gaby.lisp
    (defmethod initialize-counting-solution-from :after
        ((count-sol has-multiple-depots)
         (vrp-solution has-multiple-depots))
      "Initalizes the slots in the has-multiple-depots counting solution."
      (setf (depots count-sol) (length (depots vrp-solution))))
     #+END_SRC
*** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-clients (1 2 3 4 5 6)
             (let* ((d1 (basic-depot 1))
                    (d2 (basic-depot 2))
                    (d3 (basic-depot 3))
                    (v1 (basic-vehicle 1))
                    (vrp-md-solution (test-mdvrp-solution
                                      :id 1
                                      :routes (list
                                               (basic-route :id 1
                                                            :vehicle v1
                                                            :depot d1
                                                            :clients (list c1 c2))
                                               (basic-route :id 2
                                                            :vehicle v1
                                                            :depot d1
                                                            :clients (list c3 c4 c5))
                                               (basic-route :id 3
                                                            :vehicle v1
                                                            :depot d2
                                                            :clients (list c6)))
                                      :depots (list d1 d2 d3)))
                    (counting-sol (make-instance 'test-mdvrp-counting-solution)))

               (bformat t "Testing test-mdvrp-counting-solution")

               (format t "~a~%" vrp-md-solution)

               (format t "type-of: ~a~%" (type-of counting-sol))

               (initialize-counting-solution-from counting-sol vrp-md-solution)

               (format t "counting-solution: ~a~%" counting-sol)))
    #+END_SRC
** Add the method make-counting-solution-from for that class
*** description
    This is the last function and depends totally on the final user.
    This should be done for each "final" class that inherits from all the subclasses :-(.

    +But as the code of the function is always the same, we can create a macro for that :-).  And as this "final" classes won't have any slots, and should always inherit from =counting-basic-solution=, the user should only add the extra properties.+

    That was cute, but is not what is needed :-/.  We need to define, for each solution class in the VRP system, what counting class we need.  But that can probably be a macro too :-D.

    Anyway, I'm going to write it here for the test-classes that I created:
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes-for-gaby.lisp
    (defmethod make-counting-solution-from 
        ((vrp-solution test-mdvrp-solution))
      "Creates an instance of the corresponding counting solution."
      (make-instance 'test-mdvrp-counting-solution))
     #+END_SRC
** Test everything
*** test
**** basic-tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-clients (1 2 3 4 5 6)
             (let* ((d1 (basic-depot 1))
                    (d2 (basic-depot 2))
                    (d3 (basic-depot 3))
                    (v1 (basic-vehicle 1))
                    (vrp-md-solution (test-mdvrp-solution
                                      :id 1
                                      :routes (list
                                               (basic-route :id 1
                                                            :vehicle v1
                                                            :depot d1
                                                            :clients (list c1 c2))
                                               (basic-route :id 2
                                                            :vehicle v1
                                                            :depot d1
                                                            :clients (list c3 c4 c5))
                                               (basic-route :id 3
                                                            :vehicle v1
                                                            :depot d2
                                                            :clients (list c6)))
                                      :depots (list d1 d2 d3)))
                    (counting-sol nil))

               (bformat t "Testing test-mdvrp-counting-solution")

               ;; (format t "~a~%" vrp-md-solution)

               (setf counting-sol (make-counting-solution-from vrp-md-solution))

               (format t "type-of: ~a~%" (type-of counting-sol))

               (initialize-counting-solution-from counting-sol vrp-md-solution)

               (format t "counting-solution: ~a~%" counting-sol)))
     #+END_SRC
**** testing transform-to-counting-solution    
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-clients (1 2 3 4 5 6)
             (let* ((d1 (basic-depot 1))
                    (d2 (basic-depot 2))
                    (d3 (basic-depot 3))
                    (v1 (basic-vehicle 1))
                    (vrp-md-solution (test-mdvrp-solution
                                      :id 1
                                      :routes (list
                                               (basic-route :id 1
                                                            :vehicle v1
                                                            :depot d1
                                                            :clients (list c1 c2))
                                               (basic-route :id 2
                                                            :vehicle v1
                                                            :depot d1
                                                            :clients (list c3 c4 c5))
                                               (basic-route :id 3
                                                            :vehicle v1
                                                            :depot d2
                                                            :clients (list c6)))
                                      :depots (list d1 d2 d3)))
                    (counting-sol nil))

               (bformat t "Testing test-mdvrp-counting-solution")

               (setf counting-sol (transform-to-counting-solution vrp-md-solution))

               ;; (format t "applicable methods: ~a~%"
               ;;         (compute-applicable-methods #'transform-to-counting-solution
               ;;                                     (list vrp-md-solution)))

               (format t "applicable methods: ~a~%"
                       (compute-applicable-methods #'initialize-counting-solution-from
                                                   (list counting-sol vrp-md-solution)))

               (format t "type-of: ~a~%" (type-of counting-sol))

               ;; (initialize-counting-solution-from counting-sol vrp-md-solution)

               (format t "counting-solution: ~a~%" counting-sol)))
     #+END_SRC
** Add the new behavior to any class you want (for Gabriela 2021-11-12)
   Lo que se hizo aquí significa que ahora cuando quieras crear una clase que tenga la funcionalidad de contar cuando hay una lista de depósitos, solo tienes que hacer que herede de la clase =has-multiple-depots=.

   Por ejemplo, vamos a asumir que existe una clase que se llama =has-finite-fleet=, que se parece mucho =has-multiple-depots= y para la que ya está implementado el método :after de =initialize-counting-solution-from=.

   Si quieres tener una clase que te permita incluir múltiples depósitos y flota finita (o sea, que haya que contar también los vehículos) pudieras crear una clase:

    counting-md-ff-solution
    
    y hacer que herede de =has-multiple-depots= y =has-finite-fleet= (que todavía no existe).

    Después, solo tendrías que saber cuál es la clase en el sistema VRP que tiene esas dos propiedades y agregar el método primario de =make-counting-solution-from=.

    Vamos a suponer que la clase en el sistema VRP se llama =md-ff-solution=.  En ese caso, tendrías que definir el método =make-counting-solution-from= para que reciba una instancia de =md-ff-solution= y devuelva una instancia de =counting-md-ff-solution=, sin inicializar ningún slot de esta última.

    Si para la clase has-finite-fleet se definió el método after de =initialize-counting-solution-from= no tendrías que hacer más nada :-).
   



* Discarded                                                        :noexport:
** pp-route with solutions
        However, there is a better way to print the routes.  This is using the function pp-route, where =pp= stands for pretty-print.
     
      #+BEGIN_SRC lisp +n -r :results output :exports both.lisp
      (with-basic-solution (s1 ((1 2 3)
                                (4 5)
                                (6 7 8)))
        ;; code here
        ;; where you car reference a basic-solution s1
        ;; for instance, we can just print it
        (bformat t "Printing the properties of the solution")

        (format t "id: ~a~%" (id s1))
        (loop for r in (routes s1)
              for i from 1
              do (pp-route r s1 t))
        (format t "costs: ~a~%" (cost s1)))
      #+END_SRC

