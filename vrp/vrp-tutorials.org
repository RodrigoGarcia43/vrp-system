#+TITLE: VRP solver environment
#+AUTHOR: Fernando Rodriguez Flores
#+DATE 2019-02-14
#+TAGS: suite(s) classes(c) moments(m) data(d) algoritms(a) dcost(v)
#+TAGS: emacs(e) utils(u) strat(t) simul(i) vanny(o)
#+TODO: TODO | DONE
#+STARTUP: nologdone

* Description
  In this file we'll write all the tutorials explaining some feature of the vrp-suite.



* How to load the system (vrp) with emacs
   Here we'll assume that the user is using emacs.  
   1. Clone the git repo in the folder =vrp= to the working directory
      For the rest of the tutorial, we assume that the name of the working directory is tmp/vrp.

   2. We should have one in the working directory: vrp-emacs-utils.el. Let's load it.
      =M-x load-file /tmp/vrp/vrp-emacs-utils.el=

   3. From emacs fire up slime (=M-x slime=)

   4. In Slime, change the current directory to the working directory
       (this can be done by typing =,= in the REPL and then =cd= <RETURN>, and navigate to the working directory)

   5. In slime load the file src/vrp-load-files
      #+BEGIN_SRC lisp +n -r :results none :exports code 
      (load "src/vrp-load-files.lisp")
      #+END_SRC

   6. Change to the package vrp
      #+BEGIN_SRC lisp +n -r :results none :exports code 
      (in-package :vrp)
      #+END_SRC
      
      From here on, we are ready to work with the system, and that's what we'll do in the following tutorials.


* How to load edit the =src= files
   Here we'll assume that the user is using emacs.  
   1. We can edit the files that we want to tangle and load in the file /tmp/vrp/vrp-suite.org
   To do that, we look in utilities for the sections:
    
    =Emacs function to tangle everything=
    =A file to load all the tangled files=

   3. Then we tangle the file /tmp/vrp/vrp-suite.org for the changes to be done applied.
      Open the file /tmp/vrp-suite/vrp-suite.org in emacs and do =M-x org-babel-tangle=

   4. After the tangle, the file /tmp/vrp-emacs-utils.el should have been modified.
   This files contains a lot of useful functions.

   6. From emacs load /tmp/vrp/vrp-emacs-utils.el
      =M-x load-file /tmp/vrp/vrp-emacs-utils.el=

   7. Then we can tangle all the files (or at least those in =Emacs function to tangle everything=) in the vrp-suite at once.
      To do that, in emacs, change the current directory to tmp/vrp, and execute =M-x vrp-tangle-all-files=

      There is an alternative approach...  We can open each org file in the folder and in each of them execute =M-x org-babel-tangle=.  It will take longer, but it should also work.

   8. When we load the files in slime (like in previous tutorial), the files loaded will be those in =A file to load all the tangled files=.


* Basic elements of the suite
   In this tutorial we present the basic elements of a VRP: the clients, the vehicles, the routes, the solution and the problems.

   In the vrp-suite we have a class hierarchy for each of these elements.  And that's what we are going to present in the next section.

   The code for all these classes can be found in the file [[file:vrp-classes.org][vrp-classes.org]].

*** classes
**** clients
***** basic-client
      The most basic element in this hierarchy is the =basic-client=, that only has one id.  The constructor is =(basic-client id)= and it receives the id.

      In the following snippet, we create two basic-clients each with a different id, and we print them.

      #+begin_src lisp :export both :results output
      (let* ((c1 (basic-client 1))
             (c2 (basic-client 2)))
        (format t "Client 1: ~a~%" c1)
        (format t "Client 2: ~a~%" c2))
      #+end_src

      #+RESULTS:
      : Client 1: <c:1>
      : Client 2: <c:2>
     
***** basic-cvrp-client

      The =basic-cvrp-client= is a client that has an id and a demand.  It is the most basic client that can be used in CVRP problem.  The constructor receives two arguments: the id and the demand.

      #+begin_src lisp :export both :results output
      (let* ((c1 (basic-cvrp-client 1 10))
             (c2 (basic-cvrp-client 2 15)))
        (format t "Client 1: ~a, with demand: ~a~%" c1 (demand c1))
        (format t "Client 2: ~a, with demand: ~a~%" c2 (demand c2)))
      #+end_src

      #+RESULTS:
      : Client 1: <c1: 10>, with demand: 10
      : Client 2: <c2: 15>, with demand: 15
***** other clients
      The classes for other clients in the system can be found in this [[file:vrp-classes.org::*Clients][section]].

**** vehicles

     In the section [[file:vrp-classes.org::*Vehicles][Vehicles]] there are several classes for vehicles, but most of them are suppossed to become obsolete in a near future :-(, so let's just focus on the most basic ones, the basic vehicle and the cvrp-vehicle.

     
***** basic-vehicle
      Again, the basic vehicle is a vehicle that has only one id.  It's constructor receives a number that will be the id.

      #+begin_src lisp :export both :results output
      (let* ((v1 (basic-vehicle 1))
             (v2 (basic-vehicle 2)))
        (format t "Vehicle 1: ~a~%" v1)
        (format t "Vehicle 2: ~a~%" v2))
      #+end_src

      #+RESULTS:
      : Vehicle 1: <v:1>
      : Vehicle 2: <v:2>

***** cvrp-vehicle

      The =cvrp-vehicle= class also has a capacity, and a (current) cargo that should also be passed to the constructor.  The =cargo= argument in the constructor is optional and defaults to 0.

      #+begin_src lisp :export both :results output
      (let* ((v1 (cvrp-vehicle 1 10 5))
             (v2 (cvrp-vehicle 2 15)))
        (format t "Vehicle 1: ~a, with cargo ~a and capacity ~a~%"
                v1
                (cargo v1)
                (capacity v1))
        (format t "Vehicle 2: ~a, with cargo ~a and capacity ~a~%"
                v2
                (cargo v2)
                (capacity v2)))
      #+end_src

      #+RESULTS:
      : Vehicle 1: <cv:1. 5/10>, with capacity: 10
      : Vehicle 2: <cv:2. 0/15>, with capacity:: 15

      In the =print-object= method, we can see the =id= of the vehicle and the (current) =cargo= separated from the =capacity= by a slash.
**** depot
     The class =basic-depot= only has one id, that defaults to 0 if it is not passed as an argument to the constructor.
     
      #+begin_src lisp :export both :results output
      (let* ((d1 (basic-depot))
             (d2 (basic-depot 1)))
        (format t "depot 1 ~a, with id ~a~%" d1 (id d1))
        (format t "depot 2 ~a, with di ~a~%" d2 (id d2)))
      #+end_src


      #+RESULTS:
      : depot 1 <d:0>, with id 0
      : depot 2 <d:1>, with di 1

      You can verify in the previous code that we created the first depot without specifying the value of the id and it is set to 0, the default value.

      The classes for the depot can be found [[file:vrp-classes.org::*Depots][here]].
**** route
     The classes for the routes can be found [[file:vrp-classes.org::*Routes][here]].

     Here, we'll mention only the =basic-route= because we are only printing the objects.

     The class =basic-route= has a vehicle, a list with clients and a depot.  We can create a route by creating all the individual elements and putting them together in the basic-route class.

     The constructor for this class receives all the elements with named parameters.

     In the example, we'll create a route with 3 clients.

     #+begin_src lisp :export both :results output
     (let* ((d1 (basic-depot))
            (v1 (basic-vehicle 1))
            (c1 (basic-client 1))
            (c2 (basic-client 2))
            (c3 (basic-client 3))
            (r1 nil))
       ;; here we construct the route.
       (setf r1 (basic-route :id 1 :vehicle v1 :depot d1
                              :clients (list c1 c2 c3)))
       ;; and here we print it
       (format t "route 1 ~a~%" r1))
     #+end_src

     #+RESULTS:
     : route 1 <r1: <v:1> (<d:0>: (<c:1> <c:2> <c:3>))>

     In the next section we'll use several routes to create a solution.

**** solution
     The classes for the solution can be found in the section [[file:vrp-classes.org::*Solutions][Solutions]].
     
     Here, we'll mention only the =basic-solution= because we are only printing the objects.

     The class =basic-route= has an id, a list of routes and a cost, that right now we won't use. 

***** creating a basic-solution

      The constructor for this class receives all the elements with named parameters.  The cost argument defaults to 0.

      In the example, we'll create a solution with two routes.

      #+begin_src lisp :export both :results output
      (let* ((d1 (basic-depot))
             (v1 (basic-vehicle 1))
             (c1 (basic-client 1))
             (c2 (basic-client 2))
             (c3 (basic-client 3))
             (r1 (basic-route :id 1 :vehicle v1 :depot d1
                               :clients (list c1 c2)))
             (r2 (basic-route :id 2 :vehicle v1 :depot d1
                              :clients (list c3)))
             (s1 nil))
        ;; here we construct the solution.
        (setf s1 (basic-solution :id 1 :routes (list r1 r2)))
  
        ;; and here we print it
        (format t "solution: ~a~%" s1))
      #+end_src

      #+RESULTS:
      : solution: S1: (0)
      :   <r1: <v:1> (<d:0>: (<c:1> <c:2>))>
      :   <r2: <v:1> (<d:0>: (<c:3>))>
      :

      When we print the solution we can see it's id (after the S), the cost (in parentheses) after S1, and then each route on a line.

***** pretty-printing the solution
      In this section, we'll introduce a method to print a solution in a friendlier way.

      To do that we use the generic-function =pp-solution=.  This function receives a solution and a stream.  In this case, the stream will be t (the standard output stream).

      We'll use the solution from the previous section:
     
      #+begin_src lisp :export both :results output
      (let* ((d1 (basic-depot))
             (v1 (basic-vehicle 1))
             (c1 (basic-client 1))
             (c2 (basic-client 2))
             (c3 (basic-client 3))
             (r1 (basic-route :id 1 :vehicle v1 :depot d1
                               :clients (list c1 c2)))
             (r2 (basic-route :id 2 :vehicle v1 :depot d1
                              :clients (list c3)))
             (s1 nil))
        ;; here we construct the solution.
        (setf s1 (basic-solution :id 1 :routes (list r1 r2)))

        ;; and here we print it
        (format t "This is the printed-solution:~%~a~%" s1)

        (format t "and this is the pretty-print version:~%")
        (pp-solution s1 t))
      #+end_src

      #+RESULTS:
      : This is the printed-solution:
      : S1: (0)
      :   <r1: <v:1> (<d:0>: (<c:1> <c:2>))>
      :   <r2: <v:1> (<d:0>: (<c:3>))>
      : 
      : and this is the pretty-print version:
      : S1:
      :     R1: (1, 2)
      :     R2: (3)

**** problem

     In this section we present some problems.  All the problems currently in the suite can be found in the section [[file:vrp-classes.org::*Problems][Problems]].  Here we'll just present two problems: the basic-problem and the cvrp-problem.

     
***** basic-problem

      The basic problem has an id, a depot and a list with clients.  

      The constructor for this class receives all the elements with named parameters.  

      In the example, we'll create a problem with 3 clients.

      #+begin_src lisp :export both :results output
      (let* ((d1 (basic-depot))
             (c1 (basic-client 1))
             (c2 (basic-client 2))
             (c3 (basic-client 3))
             (p1 nil))
        ;; here we create the problem.
        (setf p1 (basic-problem :id 1
                                :clients (list c1 c2 c3)
                                :depot d1))

        ;; and here we print it
        (format t "Problem: ~a~%" p1))
      #+end_src

      #+RESULTS:
      : Problem: <P1.(<c:1> <c:2> <c:3>), <d:0>>

      This is a very basic problem and it is pretty useless.  In the next section we introduce the cvrp-problem.

***** cvrp-problem

      In the CVRP we have a set of clients a central depot, we know the distance between each pair of clients (and the depot), and we can assume an infinte number of vehicles, all of them with the same capacity.  Also, for each client we know its demand.

      The class cvrp-problem has an id, a list of clients (which should have a demand slot), a distance-matrix (with the distance between each pair of clients and the depot), and a capacity, that is the same for all the vehicles.

      The constructor for this class receives all the elements with named parameters.  

      In the example, we'll create a problem with 3 clients, all of them of type =basic-cvrp-client=

      #+begin_src lisp :export both :results output
      (let* ((d1 (basic-depot))
             (c1 (basic-cvrp-client 1 10))
             (c2 (basic-cvrp-client 2 20))
             (c3 (basic-cvrp-client 3 30))
             (distance-matrix #2a((0 1 2 3)
                                  (1 0 4 3)
                                  (2 1 0 6)
                                  (3 8 6 0)))
             (capacity 30)
             (p1 nil))
        ;; here we create the problem.
        (setf p1 (cvrp-problem :id 1
                               :clients (list c1 c2 c3)
                               :depot d1
                               :distance-matrix distance-matrix
                               :capacity capacity))

        ;; and here we print it
        (format t "Problem: ~a~%" p1))
      #+end_src

      #+RESULTS:
      : Problem: <CVRP 1: 3 clients, capacity 30>

      With this problem and a solution we can evaluate the cost of the solutions.  We'll do that on the [[*Tutorial 2: evaluating solutions][Tutorial 2: evaluating solutions]], but first we'll present a more convenient way to create clients, solutions and problems.  We'll do that in the next section.
      
*** macros to abstract the use of the classes
    In the vrp-suite there are some macros than can help us to quickly create instances of some of the classes in the suite.  Following the lisp convention, all those macros start with "with-NAME-OF-THE-INSTANCE". Let's see some examples.

    All the macros with the descrption and some examples can be found in the section:  [[file:vrp-classes.org::*Macros to deal with disposable instances][Macros to deal with disposable instances]].
    
**** with-basic-clients
     We can use this macro when we want to create some basic-clients.  It receives a list with integers and creates symbols of the form cn, for each n in the list of integers.  All those symbols are bound to an instance of a basic-client with id n.

     For example, the code we used [[*basic-client][in the introduction to basic-clients]]:

     #+begin_src lisp :export both :results output
     (let* ((c1 (basic-client 1))
            (c2 (basic-client 2)))
       (format t "Client 1: ~a~%" c1)
       (format t "Client 2: ~a~%" c2))
     #+end_src

     #+RESULTS:
     : Client 1: <c:1>
     : Client 2: <c:2>

     can be rewritten with this macro as:

      #+begin_src lisp :export both :results output
      (with-basic-clients (1 2)
        (format t "Client 1: ~a~%" c1)
        (format t "Client 2: ~a~%" c2))
      #+end_src

      #+RESULTS:
      : Client 1: <c:1>
      : Client 2: <c:2>

      And we get the same results.  Actually, the macro expansion of the macro is exactly the previous code :-o
     
      #+begin_src lisp :export both :results output
      (LET* ((C1 (BASIC-CLIENT 1)) (C2 (BASIC-CLIENT 2)))
        (FORMAT T "Client 1: ~a~%" C1)
        (FORMAT T "Client 2: ~a~%" C2))
      #+end_src

      So, any time we need a list of basic-clients, the 'elegant' way to do it is to use the macro =with-basic-client= ;-).
     
**** with-basic-solution
     We can also create basic-solutions very easily using the macro =with-basic-solution=.  This macro receives a symbol and list with lists of integers, where each inner list represent a route, and binds the symbol to a basic solution with the routes described by the inner lists.

     Maybe the easiest way to understand it is to see it in action.  (No.  The best way to understand it is to read a good description, but apparently I'm not able to do that now :-P, so let's stick to the example.)

     Once again, I'm going to rewrite a previous example using the macro.  This is the code from the [[*creating a basic-solution][section]] where we introduced the basic-solution:

      #+begin_src lisp :export both :results output
      (let* ((d1 (basic-depot))
             (v1 (basic-vehicle 1))
             (c1 (basic-client 1))
             (c2 (basic-client 2))
             (c3 (basic-client 3))
             (r1 (basic-route :id 1 :vehicle v1 :depot d1
                               :clients (list c1 c2)))
             (r2 (basic-route :id 2 :vehicle v1 :depot d1
                              :clients (list c3)))
             (s1 nil))
        ;; here we construct the solution.
        (setf s1 (basic-solution :id 1 :routes (list r1 r2)))
  
        ;; and here we print it
        (format t "solution: ~a~%" s1))
      #+end_src

      #+RESULTS:
      : solution: S1: (0)
      :   <r1: <v:1> (<d:0>: (<c:1> <c:2>))>
      :   <r2: <v:1> (<d:0>: (<c:3>))>
      :

      and this is the same code usith the macro =with-basic-solution=:

      #+begin_src lisp :export both :results output
      (with-basic-solution (s1 ((1 2) (3)))
        ;; let's print the solution
        (format t "solution: ~a~%" s1))
      #+end_src

      #+RESULTS:
      : solution: S1: (0)
      :   <r1: <v:1> (<d:0>: (<c:1> <c:2>))>
      :   <r2: <v:2> (<d:0>: (<c:3>))>
      : 
      
      Actually the macro =with-basic-solution= expands into a code that does exactly the same things that we did in the previous example, but it is a lot better when the computer writes the code for us :-P.

      As we said before, the basic-solution is not very useful to solve instances of the VRP, because we need more info.  However, it is useful to explore neighborhoods and analyze what happens in those neighborhoods, as long as we don't need to evaluate the solutions :-).

      The following macros help us to create problems and solutions than can be used to actually solve VRPs :-o.

**** with-basic-cvrp-problem
     In this section we present a macro to create instances of the class =cvrp-problem=.

     In the CVRP we have a distance-matrix, clients with demands and a capacity for all the vehicles.  There is a macro that allows us to create instances of this class very easily.  It receives a symbol, and the rest of the info required for the cvrp-problem, everything in the form of list.

     We'll rewrite the code in section [[*cvrp-problem][cvrp-problem]] using this macro.  The code in that section was:

      #+begin_src lisp :export both :results output
      (let* ((d1 (basic-depot))
             (c1 (basic-cvrp-client 1 10))
             (c2 (basic-cvrp-client 2 20))
             (c3 (basic-cvrp-client 3 30))
             (distance-matrix #2a((0 1 2 3)
                                  (1 0 4 3)
                                  (2 1 0 6)
                                  (3 8 6 0)))
             (capacity 30)
             (p1 nil))
        ;; here we create the problem.
        (setf p1 (cvrp-problem :id 1
                               :clients (list c1 c2 c3)
                               :depot d1
                               :distance-matrix distance-matrix
                               :capacity capacity))

        ;; and here we print it
        (format t "Problem: ~a~%" p1))
      #+end_src

      #+RESULTS:
      : Problem: <CVRP 1: 3 clients, capacity 30>

      If we use the macro, we would write:

      #+begin_src lisp :export both :results output
      (with-cvrp-problem (p1 :distances '((0 1 2 3)
                                          (1 0 4 3)
                                          (2 1 0 6)
                                          (3 8 6 0))
                             :demands '(10 20 30)
                             :capacity 30)

        ;; and here we print it
        (format t "Problem: ~a~%" p1)
        (format t "clients: ~a~%" (clients p1)))
      #+end_src

      #+RESULTS:
      : Problem: <CVRP 1: 3 clients, capacity 30>
      : clients: (<c1: 10> <c2: 20> <c3: 30>)

      
      In this case the distances is a list of lists and the demands is also a list.  This macro creates a depot with =id= 0, as many clients as the length of the =demands= list, named from c1 to cn, where n is the length of that list.  

**** with-basic-cvrp-solution

     In this section we create an instance of =basic-cvrp-solution=.  A cvrp-basic-solution is a solution that can be evaluated to compute its cost.  The difference with the basic-solution is that the clients are instances of =basic-cvrp-client= and the routes are instances of =route-for-simulation=.  

     But, thanks to the macro we can ignore those implementation details, as the macro takes care of them for us.

     The macro is similar to =with-basic-solution= in the sense that it receives a list of lists with the description of the routes, but it also receives an instance of =cvrp-problem=.

     Here is the example:

      #+begin_src lisp :export both :results output
      (with-cvrp-problem (p1 :distances '((0 1 2 3)
                                          (1 0 4 3)
                                          (2 1 0 6)
                                          (3 8 6 0))
                             :demands '(10 20 30)
                             :capacity 30)
        (with-basic-cvrp-solution (s1 ((1 2) (3)) p1)

         ;; and here we pretty print it
          (format t "Solution:~%")
          (pp-solution s1 t) (terpri)

          (format t "The raw solution:~%~a~%" s1)))
      #+end_src

      #+RESULTS:
      #+begin_example
      Solution:
      S1:
	  R1: (1, 2)
	  R2: (3)

      The raw solution:
      CVRP_S1: (0)
	<r1: <cv:1. 0/30> (<d:0>: (<c1: 10> <c2: 20>))>
	<r2: <cv:2. 0/30> (<d:0>: (<c3: 30>))>

      #+end_example
      
      The command =(terpri)= inserts a new line to the optional stream (that defaults to t).

      We can see in the raw solution the demand of each client, and the capacity of the vehicles.  Those values are taken from the problem passed as the third argument.

      The code and some documentation for this macro can be found [[file:vrp-classes.org::#macro:with-basic-cvrp-solution][here]].

      This is a simple introduction to the basic elements in the system.  In the next tutorial we'll show how to evaluate the solutions.

   
* How to add a new problem for evaluation of a solution

** description
   In this section we'll add a tutorial on how to add a new problem and how to evaluate a solution for that problem.  We'll consider a problem with time windows where the service time for a client is fixed during all the process.

   To do that we need to:

   1. Initialize the system
   2. Add new classes
   3. Add new methods
   4. Test it all

   We'll go through these steps one by one.

** Initialize the system
   Here we'll assume that the user is "smart enough" to use emacs with slime and org-mode =:-P=.  With that, the steps are the following:

   1. Clone the git repo in the folder =vrp= to the working directory
   2. In the working directory create the folders
      - src/
      - data/
   3. Tangle the file vrp-suite.org
      Open the file vrp-suite.org and do =M-x org-babel-tangle=
   4. From emacs load vrp-emacs-utils.el
      =M-x load-file vrp-emacs-utils.el=
      To avoid errors while loading it, add the following to your .emacs
      #+BEGIN_SRC emacs-lisp :results none :exports code
      (define-key org-mode-map (kbd "M-m") (make-sparse-keymap))
      (define-key lisp-mode-map (kbd "M-m M-o") (make-sparse-keymap))
      #+END_SRC
   5. From emacs execute =vrp-tangle-all-files=
   6. From emacs fire up slime (=M-x slime=)
   7. In Slime, change the current directory to the working directory
      (this can be done by typing =,= in the REPL and then =cd= <RETURN>, and navigate to the working directory)
   8. In slime load the file vrp-load-files
     #+BEGIN_SRC lisp +n -r :results none :exports code 
     (load "src/vrp-load-files.lisp")
     #+END_SRC
   9. Change to the package vrp
     #+BEGIN_SRC lisp +n -r :results none :exports code 
     (in-package :vrp)
     #+END_SRC
** Let's add the new classes
*** description
    We want to simulate a VRP with time windows.  For that we need a new problem (with at least, the time between clients) and new clients with the time windows.  Let's add them.

    The required classes are: [8/8]
    - [X] time-windows-client (has a time windows)
    - [X] service-time-client (has a service time)
    - [X] time-windows-problem (has the time-between clients)
    - [X] route-with-time (has current-time and start-time)
    - [X] an actual route to test things,
    - [X] an actual problem, and
    - [X] an actual class for clients to test things too.
    - [X] An action to compute time

    We'll also need a function to compute the time required to move from one element to another.  That will be the function get-time-from-to.

    We are going to add all the subtrees as if this were the file =vrp-classes.org=.
*** time-windows-client (structural, abstract)
**** documentation
     This is a client that has two values representing the opening and closing time of the time windows.
**** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-time-windows-tutorial.lisp
    (def-vrp-class time-windows-client ()
      ((open-time) (closing-time))
      :documentation "A client with time windows.")
    #+END_SRC     
**** tests (no tests because it is abstract)
*** service-time-client (structural, abstract)
**** documentation
     This is a client that has a value representing the time required to attend it.
**** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-time-windows-tutorial.lisp
    (def-vrp-class service-time-client ()
      ((service-time))
      :documentation "A client with a service time.")
    #+END_SRC     
**** tests (no tests because it is abstract)
*** time-problem (structural, abstract)
**** documentation
     This is a problem with a matrix of time travel from one client to another.
**** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-time-windows-tutorial.lisp
    (def-vrp-class time-problem ()
      ((time-matrix))
      :documentation "A problem with a time matrix where each entry is the time required to go from one client to another.")
    #+END_SRC     
**** tests (no tests because it is abstract)
*** get-time-from-to
**** description
     This function receives two has-id instances and a time-problem and returns the distance from the first instance to the second in that problem.  It will be a generic-function because I want it to be as flexible as possible.  
**** code
***** generic-function
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
       (defgeneric get-time-from-to (from to problem)
         (:documentation "Returns the time from the first point to the second in the given problem."))
       #+END_SRC   
***** method (has-id has-id distance-problem)
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
       (defmethod get-time-from-to ((from has-id)
                                    (to has-id)
                                    (problem time-problem))
         "Returns the distance from the first point to the second in the given distance-problem."
         (aref (time-matrix problem) (id from) (id to)))
       #+END_SRC   

****** tests
       #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (let* ((distance #2A ((0 1 2 3)
                             (1 0 4 5)
                             (2 4 0 6)
                             (3 5 6 0)))
              (dp (make-instance 'time-problem
                                 :time-matrix distance))
              (d0 (basic-depot))
              (c1 (basic-client 1))
              (c2 (basic-client 2))
              (c3 (basic-client 3)))
         (bformat t "Testing get-distance-from-to:")
         (check-= 0 (get-time-from-to d0 d0 dp))
         (check-= 1 (get-time-from-to d0 c1 dp))
         (check-= 2 (get-time-from-to d0 c2 dp))
         (check-= 3 (get-time-from-to d0 c3 dp))
  
         (check-= 1 (get-time-from-to c1 d0 dp))
         (check-= 0 (get-time-from-to c1 c1 dp))
         (check-= 4 (get-time-from-to c1 c2 dp))
         (check-= 5 (get-time-from-to c1 c3 dp)))
       #+END_SRC
*** route-with-time (structural abstract)
**** documentation
     This is a route that has a =start-time= and a =current-time= slot.  This probably should be the base class for any route that implements some.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class route-with-time ()
       ((start-time :initform 0))
       :documentation "A route with a start time.  Good for time based simulations.")
     #+END_SRC
**** no tests because it is abstract
*** route-for-time-simulation (structural class)
**** documentation
     This is a route for simulation where we include time in the simulation.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class route-for-time-based-simulation
         (route-for-simulation
          route-with-time)
       ()
       :documentation "A route for a simulation that includes time."
       :constructor (route-for-time-based-simulation
                     (&key id vehicle depot clients
                           start-time))
       :slots-for-obj= (id vehicle depot clients previous-client
                            start-time)
       :slots-for-clone (id vehicle depot clients previous-client
                            start-time))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-clients (1 2 3 4 5 6)
       (let* ((v1 (basic-vehicle 1))
              (v2 (basic-vehicle 2))
              (d0 (basic-depot))
              (d1 (basic-depot 1))
              (r1 (route-for-time-based-simulation
                   :id 1 :vehicle v1 :depot d0
                   :clients (list c1 c2 c3)
                   :start-time 0))
              (r2 (route-for-time-based-simulation
                   :id 2 :vehicle v2 :depot d0
                   :clients (list c4 c5 c6)
                   :start-time 0))
              (r3 (route-for-time-based-simulation
                   :id 1 :vehicle v2 :depot d0
                   :clients (list c1 c2 c3)
                   :start-time 0))
              (r4 (clone r1))
              (r5 (clone r2))
              )

         (bformat t "Testing route-for-simulation...")

         (format t "Printing the objects:~%")
         (loop for e in (list r1 r2 r3 r4 r5)
               doing (format t "   route-for-time-based-simulation with id ~a: ~a~%"
                             (id e) e))

         (deftests "Testing obj="
           (check-t (obj= r1 r1))
           (check-t (obj= r1 r4))
           (check-t (obj= r2 r5))

           (check-nil (obj= r1 r2))
           (check-nil (obj= r1 r3))
           (check-nil (obj= r2 r4)))))
     #+END_SRC
*** basic-time-windows-problem
**** documentation
     This is a very basic (and elemetary) time-windows-problem with homogeneous fleet.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class basic-time-windows-problem
         (basic-problem
          distance-problem
          capacity-problem
          time-problem)
       ()
       :documentation "A distance-problem with a capacity for all the vehicles and with time between the clients."
       :constructor (basic-time-windows-problem
                     (&key id clients depot
                           distance-matrix
                           time-matrix
                           capacity))
       :slots-for-obj= (id clients depot
                           distance-matrix
                           time-matrix
                           capacity)
       :slots-for-clone (id clients depot
                            distance-matrix
                            time-matrix
                            capacity))

     (defmethod print-object ((obj basic-time-windows-problem) stream)
        (format stream "<VRPTW ~a: ~a clients, capacity ~a>"
                (id obj)
                (length (clients obj))
                (capacity obj)))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-clients (1 2 3)
       (let* ((d0 (basic-depot))
              (d1 (basic-depot 1))
              (p1 (basic-time-windows-problem
                   :id 1 :depot d0
                   :clients (list c1 c2 c3)
                   :capacity 40
                   :distance-matrix #2A((0 1 2 3)
                                        (1 0 4 6)
                                        (2 4 0 2)
                                        (3 6 2 0))
                   :time-matrix #2A((0 1 2 3)
                                    (1 0 4 6)
                                    (2 4 0 2)
                                    (3 6 2 0))))
              (p2 (basic-time-windows-problem
                   :id 2 :depot d0
                   :clients (list c1 c2 c3)
                   :capacity 40
                   :distance-matrix #2A((0 1 2 3)
                                        (1 0 4 6)
                                        (2 4 0 2)
                                        (3 6 2 0))
                   :time-matrix #2A((0 1 2 3)
                                    (1 0 4 6)
                                    (2 4 0 2)
                                    (3 6 2 0))))
              (p3 (basic-time-windows-problem
                   :id 2 :depot d0
                   :clients (list c1 c2 c3)
                   :capacity 40
                   :distance-matrix #2A((0 1 2 3)
                                        (1 0 4 6)
                                        (2 4 0 2)
                                        (3 6 2 0))
                   :time-matrix #2A((0 1 2 5)
                                    (1 0 4 6)
                                    (2 4 0 2)
                                    (3 6 2 0))))
              (p4 (clone p1))
              (p5 (clone p3))
              )

         (bformat t "Testing vrptw-problem...")

         (format t "Printing the objects:~%")
         (loop for e in (list p1 ;; p2 p3 p4 p5 p6
                              )
               doing (format t "   time-problem with id ~a:~% ~a~%"
                             (id e) e))

         (deftests "Testing obj="
           (check-t (obj= p1 p1))
           (check-t (obj= p1 p4))
           (check-t (obj= p3 p5))

           (check-nil (obj= p1 p2))
           (check-nil (obj= p1 p3))
           (check-nil (obj= p2 p4))
           (check-nil (obj= p2 p5))
           )))
     #+END_SRC
*** basic-tw-client (actual class)
**** documentation
     A client that can be used in the basic VRPTW.  It has an id, a demand, a time windows and a service time.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class basic-vrptw-client
         (basic-client
          demand-client
          time-windows-client
          service-time-client)
       ()
       :documentation "A client for the basic VRPTW with id, demand, time windows and service time."
       :constructor (basic-cvrptw-client (id
                                          demand
                                          open-time
                                          closing-time
                                          service-time))
       :print-object-string ("<twc~a: ~a, [~a, ~a], ~a>"
                             id demand open-time closing-time
                             service-time)
       :slots-for-obj= (id demand
                           open-time
                           closing-time
                           service-time)
       :slots-for-clone (id demand
                           open-time
                           closing-time
                           service-time))
     #+END_SRC   
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((c1 (basic-cvrptw-client 1 10 2 5 2))
            (c2 (basic-cvrptw-client 2 10 3 5 2))
            (c3 (clone c1))
            (c4 (clone c2)))
       (bformat t "Testing basic-vrptw-client...")

       (format t "Printing the objects:~%")
       (loop for e in (list c1 c2 c3 c4)
             doing (format t "   basic-vrptw-client with id ~a: ~a~%"
                           (id e) e))

       (deftests "Testing obj="
         (check-t (obj= c1 c1))
         (check-t (obj= c1 c3))
         (check-t (obj= c2 c4))

         (check-nil (obj= c1 c2))
         (check-nil (obj= c2 c3))))
     #+END_SRC
*** route-time-action
**** description
     This action computes the time elapsed in a route.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-classes.lisp
     (def-vrp-class route-time-action (has-id)
       ((current-time)
        (id :documentation "The id of the route this action is being used on."))
       :documentation "An action to compute the distance travelled by a vehicle in a route."
       :constructor (route-time-action (id &optional (current-time 0)))
       :print-object-string ("<a_rt: ~a ~a>" id current-time)
       :slots-for-obj= (id current-time)
       :slots-for-clone (id current-time))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((c1 (route-time-action 1 10))
            (c2 (route-time-action 2 10))
            (c3 (route-time-action 1 20))
            (c4 (clone c1))
            (c5 (clone c2)))
       (bformat t "Testing route-distance-action...")

       (format t "Printing the objects:~%")
       (loop for e in (list c1 c2 c3 c4 c5)
             doing (format t "   route-time-action with id ~a: ~a~%"
                           (id e) e))

       (deftests "Testing obj="
         (check-t (obj= c1 c1))
         (check-t (obj= c1 c4))
         (check-t (obj= c2 c5))

         (check-nil (obj= c1 c2))
         (check-nil (obj= c1 c3))
         (check-nil (obj= c2 c4))
         (check-nil (obj= c3 c5))))
     #+END_SRC

** Now let's add the moments for the evaluation of a solution :-o
*** documentation
    Now we need to add the methods to the appropriate moments to reflect the fact that we are dealing with time windows.

    The moments that are affected are: [2/4]
    - [X] when-route-begins
      initialize the current time and start-time.
    - [X] move-from-to
      We need to update the current time
    - [ ] unload (after, increment time)
      - Update time according to service time.
    - [ ] visit-client
      - We need to check the time windows and act accordingly
        - if early: wait (and penalize?)
        - if on-time: proceed
        - if late: PENALIZE
      - store the arrival time (probably a before method)
      - penalize (with a different action)
    - [ ] Create a problem and test everything
*** when-route-begins (:before route-distance-action)
**** description
     Here we initialize the route-time-action.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-moments.lisp
     (defbehavior when-route-begins :before
       (vehicle
        (route route-with-time)
        solution
        problem
        (action route-time-action))
       :log-str "Initializing current-time to start-time"
       (setf (current-time action) (start-time route)))
     #+END_SRC
**** tests
***** test without logging
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((c1 (basic-cvrp-client 1 30))
             (c2 (basic-cvrp-client 2 20))
             (v1 (cvrp-vehicle 1 60 60))
             (d0 (basic-depot))
             (r1 (route-for-time-based-simulation
                  :id 1 :vehicle v1 :depot d0 :clients (list c1 c2)
                  :start-time 5))
             (a1 (route-time-action 1 50))
             (*vrp-logging* 0))
        (format t "Testing when-route-begins for route-distance-action:~%")
        (check-= 50 (current-time a1))
        (when-route-begins v1 r1 t t a1)
        (check-= 5 (current-time a1)))
      #+END_SRC

***** test with logging
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((c1 (basic-cvrp-client 1 30))
             (c2 (basic-cvrp-client 2 20))
             (v1 (cvrp-vehicle 1 60 60))
             (d0 (basic-depot))
             (r1 (route-for-simulation :id 1 :vehicle v1
                                       :depot d0 :clients (list c1 c2)))
             (a1 (route-distance-action 1 50))
             (*vrp-logging* 1))
        (format t "Testing *logging* when-route-begins for route-distance-action:~%")
        (when-route-begins v1 r1 t t a1))
      #+END_SRC
*** move-from-to (:after method: to compute distance)
**** description
     In this method we update the time spent by the vehicle in this arc.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-moments.lisp
     (defbehavior move-from-to :after
       ((vehicle     t)
        (from-client t)
        (to-client   t)
        (route       t)
        (solution    t)
        (problem     time-problem)
        (action      route-time-action))

       :log-str "Updating distance"
       (incf (current-time action)
             (get-time-from-to from-client to-client problem)))
     #+END_SRC
**** tests
***** test without logging
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((c1 (basic-cvrp-client 1 30))
             (c2 (basic-cvrp-client 2 20))
             (c3 (basic-cvrp-client 3 30))
             (d0 (basic-depot))
             (list (list d0 c1 c2 c3))
             (time-matrix #2A ((0 1 2 3)
                               (1 0 4 5)
                               (2 4 0 6)
                               (3 5 6 0)))
             (problem (make-instance 'time-problem
                                     :time-matrix time-matrix))
             (a1 (route-time-action 0))
             (*vrp-logging* 0))
        (bformat t "Testing move-from-to with route-distance-action:")

        (check-= 0 (current-time a1))
        (move-from-to t d0 c1 t t problem a1)
        (check-= 1 (current-time a1))

        (setf (current-time a1) 0)
        (loop for previous-client in (butlast list)
              for current-client in (rest list)
              doing (move-from-to t previous-client current-client t t problem a1))
        (check-= 11 (current-time a1)))
      #+END_SRC
** TODO Assignment
   - add the slot arrival-time to the time-action
   - implement the missing methods
     - (including two different penalization strategies)

