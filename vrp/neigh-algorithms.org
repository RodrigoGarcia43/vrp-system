#+TITLE: VRP solver environment
#+AUTHOR: Fernando Rodriguez Flores
#+AUTHOR: Hector F. Masson
#+DATE 2021-01-05
#+TODO: TODO WIP BROKEN | DONE

* Description
  In this file we are going to add algorithms to solve the VRP using Hector's generators.

  The src blocks in this file should be tangled to src/neigh-algorithms.lisp.

  
* add the package to the tangled file
  #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp 
  (in-package :vrp)
  #+END_SRC


* Descent-Neighborhood-Search

** return best-neighbor
*** description
    In this section, I'm going to add a Descent Neighboorhood Search using generators.

    This is an algorithm that receives a solution and a criterion.  It gets the best neighboor according to the criterion and, if the best-neighbor is better, repeat the process, otherwise we are in a local minimum.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp
   ;; Descent Neighboorhood Search
   (defun dns-with-generators-best-neighbor
       (problem solution criterion
        &key max-iter
          action
          ;; (print-mod 1)
          (exploration #'exhaustive-exploration))
     "Solves the VRP problem using a DNS with the given criterion starting with the given solution. We assume that the initial solution has the cost slot bound. If the result is nil, then the initial solution is an optimum for that neighboorhood. We receive a parameter with the type of exploration we want to use."
     (let* (;; let's create the tree variable
            (neigh-tree (build-neighborhood-tree criterion solution))
            (solution-generator (funcall exploration neigh-tree))

            (better-solution nil)
            (better-cost 1e10)

            ;; (current-solution nil)
            (neighboorhoods-used 1)

            (current-solution (clone solution))
            (working-copy (make-working-copy current-solution))

            (better-solution-found nil)

            )

       ;; let's initialize the working copy and the solution
       (prepare-solution-for-neighborhood-exploration working-copy)
       (initialize-action-for-delta-cost-computation working-copy
                                                     problem
                                                     action)

       ;; as an experiment, let's print the number of
       ;; current solution's neighboors
       (format t "Neighboorhood  1: ~4d candidates... "
               (cardinality neigh-tree))

       ;; let's explore the neighboorhood of the
       ;; current-solution

       (setf (values better-solution better-cost)
             (return-best-neighbor solution-generator
                                   working-copy
                                   problem
                                   action))

       ;; print info about the neighboorhood
       (if better-solution
           (then
             (format t "~6d~%" (+ (cost working-copy)
                                  better-cost))
             (setf better-solution-found t))
           (else
             (format t "    Initial solution was optimum!!!~%")))



       ;; if better-solution is non nil, then
       ;; we have a better neighboor.

       ;; (if better-solution
       ;;     (then
       ;;       ;; update the current solution
       ;;       ;; in the working-copy
       ;;       (apply-set-of-operations better-solution working-copy)
       ;;       ;; update the cost of the new solution
       ;;       ;; (again, in the working copy)
       ;;       (incf (cost (solution working-copy)) better-cost)
       ;;       ;; let's prepare the new working-copy
       ;;       ;; and the action for the new solution
       ;;       (prepare-solution-for-neighborhood-exploration working-copy)
       ;;       (initialize-action-for-delta-cost-computation working-copy
       ;;                                                     problem
       ;;                                                     action)
       ;;       ;; now let's initialize the new generator
       ;;       (setf neigh-tree (build-neighborhood-tree criterion solution))
       ;;       (setf solution-generator (funcall exploration neigh-tree))

       ;;       (pp-solution working-copy t) (terpri)
       ;;       (format t "cost: ~a~%" (cost (solution working-copy)))))

       (format t "operations: ~a~%" better-solution)

       (loop while (and better-solution
                        (<= neighboorhoods-used max-iter))
             for i from 2
             do

             ;; update the current solution
             ;; in the working-copy
             (apply-set-of-operations better-solution working-copy)
             ;; update the cost of the new solution
             ;; (again, in the working copy)
             (incf (cost (solution working-copy)) better-cost)

             ;; let's prepare the new working-copy
             ;; and the action for the new solution
             (prepare-solution-for-neighborhood-exploration working-copy)
             (initialize-action-for-delta-cost-computation working-copy
                                                           problem
                                                           action)

             ;; now let's initialize the new generator
             (setf neigh-tree (build-neighborhood-tree
                               criterion
                               (solution working-copy)))
             (setf solution-generator (funcall exploration neigh-tree))


             ;; as an experiment, let's print the number of
             ;; current solution's neighboors
             (format t "Neighboorhood ~2d: ~4d candidates..."
                     i
                     (cardinality neigh-tree))

             ;; compute the new better-solution
             (setf (values better-solution better-cost)
                   (return-best-neighbor solution-generator
                                         working-copy
                                         problem
                                         action))

             (if better-solution
                 (then
                   (format t "~6d~%" (+ (cost working-copy)
                                        better-cost)))
                 (else
                   (format t "    Optimum Found!!!~%")))


             ;; increment the number of neighboorhoods-used
             do (incf neighboorhoods-used))

       ;; finally return the current solution
       ;; if it is nil, then the initial solution is an optimum
       (if better-solution-found
           (then
             (list (solution working-copy)
                  better-cost
                  neighboorhoods-used
                  (<= neighboorhoods-used max-iter))))))
       #+END_SRC
   
*** tests
**** rarac (toy problem)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                                         :demands '(10 10 15 40 20)
                                         :capacity 40)
       (with-basic-cvrp-solution (s1 ((1 2 5) (3) (4)) p1)
           ;; (s1 ((2 4 5) (3) (1)) p1)
         (let* ((best-solution-exhaustive nil)
                (action (delta-cvrp-action*))
                (results nil)
                (cvrp-action (basic-cvrp-action  
                              :penalty-factor 1000))
                ;; (criterion-code `((select-route r1)
                ;;                   (select-client c1 from r1)
                ;;                   (select-route r2)
                ;;                   (select-client c2 from r2)
                ;;                   (swap-clients c1 c2)))

                (criterion-code `((select-route r1)
                                  (select-client c1 from r1)
                                  (select-route r2)
                                  (insert-client c2 into r2)))

                )

           (bformat t "Testing DNS")




           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (setf results (dns-with-generators-best-neighbor  
                          p1
                          s1 
                          criterion-code
                          :max-iter 30
                          :action action))

           ;; (format t "Iterations: ~a. Optimum found ~a.~%"
           ;;         (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best neighbor through exhaustive search:~%")
                 (pp-solution best-solution-exhaustive t)
                 (format t "  with cost: ~a~%"
                         (cost best-solution-exhaustive))

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)


                 (format t "Best value through Yoel's: ~a~%"
                         (+ (total-distance cvrp-action)
                            (total-penalty cvrp-action)))

                 (format t "action: ~a~%" cvrp-action)
                 )

               (else
                 (format t "Initial solution was optimum!~%")))

               )))
     #+END_SRC 
**** rab (toy problem)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
    (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                        (5 0 6 7 2 4)  ;1
                                        (1 8 0 3 9 1)  ;2
                                        (4 5 1 0 5 7)  ;3
                                        (4 5 1 5 0 6)  ;4
                                        (1 5 7 6 9 0)) ;5
                                        ;0 1 2 3 4 5 
                                        :demands '(10 10 15 40 20)
                                        :capacity 40)
      (with-basic-cvrp-solution
          ;; (s1 ((1 2 5) (3) (4)) p1)
          (s1 ((2 4 5) (3) (1)) p1)
        (let* ((best-solution-exhaustive nil)
               (action (delta-cvrp-action*))
               (results nil)
               (cvrp-action (basic-cvrp-action  
                             :penalty-factor 1000))
               ;; (criterion-code `((select-route r1)
               ;;                   (select-client c1 from r1)
               ;;                   (select-route r2)
               ;;                   (select-client c2 from r2)
               ;;                   (swap-clients c1 c2)))

               ;; (criterion-code `((select-route r1)
               ;;                   (select-client c1 from r1)
               ;;                   (insert-client c1 into r1)))

               ;; (criterion-code `((select-route r1)
               ;;                   (select-client c1 from r1)
               ;;                   (select-route r2)
               ;;                   (insert-client c1 into r2)))

               (criterion-code  `((select-route r1)
                                  (select-client c1 from r1)
                                  (select-route r2)
                                  (insert-client c1 into r2)))

               )

          (bformat t "Testing DNS with generators")

          ;; first we compute the cost of the solution
          (simulate-solution s1 p1 cvrp-action)
          (setf (cost s1) (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))

          (format t "Original solution (with cost ~a):~%"
                  (cost s1))
          (pp-solution s1 t)

          (setf results (dns-with-generators-best-neighbor  
                         p1
                         s1 
                         criterion-code
                         :max-iter 30
                         :action action))

          ;; (format t "Iterations: ~a. Optimum found ~a.~%"
          ;;         (second results) (third results))

          (setf best-solution-exhaustive (first results))

          (if best-solution-exhaustive
              (then
                (format t "Best neighbor through exhaustive search:~%")
                (pp-solution best-solution-exhaustive t)
                (format t "  with cost: ~a~%"
                        (cost best-solution-exhaustive))

                (simulate-solution best-solution-exhaustive p1 cvrp-action)


                (format t "Best value through Yoel's: ~a~%"
                        (+ (total-distance cvrp-action)
                           (total-penalty cvrp-action)))

                (format t "action: ~a~%" cvrp-action)
                )

              (else
                (format t "Initial solution was optimum!~%")))

              )))
    #+END_SRC
*** an33 problem
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
    (let* ((p1 a-n33-k6-problem)
           (s1 (make-initial-solution-for-cvrp-deterministic p1))
           (best-solution-exhaustive nil)
           (action (delta-cvrp-action*))
           (results nil)

           (cvrp-action (basic-cvrp-action))

           (criterion-code  `((select-route r1)
                              (select-client c1 from r1)
                              (select-route r2)
                              (insert-client c1 into r2)))

           ;; (criterion-code '((select-route r1)
           ;;                   (select-client c1 from r1)
           ;;                   (select-route r2)
           ;;                   (select-client c2 from r2)
           ;;                   (swap-clients c1 c2)))

           ;; (neighborhood-exhaustive
           ;;  (make-neighborhood-criterion
           ;;   criterion-code
           ;;   +exhaustive-search-strategy+
           ;;   selection-strategy))
           )

          (bformat t "Testing DNS with generators and a-n33")

          ;; first we compute the cost of the solution
          (simulate-solution s1 p1 cvrp-action)
          (setf (cost s1) (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))

          (format t "Original solution (with cost ~a):~%"
                  (cost s1))
          (pp-solution s1 t)

          (setf results (dns-with-generators-best-neighbor  
                         p1
                         s1 
                         criterion-code
                         :max-iter 30
                         :action action))

          ;; (setf results (descent-neighborhood-search
          ;;                p1 s1 neighborhood-exhaustive
          ;;                :max-iter max-iterations
          ;;                :action action))

          ;; (format t "Iterations: ~a. Optimum found ~a.~%"
          ;;         (second results) (third results))

          (setf best-solution-exhaustive (first results))

          (setf best-solution-exhaustive (first results))

          (if best-solution-exhaustive
              (then
                (format t "Best neighbor through exhaustive search:~%")
                (pp-solution best-solution-exhaustive t)
                (format t "  with cost: ~a~%"
                        (cost best-solution-exhaustive))

                (simulate-solution best-solution-exhaustive p1 cvrp-action)


                (format t "Best value through Yoel's: ~a~%"
                        (+ (total-distance cvrp-action)
                           (total-penalty cvrp-action)))

                (format t "action: ~a~%" cvrp-action)
                )

              (else
                (format t "Initial solution was optimum!~%")))
          )
    #+END_SRC
*** +ff-a-n33-k6-problem (best-improvement)+
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
    (let* ((s1 (make-initial-solution-for-finite-fleet-cvrp-deterministic
                ff-a-n33-k6-problem))
           (p1 ff-a-n33-k6-problem)
           (best-solution-exhaustive nil)
           (action (delta-cvrp-action))
           (results nil)
           (cvrp-action (basic-cvrp-action 
                         :penalty-factor 1000))
           (criterion-code `((select-route r1)
                             (select-client c1 from r1)
                             (select-route r2)
                             (insert-client c1 into r2)))

           (neighborhood-exploration
            (make-neighborhood-criterion
             criterion-code
             +exhaustive-search-strategy+
             +best-improvement+)))

      (bformat t "Testing DNS")

      ;; first we compute the cost of the solution
      (simulate-solution s1 p1 cvrp-action)
      (setf (cost s1) (+ (total-distance cvrp-action)
                         (total-penalty cvrp-action)))

      (format t "Original solution (with cost ~a):~%"
              (cost s1))
      (pp-solution s1 t)

      (setf results (funcall neighborhood-exploration s1 p1 action))

      ;; (format t "Cost: ~a~%" (cost results))
      ;; (pp-solution results t) (terpri)

      (setf results (descent-neighborhood-search  
                     p1 s1 neighborhood-exploration
                     :max-iter 300
                     :action action))

      ;; (format t "Cost: ~a~%" (cost (first results)))
      ;; (pp-solution (first results) t) (terpri)


      (format t "Iterations: ~a. Optimum found ~a.~%"
              (second results) (third results))      
      (setf best-solution-exhaustive (first results))

      (if best-solution-exhaustive
          (then
            (format t "Best value through exhaustive: ~a~%"
                    (cost best-solution-exhaustive))
            (format t "Best neighbor through exhaustive search:~%")
            (pp-solution best-solution-exhaustive t)

            ;; (format t "Best value through Yoel's: ~a~%"
            ;;         (solution-cost best-solution-exhaustive
            ;;                        p1 cvrp-action))
            ;; (format t "action: ~a~%" cvrp-action)
            )

          (else
            (format t "Initial solution was optimum!~%")))

      ;; (if best-solution-first-improvement
      ;;     (then
      ;;       (format t "Best value through 1st: ~a~%"
      ;;               (cost best-solution-first-improvement))
      ;;       (format t "Best neighbor through 1st:~%")
      ;;       (pp-working-copy
      ;;        (prepare-solution-for-neighborhood-exploration
      ;;         best-solution-first-improvement) t) (terpri)))

      ;; (if best-solution-random-improvement
      ;;     (then
      ;;       (format t "Best value through random: ~a~%"
      ;;               (cost best-solution-first-improvement))
      ;;       (format t "Best neighbor through random::~%")
      ;;       (pp-working-copy
      ;;        (prepare-solution-for-neighborhood-exploration
      ;;         best-solution-random-improvement) t) (terpri)))


      )
    #+END_SRC
*** +problem with end-depot+
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (c1 (basic-cvrp-client 1 30))
            (c2 (basic-cvrp-client 2 20))
            (c3 (basic-cvrp-client 3 40))
            (c4 (basic-cvrp-client 4 50))
            (d0 (basic-depot))
            (d1 (basic-depot 5))
            (v1 (cvrp-vehicle 1 70))
            (v2 (cvrp-vehicle 2 70))

            (distance #2A ((0 1 2 3 5 6)
                           (1 0 4 5 6 7)
                           (2 4 0 6 7 9)
                           (3 5 6 0 8 9)
                           (5 6 7 8 0 1)
                           (3 5 6 4 8 0)))
            (p1 (make-instance 'finite-fleet-end-depot-cvrp-problem
                               :depot d0
                               :end-depot d1
                               :id 1
                               :clients (list c1 c2 c3 c4)
                               :fleet (list v1 v2)
                               :distance-matrix distance))

            ;; now the algorithms related data
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action))
            (results nil)
            (cvrp-action (basic-cvrp-action 
                          :penalty-factor 1000))
            (criterion-code `((select-route r1)
                              (select-client c1 from r1)
                              (select-route r2)
                              (insert-client c1 into r2)))

            (neighborhood-exploration
             (make-neighborhood-criterion
              criterion-code
              +exhaustive-search-strategy+
              +best-improvement+))

            (*vrp-logging* 0))
  
       (bformat t "Testing VND with end-depot")

       (with-finite-fleet-end-depot-cvrp-solution (s1 ((1 1 2) (2 3 4)) p1)

         ;; first we compute the cost of the solution
         (simulate-solution s1 p1 cvrp-action)
         (setf (cost s1) (+ (total-distance cvrp-action)
                            (total-penalty cvrp-action)))

         (format t "Original solution (with cost ~a):~%"
                 (cost s1))
         (pp-solution s1 t)

         (setf results (descent-neighborhood-search  
                        p1 s1 neighborhood-exploration
                        :max-iter 300
                        :action action))

         (format t "Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))      
           (setf best-solution-exhaustive (first results))


         (if best-solution-exhaustive
               (then
                 (format t "Best value through exhaustive: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor through exhaustive search:~%")
                 (pp-solution best-solution-exhaustive t)

                 ;; (format t "Best value through Yoel's: ~a~%"
                 ;;         (solution-cost best-solution-exhaustive
                 ;;                        p1 cvrp-action))
                 ;; (format t "action: ~a~%" cvrp-action)
                 )

               (else
                 (format t "Initial solution was optimum!~%")))))
     #+END_SRC

** return-first-improvement
*** description
    In this section, I'm going to add a Descent Neighboorhood Search using generators.

    This is an algorithm that receives a solution and a criterion.  It gets the best neighboor according to the criterion and, if the best-neighbor is better, repeat the process, otherwise we are in a local minimum.

    Here, on each neighboorhood, we return the first neighbor that improves the current solution.
   
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp
   ;; Descent Neighboorhood Search
   (defun dns-with-generators-first-improvement
       (problem solution criterion
        &key max-iter
          action
          ;; (print-mod 1)
          (exploration #'exhaustive-exploration))
     "Solves the VRP problem using a DNS with the given criterion starting with the given solution. We assume that the initial solution has the cost slot bound. If the result is nil, then the initial solution is an optimum for that neighboorhood. We receive a parameter with the type of exploration we want to use."
     (let* (;; let's create the tree variable
            (neigh-tree (build-neighborhood-tree criterion solution))
            (solution-generator (funcall exploration neigh-tree))

            (better-solution nil)
            (better-cost 1e10)

            ;; (current-solution nil)
            (neighboorhoods-used 1)

            (current-solution (clone solution))
            (working-copy (make-working-copy current-solution))

            (better-solution-found nil)

            )

       ;; let's initialize the working copy and the solution
       (prepare-solution-for-neighborhood-exploration working-copy)
       (initialize-action-for-delta-cost-computation working-copy
                                                     problem
                                                     action)

       ;; as an experiment, let's print the number of
       ;; current solution's neighboors
       (format t "Neighboorhood  1: ~4d candidates... "
               (cardinality neigh-tree))

       ;; let's explore the neighboorhood of the
       ;; current-solution

       (setf (values better-solution better-cost)
             (return-first-improvement solution-generator
                                       working-copy
                                       problem
                                       action))

       ;; print info about the neighboorhood
       (if better-solution
           (then
             (format t "~6d~%" (+ (cost working-copy)
                                  better-cost))
             (setf better-solution-found t))
           (else
             (format t "    Initial solution was optimum!!!~%")))



       ;; if better-solution is non nil, then
       ;; we have a better neighboor.

       ;; (if better-solution
       ;;     (then
       ;;       ;; update the current solution
       ;;       ;; in the working-copy
       ;;       (apply-set-of-operations better-solution working-copy)
       ;;       ;; update the cost of the new solution
       ;;       ;; (again, in the working copy)
       ;;       (incf (cost (solution working-copy)) better-cost)
       ;;       ;; let's prepare the new working-copy
       ;;       ;; and the action for the new solution
       ;;       (prepare-solution-for-neighborhood-exploration working-copy)
       ;;       (initialize-action-for-delta-cost-computation working-copy
       ;;                                                     problem
       ;;                                                     action)
       ;;       ;; now let's initialize the new generator
       ;;       (setf neigh-tree (build-neighborhood-tree criterion solution))
       ;;       (setf solution-generator (funcall exploration neigh-tree))

       ;;       (pp-solution working-copy t) (terpri)
       ;;       (format t "cost: ~a~%" (cost (solution working-copy)))))

       (format t "operations: ~a~%" better-solution)

       (loop while (and better-solution
                        (<= neighboorhoods-used max-iter))
             for i from 2
             do

             ;; update the current solution
             ;; in the working-copy
             (apply-set-of-operations better-solution working-copy)
             ;; update the cost of the new solution
             ;; (again, in the working copy)
             (incf (cost (solution working-copy)) better-cost)

             ;; let's prepare the new working-copy
             ;; and the action for the new solution
             (prepare-solution-for-neighborhood-exploration working-copy)
             (initialize-action-for-delta-cost-computation working-copy
                                                           problem
                                                           action)

             ;; now let's initialize the new generator
             (setf neigh-tree (build-neighborhood-tree
                               criterion
                               (solution working-copy)))
             (setf solution-generator (funcall exploration neigh-tree))


             ;; as an experiment, let's print the number of
             ;; current solution's neighboors
             (format t "Neighboorhood ~2d: ~4d candidates..."
                     i
                     (cardinality neigh-tree))

             ;; compute the new better-solution
             (setf (values better-solution better-cost)
                   (return-best-neighbor solution-generator
                                         working-copy
                                         problem
                                         action))

             (if better-solution
                 (then
                   (format t "~6d~%" (+ (cost working-copy)
                                        better-cost)))
                 (else
                   (format t "    Optimum Found!!!~%")))


             ;; increment the number of neighboorhoods-used
             do (incf neighboorhoods-used))

       ;; finally return the current solution
       ;; if it is nil, then the initial solution is an optimum
       (if better-solution-found
           (then
             (list (solution working-copy)
                  better-cost
                  neighboorhoods-used
                  (<= neighboorhoods-used max-iter))))))
       #+END_SRC
   
*** tests
**** rarac (toy problem)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                                         :demands '(10 10 15 40 20)
                                         :capacity 40)
       (with-basic-cvrp-solution (s1 ((1 2 5) (3) (4)) p1)
           ;; (s1 ((2 4 5) (3) (1)) p1)
         (let* ((best-solution-exhaustive nil)
                (action (delta-cvrp-action*))
                (results nil)
                (cvrp-action (basic-cvrp-action  
                              :penalty-factor 1000))
                ;; (criterion-code `((select-route r1)
                ;;                   (select-client c1 from r1)
                ;;                   (select-route r2)
                ;;                   (select-client c2 from r2)
                ;;                   (swap-clients c1 c2)))

                (criterion-code  `((select-route r1)
                                   (select-client c1 from r1)
                                   (select-route r2)
                                   (insert-client c1 into r2)))

                )

           (bformat t "Testing DNS")




           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (setf results (dns-with-generators-first-improvement  
                          p1
                          s1 
                          criterion-code
                          :max-iter 30
                          :action action))

           ;; (format t "Iterations: ~a. Optimum found ~a.~%"
           ;;         (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best neighbor through exhaustive search:~%")
                 (pp-solution best-solution-exhaustive t)
                 (format t "  with cost: ~a~%"
                         (cost best-solution-exhaustive))

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)


                 (format t "Best value through Yoel's: ~a~%"
                         (+ (total-distance cvrp-action)
                            (total-penalty cvrp-action)))

                 (format t "action: ~a~%" cvrp-action)
                 )

               (else
                 (format t "Initial solution was optimum!~%")))

               )))
     #+END_SRC
**** rab (toy problem)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                                         :demands '(10 10 15 40 20)
                                         :capacity 40)
       (with-basic-cvrp-solution
           ;; (s1 ((1 2 5) (3) (4)) p1)
           (s1 ((2 4 5) (3) (1)) p1)
         (let* ((best-solution-exhaustive nil)
                (action (delta-cvrp-action*))
                (results nil)
                (cvrp-action (basic-cvrp-action  
                              :penalty-factor 1000))
                ;; (criterion-code `((select-route r1)
                ;;                   (select-client c1 from r1)
                ;;                   (select-route r2)
                ;;                   (select-client c2 from r2)
                ;;                   (swap-clients c1 c2)))

                ;; (criterion-code `((select-route r1)
                ;;                   (select-client c1 from r1)
                ;;                   (insert-client c1 into r1)))

                ;; (criterion-code `((select-route r1)
                ;;                   (select-client c1 from r1)
                ;;                   (select-route r2)
                ;;                   (insert-client c1 into r2)))

                (criterion-code  `((select-route r1)
                                   (select-client c1 from r1)
                                   (select-route r2)
                                   (insert-client c1 into r2)))

                )

           (bformat t "Testing DNS with generators")

           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (setf results (dns-with-generators-first-improvement
                          p1
                          s1 
                          criterion-code
                          :max-iter 30
                          :action action))

           ;; (format t "Iterations: ~a. Optimum found ~a.~%"
           ;;         (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best neighbor through exhaustive search:~%")
                 (pp-solution best-solution-exhaustive t)
                 (format t "  with cost: ~a~%"
                         (cost best-solution-exhaustive))

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)


                 (format t "Best value through Yoel's: ~a~%"
                         (+ (total-distance cvrp-action)
                            (total-penalty cvrp-action)))

                 (format t "action: ~a~%" cvrp-action)
                 )

               (else
                 (format t "Initial solution was optimum!~%")))

               )))
     #+END_SRC
**** an33 problem
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n65-k9-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (results nil)

            (cvrp-action (basic-cvrp-action))

            (criterion-code  `((select-route r1)
                               (select-client c1 from r1)
                               (select-route r2)
                               (insert-client c1 into r2)))

            ;; (criterion-code '((select-route r1)
            ;;                   (select-client c1 from r1)
            ;;                   (select-route r2)
            ;;                   (select-client c2 from r2)
            ;;                   (swap-clients c1 c2)))

            ;; (neighborhood-exhaustive
            ;;  (make-neighborhood-criterion
            ;;   criterion-code
            ;;   +exhaustive-search-strategy+
            ;;   selection-strategy))
            )

           (bformat t "Testing DNS with generators and a-n33")

           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (setf results (dns-with-generators-first-improvement  
                          p1
                          s1 
                          criterion-code
                          :max-iter 100
                          :action action))

           ;; (setf results (descent-neighborhood-search
           ;;                p1 s1 neighborhood-exhaustive
           ;;                :max-iter max-iterations
           ;;                :action action))

           ;; (format t "Iterations: ~a. Optimum found ~a.~%"
           ;;         (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best neighbor through exhaustive search:~%")
                 (pp-solution best-solution-exhaustive t)
                 (format t "  with cost: ~a~%"
                         (cost best-solution-exhaustive))

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)


                 (format t "Best value through Yoel's: ~a~%"
                         (+ (total-distance cvrp-action)
                            (total-penalty cvrp-action)))

                 (format t "action: ~a~%" cvrp-action)
                 )

               (else
                 (format t "Initial solution was optimum!~%")))
           )
     #+END_SRC
**** +ff-a-n33-k6-problem (best-improvement)+
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((s1 (make-initial-solution-for-finite-fleet-cvrp-deterministic
                 ff-a-n33-k6-problem))
            (p1 ff-a-n33-k6-problem)
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action))
            (results nil)
            (cvrp-action (basic-cvrp-action 
                          :penalty-factor 1000))
            (criterion-code `((select-route r1)
                              (select-client c1 from r1)
                              (select-route r2)
                              (insert-client c1 into r2)))

            (neighborhood-exploration
             (make-neighborhood-criterion
              criterion-code
              +exhaustive-search-strategy+
              +best-improvement+)))

       (bformat t "Testing DNS")

       ;; first we compute the cost of the solution
       (simulate-solution s1 p1 cvrp-action)
       (setf (cost s1) (+ (total-distance cvrp-action)
                          (total-penalty cvrp-action)))

       (format t "Original solution (with cost ~a):~%"
               (cost s1))
       (pp-solution s1 t)

       (setf results (funcall neighborhood-exploration s1 p1 action))

       ;; (format t "Cost: ~a~%" (cost results))
       ;; (pp-solution results t) (terpri)

       (setf results (descent-neighborhood-search  
                      p1 s1 neighborhood-exploration
                      :max-iter 300
                      :action action))

       ;; (format t "Cost: ~a~%" (cost (first results)))
       ;; (pp-solution (first results) t) (terpri)


       (format t "Iterations: ~a. Optimum found ~a.~%"
               (second results) (third results))      
       (setf best-solution-exhaustive (first results))

       (if best-solution-exhaustive
           (then
             (format t "Best value through exhaustive: ~a~%"
                     (cost best-solution-exhaustive))
             (format t "Best neighbor through exhaustive search:~%")
             (pp-solution best-solution-exhaustive t)

             ;; (format t "Best value through Yoel's: ~a~%"
             ;;         (solution-cost best-solution-exhaustive
             ;;                        p1 cvrp-action))
             ;; (format t "action: ~a~%" cvrp-action)
             )

           (else
             (format t "Initial solution was optimum!~%")))

       ;; (if best-solution-first-improvement
       ;;     (then
       ;;       (format t "Best value through 1st: ~a~%"
       ;;               (cost best-solution-first-improvement))
       ;;       (format t "Best neighbor through 1st:~%")
       ;;       (pp-working-copy
       ;;        (prepare-solution-for-neighborhood-exploration
       ;;         best-solution-first-improvement) t) (terpri)))

       ;; (if best-solution-random-improvement
       ;;     (then
       ;;       (format t "Best value through random: ~a~%"
       ;;               (cost best-solution-first-improvement))
       ;;       (format t "Best neighbor through random::~%")
       ;;       (pp-working-copy
       ;;        (prepare-solution-for-neighborhood-exploration
       ;;         best-solution-random-improvement) t) (terpri)))


       )
     #+END_SRC
**** +problem with end-depot+
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (c1 (basic-cvrp-client 1 30))
             (c2 (basic-cvrp-client 2 20))
             (c3 (basic-cvrp-client 3 40))
             (c4 (basic-cvrp-client 4 50))
             (d0 (basic-depot))
             (d1 (basic-depot 5))
             (v1 (cvrp-vehicle 1 70))
             (v2 (cvrp-vehicle 2 70))

             (distance #2A ((0 1 2 3 5 6)
                            (1 0 4 5 6 7)
                            (2 4 0 6 7 9)
                            (3 5 6 0 8 9)
                            (5 6 7 8 0 1)
                            (3 5 6 4 8 0)))
             (p1 (make-instance 'finite-fleet-end-depot-cvrp-problem
                                :depot d0
                                :end-depot d1
                                :id 1
                                :clients (list c1 c2 c3 c4)
                                :fleet (list v1 v2)
                                :distance-matrix distance))

             ;; now the algorithms related data
             (best-solution-exhaustive nil)
             (action (delta-cvrp-action))
             (results nil)
             (cvrp-action (basic-cvrp-action 
                           :penalty-factor 1000))
             (criterion-code `((select-route r1)
                               (select-client c1 from r1)
                               (select-route r2)
                               (insert-client c1 into r2)))

             (neighborhood-exploration
              (make-neighborhood-criterion
               criterion-code
               +exhaustive-search-strategy+
               +best-improvement+))

             (*vrp-logging* 0))
  
        (bformat t "Testing VND with end-depot")

        (with-finite-fleet-end-depot-cvrp-solution (s1 ((1 1 2) (2 3 4)) p1)

          ;; first we compute the cost of the solution
          (simulate-solution s1 p1 cvrp-action)
          (setf (cost s1) (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))

          (format t "Original solution (with cost ~a):~%"
                  (cost s1))
          (pp-solution s1 t)

          (setf results (descent-neighborhood-search  
                         p1 s1 neighborhood-exploration
                         :max-iter 300
                         :action action))

          (format t "Iterations: ~a. Optimum found ~a.~%"
                    (second results) (third results))      
            (setf best-solution-exhaustive (first results))


          (if best-solution-exhaustive
                (then
                  (format t "Best value through exhaustive: ~a~%"
                          (cost best-solution-exhaustive))
                  (format t "Best neighbor through exhaustive search:~%")
                  (pp-solution best-solution-exhaustive t)

                  ;; (format t "Best value through Yoel's: ~a~%"
                  ;;         (solution-cost best-solution-exhaustive
                  ;;                        p1 cvrp-action))
                  ;; (format t "action: ~a~%" cvrp-action)
                  )

                (else
                  (format t "Initial solution was optimum!~%")))))
      #+END_SRC

** return-random-improvement
*** description
    In this section, I'm going to add a Descent Neighboorhood Search using generators.

    This is an algorithm that receives a solution and a criterion.  It gets the best neighboor according to the criterion and, if the best-neighbor is better, repeat the process, otherwise we are in a local minimum.

    Here, on each neighboorhood, we return one of the neighbors that improves the current solution.
   
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp
   ;; Descent Neighboorhood Search
   (defun dns-with-generators-random-improvement
       (problem solution criterion
        &key max-iter
          action
          ;; (print-mod 1)
          (exploration #'exhaustive-exploration))
     "Solves the VRP problem using a DNS with the given criterion starting with the given solution. We assume that the initial solution has the cost slot bound. If the result is nil, then the initial solution is an optimum for that neighboorhood. We receive a parameter with the type of exploration we want to use."
     (let* (;; let's create the tree variable
            (neigh-tree (build-neighborhood-tree criterion solution))
            (solution-generator (funcall exploration neigh-tree))

            (better-solution nil)
            (better-cost (cost solution))



            ;; (current-solution nil)
            (neighboorhoods-used 1)

            (current-solution (clone solution))
            (working-copy (make-working-copy current-solution))

            ;; the best solution found so far
            (best-solution-found (clone solution))
            (best-solution-cost  (cost best-solution-found))

            ;; solution-better-than-best
            (wc-for-solution-better-than-best nil)
            (solution-better-than-best nil)
            (cost-better-than-best 0)


            (better-solution-found nil)

            )

       ;; let's initialize the working copy and the solution
       (prepare-solution-for-neighborhood-exploration working-copy)
       (initialize-action-for-delta-cost-computation working-copy
                                                     problem
                                                     action)

       ;; as an experiment, let's print the number of
       ;; current solution's neighboors
       (format t "Neighboorhood  1: ~4d candidates..."
               (cardinality neigh-tree))

       ;; let's explore the neighboorhood of the
       ;; current-solution

       (setf (values better-solution
                     better-cost
                     ;; just in case we find a better best solution
                     solution-better-than-best
                     cost-better-than-best)
             (return-random-improvement solution-generator
                                        working-copy
                                        problem
                                        action
                                        (- better-cost
                                           best-solution-cost)))

       ;; print info about the neighboorhood
       (if better-solution
           (then
             (format t "~6d~%" (+ (cost working-copy)
                                  better-cost))
             (setf better-solution-found t)
             ;; found a solution better than best
             ;; (format t "     better best solution with cost: ~a~%"
             ;;         (+ cost-better-than-best
             ;;            (cost working-copy)))
             )

           (else
             (format t "    Initial solution was optimum!!!~%")))
    
       ;; if we found a solution better than the best
       ;; we need to update it
       ;; (if solution-better-than-best
       ;;     (then
       ;;       ;; let's apply the operations to construct the
       ;;       ;; best neighboor

       ;;       ;; to do that, let's clone the current solution
       ;;       (setf wc-for-solution-better-than-best
       ;;             (basic-working-copy (clone (solution working-copy))))
        
       ;;       (apply-set-of-operations solution-better-than-best
       ;;                                wc-for-solution-better-than-best)

       ;;       (setf best-solution-found
       ;;             (clone
       ;;              (solution
       ;;               wc-for-solution-better-than-best)))
       ;;       (setf (cost best-solution-found)
       ;;             (+ (cost best-solution-found)
       ;;                cost-better-than-best))
        
        
       ;;       ;; (format t "Solution better than best with cost: ~a~%"
       ;;       ;;         (cost best-solution-found))
       ;;       ;; (pp-solution best-solution-found t) (terpri)
       ;;       )
       ;;     )



       ;; if better-solution is non nil, then
       ;; we have a better neighboor.

       ;; (if better-solution
       ;;     (then
       ;;       ;; update the current solution
       ;;       ;; in the working-copy
       ;;       (apply-set-of-operations better-solution working-copy)
       ;;       ;; update the cost of the new solution
       ;;       ;; (again, in the working copy)
       ;;       (incf (cost (solution working-copy)) better-cost)
       ;;       ;; let's prepare the new working-copy
       ;;       ;; and the action for the new solution
       ;;       (prepare-solution-for-neighborhood-exploration working-copy)
       ;;       (initialize-action-for-delta-cost-computation working-copy
       ;;                                                     problem
       ;;                                                     action)
       ;;       ;; now let's initialize the new generator
       ;;       (setf neigh-tree (build-neighborhood-tree criterion solution))
       ;;       (setf solution-generator (funcall exploration neigh-tree))

       ;;       (pp-solution working-copy t) (terpri)
       ;;       (format t "cost: ~a~%" (cost (solution working-copy)))))

       ;; (format t "operations: ~a~%" better-solution)

       (loop while (and better-solution
                        (<= neighboorhoods-used max-iter))
             for i from 2
             do

             ;; let's check if we found a solution
             ;; better than the best
             (if solution-better-than-best
                 (then
                   ;; let's apply the operations to construct the
                   ;; best neighboor
                
                   ;; to do that, let's clone the current solution
                   (setf wc-for-solution-better-than-best
                         (basic-working-copy (clone (solution working-copy))))
        
                   (apply-set-of-operations solution-better-than-best
                                            wc-for-solution-better-than-best)

                   (setf best-solution-found
                         (clone
                          (solution
                           wc-for-solution-better-than-best)))

                   ;; (format t "debug: cost best-solution-found: ~a~%"
                   ;;         (cost best-solution-found))

                   ;; (pp-solution best-solution-found t) (terpri)
                
                   (setf (cost best-solution-found)
                         (+ (cost best-solution-found)
                            cost-better-than-best))
                   ;; (format t "debug: after update. cost best-solution-found: ~a~%"
                   ;;         (cost best-solution-found))

                   ))

             ;; update the current solution
             ;; in the working-copy
             (apply-set-of-operations better-solution working-copy)
             ;; update the cost of the new solution
             ;; (again, in the working copy)
             (incf (cost (solution working-copy)) better-cost)

             ;; let's prepare the new working-copy
             ;; and the action for the new solution
             (prepare-solution-for-neighborhood-exploration working-copy)
             (initialize-action-for-delta-cost-computation working-copy
                                                           problem
                                                           action)

             ;; now let's initialize the new generator
             (setf neigh-tree (build-neighborhood-tree
                               criterion
                               (solution working-copy)))
             (setf solution-generator (funcall exploration neigh-tree))


             ;; as an experiment, let's print the number of
             ;; current solution's neighboors
             (format t "Neighboorhood ~2d: ~4d candidates (~a)..."
                     i
                     (cardinality neigh-tree)
                     ;; (cost working-copy)
                     ;; (cost best-solution-found)
                     (- (cost best-solution-found)
                        (cost working-copy))
                     )

             ;; compute the new better-solution
             (setf (values better-solution
                    better-cost
                    ;; just in case we find a better best solution
                    solution-better-than-best
                    cost-better-than-best)
                
                   (return-random-improvement solution-generator
                                              working-copy
                                              problem
                                              action
                                              (- (cost working-copy)
                                                 (cost best-solution-found))))

             (if better-solution
                 (then
                
                   (format t "~6d"
                           (+ (cost working-copy)
                              better-cost))

                   (if solution-better-than-best
                       (then
                         (format t "  (~a)~%"
                           (+ (cost best-solution-found)
                              cost-better-than-best))
                         ;; (format t "Solution better than best with cost: ~a~%"
                         ;;         (cost best-solution-found))
                         ;; (pp-solution best-solution-found t) (terpri)
                         )
                       (else
                         (format t " NO BEST ~%")))
                   )
              
                 (else
                   (format t "    Optimum Found!!!~%")))


             ;; increment the number of neighboorhoods-used
             do (incf neighboorhoods-used))

       ;; ;; finally return the current solution
       ;; ;; if it is nil, then the initial solution is an optimum
       (if better-solution-found
           (then
             (list best-solution-found
                   (cost best-solution-found)
                   neighboorhoods-used
                   (<= neighboorhoods-used max-iter))))
       ))
       #+END_SRC
   
*** tests
**** rarac (toy problem)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                                         :demands '(10 10 15 40 20)
                                         :capacity 40)
       (with-basic-cvrp-solution (s1 ((1 2 5) (3) (4)) p1)
           ;; (s1 ((2 4 5) (3) (1)) p1)
         (let* ((best-solution-exhaustive nil)
                (action (delta-cvrp-action*))
                (results nil)
                (cvrp-action (basic-cvrp-action  
                              :penalty-factor 1000))
                ;; (criterion-code `((select-route r1)
                ;;                   (select-client c1 from r1)
                ;;                   (select-route r2)
                ;;                   (select-client c2 from r2)
                ;;                   (swap-clients c1 c2)))

                (criterion-code  `((select-route r1)
                                   (select-client c1 from r1)
                                   (select-route r2)
                                   (insert-client c1 into r2)))

                )

           (bformat t "Testing DNS")




           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (setf results (dns-with-generators-random-improvement
                          p1
                          s1 
                          criterion-code
                          :max-iter 30
                          :action action))

           ;; (format t "Iterations: ~a. Optimum found ~a.~%"
           ;;         (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best neighbor through exhaustive search:~%")
                 (pp-solution best-solution-exhaustive t)
                 (format t "  with cost: ~a~%"
                         (cost best-solution-exhaustive))

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)


                 (format t "Best value through Yoel's: ~a~%"
                         (+ (total-distance cvrp-action)
                            (total-penalty cvrp-action)))

                 (format t "action: ~a~%" cvrp-action)
                 )

               (else
                 (format t "Best solution found with cost: ~a~%"
                         (cost best-solution-exhaustive))
                 (pp-solution best-solution-exhaustive t) (terpri)))

               )))
     #+END_SRC
**** rab (toy problem)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                                         :demands '(10 10 15 40 20)
                                         :capacity 40)
       (with-basic-cvrp-solution
           ;; (s1 ((1 2 5) (3) (4)) p1)
           (s1 ((2 4 5) (3) (1)) p1)
         (let* ((best-solution-exhaustive nil)
                (action (delta-cvrp-action*))
                (results nil)
                (cvrp-action (basic-cvrp-action  
                              :penalty-factor 1000))
                ;; (criterion-code `((select-route r1)
                ;;                   (select-client c1 from r1)
                ;;                   (select-route r2)
                ;;                   (select-client c2 from r2)
                ;;                   (swap-clients c1 c2)))

                ;; (criterion-code `((select-route r1)
                ;;                   (select-client c1 from r1)
                ;;                   (insert-client c1 into r1)))

                ;; (criterion-code `((select-route r1)
                ;;                   (select-client c1 from r1)
                ;;                   (select-route r2)
                ;;                   (insert-client c1 into r2)))

                (criterion-code  `((select-route r1)
                                   (select-client c1 from r1)
                                   (select-route r2)
                                   (insert-client c1 into r2)))

                )

           (bformat t "Testing DNS with generators")

           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (setf results (dns-with-generators-random-improvement
                          p1
                          s1 
                          criterion-code
                          :max-iter 30
                          :action action))

           ;; (format t "Iterations: ~a. Optimum found ~a.~%"
           ;;         (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best neighbor through exhaustive search:~%")
                 (pp-solution best-solution-exhaustive t)
                 (format t "  with cost: ~a~%"
                         (cost best-solution-exhaustive))

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)


                 (format t "Best value through Yoel's: ~a~%"
                         (+ (total-distance cvrp-action)
                            (total-penalty cvrp-action)))

                 (format t "action: ~a~%" cvrp-action)
                 )

               (else
                 (format t "Initial solution was optimum!~%")))

               )))
     #+END_SRC
**** an33 problem
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n33-k6-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (results nil)

            (cvrp-action (basic-cvrp-action))

            (criterion-code  `((select-route r1)
                               (select-client c1 from r1)
                               (select-route r2)
                               (insert-client c1 into r2)))

            ;; (criterion-code '((select-route r1)
            ;;                   (select-client c1 from r1)
            ;;                   (select-route r2)
            ;;                   (select-client c2 from r2)
            ;;                   (swap-clients c1 c2)))

            ;; (neighborhood-exhaustive
            ;;  (make-neighborhood-criterion
            ;;   criterion-code
            ;;   +exhaustive-search-strategy+
            ;;   selection-strategy))
            )

           (bformat t "Testing DNS with generators and a-n33")

           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (setf results (dns-with-generators-random-improvement  
                          p1
                          s1 
                          criterion-code
                          :max-iter 100
                          :action action))

           ;; (setf results (descent-neighborhood-search
           ;;                p1 s1 neighborhood-exhaustive
           ;;                :max-iter max-iterations
           ;;                :action action))

           ;; (format t "Iterations: ~a. Optimum found ~a.~%"
           ;;         (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best neighbor through exhaustive search:~%")
                 (pp-solution best-solution-exhaustive t)
                 (format t "  with cost: ~a~%"
                         (cost best-solution-exhaustive))

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)


                 (format t "Best value through Yoel's: ~a~%"
                         (+ (total-distance cvrp-action)
                            (total-penalty cvrp-action)))

                 (format t "action: ~a~%" cvrp-action)
                 )

               (else
                 (format t "Initial solution was optimum!~%")))
           )
     #+END_SRC
**** +ff-a-n33-k6-problem (best-improvement)+
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((s1 (make-initial-solution-for-finite-fleet-cvrp-deterministic
                 ff-a-n33-k6-problem))
            (p1 ff-a-n33-k6-problem)
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action))
            (results nil)
            (cvrp-action (basic-cvrp-action 
                          :penalty-factor 1000))
            (criterion-code `((select-route r1)
                              (select-client c1 from r1)
                              (select-route r2)
                              (insert-client c1 into r2)))

            (neighborhood-exploration
             (make-neighborhood-criterion
              criterion-code
              +exhaustive-search-strategy+
              +best-improvement+)))

       (bformat t "Testing DNS")

       ;; first we compute the cost of the solution
       (simulate-solution s1 p1 cvrp-action)
       (setf (cost s1) (+ (total-distance cvrp-action)
                          (total-penalty cvrp-action)))

       (format t "Original solution (with cost ~a):~%"
               (cost s1))
       (pp-solution s1 t)

       (setf results (funcall neighborhood-exploration s1 p1 action))

       ;; (format t "Cost: ~a~%" (cost results))
       ;; (pp-solution results t) (terpri)

       (setf results (descent-neighborhood-search  
                      p1 s1 neighborhood-exploration
                      :max-iter 300
                      :action action))

       ;; (format t "Cost: ~a~%" (cost (first results)))
       ;; (pp-solution (first results) t) (terpri)


       (format t "Iterations: ~a. Optimum found ~a.~%"
               (second results) (third results))      
       (setf best-solution-exhaustive (first results))

       (if best-solution-exhaustive
           (then
             (format t "Best value through exhaustive: ~a~%"
                     (cost best-solution-exhaustive))
             (format t "Best neighbor through exhaustive search:~%")
             (pp-solution best-solution-exhaustive t)

             ;; (format t "Best value through Yoel's: ~a~%"
             ;;         (solution-cost best-solution-exhaustive
             ;;                        p1 cvrp-action))
             ;; (format t "action: ~a~%" cvrp-action)
             )

           (else
             (format t "Initial solution was optimum!~%")))

       ;; (if best-solution-first-improvement
       ;;     (then
       ;;       (format t "Best value through 1st: ~a~%"
       ;;               (cost best-solution-first-improvement))
       ;;       (format t "Best neighbor through 1st:~%")
       ;;       (pp-working-copy
       ;;        (prepare-solution-for-neighborhood-exploration
       ;;         best-solution-first-improvement) t) (terpri)))

       ;; (if best-solution-random-improvement
       ;;     (then
       ;;       (format t "Best value through random: ~a~%"
       ;;               (cost best-solution-first-improvement))
       ;;       (format t "Best neighbor through random::~%")
       ;;       (pp-working-copy
       ;;        (prepare-solution-for-neighborhood-exploration
       ;;         best-solution-random-improvement) t) (terpri)))


       )
     #+END_SRC
**** +problem with end-depot+
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (c1 (basic-cvrp-client 1 30))
             (c2 (basic-cvrp-client 2 20))
             (c3 (basic-cvrp-client 3 40))
             (c4 (basic-cvrp-client 4 50))
             (d0 (basic-depot))
             (d1 (basic-depot 5))
             (v1 (cvrp-vehicle 1 70))
             (v2 (cvrp-vehicle 2 70))

             (distance #2A ((0 1 2 3 5 6)
                            (1 0 4 5 6 7)
                            (2 4 0 6 7 9)
                            (3 5 6 0 8 9)
                            (5 6 7 8 0 1)
                            (3 5 6 4 8 0)))
             (p1 (make-instance 'finite-fleet-end-depot-cvrp-problem
                                :depot d0
                                :end-depot d1
                                :id 1
                                :clients (list c1 c2 c3 c4)
                                :fleet (list v1 v2)
                                :distance-matrix distance))

             ;; now the algorithms related data
             (best-solution-exhaustive nil)
             (action (delta-cvrp-action))
             (results nil)
             (cvrp-action (basic-cvrp-action 
                           :penalty-factor 1000))
             (criterion-code `((select-route r1)
                               (select-client c1 from r1)
                               (select-route r2)
                               (insert-client c1 into r2)))

             (neighborhood-exploration
              (make-neighborhood-criterion
               criterion-code
               +exhaustive-search-strategy+
               +best-improvement+))

             (*vrp-logging* 0))
  
        (bformat t "Testing VND with end-depot")

        (with-finite-fleet-end-depot-cvrp-solution (s1 ((1 1 2) (2 3 4)) p1)

          ;; first we compute the cost of the solution
          (simulate-solution s1 p1 cvrp-action)
          (setf (cost s1) (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))

          (format t "Original solution (with cost ~a):~%"
                  (cost s1))
          (pp-solution s1 t)

          (setf results (descent-neighborhood-search  
                         p1 s1 neighborhood-exploration
                         :max-iter 300
                         :action action))

          (format t "Iterations: ~a. Optimum found ~a.~%"
                    (second results) (third results))      
            (setf best-solution-exhaustive (first results))


          (if best-solution-exhaustive
                (then
                  (format t "Best value through exhaustive: ~a~%"
                          (cost best-solution-exhaustive))
                  (format t "Best neighbor through exhaustive search:~%")
                  (pp-solution best-solution-exhaustive t)

                  ;; (format t "Best value through Yoel's: ~a~%"
                  ;;         (solution-cost best-solution-exhaustive
                  ;;                        p1 cvrp-action))
                  ;; (format t "action: ~a~%" cvrp-action)
                  )

                (else
                  (format t "Initial solution was optimum!~%")))))
      #+END_SRC

      
* Classical VNS
** description
   In this section, I'm going to add a Variable Neighboorhood Search.  This is an algorithm that receives a solution and a list with several criteria.  It gets the best neighbor according to the current criterion and, if the best-neighbor found with that criterion is better than the current one, repeat the process.  When we find a solution that is a local minimum to that criterion, we change the criterion.  If it is a local minimum to all the criteria we have, then we assume that it is a solution for the problem.

   In this section, we'll write the VNS with generators.
   
** exhaustive search / best neighbor
*** description
    Here we make an exhaustive search of each neighborhood and return the best neighbor found on each.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp
   ;; Variable Neighboorhood Search
   (defun vns-exhaustive-best-neighbor
       (problem
        solution
        criteria
        &key
          (max-iter 100)
          action
          (print-neighborhood-size nil)
          (print-mod 1)
          (exploration #'exhaustive-exploration))
     "Solves the VRP problem using a VNS with the given criterion starting with the given solution. We assume that the initial solution has the cost slot bound. If the result is nil, then the initial solution is an optimum for that neighboorhood."
     (declare (ignore print-mod))

     (let* (;; variables related to the vns
            (current-index 0)
            (number-of-criteria (length criteria))
            (current-criterion nil)

            ;; let's create the tree variable
            (neigh-tree nil)
            (solution-generator nil)

            (current-solution (clone solution))
            (working-copy (make-working-copy current-solution))

            (better-solution nil)
            (better-cost 0)

            (neighboorhoods-used 1)

            )

       ;; let's initialize the working copy and the solution
       (prepare-solution-for-neighborhood-exploration working-copy)
       (initialize-action-for-delta-cost-computation working-copy
                                                     problem
                                                     action)


       (loop while (and (< current-index number-of-criteria)
                        (<= neighboorhoods-used max-iter))


             do
             ;; let's set the current criterion
             (setf current-criterion (nth current-index criteria))

             ;; let's create the generator
             ;; first the tree
             (setf neigh-tree (build-neighborhood-tree
                               current-criterion
                               current-solution))

             ;; and now, let's create the generator
             (setf solution-generator (funcall exploration neigh-tree))


             ;; for debugging purposes
             (format t "Debug VNS.  Iteration ~3d, criterion ~2d"
                     neighboorhoods-used current-index)

             (if print-neighborhood-size
                 (format t " (~6d)"
                         (cardinality neigh-tree)))

             ;; let's explore with the current criteria
             (setf (values better-solution better-cost)
                   (return-best-neighbor solution-generator
                                         working-copy
                                         problem
                                         action))

             (if better-solution
                 (then ;; update the current solution

                   ;; (format t "~%   dbg: ~a, -solution ~a"
                   ;;         better-cost
                   ;;         better-solution)


                   ;; we found a better solution
                   ;; update the current-solution
                   ;; in the working-copy
                   (apply-set-of-operations better-solution working-copy)
                   ;; update the cost of the new solution
                   ;; (again, in the working copy)
                   (incf (cost (solution working-copy)) better-cost)



                   ;; let's prepare the new working-copy
                   ;; and the action for the new solution
                   (prepare-solution-for-neighborhood-exploration
                    working-copy)
                   (initialize-action-for-delta-cost-computation
                    working-copy
                    problem
                    action)

                   ;; (format t "~%   dbg: cost: ~a"
                   ;;         (cost working-copy))

                   ;; (format t "~%   dbg: sol:~%")
                   ;; (pp-solution working-copy t) (terpri)



                   ;; now let's initialize the new generator
                   (setf neigh-tree (build-neighborhood-tree
                                     current-criterion
                                     (solution working-copy)))
                   (setf solution-generator
                         (funcall exploration neigh-tree))

                   ;; now that the current solution is
                   ;; updated, let's set the
                   ;; number-of-criteria to 0
                   (setf current-index 0))
                 (else ;; incf the current-index
                   ;; use the next criterion
                   (incf current-index)))

             ;; update the log
             (format t ":  ~6d~%" (cost working-copy))

             ;; in any case, increment the number of neighboorhoods-used
             (incf neighboorhoods-used)

             )


       ;; finally return the current solution
       ;; the current-solution is the solution
       ;; in the working copy.
       ;; if it is nil, then the initial solution is an optimum

       (list (solution working-copy)
             neighboorhoods-used
             (<= neighboorhoods-used max-iter))))
       #+END_SRC
   
*** tests
**** rarac (best-improvement)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                                         :demands '(10 10 15 40 20)
                                         :capacity 40)
       (with-basic-cvrp-solution (s1 ((2 4 5) (3) (1)) p1)
         (let* ((best-solution-exhaustive nil)
                (action (delta-cvrp-action*))
                (results nil)
                (cvrp-action (basic-cvrp-action 
                              :penalty-factor 1000))

                )

           (bformat t "Testing VNS with generators")


           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (setf results (vns-exhaustive-best-neighbor 
                          p1 s1 (list rab
                                      rarb
                                      rarac
                                      )
                          :max-iter 150
                          :action action))

           (format t "Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))      
           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through exhaustive: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor through exhaustive search:~%")
                 (pp-solution best-solution-exhaustive t)
                 )

               (else
                 (format t "Initial solution was optimum!~%")))

               )))
     #+END_SRC
**** a-n33-k6 (best-improvement)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n33-k6-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (results nil)
            (cvrp-action (basic-cvrp-action 
                          :penalty-factor 1000))

            )

       (bformat t "Testing VNS with generators")


       ;; first we compute the cost of the solution
       (simulate-solution s1 p1 cvrp-action)
       (setf (cost s1) (+ (total-distance cvrp-action)
                          (total-penalty cvrp-action)))

       (format t "Original solution (with cost ~a):~%"
               (cost s1))
       (pp-solution s1 t)

       (setf results (vns-exhaustive-best-neighbor 
                      p1 s1 (list rab
                                  rarb
                                  rarac
                                  ref
                                  rerf
                                  rereg
                                  rerehg
                                  )
                      :max-iter 150
                      :action action))

       (format t "Iterations: ~a. Optimum found ~a.~%"
               (second results) (third results))      
       (setf best-solution-exhaustive (first results))

       (if best-solution-exhaustive
           (then
             (format t "Best value through exhaustive: ~a~%"
                     (cost best-solution-exhaustive))
             (format t "Best neighbor through exhaustive search:~%")
             (pp-solution best-solution-exhaustive t)
             )

           (else
             (format t "Initial solution was optimum!~%")))

       )
     #+END_SRC
**** a-n65-k9 (best-improvement)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n65-k9-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (results nil)
            (cvrp-action (basic-cvrp-action 
                          :penalty-factor 1000))

            )

       (bformat t "Testing VNS with generators")


       ;; first we compute the cost of the solution
       (simulate-solution s1 p1 cvrp-action)
       (setf (cost s1) (+ (total-distance cvrp-action)
                          (total-penalty cvrp-action)))

       (format t "Original solution (with cost ~a):~%"
               (cost s1))
       (pp-solution s1 t)

       (setf results (vns-exhaustive-best-neighbor 
                      p1 s1 (list rab
                                  rarb
                                  rarac
                                  ref
                                  rerf
                                  rereg
                                  rerehg
                                  )
                      :max-iter 200
                      :print-neighborhood-size t 
                      :action action))

       (format t "Iterations: ~a. Optimum found ~a.~%"
               (second results) (third results))      
       (setf best-solution-exhaustive (first results))

       (if best-solution-exhaustive
           (then
             (format t "Best value through exhaustive: ~a~%"
                     (cost best-solution-exhaustive))
             (format t "Best neighbor through exhaustive search:~%")
             (pp-solution best-solution-exhaustive t))

           (else
             (format t "Initial solution was optimum!~%")))

       )
     #+END_SRC
** exhaustive search / best neighbor / fixed size
*** description
    Here, we check the size of the neighborhood and if it greater than a fixed parameter, then turn to uniform exploration.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp
   ;; Variable Neighboorhood Search
   (defun vns-exhaustive-best-neighbor-max-neigh-size
       (problem
        solution
        criteria
        &key
          (max-iter 100)
          (max-neighborhood-size 4000)
          action
          (print-neighborhood-size nil)
          (print-mod 1)
          ;; (exploration #'exhaustive-exploration)
          )
     "Solves the VRP problem using a VNS with the given criterion starting with the given solution. We assume that the initial solution has the cost slot bound. If the result is nil, then the initial solution is an optimum for that neighboorhood. If a given neighboorhood has a cardinality greater than max-neighborhood-size, then just make a uniform exploration."
     (declare (ignore print-mod))

     (let* (;; variables related to the vns
            (current-index 0)
            (number-of-criteria (length criteria))
            (current-criterion nil)

            ;; let's create the tree variable
            (neigh-tree nil)
            (solution-generator nil)

            (current-solution (clone solution))
            (working-copy (make-working-copy current-solution))

            (better-solution nil)
            (better-cost 0)

            (neighboorhoods-used 1)

            )

       ;; let's initialize the working copy and the solution
       (prepare-solution-for-neighborhood-exploration working-copy)
       (initialize-action-for-delta-cost-computation working-copy
                                                     problem
                                                     action)


       (loop while (and (< current-index number-of-criteria)
                        (<= neighboorhoods-used max-iter))


             do
             ;; let's set the current criterion
             (setf current-criterion (nth current-index criteria))

             ;; let's create the generator
             ;; first the tree
             (setf neigh-tree (build-neighborhood-tree
                               current-criterion
                               current-solution))

             ;; and now, let's create the generator
             ;; according to the size of the neighborhood
             (if (<= (cardinality neigh-tree) max-neighborhood-size)
                 (then ;; use exhaustive-exploration
                   (setf solution-generator
                         (exhaustive-exploration neigh-tree)))
                 (else ;; use uniform-exploration
                   (setf solution-generator
                         (uniform-exploration neigh-tree
                                              max-neighborhood-size))))


             ;; for debugging purposes
             (format t "Debug VNS.  Iteration ~3d, criterion ~2d"
                     neighboorhoods-used current-index)

             (if print-neighborhood-size
                 (format t " (~6d)"
                         (if (<= (cardinality neigh-tree)
                                 max-neighborhood-size)
                             (then (cardinality neigh-tree))
                             (else max-neighborhood-size))))

             ;; let's explore with the current criteria
             (setf (values better-solution better-cost)
                   (return-best-neighbor solution-generator
                                         working-copy
                                         problem
                                         action))

             (if better-solution
                 (then ;; update the current solution

                   ;; (format t "~%   dbg: ~a, -solution ~a"
                   ;;         better-cost
                   ;;         better-solution)


                   ;; we found a better solution
                   ;; update the current-solution
                   ;; in the working-copy
                   (apply-set-of-operations better-solution working-copy)
                   ;; update the cost of the new solution
                   ;; (again, in the working copy)
                   (incf (cost (solution working-copy)) better-cost)



                   ;; let's prepare the new working-copy
                   ;; and the action for the new solution
                   (prepare-solution-for-neighborhood-exploration
                    working-copy)
                   (initialize-action-for-delta-cost-computation
                    working-copy
                    problem
                    action)

                   ;; (format t "~%   dbg: cost: ~a"
                   ;;         (cost working-copy))

                   ;; (format t "~%   dbg: sol:~%")
                   ;; (pp-solution working-copy t) (terpri)



                   ;; now let's initialize the new generator
                   (setf neigh-tree (build-neighborhood-tree
                                     current-criterion
                                     (solution working-copy)))
                   ;; create the generator according to the
                   ;; size of the neighboorhood
                   (if (<= (cardinality neigh-tree) max-neighborhood-size)
                       (then ;; use exhaustive-exploration
                         (setf solution-generator
                               (exhaustive-exploration neigh-tree)))
                       (else ;; use uniform-exploration
                         (setf solution-generator
                               (uniform-exploration neigh-tree
                                                    max-neighborhood-size))))

                   ;; now that the current solution is
                   ;; updated, let's set the
                   ;; number-of-criteria to 0
                   (setf current-index 0))
                 (else ;; incf the current-index
                   ;; use the next criterion
                   (incf current-index)))

             ;; update the log
             (format t ":  ~6d~%" (cost working-copy))

             ;; in any case, increment the number of neighboorhoods-used
             (incf neighboorhoods-used)

             )


       ;; finally return the current solution
       ;; the current-solution is the solution
       ;; in the working copy.
       ;; if it is nil, then the initial solution is an optimum

       (list (solution working-copy)
             neighboorhoods-used
             (<= neighboorhoods-used max-iter))))
       #+END_SRC
   
*** tests
**** rarac (best-improvement)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                                         :demands '(10 10 15 40 20)
                                         :capacity 40)
       (with-basic-cvrp-solution (s1 ((2 4 5) (3) (1)) p1)
         (let* ((best-solution-exhaustive nil)
                (action (delta-cvrp-action*))
                (results nil)
                (cvrp-action (basic-cvrp-action 
                              :penalty-factor 1000))

                )

           (bformat t "Testing VNS with generators")


           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (setf results (vns-exhaustive-best-neighbor-max-neigh-size 
                          p1 s1 (list rab
                                      rarb
                                      rarac
                                      )
                          :max-iter 150
                          :print-neighborhood-size t
                          :max-neighborhood-size 20
                          :action action))

           (format t "Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))      
           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through exhaustive: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor through exhaustive search:~%")
                 (pp-solution best-solution-exhaustive t)
                 )

               (else
                 (format t "Initial solution was optimum!~%")))

               )))
     #+END_SRC
**** a-n33-k6 (best-improvement)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n65-k9-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (results nil)
            (cvrp-action (basic-cvrp-action 
                          :penalty-factor 1000))

            )

       (bformat t "Testing VNS with generators")


       ;; first we compute the cost of the solution
       (simulate-solution s1 p1 cvrp-action)
       (setf (cost s1) (+ (total-distance cvrp-action)
                          (total-penalty cvrp-action)))

       (format t "Original solution (with cost ~a):~%"
               (cost s1))
       (pp-solution s1 t)

       (setf results (vns-exhaustive-best-neighbor-max-neigh-size 
                      p1 s1 (list rab
                                  rarb
                                  rarac
                                  ref
                                  rerf
                                  rereg
                                  rerehg
                                  )
                      :max-iter 350
                      :print-neighborhood-size t
                      :max-neighborhood-size 5000
                      :action action))

       (format t "Iterations: ~a. Optimum found ~a.~%"
               (second results) (third results))      
       (setf best-solution-exhaustive (first results))

       (if best-solution-exhaustive
           (then
             (format t "Best value through exhaustive: ~a~%"
                     (cost best-solution-exhaustive))
             (format t "Best neighbor through exhaustive search:~%")
             (pp-solution best-solution-exhaustive t)
             )

           (else
             (format t "Initial solution was optimum!~%")))

       )
     #+END_SRC
**** a-n65-k9 (best-improvement)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n65-k9-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (results nil)
            (cvrp-action (basic-cvrp-action 
                          :penalty-factor 1000))

            )

       (bformat t "Testing VNS with generators")


       ;; first we compute the cost of the solution
       (simulate-solution s1 p1 cvrp-action)
       (setf (cost s1) (+ (total-distance cvrp-action)
                          (total-penalty cvrp-action)))

       (format t "Original solution (with cost ~a):~%"
               (cost s1))
       (pp-solution s1 t)

       (setf results (vns-exhaustive-best-neighbor-max-neigh-size 
                      p1 s1 (list rab
                                  rarb
                                  rarac
                                  ref
                                  rerf
                                  rereg
                                  rerehg
                                  )
                      :max-iter 200
                      :print-neighborhood-size t 
                      :print-neighborhood-size t
                      :max-neighborhood-size 1000
                      :action action))

       (format t "Iterations: ~a. Optimum found ~a.~%"
               (second results) (third results))      
       (setf best-solution-exhaustive (first results))

       (if best-solution-exhaustive
           (then
             (format t "Best value through exhaustive: ~a~%"
                     (cost best-solution-exhaustive))
             (format t "Best neighbor through exhaustive search:~%")
             (pp-solution best-solution-exhaustive t))

           (else
             (format t "Initial solution was optimum!~%")))

       )
     #+END_SRC
** exhaustive search / first improvement / bounded size
*** description
    Here, we check the size of the neighborhood and if it greater than a fixed parameter, then turn to uniform exploration.  We are using first improvement here.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp
   ;; Variable Neighboorhood Search
   (defun vns-adaptative-first-improvement-max-neigh-size
       (problem
        solution
        criteria
        &key
          (max-iter 100)
          (max-neighborhood-size 4000)
          action
          (print-neighborhood-size nil)
          (print-mod 1)
          ;; (exploration #'exhaustive-exploration)
          )
     "Solves the VRP problem using a VNS with the given criterion starting with the given solution. We assume that the initial solution has the cost slot bound. If the result is nil, then the initial solution is an optimum for that neighboorhood. If a given neighboorhood has a cardinality greater than max-neighborhood-size, then just make a uniform exploration."
     (declare (ignore print-mod))

     (let* (;; variables related to the vns
            (current-index 0)
            (number-of-criteria (length criteria))
            (current-criterion nil)

            ;; let's create the tree variable
            (neigh-tree nil)
            (solution-generator nil)

            (current-solution (clone solution))
            (working-copy (make-working-copy current-solution))

            (better-solution nil)
            (better-cost 0)

            (neighboorhoods-used 1)

            )

       ;; let's initialize the working copy and the solution
       (prepare-solution-for-neighborhood-exploration working-copy)
       (initialize-action-for-delta-cost-computation working-copy
                                                     problem
                                                     action)


       (loop while (and (< current-index number-of-criteria)
                        (<= neighboorhoods-used max-iter))


             do
             ;; let's set the current criterion
             (setf current-criterion (nth current-index criteria))

             ;; let's create the generator
             ;; first the tree
             (setf neigh-tree (build-neighborhood-tree
                               current-criterion
                               current-solution))

             ;; and now, let's create the generator
             ;; according to the size of the neighborhood
             (if (<= (cardinality neigh-tree) max-neighborhood-size)
                 (then ;; use exhaustive-exploration
                   (setf solution-generator
                         (exhaustive-exploration neigh-tree)))
                 (else ;; use uniform-exploration
                   (setf solution-generator
                         (uniform-exploration neigh-tree
                                              max-neighborhood-size))))


             ;; for debugging purposes
             (format t "Debug VNS.  Iteration ~3d, criterion ~2d"
                     neighboorhoods-used current-index)

             (if print-neighborhood-size
                 (format t " (~6d)"
                         (if (<= (cardinality neigh-tree)
                                 max-neighborhood-size)
                             (then (cardinality neigh-tree))
                             (else max-neighborhood-size))))

             ;; let's explore with the current criteria
             (setf (values better-solution better-cost)
                   (return-first-improvement
                    solution-generator
                    working-copy
                    problem
                    action))

             (if better-solution
                 (then ;; update the current solution

                   ;; we found a better solution
                   ;; update the current-solution
                   ;; in the working-copy
                   (apply-set-of-operations better-solution working-copy)
                   ;; update the cost of the new solution
                   ;; (again, in the working copy)
                   (incf (cost (solution working-copy)) better-cost)


                   ;; let's prepare the new working-copy
                   ;; and the action for the new solution
                   (prepare-solution-for-neighborhood-exploration
                    working-copy)
                   (initialize-action-for-delta-cost-computation
                    working-copy
                    problem
                    action)


                   ;; now let's initialize the new generator
                   (setf neigh-tree (build-neighborhood-tree
                                     current-criterion
                                     (solution working-copy)))
                   ;; create the generator according to the
                   ;; size of the neighboorhood
                   (if (<= (cardinality neigh-tree) max-neighborhood-size)
                       (then ;; use exhaustive-exploration
                         (setf solution-generator
                               (exhaustive-exploration neigh-tree)))
                       (else ;; use uniform-exploration
                         (setf solution-generator
                               (uniform-exploration neigh-tree
                                                    max-neighborhood-size))))

                   ;; now that the current solution is
                   ;; updated, let's set the
                   ;; number-of-criteria to 0
                   (setf current-index 0))
                 (else ;; incf the current-index
                   ;; to use the next criterion
                   (incf current-index)))

             ;; update the log
             (format t ":  ~6d~%" (cost working-copy))

             ;; in any case, increment the number of neighboorhoods-used
             (incf neighboorhoods-used)

             )


       ;; finally return the current solution
       ;; the current-solution is the solution
       ;; in the working copy.
       ;; if it is nil, then the initial solution is an optimum

       (list (solution working-copy)
             neighboorhoods-used
             (<= neighboorhoods-used max-iter))))
       #+END_SRC
   
*** tests
**** rarac (best-improvement)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                                         :demands '(10 10 15 40 20)
                                         :capacity 40)
       (with-basic-cvrp-solution (s1 ((2 4 5) (3) (1)) p1)
         (let* ((best-solution-exhaustive nil)
                (action (delta-cvrp-action*))
                (results nil)
                (cvrp-action (basic-cvrp-action 
                              :penalty-factor 1000))

                )

           (bformat t "Testing VNS with generators")


           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost sc1))
           (pp-solution s1 t)

           (setf results (vns-adaptative-first-improvement-max-neigh-size 
                          p1 s1 (list rab
                                      rarb
                                      rarac
                                      )
                          :max-iter 150
                          :print-neighborhood-size t
                          :max-neighborhood-size 15
                          :action action))

           (format t "Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))      
           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through exhaustive: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor through exhaustive search:~%")
                 (pp-solution best-solution-exhaustive t)
                 )

               (else
                 (format t "Initial solution was optimum!~%")))

               )))
     #+END_SRC
**** a-n33-k6 (best-improvement)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n33-k6-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (results nil)
            (cvrp-action (basic-cvrp-action 
                          :penalty-factor 1000))

            )

       (bformat t "Testing VNS with generators")


       ;; first we compute the cost of the solution
       (simulate-solution s1 p1 cvrp-action)
       (setf (cost s1) (+ (total-distance cvrp-action)
                          (total-penalty cvrp-action)))

       (format t "Original solution (with cost ~a):~%"
               (cost s1))
       (pp-solution s1 t)

       (setf results (vns-adaptative-first-improvement-max-neigh-size 
                      p1 s1 (list rab
                                  rarb
                                  rarac
                                  ref
                                  rerf
                                  rereg
                                  rerehg
                                  )
                      :max-iter 350
                      :print-neighborhood-size t
                      :max-neighborhood-size 700
                      :action action))

       (format t "Iterations: ~a. Optimum found ~a.~%"
               (second results) (third results))      
       (setf best-solution-exhaustive (first results))

       (if best-solution-exhaustive
           (then
             (format t "Best value through exhaustive: ~a~%"
                     (cost best-solution-exhaustive))
             (format t "Best neighbor through exhaustive search:~%")
             (pp-solution best-solution-exhaustive t)
             )

           (else
             (format t "Initial solution was optimum!~%")))

       )
     #+END_SRC
**** a-n65-k9 (best-improvement)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n65-k9-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (results nil)
            (cvrp-action (basic-cvrp-action 
                          :penalty-factor 1000))

            )

       (bformat t "Testing VNS with generators")


       ;; first we compute the cost of the solution
       (simulate-solution s1 p1 cvrp-action)
       (setf (cost s1) (+ (total-distance cvrp-action)
                          (total-penalty cvrp-action)))

       (format t "Original solution (with cost ~a):~%"
               (cost s1))
       (pp-solution s1 t)

       (setf results (vns-adaptative-first-improvement-max-neigh-size 
                      p1 s1 (list rab
                                  rarb
                                  rarac
                                  ref
                                  rerf
                                  rereg
                                  rerehg
                                  )
                      :max-iter 550
                      :print-neighborhood-size t
                      :max-neighborhood-size 3000
                      :action action))

       (format t "Iterations: ~a. Optimum found ~a.~%"
               (second results) (third results))      
       (setf best-solution-exhaustive (first results))

       (if best-solution-exhaustive
           (then
             (format t "Best value through exhaustive: ~a~%"
                     (cost best-solution-exhaustive))
             (format t "Best neighbor through exhaustive search:~%")
             (pp-solution best-solution-exhaustive t))

           (else
             (format t "Initial solution was optimum!~%")))

       )
     #+END_SRC
** TODO receiving the criteria as a list of descriptions
*** description
    The main characteristic of this implementation is that the criteria passed as a list of descriptions and the algorithm can choose the strategy to explore the neighborhood with.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp
   ;; Variable Neighboorhood Search
   (defun vns-code
       (problem solution criteria
        &key
          (search-strategy +exhaustive-search-strategy+)
          (selection-strategy +random-improvement+)
          max-iter action (print-mod 1))
     "Solves the VRP problem using a VNS with the given criterion starting with the given solution. We assume that the initial solution has the cost slot bound. If the result is nil, then the initial solution is an optimum for that neighboorhood."
     (declare (ignore print-mod))

     (let* ((current-index 0)
            (number-of-criteria (length criteria))
            ;; ;; this is to make only one call to
            ;; make-neighborhood-criterion
            (criteria-as-functions (mapcar (lambda (x)
                                             (make-neighborhood-criterion
                                              x
                                              search-strategy
                                              selection-strategy))
                                           criteria))
            (current-criterion nil)
            (better-solution nil)
            (current-solution solution)
            (neighboorhoods-used 1)



            )

       (loop while (and (< current-index number-of-criteria)
                        (<= neighboorhoods-used max-iter))

             ;; let's set the current-criterion
             do (setf current-criterion (nth current-index
                                             criteria-as-functions))


             ;; let's explore with the current criteria

             ;; for debugging purposes
             do (format t "Debug inside VNS.  Iteration ~a, criterion ~a"
                         neighboorhoods-used current-index)

             do (setf better-solution
                      (funcall current-criterion
                               current-solution problem action))

             do (if better-solution
                    (then 
                      ;; we found a better solution
                      ;; update the current-solution
                      (setf current-solution better-solution)
                      ;; set the number-of-criteria to 0
                      (setf current-index 0))
                    (else
                      ;; use the next criterion
                      (incf current-index)))

             ;; ;; ;;{{{ for debugging purposes
             ;; do (format t "Debug inside VNS.  Iteration ~a, criterion ~a"
             ;;         neighboorhoods-used current-index)
             do (if better-solution
                    (then
                      (format t ", cost: ~a~%" (cost better-solution))
                      ;; (pp-solution better-solution t) (terpri)
                      )
                    (else
                      (format t ".  Best solution found.~%")))
             ;; ;; ;; end of debug.

             ;; in any case, increment the number of neighboorhoods-used
             do (incf neighboorhoods-used)

             ;; ;; ;; for debugging purposes
             ;; (format t "At the end of the while: ~a, ~a~%"
             ;;         current-index number-of-criteria
             ;;         ;; (< current-index number-of-criteria)
             ;;         ;; (<= neighboorhoods-used max-iter)
             ;;         )
             ;; ;; ;; end of debugging purposes ;;}}}

             )
       ;; finally return the current solution
       ;; if it is nil, then the initial solution is an optimum
       (list current-solution
             neighboorhoods-used
             (<= neighboorhoods-used max-iter))))
       #+END_SRC
   
*** tests
**** testing add route
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                                         :demands '(10 10 15 40 20)
                                         :capacity 40)
       (with-basic-cvrp-solution (s1 ((1 2 3 4 5)) p1)
         (let* ((best-solution-exhaustive nil)
                (action (delta-cvrp-action))
                (results nil)
                (cvrp-action (basic-cvrp-action 
                              :penalty-factor 1000))
                )

           (bformat t "Testing VNS with add-route")


           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (get-cost-from-action cvrp-action))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (setf results (vns-shake 
                          p1 s1 (list
                                 rab   ; 0
                                 rarb  ; 1
                                 rarac ; 2
                                 rad   ; 3   
                                 )
                          :max-iter 150
                          :action action
                          :selection-strategy +best-improvement+))

           (format t "Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))      
           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through exhaustive: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor through exhaustive search:~%")
                 (pp-solution best-solution-exhaustive t)

                 ;; (format t "Best value through Yoel's: ~a~%"
                 ;;         (solution-cost best-solution-exhaustive
                 ;;                        p1 cvrp-action))
                 ;; (format t "action: ~a~%" cvrp-action)
                 )

               (else
                 (format t "Initial solution was optimum!~%")))

               )))
     #+END_SRC
**** a33 problem
***** exhaustive search (best/first/random improvement)
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((p1 a-n65-k9-problem)
             (s1 (make-initial-solution-for-cvrp-deterministic p1))
             (best-solution-exhaustive nil)
             (action (delta-cvrp-action*))
             (results nil)

             (max-iterations 1000)
             (no-of-jumps 4)

             (cvrp-action (basic-cvrp-action))
             )


            (bformat t "Testing DNS with a-n33-k6")

            ;; first we compute the cost of the solution
            (simulate-solution s1 p1 cvrp-action)
            (setf (cost s1) (+ (total-distance cvrp-action)
                               (total-penalty cvrp-action)))

            (format t "Original solution (with cost ~a):~%"
                    (cost s1))
            (pp-solution s1 t)

            (time
             (setf results (vns-code
                            p1 s1
                            (list rabs*     ;1
                                  rarbs*   ;2
                                  raracs*   ;3
                                  refs*     ;4
                                  reregs*   ;5
                                  rehfs*    ;6
                                  rerfs*    ;7
                                  rehrfs*   ;8
                                  rerehgs*  ;9
                                  rehregs*  ;10
                                  rehrehgs* ;11
                                  )
                            ;; :inner-search-max-iter max-iterations
                            :action action
                            :max-iter max-iterations
                            :selection-strategy
                            ;; (random-improvement-smart 0.5 )
                            ,*random-improvement-with-candidates*
                            ;; +first-improvement+
                            :search-strategy *exhaustive-search-strategy*)))


            (format t "Iterations: ~a. Optimum found ~a.~%"
                    (second results) (third results))

            (setf best-solution-exhaustive (first results))

            (if best-solution-exhaustive
                (then
                  (format t "Best value through: ~a~%"
                          (cost best-solution-exhaustive))
                  (format t "Best neighbor:~%")
                  (pp-solution best-solution-exhaustive t)

                  (simulate-solution best-solution-exhaustive p1 cvrp-action)

                  (setf best-solution-exhaustive (first results))
                  (format t "Best value through Yoel's: ~a~%"
                          (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))
                  )

                (else
                  (format t "Initial solution was optimum!~%")))



            )
      #+END_SRC
***** testing the smart* version of the criteria
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((p1 a-n65-k9-problem)
             (s1 (make-initial-solution-for-cvrp-deterministic p1))
             (best-solution-exhaustive nil)
             (action (delta-cvrp-action))
             (results nil)

             (max-iterations 1000)
             ;; (no-of-jumps 4)

             (cvrp-action (basic-cvrp-action))
             )


            (bformat t "Testing DNS with a-n33-k6")

            ;; first we compute the cost of the solution
            (simulate-solution s1 p1 cvrp-action)
            (setf (cost s1) (+ (total-distance cvrp-action)
                               (total-penalty cvrp-action)))

            (format t "Original solution (with cost ~a):~%"
                    (cost s1))
            (pp-solution s1 t)

            ;; (time
            ;;  (setf results (vns-code
            ;;                 p1 s1
            ;;                 (list rab         ;1
            ;;                       rarb        ;2
            ;;                       rarac       ;3
            ;;                       ref     ;4
            ;;                       rereg   ;5
            ;;                       rerf    ;6
            ;;                       rehf    ;7
            ;;                       rehrf   ;8
            ;;                       )
            ;;                 ;; :inner-search-max-iter max-iterations
            ;;                 :action action
            ;;                 :max-iter max-iterations
            ;;                 :selection-strategy +best-improvement+
            ;;                 ;; :shake-search (jump-around-search-strategy no-of-jumps)
            ;;                 :search-strategy +exhaustive-search-strategy+)))

            (time
             (setf results (vns-code
                            p1 s1
                            (list
                             rabs             ;0
                             rarbs            ;1
                             raracs           ;2
                             refs             ;3
                             rerfs            ;4
                             rehfs            ;5
                             rehrfs           ;6
                             reregs           ;7
                             rehrfs           ;8
                             rerehgs          ;9
                             rehregs          ;10
                             rehrehgs          ;11
                             )
                            ;; :inner-search-max-iter max-iterations
                            :action action
                            :max-iter max-iterations
                            :selection-strategy +best-improvement+
                            ;; :shake-search (jump-around-search-strategy no-of-jumps)
                            :search-strategy +exhaustive-search-strategy+)))


            (format t "Iterations: ~a. Optimum found ~a.~%"
                    (second results) (third results))

            (setf best-solution-exhaustive (first results))

            (if best-solution-exhaustive
                (then
                  (format t "Best value through: ~a~%"
                          (cost best-solution-exhaustive))
                  (format t "Best neighbor:~%")
                  (pp-solution best-solution-exhaustive t)

                  (simulate-solution best-solution-exhaustive p1 cvrp-action)

                  (setf best-solution-exhaustive (first results))
                  (format t "Best value through Yoel's: ~a~%"
                          (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))
                  )

                (else
                  (format t "Initial solution was optimum!~%")))



            )
      #+END_SRC
***** testing the * macros
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((p1 a-n65-k9-problem)
             (s1 (make-initial-solution-for-cvrp-deterministic p1))
             (best-solution-exhaustive nil)
             (action (delta-cvrp-action*))
             (results nil)

             (max-iterations 1000)
             ;; (no-of-jumps 4)

             (cvrp-action (basic-cvrp-action))
             )


            (bformat t "Testing DNS with a-n33-k6")

            ;; first we compute the cost of the solution
            (simulate-solution s1 p1 cvrp-action)
            (setf (cost s1) (+ (total-distance cvrp-action)
                               (total-penalty cvrp-action)))

            (format t "Original solution (with cost ~a):~%"
                    (cost s1))
            (pp-solution s1 t)

            (time
             (setf results (vns-code
                            p1 s1
                            (list
                             rabs*            ;0
                             rarbs*           ;1
                             raracs*          ;2
                             refs*             ;3
                             rerfs*            ;4
                             rehfs*            ;5
                             rehrfs*           ;6
                             reregs*           ;7
                             rehrfs*           ;8
                             rerehgs*          ;9
                             rehregs*          ;10
                             rehrehgs*         ;11
                             )
                            ;; :inner-search-max-iter max-iterations
                            :action action
                            :max-iter max-iterations
                            :selection-strategy *random-improvement*
                            ;; :shake-search (jump-around-search-strategy no-of-jumps)
                            :search-strategy *exhaustive-search-strategy*)))


            (format t "Iterations: ~a. Optimum found ~a.~%"
                    (second results) (third results))

            (setf best-solution-exhaustive (first results))

            (if best-solution-exhaustive
                (then
                  (format t "Best value through: ~a~%"
                          (cost best-solution-exhaustive))
                  (format t "Best neighbor:~%")
                  (pp-solution best-solution-exhaustive t)

                  (simulate-solution best-solution-exhaustive p1 cvrp-action)

                  (setf best-solution-exhaustive (first results))
                  (format t "Best value through Yoel's: ~a~%"
                          (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))
                  )

                (else
                  (format t "Initial solution was optimum!~%")))



            )
      #+END_SRC

***** testing the * macros a-n80-k10
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((p1 a-n80-k10-problem)
             (s1 (make-initial-solution-for-cvrp-deterministic p1))
             (best-solution-exhaustive nil)
             (action (delta-cvrp-action*))
             (results nil)

             (max-iterations 1000)
             ;; (no-of-jumps 4)

             (cvrp-action (basic-cvrp-action))
             )


            (bformat t "Testing DNS with a-n33-k6")

            ;; first we compute the cost of the solution
            (simulate-solution s1 p1 cvrp-action)
            (setf (cost s1) (+ (total-distance cvrp-action)
                               (total-penalty cvrp-action)))

            (format t "Original solution (with cost ~a):~%"
                    (cost s1))
            (pp-solution s1 t)

            (time
             (setf results (vns-code
                            p1 s1
                            (list
                             rabs*            ;0
                             rarbs*           ;1
                             raracs*          ;2
                             refs*             ;3
                             rerfs*            ;4
                             rehfs*            ;5
                             rehrfs*           ;6
                             reregs*           ;7
                             rehrfs*           ;8
                             rerehgs*          ;9
                             rehregs*          ;10
                             rehrehgs*         ;11
                             )
                            ;; :inner-search-max-iter max-iterations
                            :action action
                            :max-iter 1000
                            :selection-strategy *random-improvement*
                            :search-strategy *exhaustive-search-strategy*)))


            (format t "Iterations: ~a. Optimum found ~a.~%"
                    (second results) (third results))

            (setf best-solution-exhaustive (first results))

            (if best-solution-exhaustive
                (then
                  (format t "Best value through: ~a~%"
                          (cost best-solution-exhaustive))
                  (format t "Best neighbor:~%")
                  (pp-solution best-solution-exhaustive t)

                  (simulate-solution best-solution-exhaustive p1 cvrp-action)

                  (setf best-solution-exhaustive (first results))
                  (format t "Best value through Yoel's: ~a~%"
                          (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))
                  )

                (else
                  (format t "Initial solution was optimum!~%")))



            )
      #+END_SRC

** TODO receiving the criteria as a list of functions no output
*** description
    The main characteristic of this implementation is that the criteria are a list of functions.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp
   (defun vns-fn-no-output
       (problem solution criteria
        &key max-iter action)
     "Solves the VRP problem using a VNS with the given criterion starting with the given solution. We assume that the initial solution has the cost slot bound. If the result is nil, then the initial solution is an optimum for that neighboorhood."

     (let* ((current-index 0)
            (number-of-criteria (length criteria))
            (current-criterion nil)
            (better-solution nil)
            (current-solution solution)
            (neighboorhoods-used 1)
            )

       (loop while (and (< current-index number-of-criteria)
                        (<= neighboorhoods-used max-iter))

             ;; let's set the current criterion
             do (setf current-criterion
                      (nth current-index criteria))

             ;; let's explore with the current criteria


             do (setf better-solution
                      (funcall current-criterion
                               current-solution problem action))

             do (if better-solution
                    (then 
                      ;; we found a better solution
                      ;; update the current-solution
                      (setf current-solution better-solution)
                      ;; set the number-of-criteria to 0
                      (setf current-index 0))
                    (else
                      ;; use the next criterion
                     (incf current-index)))
             ;; in any case, increment the number of
             ;; neighboorhoods-used
             do (incf neighboorhoods-used))

       ;; finally return the current solution
       ;; if it is nil, then the initial solution is an optimum
       (list current-solution
             neighboorhoods-used
             (<= neighboorhoods-used max-iter))))
       #+END_SRC
   
*** tests
**** rarac (best-improvement)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                                         :demands '(10 10 15 40 20)
                                         :capacity 40)
       (with-basic-cvrp-solution (s1 ((2 4 5) (3) (1)) p1)
         (let* ((best-solution-exhaustive nil)
                (action (delta-cvrp-action))
                (results nil)
                (cvrp-action (basic-cvrp-action 
                              :penalty-factor 1000)))

           (bformat t "Testing VNS")

           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (setf results (vns-fn-no-output 
                          p1 s1 (list rab-best
                                      rarb-best
                                      rarac-best)
                          :max-iter 150
                          :action action))

           (format t "Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))      
           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through exhaustive: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor through exhaustive search:~%")
                 (pp-solution best-solution-exhaustive t)

                 ;; (format t "Best value through Yoel's: ~a~%"
                 ;;         (solution-cost best-solution-exhaustive
                 ;;                        p1 cvrp-action))
                 ;; (format t "action: ~a~%" cvrp-action)
                 )

               (else
                 (format t "Initial solution was optimum!~%")))

               )))
     #+END_SRC
**** a33 problem
***** exhaustive search (best/first/random improvement)
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((p1 a-n33-k6-problem)
             (s1 (make-initial-solution-for-cvrp-deterministic p1))
             (best-solution-exhaustive nil)
             (action (delta-cvrp-action))
             (results nil)

             ;(selection-strategy +first-improvement+)
             (selection-strategy +random-improvement+)
             ;(selection-strategy +best-improvement+)
             (max-iterations 550)

             (cvrp-action (basic-cvrp-action))
             )


            (bformat t "Testing DNS with a-n33-k6")

            ;; first we compute the cost of the solution
            (simulate-solution s1 p1 cvrp-action)
            (setf (cost s1) (+ (total-distance cvrp-action)
                               (total-penalty cvrp-action)))

            (format t "Original solution (with cost ~a):~%"
                    (cost s1))
            (pp-solution s1 t)

            (setf results (vns-fn-no-output
                           p1 s1
                           (list rab-random
                                 rehrf-random
                                 rarac-random
                                 ref-random
                                 rereg-random
                                 rerf-random
                                 rehf-random
                                 rarb-random
                                 )
                           :max-iter max-iterations
                           :action action))

            (format t "Iterations: ~a. Optimum found ~a.~%"
                    (second results) (third results))

            (setf best-solution-exhaustive (first results))

            (if best-solution-exhaustive
                (then
                  (format t "Best value through ~a: ~a~%"
                          selection-strategy
                          (cost best-solution-exhaustive))
                  (format t "Best neighbor through ~a:~%"
                          selection-strategy)
                  (pp-solution best-solution-exhaustive t)

                  (simulate-solution best-solution-exhaustive p1 cvrp-action)

                  (setf best-solution-exhaustive (first results))
                  (format t "Best value through Yoel's: ~a~%"
                          (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))
                  )

                (else
                  (format t "Initial solution was optimum!~%")))



            )
      #+END_SRC
***** TODO random search (best/first/random improvement)
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((p1 a-n33-k6-problem)
             (s1 (make-initial-solution-for-cvrp-deterministic p1))
             (best-solution-exhaustive nil)
             (action (delta-cvrp-action))
             (results nil)

             ;(search-strategy +exhaustive-search-strategy+)
             (search-strategy (random-neighborhood-search-strategy 100))

             (selection-strategy +first-improvement+)
             ;(selection-strategy +random-improvement+)
             ;(selection-strategy +best-improvement+)
             (max-iterations 550)

             (rarac-r-ex (make-neighborhood-criterion
                          rarac-description
                          search-strategy
                          selection-strategy))

             (rab-r-ex (make-neighborhood-criterion
                        rab-description
                        search-strategy
                        selection-strategy))

             (rereg-r-ex (make-neighborhood-criterion
                          rereg-description
                          search-strategy
                          selection-strategy))


             (cvrp-action (basic-cvrp-action))
             )


            (bformat t "Testing DNS with a-n33-k6")

            ;; first we compute the cost of the solution
            (simulate-solution s1 p1 cvrp-action)
            (setf (cost s1) (+ (total-distance cvrp-action)
                               (total-penalty cvrp-action)))

            (format t "Original solution (with cost ~a):~%"
                    (cost s1))
            (pp-solution s1 t)

            (setf results (vns
                           p1 s1
                           (list
                            rarac-r-ex
                            rab-r-ex
                            rereg-r-ex
                                 )
                           :max-iter max-iterations
                           :action action))

            (format t "Iterations: ~a. Optimum found ~a.~%"
                    (second results) (third results))

            (setf best-solution-exhaustive (first results))

            (if best-solution-exhaustive
                (then
                  (format t "Best value through ~a: ~a~%"
                          selection-strategy
                          (cost best-solution-exhaustive))
                  (format t "Best neighbor through ~a:~%"
                          selection-strategy)
                  (pp-solution best-solution-exhaustive t)

                  (simulate-solution best-solution-exhaustive p1 cvrp-action)

                  (setf best-solution-exhaustive (first results))
                  (format t "Best value through Yoel's: ~a~%"
                          (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))
                  )

                (else
                  (format t "Initial solution was optimum!~%")))



            )
      #+END_SRC
** TODO receiving the criteria as a list of descriptions no output
*** description
    The main characteristic of this implementation is that the criteria passed as a list of descriptions and the algorithm can choose the strategy to explore the neighborhood with.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp
   ;; Variable Neighboorhood Search
   (defun vns-code-no-output
       (problem solution criteria
        &key
          (search-strategy +exhaustive-search-strategy+)
          (selection-strategy +random-improvement+)
          max-iter action (print-mod 1))
     "Solves the VRP problem using a VNS with the given criterion starting with the given solution. We assume that the initial solution has the cost slot bound. If the result is nil, then the initial solution is an optimum for that neighboorhood."
     (declare (ignore print-mod))

     (let* ((current-index 0)
            (number-of-criteria (length criteria))
            ;; ;; this is to make only one call to
            ;; make-neighborhood-criterion
            (criteria-as-functions (mapcar (lambda (x)
                                             (make-neighborhood-criterion
                                              x
                                              search-strategy
                                              selection-strategy))
                                           criteria))
            (current-criterion nil)
            (better-solution nil)
            (current-solution solution)
            (neighboorhoods-used 1)



            )

       (loop while (and (< current-index number-of-criteria)
                        (<= neighboorhoods-used max-iter))

             ;; let's set the current-criterion
             do (setf current-criterion (nth current-index
                                             criteria-as-functions))


             ;; let's explore with the current criteria

             do (setf better-solution
                      (funcall current-criterion
                               current-solution problem action))

             do (if better-solution
                    (then 
                      ;; we found a better solution
                      ;; update the current-solution
                      (setf current-solution better-solution)
                      ;; set the number-of-criteria to 0
                      (setf current-index 0))
                    (else
                      ;; use the next criterion
                      (incf current-index)))
             ;; in any case, increment the number of
             ;; neighboorhoods-used
             do (incf neighboorhoods-used)

             )
       ;; finally return the current solution
       ;; if it is nil, then the initial solution is an optimum
       (list current-solution
             neighboorhoods-used
             (<= neighboorhoods-used max-iter))))
       #+END_SRC
   
*** tests
**** testing add route
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                                         :demands '(10 10 15 40 20)
                                         :capacity 40)
       (with-basic-cvrp-solution (s1 ((1 2 3 4 5)) p1)
         (let* ((best-solution-exhaustive nil)
                (action (delta-cvrp-action))
                (results nil)
                (cvrp-action (basic-cvrp-action 
                              :penalty-factor 1000))
                )

           (bformat t "Testing VNS with add-route")


           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (get-cost-from-action cvrp-action))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (setf results (vns-code-no-output 
                          p1 s1 (list
                                 rab   ; 0
                                 rarb  ; 1
                                 rarac ; 2
                                 rad   ; 3   
                                 )
                          :max-iter 150
                          :action action
                          :selection-strategy +best-improvement+))

           (format t "Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))      
           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through exhaustive: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor through exhaustive search:~%")
                 (pp-solution best-solution-exhaustive t)

                 ;; (format t "Best value through Yoel's: ~a~%"
                 ;;         (solution-cost best-solution-exhaustive
                 ;;                        p1 cvrp-action))
                 ;; (format t "action: ~a~%" cvrp-action)
                 )

               (else
                 (format t "Initial solution was optimum!~%")))

               )))
     #+END_SRC
**** a33 problem
***** exhaustive search (best/first/random improvement)
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((p1 a-n33-k6-problem)
             (s1 (make-initial-solution-for-cvrp-deterministic p1))
             (best-solution-exhaustive nil)
             (action (delta-cvrp-action*))
             (results nil)

             (max-iterations 1000)
             (no-of-jumps 4)

             (cvrp-action (basic-cvrp-action))
             )


            (bformat t "Testing DNS with a-n33-k6")

            ;; first we compute the cost of the solution
            (simulate-solution s1 p1 cvrp-action)
            (setf (cost s1) (+ (total-distance cvrp-action)
                               (total-penalty cvrp-action)))

            (format t "Original solution (with cost ~a):~%"
                    (cost s1))
            (pp-solution s1 t)

            (time
             (setf results (vns-code-no-output
                            p1 s1
                            (list rabs*     ;1
                                  rarbs*   ;2
                                  raracs*   ;3
                                  refs*     ;4
                                  reregs*   ;5
                                  rehfs*    ;6
                                  rerfs*    ;7
                                  rehrfs*   ;8
                                  rerehgs*  ;9
                                  rehregs*  ;10
                                  rehrehgs* ;11
                                  )
                            ;; :inner-search-max-iter max-iterations
                            :action action
                            :max-iter max-iterations
                            :selection-strategy
                            ;; (random-improvement-smart 0.5 )
                            ,*random-improvement*
                            ;; +first-improvement+
                            :search-strategy *exhaustive-search-strategy*)))


            (format t "Iterations: ~a. Optimum found ~a.~%"
                    (second results) (third results))

            (setf best-solution-exhaustive (first results))

            (if best-solution-exhaustive
                (then
                  (format t "Best value through: ~a~%"
                          (cost best-solution-exhaustive))
                  (format t "Best neighbor:~%")
                  (pp-solution best-solution-exhaustive t)

                  (simulate-solution best-solution-exhaustive p1 cvrp-action)

                  (setf best-solution-exhaustive (first results))
                  (format t "Best value through Yoel's: ~a~%"
                          (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))
                  )

                (else
                  (format t "Initial solution was optimum!~%")))



            )
      #+END_SRC
** TODO receiving the criteria as a list of descriptions with bar
*** description
    In this implementation we pass the criteria as a list of descriptions and the algorithm can choose the strategy to explore the neighborhood with.

    We also only output very little information.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp
   ;; Variable Neighboorhood Search
   (defun vns-code-bar
       (problem solution criteria
        &key
          (search-strategy +exhaustive-search-strategy+)
          (selection-strategy +random-improvement+)
          max-iter action (print-mod 1)
          (dots-canvas 20))
     "Solves the VRP problem using a VNS with the given criterion starting with the given solution. We assume that the initial solution has the cost slot bound. If the result is nil, then the initial solution is an optimum for that neighboorhood."
     (declare (ignore print-mod))

     (let* ((current-index 0)
            (number-of-criteria (length criteria))
                     ;; ;; this is to make only one call to
            ;; make-neighborhood-criterion
            (criteria-as-functions (mapcar (lambda (x)
                                             (make-neighborhood-criterion
                                              x
                                              search-strategy
                                              selection-strategy))
                                           criteria))
            (current-criterion nil)
            (better-solution nil)
            (current-solution solution)
            (neighboorhoods-used 1)
            ;; (progress-bar-increment (round (/ max-iter dots-canvas)))
            (progress-bar-increment (round dots-canvas))
            )

       ;; this is for the progress-bar
       (format t "     Running VNS ")

       (loop while (and (< current-index number-of-criteria)
                        (<= neighboorhoods-used max-iter))

             ;; let's build the criterion
             do (setf current-criterion (nth current-index
                                             criteria-as-functions))


             ;; let's explore with the current criteria

             do (setf better-solution
                      (funcall current-criterion
                               current-solution problem action))

             do (if better-solution
                    (then 
                      ;; we found a better solution
                      ;; update the current-solution
                      (setf current-solution better-solution)
                      ;; set the number-of-criteria to 0
                      (setf current-index 0))
                    (else
                      ;; use the next criterion
                      (incf current-index)))

             ;; in any case, increment the number of neighboorhoods-used
             do (incf neighboorhoods-used)

             ;; display the dots line
             do (if (= (mod neighboorhoods-used progress-bar-increment) 0)
                    (format t "."))
             )
       ;; here we just finished the iterations

       ;; finally return the current solution
       ;; if it is nil, then the initial solution is an optimum
       (list current-solution
             neighboorhoods-used
             (<= neighboorhoods-used max-iter))))
       #+END_SRC
   
*** tests
**** testing add route
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                                         :demands '(10 10 15 40 20)
                                         :capacity 40)
       (with-basic-cvrp-solution (s1 ((1 2 3 4 5)) p1)
         (let* ((best-solution-exhaustive nil)
                (action (delta-cvrp-action))
                (results nil)
                (cvrp-action (basic-cvrp-action 
                              :penalty-factor 1000))
                )

           (bformat t "Testing VNS with add-route")


           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (get-cost-from-action cvrp-action))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (setf results (vns-shake 
                          p1 s1 (list
                                 rab   ; 0
                                 rarb  ; 1
                                 rarac ; 2
                                 rad   ; 3   
                                 )
                          :max-iter 150
                          :action action
                          :selection-strategy +best-improvement+))

           (format t "Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))      
           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through exhaustive: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor through exhaustive search:~%")
                 (pp-solution best-solution-exhaustive t)

                 ;; (format t "Best value through Yoel's: ~a~%"
                 ;;         (solution-cost best-solution-exhaustive
                 ;;                        p1 cvrp-action))
                 ;; (format t "action: ~a~%" cvrp-action)
                 )

               (else
                 (format t "Initial solution was optimum!~%")))

               )))
     #+END_SRC
**** a33 problem
***** exhaustive search (best/first/random improvement)
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((p1 a-n33-k6-problem)
             (s1 (make-initial-solution-for-cvrp-deterministic p1))
             (best-solution-exhaustive nil)
             (action (delta-cvrp-action*))
             (results nil)

             (max-iterations 1000)
             ;; (no-of-jumps 4)

             (cvrp-action (basic-cvrp-action))
             )


            (bformat t "Testing DNS with a-n33-k6")

            ;; first we compute the cost of the solution
            (simulate-solution s1 p1 cvrp-action)
            (setf (cost s1) (+ (total-distance cvrp-action)
                               (total-penalty cvrp-action)))

            (format t "Original solution (with cost ~a):~%"
                    (cost s1))
            (pp-solution s1 t)

            (setf results (vns-code-bar
                           p1 s1
                           (list
                            rabs*             ;0
                            rarbs*            ;1
                            raracs*           ;2
                            refs*             ;3
                            rerfs*            ;4
                            rehfs*            ;5
                            rehrfs*           ;6
                            reregs*           ;7
                            rehrfs*           ;8
                            rerehgs*          ;9
                            rehregs*          ;10
                            rehrehgs*         ;11
                            )
                           :max-iter max-iterations
                           :action action
                           :selection-strategy *first-improvement*
                           ;; :shake-search (jump-around-search-strategy no-of-jumps)
                           :search-strategy *exhaustive-search-strategy*))


            (format t "~%Iterations: ~a. Optimum found ~a.~%"
                    (second results) (third results))

            (setf best-solution-exhaustive (first results))

            (if best-solution-exhaustive
                (then
                  (format t "Best value through: ~a~%"
                          (cost best-solution-exhaustive))
                  (format t "Best neighbor:~%")
                  (pp-solution best-solution-exhaustive t)

                  (simulate-solution best-solution-exhaustive p1 cvrp-action)

                  (setf best-solution-exhaustive (first results))
                  (format t "Best value through Yoel's: ~a~%"
                          (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))
                  )

                (else
                  (format t "Initial solution was optimum!~%")))



            )
      #+END_SRC
**** a33 problem with random-improvement (no candidates)
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n33-k6-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (results nil)

            (max-iterations 1000)
            ;; (no-of-jumps 4)

            (cvrp-action (basic-cvrp-action))
            )


           (bformat t "Testing DNS with a-n33-k6")

           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (setf results (vns-code-bar
                          p1 s1
                          (list
                           rabs*             ;0
                           rarbs*            ;1
                           raracs*           ;2
                           refs*             ;3
                           rerfs*            ;4
                           rehfs*            ;5
                           rehrfs*           ;6
                           reregs*           ;7
                           rehrfs*           ;8
                           rerehgs*          ;9
                           rehregs*          ;10
                           rehrehgs*         ;11
                           )
                          :max-iter max-iterations
                          :action action
                          :selection-strategy +first-improvement+
                          :search-strategy +exhaustive-search-strategy+))


           (format t "~%Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor:~%")
                 (pp-solution best-solution-exhaustive t)

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)

                 (setf best-solution-exhaustive (first results))
                 (format t "Best value through Yoel's: ~a~%"
                         (+ (total-distance cvrp-action)
                            (total-penalty cvrp-action)))
                 )

               (else
                 (format t "Initial solution was optimum!~%")))



           )
     #+END_SRC
**** tiny problem with end-depot
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (c1 (basic-cvrp-client 1 30))
             (c2 (basic-cvrp-client 2 20))
             (c3 (basic-cvrp-client 3 40))
             (c4 (basic-cvrp-client 4 50))
             (d0 (basic-depot))
             (d1 (basic-depot 5))
             (v1 (cvrp-vehicle 1 70))
             (v2 (cvrp-vehicle 2 70))

             (distance #2A ((0 1 2 3 5 6)
                            (1 0 4 5 6 7)
                            (2 4 0 6 7 9)
                            (3 5 6 0 8 9)
                            (5 6 7 8 0 1)
                            (3 5 6 4 8 0)))
             (p1 (make-instance 'finite-fleet-end-depot-cvrp-problem
                                :depot d0
                                :end-depot d1
                                :id 1
                                :clients (list c1 c2 c3 c4)
                                :fleet (list v1 v2)
                                :distance-matrix distance))

             ;; now the algorithms related data
             (best-solution-exhaustive nil)
             (action (delta-cvrp-action))
             (results nil)
             (cvrp-action (basic-cvrp-action 
                           :penalty-factor 1000))
             (criterion-code `((select-route r1)
                               (select-client c1 from r1)
                               (select-route r2)
                               (insert-client c1 into r2)))

             (neighborhood-exploration
              (make-neighborhood-criterion
               criterion-code
               +exhaustive-search-strategy+
               +best-improvement+))

             (results nil)
             (max-iterations 1000)

             (*vrp-logging* 0))

        (bformat t "Testing VNS with end-depot")

        (with-finite-fleet-end-depot-cvrp-solution (s1 ((1 1 2) (2 3 4)) p1)

          ;; first we compute the cost of the solution
          (simulate-solution s1 p1 cvrp-action)
          (setf (cost s1) (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))

          (format t "Original solution (with cost ~a):~%"
                  (cost s1))
          (pp-solution s1 t)

          (setf results (vns-code-bar
                           p1 s1
                           (list
                            rabs*             ;0
                            rarbs*            ;1
                            raracs*           ;2
                            refs*             ;3
                            rerfs*            ;4
                            rehfs*            ;5
                            rehrfs*           ;6
                            reregs*           ;7
                            rehrfs*           ;8
                            rerehgs*          ;9
                            rehregs*          ;10
                            rehrehgs*         ;11
                            )
                           :max-iter max-iterations
                           :action action
                           :selection-strategy *first-improvement*
                           ;; :shake-search (jump-around-search-strategy no-of-jumps)
                           :search-strategy *exhaustive-search-strategy*))

          (format t "~%Iterations: ~a. Optimum found ~a.~%"
                    (second results) (third results))

          (setf best-solution-exhaustive (first results))

          (if best-solution-exhaustive
                (then
                  (format t "Best value through: ~a~%"
                          (cost best-solution-exhaustive))
                  (format t "Best neighbor:~%")
                  (pp-solution best-solution-exhaustive t)

                  (simulate-solution best-solution-exhaustive p1 cvrp-action)

                  (setf best-solution-exhaustive (first results))
                  (format t "Best value through Yoel's: ~a~%"
                          (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))
                  )

                (else
                  (format t "Initial solution was optimum!~%")))


          ))
      #+END_SRC
** TODO receiving the criteria as a list of functions with bar
*** description
    The main characteristic of this implementation is that the criteria are a list of functions.

    We also only output very little information: only a dotted progress-bar.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp
   ;; Variable Neighboorhood Search
   (defun vns-fn-bar
       (problem solution criteria
        &key
          max-iter action (print-mod 1)
          (dots-canvas 20))
     "Solves the VRP problem using a VNS with the given criterion starting with the given solution. We assume that the initial solution has the cost slot bound. If the result is nil, then the initial solution is an optimum for that neighboorhood."
     (declare (ignore print-mod))

     (let* ((current-index 0)
            (number-of-criteria (length criteria))
            (current-criterion nil)
            (better-solution nil)
            (current-solution solution)
            (neighboorhoods-used 1)
            ;; (progress-bar-increment (round (/ max-iter dots-canvas)))
            (progress-bar-increment (round dots-canvas))
            )

       ;; this is for the progress-bar
       (format t "     Running VNS ")

       (loop while (and (< current-index number-of-criteria)
                        (<= neighboorhoods-used max-iter))

             ;; let's build the criterion
             do (setf current-criterion (nth current-index
                                             criteria))


             ;; let's explore with the current criteria

             do (setf better-solution
                      (funcall current-criterion
                               current-solution problem action))

             do (if better-solution
                    (then 
                      ;; we found a better solution
                      ;; update the current-solution
                      (setf current-solution better-solution)
                      ;; set the number-of-criteria to 0
                      (setf current-index 0))
                    (else
                      ;; use the next criterion
                      (incf current-index)))

             ;; in any case, increment the number of neighboorhoods-used
             do (incf neighboorhoods-used)

             ;; display the dots line
             do (if (= (mod neighboorhoods-used progress-bar-increment) 0)
                    (format t "."))
             )
       ;; here we just finished the iterations

       ;; finally return the current solution
       ;; if it is nil, then the initial solution is an optimum
       (list current-solution
             neighboorhoods-used
             (<= neighboorhoods-used max-iter))))
       #+END_SRC
*** tests
**** a33 problem
***** exhaustive search (best/first/random improvement)
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((p1 a-n33-k6-problem)
             (s1 (make-initial-solution-for-cvrp-deterministic p1))
             (best-solution-exhaustive nil)
             (action (delta-cvrp-action*))
             (results nil)

             (max-iterations 1000)
             ;; (no-of-jumps 4)

             (cvrp-action (basic-cvrp-action))
             )


            (bformat t "Testing DNS with a-n33-k6")

            ;; first we compute the cost of the solution
            (simulate-solution s1 p1 cvrp-action)
            (setf (cost s1) (get-cost-from-action cvrp-action))

            (format t "Original solution (with cost ~a):~%"
                    (cost s1))
            (pp-solution s1 t)

            (setf results (vns-fn-bar 
                           p1 s1
                           (mapcar (lambda (x)
                                     (make-neighborhood-criterion
                                      x
                                      ,*exhaustive-search-strategy*
                                      ,*random-improvement*
                                      ))
                            (list
                             rabs*            ;0
                             rarbs*           ;1
                             raracs*          ;2
                             refs*            ;3
                             rerfs*           ;4
                             rehfs*           ;5
                             rehrfs*          ;6
                             reregs*          ;7
                             rehrfs*          ;8
                             rerehgs*         ;9
                             rehregs*         ;10
                             rehrehgs*        ;11
                             ))
                           :max-iter max-iterations 
                           :action action))


            (format t "~%Iterations: ~a. Optimum found ~a.~%"
                    (second results) (third results))

            (setf best-solution-exhaustive (first results))

            (if best-solution-exhaustive
                (then
                  (format t "Best value through: ~a~%"
                          (cost best-solution-exhaustive))
                  (format t "Best neighbor:~%")
                  (pp-solution best-solution-exhaustive t)

                  (simulate-solution best-solution-exhaustive p1 cvrp-action)

                  (setf best-solution-exhaustive (first results))
                  (format t "Best value through Yoel's: ~a~%"
                          (get-cost-from-action cvrp-action))
                  )

                (else
                  (format t "Initial solution was optimum!~%")))

            (format t "length delta-distance-stack: ~a~%"
                    (length (delta-distance-stack action )))
            (format t "length total-penalty: ~a~%"
                    (length (total-penalty-stack action )))

            )
      #+END_SRC
**** a-n80-k10 problem
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n80-k10-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (results nil)

            (max-iterations 1000)
            ;; (no-of-jumps 4)

            (cvrp-action (basic-cvrp-action))
            )


           (bformat t "Testing DNS with a-n33-k6")

           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (get-cost-from-action cvrp-action))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (setf results (vns-fn-bar 
                          p1 s1
                          (mapcar (lambda (x)
                                    (make-neighborhood-criterion
                                     x
                                     ,*exhaustive-search-strategy*
                                     ,*random-improvement*
                                     ))
                           (list
                            rabs*            ;0
                            rarbs*           ;1
                            raracs*          ;2
                            refs*            ;3
                            rerfs*           ;4
                            rehfs*           ;5
                            rehrfs*          ;6
                            reregs*          ;7
                            rehrfs*          ;8
                            rerehgs*         ;9
                            rehregs*         ;10
                            rehrehgs*        ;11
                            ))
                          :max-iter max-iterations 
                          :action action))


           (format t "~%Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor:~%")
                 (pp-solution best-solution-exhaustive t)

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)

                 (setf best-solution-exhaustive (first results))
                 (format t "Best value through Yoel's: ~a~%"
                         (get-cost-from-action cvrp-action))
                 )

               (else
                 (format t "Initial solution was optimum!~%")))

           (format t "length delta-distance-stack: ~a~%"
                   (length (delta-distance-stack action )))
           (format t "length total-penalty: ~a~%"
                   (length (total-penalty-stack action )))

           )
     #+END_SRC
**** a-n80-k10 problem
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 ff-a-n33-k6-problem)
            (s1 (make-initial-solution-for-finite-fleet-cvrp-deterministic
                 p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (results nil)

            (max-iterations 1000)
            ;; (no-of-jumps 4)

            (cvrp-action (basic-cvrp-action))
            )


           (bformat t "Testing DNS with a-n33-k6")

           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (get-cost-from-action cvrp-action))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (setf results (vns-fn-bar 
                          p1 s1
                          (mapcar (lambda (x)
                                    (make-neighborhood-criterion
                                     x
                                     ,*exhaustive-search-strategy*
                                     ,*random-improvement*
                                     ))
                           (list
                            rabs*            ;0
                            rarbs*           ;1
                            raracs*          ;2
                            refs*            ;3
                            rerfs*           ;4
                            rehfs*           ;5
                            rehrfs*          ;6
                            reregs*          ;7
                            rehrfs*          ;8
                            rerehgs*         ;9
                            rehregs*         ;10
                            rehrehgs*        ;11
                            ))
                          :max-iter max-iterations 
                          :action action))


           (format t "~%Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor:~%")
                 (pp-solution best-solution-exhaustive t)

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)

                 (setf best-solution-exhaustive (first results))
                 (format t "Best value through Yoel's: ~a~%"
                         (get-cost-from-action cvrp-action))
                 )

               (else
                 (format t "Initial solution was optimum!~%")))

           (format t "length delta-distance-stack: ~a~%"
                   (length (delta-distance-stack action )))
           (format t "length total-penalty: ~a~%"
                   (length (total-penalty-stack action )))

           )
     #+END_SRC
** TODO criteria as a list of descriptions scrambling
*** description
    Everytime we set the counter to 0, we scramble the criteria list.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp
   ;; Variable Neighboorhood Search
   (defun vns-code-scrambling
       (problem solution criteria
        &key
          (search-strategy +exhaustive-search-strategy+)
          (selection-strategy +random-improvement+)
          max-iter action (print-mod 1))
     "Solves the VRP problem using a VNS with the given criterion starting with the given solution. We assume that the initial solution has the cost slot bound. If the result is nil, then the initial solution is an optimum for that neighboorhood."
     (declare (ignore print-mod))

     (let* ((current-index 0)
            (number-of-criteria (length criteria))
            ;; ;; this is to make only one call to
            ;; make-neighborhood-criterion
            (criteria-as-functions (loop for i from 1
                                         for x in criteria
                                         collecting
                                         (list i (make-neighborhood-criterion
                                                  x
                                                  search-strategy
                                                  selection-strategy))))
            (current-criterion nil)
            (better-solution nil)
            (current-solution solution)
            (neighboorhoods-used 1)
            )

       ;; first let's scramble the list
       (setf criteria-as-functions
             (scramble criteria-as-functions))

       (loop while (and (< current-index number-of-criteria)
                        (<= neighboorhoods-used max-iter))

             ;; let's set the current-criterion
             do (setf current-criterion (second
                                         (nth current-index
                                              criteria-as-functions)))


             ;; let's explore with the current criteria

             ;; for debugging purposes
             do (format t "Debug. Iteration ~4d, criterion ~2d (~2d/~2d)"
                        neighboorhoods-used
                        (first (nth current-index
                                    criteria-as-functions))
                        (1+ current-index)
                        number-of-criteria)

             do (setf better-solution
                      (funcall current-criterion
                               current-solution problem action))

             do (if better-solution
                    (then 
                      ;; we found a better solution
                      ;; update the current-solution
                      (setf current-solution better-solution)
                      ;; set the number-of-criteria to 0
                      (setf current-index 0)
                      ;; scramble the list with the criteria
                      (setf criteria-as-functions
                            (scramble criteria-as-functions))
                      )
                    (else
                      ;; use the next criterion
                      (incf current-index)))

             ;; ;; ;;{{{ for debugging purposes
             ;; do (format t "Debug inside VNS.  Iteration ~a, criterion ~a"
             ;;         neighboorhoods-used current-index)
             do (if better-solution
                    (then
                      (format t ", cost: ~a~%" (cost better-solution))
                      ;; (pp-solution better-solution t) (terpri)
                      )
                    (else
                      (format t ". Best solution found.~%")))
             ;; ;; ;; end of debug.

             ;; in any case, increment the number of neighboorhoods-used
             do (incf neighboorhoods-used)

             ;; ;; ;; for debugging purposes
             ;; (format t "At the end of the while: ~a, ~a~%"
             ;;         current-index number-of-criteria
             ;;         ;; (< current-index number-of-criteria)
             ;;         ;; (<= neighboorhoods-used max-iter)
             ;;         )
             ;; ;; ;; end of debugging purposes ;;}}}

             )
       ;; finally return the current solution
       ;; if it is nil, then the initial solution is an optimum
       (list current-solution
             neighboorhoods-used
             (<= neighboorhoods-used max-iter))))
       #+END_SRC
   
*** tests
**** testing a-n33-k6
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n33-k6-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (results nil)

            (max-iterations 1000)
            ;; (no-of-jumps 4)

            (cvrp-action (basic-cvrp-action)))



           (bformat t "Testing DNS with a-n33-k6")

           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (time
            (setf results (vns-code-scrambling
                           p1 s1
                           (list
                            rabs*            ;1
                            rarbs*           ;2
                            raracs*          ;3
                            refs*             ;4
                            rerfs*            ;5
                            rehfs*            ;6
                            rehrfs*           ;7
                            reregs*           ;8
                            rehrfs*           ;9
                            rerehgs*          ;10
                            rehregs*          ;11
                            rehrehgs*         ;12
                            )
                           ;; :inner-search-max-iter max-iterations
                           :action action
                           :max-iter max-iterations
                           :selection-strategy *random-improvement*
                           :search-strategy *exhaustive-search-strategy*)))


           (format t "Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor:~%")
                 (pp-solution best-solution-exhaustive t)

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)

                 (setf best-solution-exhaustive (first results))
                 (format t "Best value through Yoel's: ~a~%"
                         (+ (total-distance cvrp-action)
                            (total-penalty cvrp-action)))
                 )

               (else
                 (format t "Initial solution was optimum!~%")))



           )
     #+END_SRC

**** testing a-n80-k10
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n65-k9-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (results nil)

            (max-iterations 1000)
            ;; (no-of-jumps 4)

            (cvrp-action (basic-cvrp-action))
            )


           (bformat t "Testing DNS with a-n33-k6")

           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (time
            (setf results (vns-code-scrambling
                           p1 s1
                           (list
                            rabs*            ;1
                            rarbs*           ;2
                            raracs*          ;3
                            refs*            ;4
                            rerfs*           ;5
                            rehfs*           ;6
                            rehrfs*          ;7
                            reregs*          ;8
                            rehrfs*          ;9
                            rerehgs*         ;10
                            rehregs*         ;11
                            rehrehgs*        ;12
                            )
                           :action action
                           :max-iter max-iterations
                           :selection-strategy *random-improvement*
                           :search-strategy *exhaustive-search-strategy*)))


           (format t "Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor:~%")
                 (pp-solution best-solution-exhaustive t)

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)

                 (setf best-solution-exhaustive (first results))
                 (format t "Best value through Yoel's: ~a~%"
                         (+ (total-distance cvrp-action)
                            (total-penalty cvrp-action)))
                 )

               (else
                 (format t "Initial solution was optimum!~%")))



           )
     #+END_SRC
     

* VNS with shake operator
** description
   In this section, I'm going to add a Variable Neighboorhood Search with a shake operation.  A shake is a perturbation of the current solution to escape local minima.  This is the case where we have something like:

   #+BEGIN_EXAMPLE
   Function VNS(x, criteria, t_max);
     repeat
       k  1;
         repeat
           x'   Shake(x, k) /Shaking/;
           x''  FirstImprovement(x') /Local search/;
           NeighbourhoodChange(x, x'', k) /Change neighbourhood/;
         until k = number_of_criteria ;
       t  CpuTime()
     until stop-criteria-met
   #+END_EXAMPLE

   We can have several shaking strategies.  Maybe it can lead to some shaking strategies generation.

   We'll assume that the criteria are passed as pseudo-natural descriptions.
   
** receiving the criteria as a list of descriptions (bad shake)
*** description
    Here we add a shake step in the algorithm.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp
   ;; Variable Neighboorhood Search
   (defun vns-shake
       (problem solution criteria
        &key
          (descent-search-strategy +exhaustive-search-strategy+)
          (descent-selection-strategy +best-improvement+)
          (shake-search (jump-around-search-strategy 5))
          (shake-selection (jump-around-return-last-neighbor))
          (max-iter 100)
          action (print-mod 1))
     "Solves the VRP problem using a VNS with the given criterion starting with the given solution. We assume that the initial solution has the cost slot bound. If the result is nil, then the initial solution is an optimum for that neighboorhood."
     (declare (ignore print-mod))

     (let* ((current-index 0)
            (number-of-criteria (length criteria))
            (current-criterion-code nil)
            (current-criterion nil)
            (better-solution nil)
            (current-solution solution)
            (neighboorhoods-used 1)
            (x_prime nil)
            (initial-best-delta-cost 0)
            )

       (loop while (and (< current-index number-of-criteria)
                        (<= neighboorhoods-used max-iter))
             for better-solution-found-in-shake = nil 

             ;; let's set the current criterion
             do (setf current-criterion-code (nth current-index criteria))
             ;; let's build the criterion for shaking
             do (setf current-criterion
                      (make-neighborhood-criterion
                       current-criterion-code
                       shake-search
                       shake-selection))

             ;; let's shake the current solution
             ;; we expect two values because we also need
             ;; to know the initial-best-delta-cost
             ;; to pass it to the second step.
             do (setf (values x_prime initial-best-delta-cost)
                      (funcall current-criterion
                               current-solution problem action))

             ;; (format t "     x_prime? ~a~%" (not (null x_prime)))


             ;; for debugging purposes
             do (format t "Debug inside VNS.  Iteration ~a, criterion ~a.
        Best:    ~a
        Shaking: ~a~%"
                        neighboorhoods-used
                        current-index
                        (cost current-solution)
                        (cost x_prime))

         do (format t "     initial-delta-cost: ~a~%"
                        initial-best-delta-cost)


             do (if (< initial-best-delta-cost 0)
                    (then ;; we found a better solution in the shake
                      ;; so, let's update.
                      (setf better-solution-found-in-shake t)
                      (setf current-solution x_prime)
                      (format t "     Found a better solution in shake with cost ~a.~%"
                              (cost current-solution))))

             ;; the following should be done
             ;; only if no better-solution-found-in-shake


             ;; let's build the criterion for shake
             do (unless better-solution-found-in-shake
                  (format t "     Creating criterion to exploit shaked solution~%")
                  ;; let's see what happens if we exploit with
                  ;; a different criterion
                  (setf current-criterion-code
                        (nth (mod (1+ current-index)
                                  (length criteria))
                             criteria))

                  (setf current-criterion
                        (make-neighborhood-criterion
                         current-criterion-code
                         descent-search-strategy
                         descent-selection-strategy)))


             ;; let's explore with the current criterion
             ;; starting from x_prime, but using
             ;; initial-best-delta-cost
             do (unless better-solution-found-in-shake
                  (format t "     Exploiting shaked solution~%")
                  (setf (values better-solution)
                       (funcall current-criterion
                                x_prime
                                problem
                                action
                                (- initial-best-delta-cost))))

             ;; for debugging purposes
             do (unless better-solution-found-in-shake
                  (format t "     Descent"))


             do (unless better-solution-found-in-shake
                  (if better-solution
                     (then 
                       ;; we found a better solution
                       ;; update the current-solution
                       (setf current-solution better-solution)
                       ;; set the number-of-criteria to 0
                       (setf current-index 0)
                       ;; this is for debug
                       (format t ": ~a~%" (cost better-solution)))
                     (else
                       ;; use the next criterion
                       (incf current-index)
                       ;; this is for debug
                       (format t ".  No improvement.~%"))))

             ;; in any case, increment the number of neighboorhoods-used
             do (incf neighboorhoods-used)

             ;; ;; ;; for debugging
             (format t "     At the end of loop: cost of current-sol: ~a~%"
                     (cost current-solution))

             ;; ;; ;; for debugging purposes
             ;; (format t "At the end of the while: ~a, ~a~%"
             ;;         current-index number-of-criteria
             ;;         ;; (< current-index number-of-criteria)
             ;;         ;; (<= neighboorhoods-used max-iter)
             ;;         )
             ;; ;; ;; end of debugging purposes ;;}}}

             )
       ;; finally return the current solution
       ;; if it is nil, then the initial solution is an optimum
       (list current-solution
             neighboorhoods-used
             (<= neighboorhoods-used max-iter))))
       #+END_SRC
   
*** tests
**** a33 problem
***** exhaustive search (best/first/random improvement)
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((p1 a-n33-k6-problem)
             (s1 (make-initial-solution-for-cvrp-deterministic p1))
             (best-solution-exhaustive nil)
             (action (delta-cvrp-action))
             (results nil)

             (max-iterations 200)

             (cvrp-action (basic-cvrp-action))
             )


            (bformat t "Testing DNS with a-n33-k6")

            ;; first we compute the cost of the solution
            (simulate-solution s1 p1 cvrp-action)
            (setf (cost s1) (+ (total-distance cvrp-action)
                               (total-penalty cvrp-action)))

            (format t "Original solution (with cost ~a):~%"
                    (cost s1))
            ;; (pp-solution s1 t)

            ;; (setf results (vns-shake
            ;;                p1 s1
            ;;                (list
            ;;                 rab
            ;;                 rehrf
            ;;                 rarac
            ;;                 ref
            ;;                 rereg
            ;;                 rerf
            ;;                 rehf
            ;;                 rarb
            ;;                 )
            ;;                :max-iter max-iterations
            ;;                :action action
            ;;                ;; :shake-search (jump-around-search-strategy 10)
            ;;                :shake-search (jump-around-search-strategy 5)
            ;;                :shake-selection +jump-around-return-last-neighbor+
            ;;                :descent-selection-strategy +random-improvement+))

            (setf results (vns-code
                           p1 s1
                           (list
                            rab
                            rehrf
                            rarac
                            ref
                            rereg
                            rerf
                            rehf
                            rarb
                            )
                           :max-iter max-iterations
                           :action action
                           :selection-strategy +random-improvement+))

            (format t "finished vns-shake~%")


            (format t "Iterations: ~a. Optimum found ~a.~%"
                    (second results) (third results))

            (setf best-solution-exhaustive (first results))

            (if best-solution-exhaustive
                (then
                  (format t "Best value through: ~a~%"
                          (cost best-solution-exhaustive))
                  (format t "Best neighbor:~%")
                  (pp-solution best-solution-exhaustive t)

                  (simulate-solution best-solution-exhaustive p1 cvrp-action)

                  (setf best-solution-exhaustive (first results))
                  (format t "Best value through Yoel's: ~a~%"
                          (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))
                  )

                (else
                  (format t "Initial solution was optimum!~%")))



            )
      #+END_SRC
** receiving the criteria as a list of descriptions (good shake)
*** description
    Here we add a shake step in the algorithm, but in the following way: we do normal vns.  After that, we shake with the first neighborhood and repeat the vns. If no improvement is found we increase the shake index and repeat.  After all the neighborhoods have been used in the shake, and no improvement is made, we assume we have found the optimum.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp
   ;; Variable Neighboorhood Search
   (defun vns-shake
       (problem solution criteria
        &key
          (search-strategy +exhaustive-search-strategy+)
          (selection-strategy +best-improvement+)
          (shake-search (jump-around-search-strategy 5))
          (shake-selection (jump-around-return-last-neighbor))
          (list-returned-by-vns nil)
          (inner-search-max-iter 100)
          (max-iter 100)

          action
          (print-mod 1)
          )
     "Solves the VRP problem using a VNS with the given criterion starting with the given solution. We assume that the initial solution has the cost slot bound. If the result is nil, then the initial solution is an optimum for that neighboorhood."
     (declare (ignore print-mod))

     (let* (;; (current-index 0)
            (number-of-criteria (length criteria))
            (current-criterion-code nil)
            (current-criterion nil)
            (better-solution nil)
            (current-solution solution)
            (neighboorhoods-used 1)
            ;; (best-solution (clone solution))
            (x_prime nil)
            (initial-best-delta-cost 0)
            (shake-index 0)
            (neighboorhoods-used-in-vns 0)
            (optimum-found-in-vns nil)
            )

       (loop while (and (< shake-index number-of-criteria)
                        (<= neighboorhoods-used max-iter))
             for better-solution-found-in-shake = nil 
             ;; let's set the current criterion
             do (setf current-criterion-code (nth shake-index criteria))
             ;; let's build the criterion for shaking
             do (setf current-criterion
                      (make-neighborhood-criterion
                       current-criterion-code
                       shake-search
                       shake-selection))

             ;; let's shake the current solution
             ;; we expect two values because we also need
             ;; to know the initial-best-delta-cost
             ;; to pass it to the second step.
             do (setf (values x_prime initial-best-delta-cost)
                      (funcall current-criterion
                               current-solution problem action))

             ;; (format t "     x_prime? ~a~%" (not (null x_prime)))


             ;; for debugging purposes
             do (format t "Iteration ~a, shake criterion ~a.
        Best:    ~a (~a)~%"
                        neighboorhoods-used
                        shake-index
                        (cost current-solution)
                        (cost x_prime))

         ;; do (format t "     initial-delta-cost: ~a~%"
         ;;                initial-best-delta-cost)


             do (if (< initial-best-delta-cost 0)
                    (then ;; we found a better solution in the shake
                      ;; so, let's update.
                      (setf better-solution-found-in-shake t)
                      (setf current-solution x_prime)
                      (format t "     Found a better solution in shake with cost ~a.~%"
                              (cost current-solution))))

             ;; the following should be done
             ;; only if no better-solution-found-in-shake


             ;; let's call vns on the shaked solution
             do (unless better-solution-found-in-shake
                  ;; let's call vns on the shaked solution
                  (setf list-returned-by-vns
                        (vns-code-bar
                         problem x_prime criteria
                         :search-strategy search-strategy
                         :selection-strategy selection-strategy
                         :max-iter inner-search-max-iter
                         :action action))
                  ;; let's get the results
                  (setf better-solution (first list-returned-by-vns)
                        neighboorhoods-used-in-vns (nth 1 list-returned-by-vns)
                        optimum-found-in-vns (third list-returned-by-vns)))

                ;; let's see if the vns solution is better than x
             do (unless better-solution-found-in-shake
                  (if better-solution
                      (then
                        ;; let's see if the solution is better
                        (if (< (cost better-solution)
                               (cost current-solution))
                            (then
                             ;; we found a better solution
                             ;; update the current-solution
                             (setf current-solution better-solution)
                             ;; set the number-of-criteria to 0
                             (setf shake-index 0)
                             ;; this is for debug
                             (format t ": ~a~%" (cost better-solution)))
                            (else
                              ;; there is no improvement
                              ;; use the next criterion for the shake
                              (incf shake-index)
                              ;; this is for debug
                              (format t ".  :-(~%"))))))

             ;; in any case, increment the number of neighboorhoods-used
             do (incf neighboorhoods-used)

             ;; ;; ;; for debugging
             ;; (format t "     At the end of loop: cost of current-sol: ~a~%"
             ;;         (cost current-solution))

             ;; ;; ;; for debugging purposes
             ;; (format t "At the end of the while: ~a, ~a~%"
             ;;         current-index number-of-criteria
             ;;         ;; (< current-index number-of-criteria)
             ;;         ;; (<= neighboorhoods-used max-iter)
             ;;         )
             ;; ;; ;; end of debugging purposes ;;}}}

             )
       ;; finally return the current solution
       ;; if it is nil, then the initial solution is an optimum
       (list current-solution
             neighboorhoods-used
             (<= neighboorhoods-used max-iter))))
       #+END_SRC
   
*** tests
**** a33 problem
***** exhaustive search (best/first/random improvement)
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((p1 a-n33-k6-problem)
             (s1 (make-initial-solution-for-cvrp-deterministic p1))
             (best-solution-exhaustive nil)
             (action (delta-cvrp-action))
             (results nil)

             (max-iterations 100)

             (cvrp-action (basic-cvrp-action))
             )


            (bformat t "Testing DNS with a-n33-k6")

            ;; first we compute the cost of the solution
            (simulate-solution s1 p1 cvrp-action)
            (setf (cost s1) (+ (total-distance cvrp-action)
                               (total-penalty cvrp-action)))

            (format t "Original solution (with cost ~a):~%"
                    (cost s1))
            ;; (pp-solution s1 t)

            (time
             (progn
             ;; (setf results (vns-shake
             ;;                p1 s1
             ;;                (list
             ;;                 ; rabs
             ;;                 rab
             ;;                 rehrf
             ;;                 ;raracs
             ;;                 rarac
             ;;                 ref
             ;;                 rereg
             ;;                 rerf
             ;;                 rehf
             ;;                 ;rarbs
             ;;                 rarb
             ;;                 )
             ;;                :max-iter max-iterations
             ;;                :action action
             ;;                ;; :shake-search (jump-around-search-strategy 10)
             ;;                :shake-search (jump-around-search-strategy 1)
             ;;                :shake-selection +jump-around-return-last-neighbor+
             ;;                :selection-strategy +first-improvement+))

               (setf results (vns-shake 
                           p1 s1
                           (list
                            rab
                            ;;rehrf
                            raracs
                            ref
                            reregs
                            ;;rerf
                            ;;rehf
                            rarb
                            )
                           :max-iter max-iterations
                           :action action
                           :selection-strategy +random-improvement+
                           :inner-search-max-iter 20))

            (format t "finished vns-shake~%")


            (format t "Iterations: ~a. Optimum found ~a.~%"
                    (second results) (third results))

            (setf best-solution-exhaustive (first results))

            (if best-solution-exhaustive
                (then
                  (format t "Best value through: ~a~%"
                          (cost best-solution-exhaustive))
                  (format t "Best neighbor:~%")
                  (pp-solution best-solution-exhaustive t)

                  (simulate-solution best-solution-exhaustive p1 cvrp-action)

                  (setf best-solution-exhaustive (first results))
                  (format t "Best value through Yoel's: ~a~%"
                          (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))
                  )

                (else
                  (format t "Initial solution was optimum!~%")))

            ))

            )
      #+END_SRC
***** testing the smart neighborhoods
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((p1 a-n33-k6-problem)
             (s1 (make-initial-solution-for-cvrp-deterministic p1))
             (best-solution-exhaustive nil)
             (action (delta-cvrp-action))
             (results nil)

             (max-iterations 100)

             (cvrp-action (basic-cvrp-action))
             )


            (bformat t "Testing DNS with a-n33-k6")

            ;; first we compute the cost of the solution
            (simulate-solution s1 p1 cvrp-action)
            (setf (cost s1) (+ (total-distance cvrp-action)
                               (total-penalty cvrp-action)))

            (format t "Original solution (with cost ~a):~%"
                    (cost s1))
            ;; (pp-solution s1 t)

            (time
             (progn
               (setf results (vns-shake 
                           p1 s1
                           (list
                            rabs*              ;1
                            rarbs*             ;2
                            raracs*            ;3
                            refs*              ;4
                            reregs*            ;5
                            rehfs*             ;6
                            rerfs*             ;7
                            rads*              ;8
                            rehrfs*            ;9
                            rerehgs*           ;10
                            rehregs*           ;11
                            rehrehgs*          ;12
                            )
                           :max-iter max-iterations
                           :action action
                           :selection-strategy +random-improvement+
                           :inner-search-max-iter 20))

            (format t "finished vns-shake~%")


            (format t "Iterations: ~a. Optimum found ~a.~%"
                    (second results) (third results))

            (setf best-solution-exhaustive (first results))

            (if best-solution-exhaustive
                (then
                  (format t "Best value through: ~a~%"
                          (cost best-solution-exhaustive))
                  (format t "Best neighbor:~%")
                  (pp-solution best-solution-exhaustive t)

                  (simulate-solution best-solution-exhaustive p1 cvrp-action)

                  (setf best-solution-exhaustive (first results))
                  (format t "Best value through Yoel's: ~a~%"
                          (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))
                  )

                (else
                  (format t "Initial solution was optimum!~%")))

            ))

            )
      #+END_SRC
***** testing the actions*
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((p1 a-n33-k6-problem)
             (s1 (make-initial-solution-for-cvrp-deterministic p1))
             (best-solution-exhaustive nil)
             (action (delta-cvrp-action*))
             (results nil)

             (max-iterations 20)

             (cvrp-action (basic-cvrp-action))
             )


            (bformat t "Testing DNS with a-n33-k6")

            ;; first we compute the cost of the solution
            (simulate-solution s1 p1 cvrp-action)
            (setf (cost s1) (+ (total-distance cvrp-action)
                               (total-penalty cvrp-action)))

            (format t "Original solution (with cost ~a):~%"
                    (cost s1))
            ;; (pp-solution s1 t)

            (time
             (progn
               (setf results (vns-shake 
                           p1 s1
                           (list
                            rabs*              ;1
                            rarbs*             ;2
                            raracs*            ;3
                            refs*              ;4
                            ;; reregs*            ;5
                            ;; rehfs*             ;6
                            ;; rerfs*             ;7
                            ;; rads*              ;8
                            ;; rehrfs*            ;9
                            ;; rerehgs*           ;10
                            ;; rehregs*           ;11
                            ;; rehrehgs*          ;12
                            )
                           :max-iter max-iterations
                           :action action
                           :selection-strategy +random-improvement+
                           :inner-search-max-iter 10))

            (format t "finished vns-shake~%")


            (format t "Iterations: ~a. Optimum found ~a.~%"
                    (second results) (third results))

            (setf best-solution-exhaustive (first results))

            (if best-solution-exhaustive
                (then
                  (format t "Best value through: ~a~%"
                          (cost best-solution-exhaustive))
                  (format t "Best neighbor:~%")
                  (pp-solution best-solution-exhaustive t)

                  (simulate-solution best-solution-exhaustive p1 cvrp-action)

                  (setf best-solution-exhaustive (first results))
                  (format t "Best value through Yoel's: ~a~%"
                          (+ (total-distance cvrp-action)
                             (total-penalty cvrp-action)))
                  )

                (else
                  (format t "Initial solution was optimum!~%"))))) ;; time

            (format t "distance-stack: ~a~%"
                    (length (delta-distance-stack action)))

            )
      #+END_SRC
** criteria as descriptions good shake (only once creation)
*** description
    This is the last shake we had, but now we create the code for the criteria only once at the beginning of the the algorithm.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp
   ;; Variable Neighboorhood Search
   (defun vns-shake-smart
       (problem solution criteria
        &key
          (search-strategy +exhaustive-search-strategy+)
          (selection-strategy +best-improvement+)
          (shake-search (jump-around-search-strategy 5))
          (shake-selection (jump-around-return-last-neighbor))
          (list-returned-by-vns nil)
          (inner-search-max-iter 100)
          (max-iter 100)

          action
          action-for-shake
          (print-mod 1)
          )
     "Solves the VRP problem using a VNS with the given criterion starting with the given solution. We assume that the initial solution has the cost slot bound. If the result is nil, then the initial solution is an optimum for that neighboorhood."
     (declare (ignore print-mod))

     (let* (;; (current-index 0)
            (number-of-criteria (length criteria))
            ;; the criteria to be passed to the vns-fn-bar
            (exhaustive-criteria-code (mapcar (lambda (x)
                                                (make-neighborhood-criterion
                                                 x
                                                 search-strategy
                                                 selection-strategy))
                                              criteria))
            ;; the criteria to use for the shake
            (random-criteria-code (mapcar (lambda (x)
                                                (make-neighborhood-criterion
                                                 x
                                                 shake-search
                                                 shake-selection))
                                              criteria))
            (current-criterion-for-shake nil)
            (better-solution nil)
            (current-solution solution)
            (neighboorhoods-used 1)
            ;; (best-solution (clone solution))
            (x_prime nil)
            (initial-best-delta-cost 0)
            (shake-index 0)
            (neighboorhoods-used-in-vns 0)
            (optimum-found-in-vns nil)
            )

       (loop while (and (< shake-index number-of-criteria)
                        (<= neighboorhoods-used max-iter))
             for better-solution-found-in-shake = nil 
             ;; let's get the criterion for shaking
             do (setf current-criterion-for-shake
                      (nth shake-index random-criteria-code))

             ;; let's shake the current solution
             ;; we expect two values because we also need
             ;; to know the initial-best-delta-cost
             ;; to pass it to the second step.

             ;; do (initialize-action-for-delta-cost-computation
             ;;     current-solution
             ;;     problem
             ;;     action-for-shake)

             do (setf (values x_prime initial-best-delta-cost)
                      (funcall current-criterion-for-shake
                               current-solution
                               problem
                               action-for-shake))

             ;; (format t "    debug: distance-stack after shake: ~a~%"
             ;;         (length (delta-distance-stack action)))


             ;; for debugging purposes
             do (format t "Iteration ~a, shake criterion ~a.
        Best:    ~a (~a)~%"
                        neighboorhoods-used
                        shake-index
                        (cost current-solution)
                        (cost x_prime))

         ;; do (format t "     initial-delta-cost: ~a~%"
         ;;                initial-best-delta-cost)


             do (if (< initial-best-delta-cost 0)
                    (then ;; we found a better solution in the shake
                      ;; so, let's update.
                      (setf better-solution-found-in-shake t)
                      (setf current-solution x_prime)
                      (format t "     Found a better solution in shake with cost ~a.~%"
                              (cost current-solution))))

             ;; the following should be done
             ;; only if no better-solution-found-in-shake


             ;; let's call vns on the shaked solution
             do (unless better-solution-found-in-shake
                  ;; let's call vns on the shaked solution
                  (setf list-returned-by-vns
                        (vns-fn-bar
                         problem x_prime
                         exhaustive-criteria-code
                         :max-iter inner-search-max-iter
                         :action action
                         :dots-canvas 1
                         ))
                  ;; let's get the results
                  (setf better-solution
                        (first list-returned-by-vns))
                  (setf neighboorhoods-used-in-vns
                        (nth 1 list-returned-by-vns))
                  (setf optimum-found-in-vns
                        (third list-returned-by-vns)))

                ;; let's see if the vns solution is better than x
             do (unless better-solution-found-in-shake
                  (if better-solution
                      (then
                        ;; let's see if the solution is better
                        (if (< (cost better-solution)
                               (cost current-solution))
                            (then
                             ;; we found a better solution
                             ;; update the current-solution
                             (setf current-solution better-solution)
                             ;; set the number-of-criteria to 0
                             (setf shake-index 0)
                             ;; this is for debug
                             (format t ": ~a~%" (cost better-solution)))
                            (else
                              ;; there is no improvement
                              ;; use the next criterion for the shake
                              (incf shake-index)
                              ;; this is for debug
                              (format t ".  :-(~%"))))))

             ;; in any case, increment the number of neighboorhoods-used
             do (incf neighboorhoods-used)

             ;; ;; ;; for debugging
             ;; (format t "     At the end of loop: cost of current-sol: ~a~%"
             ;;         (cost current-solution))

             ;; ;; ;; for debugging purposes
             ;; (format t "At the end of the while: ~a, ~a~%"
             ;;         current-index number-of-criteria
             ;;         ;; (< current-index number-of-criteria)
             ;;         ;; (<= neighboorhoods-used max-iter)
             ;;         )
             ;; ;; ;; end of debugging purposes ;;}}}

             )
       ;; finally return the current solution
       ;; if it is nil, then the initial solution is an optimum
       (list current-solution
             neighboorhoods-used
             (<= neighboorhoods-used max-iter))))
       #+END_SRC
   
*** tests
**** testing the actions* a-n33-k6
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n33-k6-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (action-for-shake (delta-cvrp-action))
            (results nil)
            (max-iterations 200)
            (cvrp-action (basic-cvrp-action))
            )


           (bformat t "Testing DNS with a-n33-k6")

           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           ;; (pp-solution s1 t)

           (time
            (progn
              (setf results (vns-shake-smart
                          p1 s1
                          (list
                           rabs*              ;0
                           rarbs*             ;1
                           raracs*            ;2
                           refs*              ;3
                           reregs*            ;4
                           rehfs*             ;5
                           rerfs*             ;6
                           rads*              ;7
                           rehrfs*            ;8
                           rerehgs*           ;9
                           rehregs*           ;10
                           rehrehgs*          ;11
                           )
                          :max-iter max-iterations
                          :action action
                          :action-for-shake action-for-shake
                          :selection-strategy *random-improvement*
                          :search-strategy *exhaustive-search-strategy*
                          :inner-search-max-iter 200))

           (format t "finished vns-shake~%")


           (format t "Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor:~%")
                 (pp-solution best-solution-exhaustive t)

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)

                 (setf best-solution-exhaustive (first results))
                 (format t "Best value through Yoel's: ~a~%"
                         (get-cost-from-action cvrp-action))
                 )

               (else
                 (format t "Initial solution was optimum!~%"))))) ;; time

           ;; (format t "distance-stack: ~a~%"
           ;;         (length (delta-distance-stack action)))

           )
     #+END_SRC
**** testing the actions* a-n80-k10
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n80-k10-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (action-for-shake (delta-cvrp-action))
            (results nil)
            (max-iterations 200)
            (cvrp-action (basic-cvrp-action))
            )


           (bformat t "Testing DNS with a-n33-k6")

           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           ;; (pp-solution s1 t)

           (time
            (progn
              (setf results (vns-shake-smart
                          p1 s1
                          (list
                           rabs*              ;0
                           rarbs*             ;1
                           raracs*            ;2
                           refs*              ;3
                           reregs*            ;4
                           rehfs*             ;5
                           rerfs*             ;6
                           rads*              ;7
                           rehrfs*            ;8
                           rerehgs*           ;9
                           rehregs*           ;10
                           rehrehgs*          ;11
                           )
                          :max-iter max-iterations
                          :action action
                          :action-for-shake action-for-shake
                          :selection-strategy *random-improvement*
                          :search-strategy *exhaustive-search-strategy*
                          :inner-search-max-iter 60))

           (format t "finished vns-shake~%")


           (format t "Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor:~%")
                 (pp-solution best-solution-exhaustive t)

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)

                 (setf best-solution-exhaustive (first results))
                 (format t "Best value through Yoel's: ~a~%"
                         (get-cost-from-action cvrp-action))
                 )

               (else
                 (format t "Initial solution was optimum!~%"))))) ;; time

           ;; (format t "distance-stack: ~a~%"
           ;;         (length (delta-distance-stack action)))

           )
     #+END_SRC
**** testing the new random-improvement a-n80-k10
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n65-k9-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (action-for-shake (delta-cvrp-action))
            (results nil)
            (max-iterations 200)
            (cvrp-action (basic-cvrp-action))
            )


           (bformat t "Testing DNS with a-n33-k6")

           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (time
            (progn
              (setf results (vns-shake-smart
                          p1 s1
                          (list
                           rabs*              ;0
                           rarbs*             ;1
                           raracs*            ;2
                           refs*              ;3
                           reregs*            ;4
                           rehfs*             ;5
                           rerfs*             ;6
                           rads*              ;7
                           rehrfs*            ;8
                           rerehgs*           ;9
                           rehregs*           ;10
                           rehrehgs*          ;11
                           )
                          :max-iter max-iterations
                          :action action
                          :action-for-shake action-for-shake
                          :selection-strategy
                          ;;(random-improvement-smart 0.7)
                           ,*first-improvement*
                          :search-strategy *exhaustive-search-strategy*
                          :inner-search-max-iter 50))

           (format t "finished vns-shake~%")


           (format t "Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor:~%")
                 (pp-solution best-solution-exhaustive t)

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)

                 (setf best-solution-exhaustive (first results))
                 (format t "Best value through Yoel's: ~a~%"
                         (get-cost-from-action cvrp-action))
                 )

               (else
                 (format t "Initial solution was optimum!~%")))))
           ;; time

           ;; (format t "distance-stack: ~a~%"
           ;;         (length (delta-distance-stack action)))

           )
     #+END_SRC
**** testing the random initial solution a-n80-k10
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n65-k9-problem)
            (s1 (make-initial-random-cvrp-solution p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (action-for-shake (delta-cvrp-action))
            (results nil)
            (max-iterations 200)
            (cvrp-action (basic-cvrp-action))
            )


           (bformat t "Testing DNS with a-n65-k9-problem")

           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           (pp-solution s1 t)

           (time
            (progn
              (setf results (vns-shake-smart
                          p1 s1
                          (list
                           rabs*              ;0
                           rarbs*             ;1
                           raracs*            ;2
                           refs*              ;3
                           reregs*            ;4
                           rehfs*             ;5
                           rerfs*             ;6
                           rads*              ;7
                           rehrfs*            ;8
                           rerehgs*           ;9
                           ;; rehregs*           ;10
                           rehrehgs*          ;11
                           )
                          :max-iter max-iterations
                          :action action
                          :action-for-shake action-for-shake
                          :selection-strategy
                          ;; (random-improvement-smart 0.7)
                           ,*first-improvement*
                          :search-strategy *exhaustive-search-strategy*
                          :inner-search-max-iter 500))

           (format t "finished vns-shake~%")


           (format t "Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor:~%")
                 (pp-solution best-solution-exhaustive t)

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)

                 (setf best-solution-exhaustive (first results))
                 (format t "Best value through Yoel's: ~a~%"
                         (get-cost-from-action cvrp-action))
                 )

               (else
                 (format t "Initial solution was optimum!~%")))))
           ;; time

           ;; (format t "distance-stack: ~a~%"
           ;;         (length (delta-distance-stack action)))

           )
     #+END_SRC

**** testing camila's initial solution  a-n65-k9
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n65-k9-problem)
            (s1 (make-basic-cvrp-solution-from-list
                 1 `(( 2 )
                     ( 23 )( 48 )( 35  46 )( 45  6 )( 63 )( 55 )
                     ( 51  38 )( 40 )( 28  11 )( 25 )(43  22  4 )
                     ( 29  42  50  60  19 )( 57 )( 49 )( 53 )( 41 )
                     ( 44  37 )( 52 )( 16  15  5 )( 10  58 )
                     ( 64  24  39 )( 61 )( 47  21 )( 9 )( 14  32 )
                     ( 56 )( 33  12  34  27 )( 62 )( 20  26  1 )
                     ( 17 )( 18 )( 13  59 )( 54  36 30  7  3  8 )
                     ( 31 ))
                 a-n65-k9-problem))
                 (best-solution-exhaustive nil)
                 (action (delta-cvrp-action*))
                 (action-for-shake (delta-cvrp-action))
                 (results nil)
                 (max-iterations 200)
                 (cvrp-action (basic-cvrp-action))
                 )


                (bformat t "Testing DNS with a-n65-k9-problem")

                ;; first we compute the cost of the solution
                (simulate-solution s1 p1 cvrp-action)
                (setf (cost s1) (+ (total-distance cvrp-action)
                                   (total-penalty cvrp-action)))

                (format t "Original solution (with cost ~a):~%"
                        (cost s1))
                (pp-solution s1 t)

                (time
                 (progn
                   (setf results (vns-shake-smart
                               p1 s1
                               (list
                                rabs*              ;0
                                rarbs*             ;1
                                raracs*            ;2
                                refs*              ;3
                                reregs*            ;4
                                rehfs*             ;5
                                rerfs*             ;6
                                rads*              ;7
                                rehrfs*            ;8
                                rerehgs*           ;9
                                rehregs*           ;10
                                rehrehgs*          ;11
                                )
                               :max-iter max-iterations
                               :action action
                               :action-for-shake action-for-shake
                               :selection-strategy
                               ;; (random-improvement-smart 0.7)
                                ,*first-improvement*
                               :search-strategy *exhaustive-search-strategy*
                               :inner-search-max-iter 50))

                (format t "finished vns-shake~%")


                (format t "Iterations: ~a. Optimum found ~a.~%"
                        (second results) (third results))

                (setf best-solution-exhaustive (first results))

                (if best-solution-exhaustive
                    (then
                      (format t "Best value through: ~a~%"
                              (cost best-solution-exhaustive))
                      (format t "Best neighbor:~%")
                      (pp-solution best-solution-exhaustive t)

                      (simulate-solution best-solution-exhaustive p1 cvrp-action)

                      (setf best-solution-exhaustive (first results))
                      (format t "Best value through Yoel's: ~a~%"
                              (get-cost-from-action cvrp-action))
                      )

                    (else
                      (format t "Initial solution was optimum!~%")))))
                ;; time

                ;; (format t "distance-stack: ~a~%"
                ;;         (length (delta-distance-stack action)))

                )
     #+END_SRC

**** testing ff-a-n33-k6-problem
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 ff-a-n33-k6-problem)
            (s1 (make-initial-solution-for-finite-fleet-cvrp-random
                 p1))
                 (best-solution-exhaustive nil)
                 (action (delta-cvrp-action*))
                 (action-for-shake (delta-cvrp-action))
                 (results nil)
                 (max-iterations 200)
                 (cvrp-action (basic-cvrp-action))
                 )


                (bformat t "Testing DNS with a-n65-k9-problem")

                ;; first we compute the cost of the solution
                (simulate-solution s1 p1 cvrp-action)
                (setf (cost s1) (+ (total-distance cvrp-action)
                                   (total-penalty cvrp-action)))

                (format t "Original solution (with cost ~a):~%"
                        (cost s1))
                (pp-solution s1 t)

                (time
                 (progn
                   (setf results (vns-shake-smart
                               p1 s1
                               (list
                                rabs*              ;0
                                rarbs*             ;1
                                raracs*            ;2
                                refs*              ;3
                                reregs*            ;4
                                ;; rehfs*             ;5
                                rerfs*             ;6
                                ;; rads*              ;7
                                ;; rehrfs*            ;8
                                ;; rerehgs*           ;9
                                ;; rehregs*           ;10
                                ;; rehrehgs*          ;11
                                )
                               :max-iter max-iterations
                               :action action
                               :action-for-shake action-for-shake
                               :selection-strategy
                               ;; (random-improvement-smart 0.7)
                                ,*first-improvement*
                               :search-strategy *exhaustive-search-strategy*
                               :inner-search-max-iter 50))

                (format t "finished vns-shake~%")


                (format t "Iterations: ~a. Optimum found ~a.~%"
                        (second results) (third results))

                (setf best-solution-exhaustive (first results))

                (if best-solution-exhaustive
                    (then
                      (format t "Best value through: ~a~%"
                              (cost best-solution-exhaustive))
                      (format t "Best neighbor:~%")
                      (pp-solution best-solution-exhaustive t)

                      (simulate-solution best-solution-exhaustive p1 cvrp-action)

                      (setf best-solution-exhaustive (first results))
                      (format t "Best value through Yoel's: ~a~%"
                              (get-cost-from-action cvrp-action))
                      )

                    (else
                      (format t "Initial solution was optimum!~%")))))
                ;; time

                ;; (format t "distance-stack: ~a~%"
                ;;         (length (delta-distance-stack action)))

                )
     #+END_SRC

** criteria as descriptions good shake, only once, no output
*** description
    This is the last shake we had, but now we create the code for the criteria only once at the beginning of the the algorithm.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/neigh-algorithms.lisp
   ;; Variable Neighboorhood Search
   (defun vns-shake-smart-no-output
       (problem solution criteria
        &key
          (search-strategy +exhaustive-search-strategy+)
          (selection-strategy +best-improvement+)
          (shake-search (jump-around-search-strategy 5))
          (shake-selection (jump-around-return-last-neighbor))
          (list-returned-by-vns nil)
          (inner-search-max-iter 100)
          (max-iter 100)

          action
          action-for-shake
          )
     "Solves the VRP problem using a VNS with the given criterion starting with the given solution. We assume that the initial solution has the cost slot bound. If the result is nil, then the initial solution is an optimum for that neighboorhood."

     (let* (;; (current-index 0)
            (number-of-criteria (length criteria))
            ;; the criteria to be passed to the vns-fn-bar
            (exhaustive-criteria-code (mapcar (lambda (x)
                                                (make-neighborhood-criterion
                                                 x
                                                 search-strategy
                                                 selection-strategy))
                                              criteria))
            ;; the criteria to use for the shake
            (random-criteria-code (mapcar (lambda (x)
                                                (make-neighborhood-criterion
                                                 x
                                                 shake-search
                                                 shake-selection))
                                              criteria))
            (current-criterion-for-shake nil)
            (better-solution nil)
            (current-solution solution)
            (neighboorhoods-used 1)
            ;; (best-solution (clone solution))
            (x_prime nil)
            (initial-best-delta-cost 0)
            (shake-index 0)
            (neighboorhoods-used-in-vns 0)
            (optimum-found-in-vns nil)
            )

       (loop while (and (< shake-index number-of-criteria)
                        (<= neighboorhoods-used max-iter))
             for better-solution-found-in-shake = nil 
             ;; let's get the criterion for shaking
             do (setf current-criterion-for-shake
                      (nth shake-index random-criteria-code))

             ;; let's shake the current solution
             ;; we expect two values because we also need
             ;; to know the initial-best-delta-cost
             ;; to pass it to the second step.

             do (setf (values x_prime initial-best-delta-cost)
                      (funcall current-criterion-for-shake
                               current-solution
                               problem
                               action-for-shake))


             do (if (< initial-best-delta-cost 0)
                    (then ;; we found a better solution in the shake
                      ;; so, let's update.
                      (setf better-solution-found-in-shake t)
                      (setf current-solution x_prime)))

             ;; the following should be done
             ;; only if no better-solution-found-in-shake

             ;; let's call vns on the shaked solution
             do (unless better-solution-found-in-shake
                  ;; let's call vns on the shaked solution
                  (setf list-returned-by-vns
                        (vns-fn-no-output
                         problem x_prime
                         exhaustive-criteria-code
                         :max-iter inner-search-max-iter
                         :action action))
                  ;; let's get the results
                  (setf better-solution
                        (first list-returned-by-vns))
                  (setf neighboorhoods-used-in-vns
                        (nth 1 list-returned-by-vns))
                  (setf optimum-found-in-vns
                        (third list-returned-by-vns)))

                ;; let's see if the vns solution is better than x
             do (unless better-solution-found-in-shake
                  (if better-solution
                      (then
                        ;; let's see if the solution is better
                        (if (< (cost better-solution)
                               (cost current-solution))
                            (then
                             ;; we found a better solution
                             ;; update the current-solution
                             (setf current-solution better-solution)
                             ;; set the number-of-criteria to 0
                             (setf shake-index 0))
                            (else
                              ;; there is no improvement
                              ;; use the next criterion for the shake
                              (incf shake-index))))))

             ;; in any case, increment the number of neighboorhoods-used
             do (incf neighboorhoods-used)
             )
       ;; finally return the current solution
       ;; if it is nil, then the initial solution is an optimum
       (list current-solution
             neighboorhoods-used
             (<= neighboorhoods-used max-iter))))
       #+END_SRC
   
*** tests
**** testing the actions*
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n33-k6-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (best-solution-exhaustive nil)
            (action (delta-cvrp-action*))
            (action-for-shake (delta-cvrp-action))
            (results nil)
            (max-iterations 200)
            (cvrp-action (basic-cvrp-action))
            )


           (bformat t "Testing VNS shake no output with a-n33-k6")

           ;; first we compute the cost of the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Original solution (with cost ~a):~%"
                   (cost s1))
           ;; (pp-solution s1 t)

           (time
            (progn
              (setf results (vns-shake-smart-no-output
                          p1 s1
                          (list
                           rabs*              ;0
                           rarbs*             ;1
                           raracs*            ;2
                           refs*              ;3
                           reregs*            ;4
                           rehfs*             ;5
                           rerfs*             ;6
                           rads*              ;7
                           rehrfs*            ;8
                           rerehgs*           ;9
                           rehregs*           ;10
                           rehrehgs*          ;11
                           )
                          :max-iter max-iterations
                          :action action
                          :action-for-shake action-for-shake
                          :selection-strategy *random-improvement*
                          :search-strategy *exhaustive-search-strategy*
                          :inner-search-max-iter 40))

           (format t "finished vns-shake~%")


           (format t "Iterations: ~a. Optimum found ~a.~%"
                   (second results) (third results))

           (setf best-solution-exhaustive (first results))

           (if best-solution-exhaustive
               (then
                 (format t "Best value through: ~a~%"
                         (cost best-solution-exhaustive))
                 (format t "Best neighbor:~%")
                 (pp-solution best-solution-exhaustive t)

                 (simulate-solution best-solution-exhaustive p1 cvrp-action)

                 (setf best-solution-exhaustive (first results))
                 (format t "Best value through Yoel's: ~a~%"
                         (get-cost-from-action cvrp-action))
                 )

               (else
                 (format t "Initial solution was optimum!~%")))))

           )
     #+END_SRC


* Hill climbing generated by Claudia Barcelo :-o
** code
    #+BEGIN_SRC lisp +n -r :results none :exports code
    (defun hill-climbing (solution criterion problem max-iter  action)
      (defparameter better-solution solution)
      (defparameter current-solution solution)
      (defparameter cond1 0)
      (loop while (< cond1 max-iter)
            do (progn
                 (setf current-solution (funcall criterion current-solution problem action))
                 (if (is-better current-solution better-solution) 
                     (progn
                       (setf better-solution current-solution)
                       )
                     (progn
                       (setf cond1 max-iter)
                       ))
                 (setf cond1 (+ cond1 1))


                 ))
      (return-from hill-climbing better-solution
                   )

      )
    #+END_SRC   
** tests
   #+BEGIN_SRC lisp +n -r :results none :exports code
   (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                       (5 0 6 7 2 4)  ;1
                                       (1 8 0 3 9 1)  ;2
                                       (4 5 1 0 5 7)  ;3
                                       (4 5 1 5 0 6)  ;4
                                       (1 5 7 6 9 0)) ;5
                                       ;0 1 2 3 4 5 
                          :demands '(20 10 15 40 30)
                          :capacity 40)
     (with-basic-cvrp-solution (s1 ((1 2 3) (4 5)) p1)
       (let* ((best-solution nil)
              (action (delta-cvrp-action))
              (cvrp-action (basic-cvrp-action 
                            :penalty-factor 1000))
              )
         (bformat t "Testing automatically generated hill-climbing")

         ;; initializing the cost of the initial solution
         (simulate-solution s1 p1 cvrp-action)
         (setf (cost s1) (get-cost-from-action cvrp-action))

         (pp-solution s1 t) (terpri)

         (format t "Cost: ~a~%" (cost s1))

         ;; (setf best-solution (funcall rarb-random s1 p1 action))
         (setf best-solution (hill-climbing s1 rarb-first p1 100 action))

         (pp-solution best-solution t) (terpri)
         (format t "Cost: ~a~%" (cost best-solution))



         )))
   #+END_SRC   
   
