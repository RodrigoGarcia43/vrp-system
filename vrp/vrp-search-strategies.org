#+TITLE: VRP solver environment
#+AUTHOR: Fernando Rodriguez Flores
#+AUTHOR: Heidy Abreu Fumero
#+DATE 2018-08-25
#+TODO: TODO WIP BROKEN | DONE

* Add the package to the file
  #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
  (in-package :vrp)
  #+END_SRC


* Description

** general description
   In this file I'm going to add the functionalities required to automatically implement several ways to explore a neighborhood according to the combinations of different strategies.

   Some examples of these combinations are:

    - exhaustive-search with random improvement
    - random-search with first-improvement
    - exhaustive-search with best improvement.

   There are two things here to take into account:

    1. how to explore the neighborhood
    2. how to select the best neighbor from the explored ones.

   Some strategies to search the neighborhood are:

     - exhaustive search :: check all the neighbors in the neighborhood.
     - random-search :: check a fixed number of random neighbors.

   Some strategies to select the best neighbor are:

     - best-improvement:
          the best neighbor in the explored neighborhood.
     - random-improvement:
          a random neighbor with a better evaluation than the current solution
     - first-improvement:
        the first neighbor that is better than the current solution.
     - weighted-random-improvement:
        a random better neighbor, but the selection is not uniform, the probability of any client of being selected depends on the quality of that neighbor.
     - simulated-annealing-selection:
       sometimes accept worse solutions according to the quality of that solution and the state of the algorithm.

   What we want to do in this file is to create a mechanism that allows us to create a function to explore a neighborhood of a solution using any combination of the existing options.

   A neighborhood criterion can be described as a list of neighborhood operations with the parameters specified.  For instance, the criterion change a client inside its route can be written as:

   #+BEGIN_EXAMPLE
   (select-route r1)
   (select-client c1 from r1)
   (insert-client c1 into r1)
   #+END_EXAMPLE

   Now, from that description we can have several functions according to the strategies.

   To create these functions, we need to define several things:
     1. what do we need to initialize things
     2. how to explore the neighborhood
     3. what to do when we have the operations that define the neighbor.
     4. what to do when the exploration is over
   
   Each strategy does those steps differently.  In the next section (tutorials) we'll explore these ideas with more detail, and we'll make some generalizations.

   The src blocks in this file will be tangled to vrp-search-strategies.lisp.

** tutorials and examples
*** create an exhaustive-search/best-improvement search for rab
**** description

     In this section we want to create a function that explores the neighborhood of a solution using an exhaustive/best-improvement strategy.  The criterion will be =rab= that means move the client inside its route.

     As we want an exhaustive search we need to explore all the neighborhood.  We can do that with the do-neighborhood-operations macro.

     The description of the criterion is:
     #+BEGIN_EXAMPLE
     (select-route r1)
     (select-client c1 from r1)
     (insert-client c1 into r1)
     #+END_EXAMPLE
     
     To create this function, we need to do several things:
     1. what do we need to initialize things
     2. how to explore the neighborhood
     3. what to do when we have the operations that define the neighbor
     4. what to do when the exploration is over

     Let's analyze each of those points.  I'm going to leave the first point to the end, because it will be easier to deduce after we have analyzed the remaining points.
     
***** 2. how to explore the neighborhood (exhaustive-search)

      First, let's see how to create a function that explores the full neighborhood of rab.  We can do that with the do-neighborhood macros.  For instance, for this example:

      #+BEGIN_EXAMPLE
      (select-route r1)
      (select-client c1 from r1)
      (insert-client c1 into r1)
      #+END_EXAMPLE

      We can translate it into:
      #+BEGIN_EXAMPLE
      (doselect-route (r1 wc)
        (doselect-client (c1 r1 wc)
          (doinsert-client (c1 r1 wc))
            ...do whatever we want here
          ))
      #+END_EXAMPLE

      If instead of rab the criterion were rarac, we would have:
      #+BEGIN_EXAMPLE
      (select-route r1)
      (select-client c1 from r1)
      (select-route r2)
      (select-client c2 from r2)
      (swap-clients c1 c2)
      #+END_EXAMPLE

      We could translate it into:
      #+BEGIN_EXAMPLE
      (doselect-route (r1 wc)
        (doselect-client (c1 r1 wc)
           (doselect-route (r2 wc)
              (doselect-client (c2 r2 wc)
                 (doswap-clients (c1 c2 wc)
                   ...do whatever we want here
                 )))))
      #+END_EXAMPLE

     So, in an exhaustive search, to create the code we only need to translate the description of the criterion into nested calls to the corresponding do-neighborhood macros.

     Now we know how to explore the neighborhood in an exhaustive search, and that answers the question 2.  Let's see now what to do when we have the operations that define the neighbor.     
     
***** 3. what to do when we have the operations that define the neighbor

      We can explore the full neighborhood with the do-neighborhood-operation macros, but still we need to define what to do when the macros give the control to our code.  What we do depends on the strategy we want to follow.  In this case we want an exhaustive search of the neighborhood and we want the best neighbor of all.

      To do that we need to evaluate the current-neighbor (that we'll have in the variable ops-list in the form of the neighborhood-operations that should be applied to the current-solution to get the neighbor.)  For that we could use the function =delta-cost=.

      But as we want the best neighbor, everytime we compute the delta-cost for a client, we need to compare it with the current best neighbor.  If the new one is better, then let's update things.

      It could be something like this:

      #+BEGIN_EXAMPLE 
      (doselect-route (r1 wc)
        (doselect-client (c1 r1 wc)
          (doinsert-client (c1 r1 wc)

            ;; ==== this is the new stuff ==== ;;

            ;; let's get the cost of the current neighbor
            (setf current-delta-cost
                  (delta-cost ops-list wc problem action))
            ;; let's see if it is better
            (if (< current-delta-cost best-delta-cost)
                ;; if it is
                (then
                   ;; let's save the ops that make it
                   (setf best-neighbor (clone ops-list))
                   ;; let's update the best-cost
                   (setf best-delta-cost current-delta-cost)))

            ;; ==== end of the new stuff ==== ;;
           )))
      #+END_EXAMPLE

      So, this way, when we exit the do-neighborhood-operation macros we have in best-neighbor the operations from where we can construct the best neighbor, and in best-delta-cost we have the delta-cost of this neighbor.

      The next thing to define is what to do when the exploration ends.  We'll address that point in the next section.
     
***** 4. what to do when the exploration is over
      Here, we should decide what to do when the exploration is over.  In this case of best-improvement, what we need to do is simple.  If the best-delta-cost is smaller than 0, then we have a better solution than the current one, and that's what we should return.  Otherwise we should return nil.

      In the code it would be something like:

      #+BEGIN_EXAMPLE 
      (doselect-route (r1 wc)
        (doselect-client (c1 r1 wc)
          (doinsert-client (c1 r1 wc)
            ;; let's get the cost of the current neighbor
            (setf current-delta-cost
                  (delta-cost ops-list wc problem action))
            ;; let's see if it is better
            (if (< current-delta-cost best-delta-cost)
                ;; if it is
                (then
                   ;; let's save the ops that make it
                   (setf best-neighbor (clone ops-list))
                   ;; let's update the best-cost
                   (setf best-delta-cost current-delta-cost))))))

      ======== from here on is the new stuff ========     
      ;; here we check if we found a neighbor better than solution
      ;; if so, we apply the operations in best-neighbor to solution
      ;; and return the best-neighbor
      ;; otherwise, we return nil
      ;; and that means that we didn't find a better neighbor

      (if best-neighbor
          (then
            (apply-set-of-operations (reverse best-neighbor) wc)
            (setf best-neighbor-as-solution
                  (solution wc))
            ;; return best-neighbor-as-solution
            ;; and the best-delta-cost
            (values best-neighbor-as-solution best-delta-cost)))
      ======== here ends the new stuff ========
      #+END_EXAMPLE

      Obviously, to do that, we need to initialize several things, and what we need to initialize depends on the strategy we want to use.  We talk about that in the next section.
***** 1. what do we need to initialize things

      To use an exhaustive search of the neighborhood and return the best neighbor found, we need to initialize the following:

        - best-delta-cost (to 0, that means no improvement)
        - best-neighbor (to nil)
        - best-neighbor-as-solution (to nil)
        - current-delta-cost (to avoid warnings)

      And there are some things that should be initialized in any strategy:

        - the ops-list (to nil)
        - *vrp-stop-neighborhood-search* to nil
        - we should create a working-copy from the solution
          or initialize the working-copy, depending on what we want to pass around as arguments.

          So the initializations for the criterion =rab= with an exhaustive search (assuming that the user passes a solution as argument) could look like:

         
      #+BEGIN_EXAMPLE
      ===== here is the new stuff =====
      (let* (;; first the standard initializations
             (*vrp-stop-neighborhood-search* nil)
             (ops-list nil)
             (wc (basic-working-copy solution))
             ;; now the corresponding to the
             ;; best-improvement strategy
             (current-delta-cost 0)
             (best-delta-cost 0)
             (best-neighbor nil)
             (best-neighbor-as-solution nil)
             )

        (prepare-solution-for-neighborhood-exploration wc)

       ===== here ends the new stuff =====
     
        (doselect-route (r1 wc)
          (doselect-client (c1 r1 wc)
            (doinsert-client (c1 r1 wc))
              ;; let's get the cost of the current neighbor
              (setf current-delta-cost
                    (delta-cost ops-list wc problem action)
              ;; let's see if it is better
              (if (< current-delta-cost best-delta-cost)
                  ;; if it is
                  (then
                     ;; let's save the ops that make it
                     (setf best-neighbor (clone ops-list))
                     ;; let's update the best-cost
                     (setf best-delta-cost current-delta-cost))))))
  
        ;; here we check if we found a neighbor better than solution
        ;; if so, we apply the operations in best-neighbor to solution
        ;; and return the best-neighbor
        ;; otherwise, we return nil
        ;; and that means that we didn't find a better neighbor
  
        (if best-neighbor
          (then
            (apply-set-of-operations (reverse best-neighbor) wc)
            (setf best-neighbor-as-solution
                  (solution wc))
            ;; return best-neighbor-as-solution
            ;; and the best-delta-cost
            (values best-neighbor-as-solution best-delta-cost))))
      #+END_EXAMPLE
      
     In the next sections, we'll write a working code for this criterion and run some tests.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defun rab-exhaustive-best (solution problem action)
       "Returns the best neighbor of the solution in wc, using an exhaustive search and best-improvment strategy."
       (let* ( ;; first the standard initializations
              (*vrp-stop-neighborhood-search* nil)
              (wc (basic-working-copy solution))
              (ops-list nil)
              ;; now the corresponding to the
              ;; best-improvement strategy
              (current-delta-cost 0)
              (best-delta-cost 0)
              (best-neighbor nil)
              (best-neighbor-as-solution nil)
              )
         (prepare-solution-for-neighborhood-exploration wc)
         (initialize-action-for-delta-cost-computation wc problem action)

         (doselect-route (r1 wc)
           (doselect-client (c1 r1 wc)
             (doinsert-client (c1 r1 wc)
               ;; let's get the cost of the current neighbor
               (setf current-delta-cost
                     (delta-cost (reverse ops-list) wc problem action))

               (format t "~%With delta-cost: ~a~%" current-delta-cost)
               (pp-solution wc t) (terpri)

               ;; let's see if it is better
               (if (< current-delta-cost best-delta-cost)
                   ;; if it is
                   (then
                     ;; let's save the ops that make it
                     (setf best-neighbor (clone ops-list))
                     ;; let's update the best-cost
                     (setf best-delta-cost current-delta-cost))))))

         ;; here we check if we found a neighbor better than solution
         ;; if so, we apply the operations in best-neighbor to solution
         ;; and return the best-neighbor
         ;; otherwise, we return nil
         ;; and that means that we didn't find a better neighbor

         (if best-neighbor
             (then
               (apply-set-of-operations (reverse best-neighbor) wc)
               (setf best-neighbor-as-solution
                     (solution wc))
               (setf (cost best-neighbor-as-solution)
                     (+ (cost solution)
                        best-delta-cost))
               ;; return best-neighbor-as-solution
               (values best-neighbor-as-solution
                       best-delta-cost)))))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                            :demands '(10 10 15 40 20)
                            :capacity 40)
       (with-basic-cvrp-solution (s1 ((3 2 4) (1 5)) p1)
         (let* ((best-solution-found nil)
                (best-cost-found 0)
                (wc0 (basic-working-copy s1))
                (wc2 nil)
                (action (delta-cvrp-action))
                (cvrp-action (basic-cvrp-action)))



           (bformat t "Testing exhaustive/best-improvement rab")

           ;; let's evaluate the solution

           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Distance: ~a, penalty: ~a, cost: ~a~%"
                   (total-distance cvrp-action)
                   (total-penalty cvrp-action)
                   (cost s1))

           (prepare-solution-for-neighborhood-exploration wc0)

           (format t "~%Testing exhaustive rab...~%")
           (pp-solution wc0 t)

           ;;{{{ let's explore the neighborhood rarb
           (setf best-solution-found
                 (rab-exhaustive-best s1 p1 action))
           ;;}}}


           (if best-solution-found
               (then
                 ;;{{{ print the best neighbor
                 ;; (format t "Best value: ~a~%" (cost best-solution-found))
                 (format t "------------------~%Best neighbor:~%")
                 (setf wc2 (basic-working-copy best-solution-found))
                 (prepare-solution-for-neighborhood-exploration wc2)
                 (pp-solution wc2 t) (terpri)


                 (format t "with cost: ~a~%" (cost wc2))
                 (format t "------------------~%")
                 ;;}}}

                 ;; ;;{{{ using yoel approach
                 ;; (format t "Cost of original solution: ~a~%"
                 ;;         (solution-cost s1 p1 cvrp-action))
                 ;; (format t "Cost of best-neighbor: ~a~%"
                 ;;         (solution-cost best-solution-found
                 ;;                        p1 cvrp-action))
                 ;; ;;}}}
                 )
               (else
                 (format t "No better solution found in neighbor.~%")))

           )))
     #+END_SRC
*** create an exhaustive-search/first-improvement search for rab
**** description

     In this section we want to create a function that explores the neighborhood of a solution using an exhaustive/first-improvement strategy.  The criterion will be =rarac= that means to swap two clients.

     As we want an exhaustive search we need to explore all the neighborhood.  We can do that with the do-neighborhood-operations macro.

     The description of the criterion is:
     #+BEGIN_EXAMPLE
     (select-route r1)
     (select-client c1 from r1)
     (insert-client c1 into r1)
     #+END_EXAMPLE
     
     To create this function, we need to do several things:
     1. what do we need to initialize things
     2. how to explore the neighborhood
     3. what to do when we have the operations that define the neighbor
     4. what to do when the exploration is over

     Let's analyze each of those points.  I'm going to leave the first point to the end, because it will be easier to deduce after we have analyzed the remaining points.
     
***** 2. how to explore the neighborhood (exhaustive-search)

      First, let's see how to create a function that explores the full neighborhood of rab.  We can do that with the do-neighborhood macros.  For instance, for this example:

      #+BEGIN_EXAMPLE
      (select-route r1)
      (select-client c1 from r1)
      (insert-client c1 into r1)
      #+END_EXAMPLE

      We can translate it into:
      #+BEGIN_EXAMPLE
      (doselect-route (r1 wc)
        (doselect-client (c1 r1 wc)
          (doinsert-client (c1 r1 wc))
            ...do whatever we want here
          ))
      #+END_EXAMPLE

      If instead of rab the criterion were rarac, we would have:
      #+BEGIN_EXAMPLE
      (select-route r1)
      (select-client c1 from r1)
      (select-route r2)
      (select-client c2 from r2)
      (swap-clients c1 c2)
      #+END_EXAMPLE

      We could translate it into:
      #+BEGIN_EXAMPLE
      (doselect-route (r1 wc)
        (doselect-client (c1 r1 wc)
           (doselect-route (r2 wc)
              (doselect-client (c2 r2 wc)
                 (doswap-clients (c1 c2 wc)
                   ...do whatever we want here
                 )))))
      #+END_EXAMPLE

     So, in an exhaustive search, to create the code we only need to translate the description of the criterion into nested calls to the corresponding do-neighborhood macros.

     Now we know how to explore the neighborhood in an exhaustive search, and that answers the question 2.  Let's see now what to do when we have the operations that define the neighbor.     
     
***** 3. what to do when we have the operations that define the neighbor

      We can explore the full neighborhood with the do-neighborhood-operation macros, but still we need to define what to do when the macros give the control to our code.  What we do depends on the strategy we want to follow.  In this case we want an exhaustive search of the neighborhood and we want the best neighbor of all.

      To do that we need to evaluate the current-neighbor (that we'll have in the variable ops-list in the form of the neighborhood-operations that should be applied to the current-solution to get the neighbor.)  For that we could use the function =delta-cost=.

      But as we want the best neighbor, everytime we compute the delta-cost for a client, we need to compare it with the current best neighbor.  If the new one is better, then let's update things.

      It could be something like this:

      #+BEGIN_EXAMPLE 
      (doselect-route (r1 wc)
        (doselect-client (c1 r1 wc)
          (doinsert-client (c1 r1 wc)

            ;; ==== this is the new stuff ==== ;;

            ;; let's get the cost of the current neighbor
            (setf current-delta-cost
                  (delta-cost ops-list wc problem action))
            ;; let's see if it is better
            (if (< current-delta-cost best-delta-cost)
                ;; if it is, set the best values 
                ;; and stop the iterations
                (then
                  ;; let's save the ops that make it
                  (setf best-neighbor (clone ops-list))
                  ;; let's update the best-cost
                  (setf best-delta-cost current-delta-cost)
                  ;; let's stop the iteration
                  (stop-neighborhood-search)))
            ;; ==== end of the new stuff ==== ;;
           )))
      #+END_EXAMPLE

      So, this way, when we exit the do-neighborhood-operation macros we have in best-neighbor the operations from where we can construct the best neighbor, and in best-delta-cost we have the delta-cost of this neighbor.

      The next thing to define is what to do when the exploration ends.  We'll address that point in the next section.
     
***** 4. what to do when the exploration is over
      Here, we should decide what to do when the exploration is over.  In this case of first-improvement, it is the same as in the best-improvement, because, the change happened inside the do-neighborhood macros.  

      What we do here is the same: if the best-delta-cost is smaller than 0, then we have a better solution than the current one, and that's what we should return.  Otherwise we should return nil.

      In the code it would be something like:

      #+BEGIN_EXAMPLE 
      (doselect-route (r1 wc)
        (doselect-client (c1 r1 wc)
          (doinsert-client (c1 r1 wc)
            ;; let's get the cost of the current neighbor
            (setf current-delta-cost
                  (delta-cost ops-list wc problem action))
            ;; let's see if it is better
            (if (< current-delta-cost best-delta-cost)
                ;; if it is, set the best values 
                ;; and stop the iterations
                (then
                  ;; let's save the ops that make it
                  (setf best-neighbor (clone ops-list))
                  ;; let's update the best-cost
                  (setf best-delta-cost current-delta-cost)
                  ;; let's stop the iteration
                  (stop-neighborhood-search))))))

      ======== from here on is the new stuff ========     
      ;; here we check if we found a neighbor better than solution
      ;; if so, we apply the operations in best-neighbor to solution
      ;; and return the best-neighbor
      ;; otherwise, we return nil
      ;; and that means that we didn't find a better neighbor

      (if best-neighbor
          (then
            (apply-set-of-operations (reverse best-neighbor) wc)
            (setf best-neighbor-as-solution
                  (solution wc))
            ;; return best-neighbor-as-solution
            ;; and the best-delta-cost
            (values best-neighbor-as-solution best-delta-cost)))
      ======== here ends the new stuff ========
      #+END_EXAMPLE

      Obviously, to do that, we need to initialize several things, and what we need to initialize depends on the strategy we want to use.  We talk about that in the next section.
***** 1. what do we need to initialize things

      To use an exhaustive search of the neighborhood and return the first neighbor better than the current solution, we need to initialize the following:

        - best-delta-cost (to 0, that means no improvement)
        - best-neighbor (to nil)
        - best-neighbor-as-solution (to nil)
        - current-delta-cost (to avoid warnings)

      And there are some things that should be initialized in any strategy:

        - the ops-list (to nil)
        - *vrp-stop-neighborhood-search* to nil
        - we should also create a working-copy from the solution
          or initialize the working-copy, depending on what we want to pass around as arguments.

          So the initializations for the criterion =rab= with an exhaustive search (assuming that the user passes a solution as argument) could look like:

         
      #+BEGIN_EXAMPLE
      ===== here is the new stuff =====
      (let* (;; first the standard initializations
             (*vrp-stop-neighborhood-search* nil)
             (ops-list nil)
             (wc (basic-working-copy solution))
             ;; now the corresponding to the
             ;; best-improvement strategy
             (current-delta-cost 0)
             (best-delta-cost 0)
             (best-neighbor nil)
             (best-neighbor-as-solution nil)
             )

        (prepare-solution-for-neighborhood-exploration wc)

       ===== here ends the new stuff =====
     
        (doselect-route (r1 wc)
          (doselect-client (c1 r1 wc)
            (doinsert-client (c1 r1 wc))
              ;; let's get the cost of the current neighbor
              (setf current-delta-cost
                    (delta-cost ops-list wc problem action)
              ;; let's see if it is better
              (if (< current-delta-cost best-delta-cost)
                  ;; if it is
                  (then
                     ;; let's save the ops that make it
                     (setf best-neighbor (clone ops-list))
                     ;; let's update the best-cost
                     (setf best-delta-cost current-delta-cost))))))
  
        ;; here we check if we found a neighbor better than solution
        ;; if so, we apply the operations in best-neighbor to solution
        ;; and return the best-neighbor
        ;; otherwise, we return nil
        ;; and that means that we didn't find a better neighbor
  
        (if best-neighbor
          (then
            (apply-set-of-operations (reverse best-neighbor) wc)
            (setf best-neighbor-as-solution
                  (solution wc))
            ;; return best-neighbor-as-solution
            ;; and the best-delta-cost
            (values best-neighbor-as-solution best-delta-cost))))
      #+END_EXAMPLE
      
     In the next sections, we'll write a working code for this criterion and run some tests.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defun rab-exhaustive-first (solution problem action)
       "Returns the first neighbor of the solution in wc, that is better that wc.."
       (let* ( ;; first the standard initializations
              (*vrp-stop-neighborhood-search* nil)
              (wc (basic-working-copy solution))
              (ops-list nil)
              ;; now the corresponding to the
              ;; best-improvement strategy
              (current-delta-cost 0)
              (best-delta-cost 0)
              (best-neighbor nil)
              (best-neighbor-as-solution nil)
              )
         (prepare-solution-for-neighborhood-exploration wc)
         (initialize-action-for-delta-cost-computation wc problem action)

         (doselect-route (r1 wc)
           (doselect-client (c1 r1 wc)
             (doinsert-client (c1 r1 wc)
               ;; let's get the cost of the current neighbor
               (setf current-delta-cost
                     (delta-cost (reverse ops-list) wc problem action))

               (format t "~%With delta-cost: ~a~%" current-delta-cost)
               (pp-solution wc t) (terpri)

               ;; let's see if it is better
               (if (< current-delta-cost best-delta-cost)
                   ;; if it is, set the best values 
                   ;; and stop the iterations
                   (then
                     ;; let's save the ops that make it
                     (setf best-neighbor (clone ops-list))
                     ;; let's update the best-cost
                     (setf best-delta-cost current-delta-cost)
                     ;; let's stop the iteration
                     (stop-neighborhood-search))))))

         ;; here we check if we found a neighbor better than solution
         ;; if so, we apply the operations in best-neighbor to solution
         ;; and return the best-neighbor
         ;; otherwise, we return nil
         ;; and that means that we didn't find a better neighbor

         (if best-neighbor
             (then
               (apply-set-of-operations (reverse best-neighbor) wc)
               (setf best-neighbor-as-solution
                     (solution wc))
               (setf (cost best-neighbor-as-solution)
                     (+ (cost solution)
                        best-delta-cost))))

         ;; return best-neighbor-as-solution
         ;; and the best-delta-cost
         (values best-neighbor-as-solution
                 best-delta-cost)))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                            :demands '(10 10 15 40 20)
                            :capacity 40)
       (with-basic-cvrp-solution (s1 ((3 2 4) (1 5)) p1)
         (let* ((best-solution-found nil)
                (best-cost-found 0)
                (wc0 (basic-working-copy s1))
                (wc2 nil)
                (action (delta-cvrp-action))
                (cvrp-action (basic-cvrp-action)))



           (bformat t "Testing exhaustive/best-improvement rab")

           ;; let's evaluate the solution

           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Distance: ~a, penalty: ~a, cost: ~a~%"
                   (total-distance cvrp-action)
                   (total-penalty cvrp-action)
                   (cost s1))

           (prepare-solution-for-neighborhood-exploration wc0)

           (format t "~%Testing exhaustive rab (first)...~%")
           (pp-solution wc0 t)

           ;;{{{ let's explore the neighborhood rarb
           (setf best-solution-found
                 (rab-exhaustive-first s1 p1 action))
           ;;}}}


           (if best-solution-found
               (then
                 ;;{{{ print the best neighbor
                 ;; (format t "Best value: ~a~%" (cost best-solution-found))
                 (format t "------------------~%Best neighbor:~%")
                 (setf wc2 (basic-working-copy best-solution-found))
                 (prepare-solution-for-neighborhood-exploration wc2)
                 (pp-solution wc2 t) (terpri)


                 (format t "with cost: ~a~%" (cost wc2))
                 (format t "------------------~%")
                 ;;}}}

                 ;; ;;{{{ using yoel approach
                 ;; (format t "Cost of original solution: ~a~%"
                 ;;         (solution-cost s1 p1 cvrp-action))
                 ;; (format t "Cost of best-neighbor: ~a~%"
                 ;;         (solution-cost best-solution-found
                 ;;                        p1 cvrp-action))
                 ;; ;;}}}
                 )
               (else
                 (format t "No better solution found in neighbor.~%")))

           )))
     #+END_SRC
*** create a jump-around (return the last solution) search for rab
**** description

     In this section I want to create a function that jumps around the neighborhood =*n*= times the neighborhood =rab= and inconditionally returns the last solution found.

     The final code should be the following.
**** code
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (defun jump-around-rab (solution problem action repetitions)
       (let* (;; first the standard initializations
             (*vrp-stop-neighborhood-search* nil)
             (ops-list nil)
             (wc (basic-working-copy solution))
             (current-delta-cost 0)
             ;; now the corresponding to the
             ;; jump-around strategy
             (cumulative-delta-cost 0)
             )

         (prepare-solution-for-neighborhood-exploration wc)

         (loop for i from 1 to repetitions
               while (not *vrp-stop-neighborhood-search*)
               do (prepare-solution-for-neighborhood-exploration wc)
               do (random-select-route (r1 wc)
                    (random-select-client (c1 r1 wc)
                      (random-insert-client (c1 r1 wc)
                        ;; let's compute the delta-cost
                        (setf current-delta-cost
                              (delta-cost (reverse ops-list)
                                          wc problem action))
                        ;; let's update the cumulative-delta-cost
                        (incf cumulative-delta-cost
                              current-delta-cost)

                        (format t "current-delta-cost: ~a, cumulative: ~a~%"
                                current-delta-cost
                                cumulative-delta-cost)

                        ;; let's apply the operations
                        (apply-set-of-operations
                         (reverse ops-list) wc)

                        ;; let's update the solution cost
                        (setf (cost wc) 
                              (+ (cost wc)
                                 (+ (delta-distance action)
                                    (total-penalty action))))


                        (format t "      solution cost: ~a~%"
                                (cost wc))
                        ))))
         ;; after we leave the loop
         ;; we should return the cumulative-solution
         ;; and the cumulative-delta-cost
         ;; The cumulative solution is the one in the wc
         ;; and the cumulative cost is the one we have
         ;; computed.
         (values (solution wc) cumulative-delta-cost)))
     #+END_SRC

     #+RESULTS:

**** tests with toy problem
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                            :demands '(10 10 15 40 20)
                            :capacity 40)
       (with-basic-cvrp-solution (s1 ((3 2 4) (1 5)) p1)
         (let* ((cumulative-solution-found nil)
                (cumulative-delta-cost 0)
                (wc0 (basic-working-copy s1))
                (wc2 nil)
                (action (delta-cvrp-action))
                (cvrp-action (basic-cvrp-action)))



           (bformat t "Testing jump-around rab")

           ;; let's evaluate the solution

           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Distance: ~a, penalty: ~a, cost: ~a~%"
                   (total-distance cvrp-action)
                   (total-penalty cvrp-action)
                   (cost s1))

           (prepare-solution-for-neighborhood-exploration wc0)

           (format t "~%Testing jump-around rab with solution...~%")
           (pp-solution wc0 t)

           ;;{{{ let's explore the neighborhood rarb
           (setf (values cumulative-solution-found
                         cumulative-delta-cost)
                 (jump-around-rab s1 p1 action 10))
           ;;}}}


           (if cumulative-solution-found
               (then
                 ;;{{{ print the best neighbor
                 ;; (format t "Best value: ~a~%" (cost best-solution-found))
                 (format t "------------------~%Cumulative neighbor:~%")
                 (setf wc2 (basic-working-copy cumulative-solution-found))
                 (prepare-solution-for-neighborhood-exploration wc2)
                 (pp-solution wc2 t) (terpri)


                 (format t "with cumulative cost: ~a~%" (cost wc2))
                 (format t "------------------~%")
                 ;;}}}

                 ;; ;;{{{ using yoel approach
                 ;; (format t "Cost of original solution: ~a~%"
                 ;;         (solution-cost s1 p1 cvrp-action))
                 ;; (format t "Cost of best-neighbor: ~a~%"
                 ;;         (solution-cost best-solution-found
                 ;;                        p1 cvrp-action))
                 ;; ;;}}}
                 )
               (else
                 (format t "No better solution found in neighborhood.~%")))

           )))
     #+END_SRC
**** tests with a-n33-k6
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n33-k6-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (cumulative-solution-found nil)
            (cumulative-delta-cost 0)
            (wc0 (basic-working-copy s1))
            (wc2 nil)
            (action (delta-cvrp-action))
            (cvrp-action (basic-cvrp-action)))



       (bformat t "Testing jump-around rab")

       ;; let's evaluate the solution

       (simulate-solution s1 p1 cvrp-action)
       (setf (cost s1) (+ (total-distance cvrp-action)
                          (total-penalty cvrp-action)))

       (format t "Distance: ~a, penalty: ~a, cost: ~a~%"
               (total-distance cvrp-action)
               (total-penalty cvrp-action)
               (cost s1))

       (prepare-solution-for-neighborhood-exploration wc0)

       (format t "~%Testing jump-around rab with solution...~%")
       (pp-solution wc0 t)

       ;;{{{ let's explore the neighborhood rarb
       (setf (values cumulative-solution-found
                     cumulative-delta-cost)
             (jump-around-rab s1 p1 action 20))
       ;;}}}


       (if cumulative-solution-found
           (then
             ;;{{{ print the best neighbor
             ;; (format t "Best value: ~a~%" (cost best-solution-found))
             (format t "------------------~%Cumulative neighbor:~%")
             (setf wc2 (basic-working-copy cumulative-solution-found))
             (prepare-solution-for-neighborhood-exploration wc2)
             (pp-solution wc2 t) (terpri)


             (format t "with cumulative cost: ~a (~a)~%"
                     (cost wc2)
                     (cond ((> cumulative-delta-cost 0) "worse")
                           ((< cumulative-delta-cost 0) "better")
                           (t "equal")))
        
             (format t "------------------~%")
             ;;}}}

             ;; ;;{{{ using yoel approach
             ;; (format t "Cost of original solution: ~a~%"
             ;;         (solution-cost s1 p1 cvrp-action))
             ;; (format t "Cost of best-neighbor: ~a~%"
             ;;         (solution-cost best-solution-found
             ;;                        p1 cvrp-action))
             ;; ;;}}}
             )
           (else
             (format t "No better solution found in neighborhood.~%")))

       )
     #+END_SRC
*** create a jump-around-rab (return the last and best solution)
**** description

     In this section I want to create a function that jumps around the neighborhood =*n*= times the neighborhood =rab= and inconditionally returns the last solution found.  If also returns the best of all the solutions with a delta-cost smaller than 0.

     The final code should be the following.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-tests.lisp 
     (defun jump-around-rab-best (solution problem action repetitions)
       (let* (;; first the standard initializations
             (*vrp-stop-neighborhood-search* nil)
             (ops-list nil)
             (wc (basic-working-copy solution))
             (current-delta-cost 0)
             ;; now the corresponding to the
             ;; jump-around strategy
             (cumulative-delta-cost 0)
             ;; the corresponding to the find the best better solution
             (best-neighbor-as-solution nil)
             (best-delta-cost 0)
             (how-many-better 0)
             )

         (loop for i from 1 to repetitions
               while (not *vrp-stop-neighborhood-search*)
               do (prepare-solution-for-neighborhood-exploration wc)
               do (random-select-route (r1 wc)
                    (random-select-client (c1 r1 wc)
                      (random-insert-client (c1 r1 wc)
                        ;; let's compute the delta-cost
                        (setf current-delta-cost
                              (delta-cost (reverse ops-list)
                                          wc problem action))
                        ;; let's update the cumulative-delta-cost
                        (incf cumulative-delta-cost
                              current-delta-cost)

                        ;; let's apply the operations
                        (apply-set-of-operations
                         (reverse ops-list) wc)

                        ;; let's update the solution cost
                        (setf (cost wc) 
                              (+ (cost wc)
                                 (+ (delta-distance action)
                                    (total-penalty action))))



                        ;; let's check for the best better solution
                        (if (< current-delta-cost best-delta-cost)
                            (then ;; we found a best-better-solution

                              (format t "found a better-best-better!!!~%")

                              (incf how-many-better)

                              (setf best-neighbor-as-solution
                                    (clone (solution wc)))
                              ;; we don't need to update the cost
                              ;; of the best solution
                              ;; because it was already done before.


                              ;; the best-delta-cost is now 0
                              ;; because the current-neighbor
                              ;; is updated
                              (setf best-delta-cost 0))
                            (else ;; we need to update the best-delta-cost
                              (incf best-delta-cost
                                    (- current-delta-cost))))

                        (format t "current ~a, cumulative: ~a, best: ~a"
                                current-delta-cost
                                cumulative-delta-cost
                                best-delta-cost)
                        (format t ". cost: ~a~%"
                                 (cost wc))


                        ))))
         ;; after we leave the loop
         ;; we should return the cumulative-solution
         ;; and the cumulative-delta-cost
         ;; The cumulative solution is the one in the wc
         ;; and the cumulative cost is the one we have
         ;; computed.
         (values (solution wc)
                 cumulative-delta-cost
                 best-neighbor-as-solution
                 how-many-better)))
     #+END_SRC

     
**** tests with toy problem
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                            :demands '(10 10 15 40 20)
                            :capacity 40)
       (with-basic-cvrp-solution (s1 ((3 2 4) (1 5)) p1)
         (let* ((cumulative-solution-found nil)
                (cumulative-delta-cost 0)
                (best-better-solution nil)
                (wc0 (basic-working-copy s1))
                (wc2 nil)
                (action (delta-cvrp-action))
                (cvrp-action (basic-cvrp-action)))



           (bformat t "Testing jump-around rab")

           ;; let's evaluate the solution

           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Distance: ~a, penalty: ~a, cost: ~a~%"
                   (total-distance cvrp-action)
                   (total-penalty cvrp-action)
                   (cost s1))

           (prepare-solution-for-neighborhood-exploration wc0)

           (format t "~%Testing jump-around rab with solution...~%")
           (pp-solution wc0 t)

           ;;{{{ let's explore the neighborhood rarb
           (setf (values cumulative-solution-found
                         cumulative-delta-cost
                         best-better-solution)
                 (jump-around-rab-best s1 p1 action 10))
           ;;}}}


           (if cumulative-solution-found
               (then
                 ;;{{{ print the best neighbor
                 ;; (format t "Best value: ~a~%" (cost best-solution-found))
                 (format t "------------------~%Cumulative neighbor:~%")
                 (setf wc2 (basic-working-copy cumulative-solution-found))
                 (prepare-solution-for-neighborhood-exploration wc2)
                 (pp-solution wc2 t) (terpri)


                 (format t "with cumulative cost: ~a~%" (cost wc2))
                 (format t "------------------~%")
                 ;;}}}

                 ;; ;;{{{ using yoel approach
                 ;; (format t "Cost of original solution: ~a~%"
                 ;;         (solution-cost s1 p1 cvrp-action))
                 ;; (format t "Cost of best-neighbor: ~a~%"
                 ;;         (solution-cost best-solution-found
                 ;;                        p1 cvrp-action))
                 ;; ;;}}}
                 )
               (else
                 (format t "No better solution found in neighborhood.~%")))

           (if best-better-solution
               (format t "Found a better solution with cost ~a~%"
                       (cost best-better-solution))
               ;; else
               (format t "All neighbors were worse."))

           )))
     #+END_SRC
**** tests with a-n33-k6
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n33-k6-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (cumulative-solution-found nil)
            (cumulative-delta-cost 0)
            (best-better-solution nil)
            (how-many-better 0)

            (wc0 (basic-working-copy s1))
            (wc2 nil)
            (action (delta-cvrp-action))
            (cvrp-action (basic-cvrp-action)))



       (bformat t "Testing jump-around rab")

       ;; let's evaluate the solution

       (simulate-solution s1 p1 cvrp-action)
       (setf (cost s1) (+ (total-distance cvrp-action)
                          (total-penalty cvrp-action)))

       (format t "Distance: ~a, penalty: ~a, cost: ~a~%"
               (total-distance cvrp-action)
               (total-penalty cvrp-action)
               (cost s1))

       (prepare-solution-for-neighborhood-exploration wc0)

       ;; (format t "~%Testing jump-around rab with solution...~%")
       ;; (pp-solution wc0 t)
       (format t "-----------------~2%")

       ;;{{{ let's explore the neighborhood rarb
       (setf (values cumulative-solution-found
                     cumulative-delta-cost
                     best-better-solution
                     how-many-better)
             (jump-around-rab-best s1 p1 action 10))
       ;;}}}


       (if cumulative-solution-found
           (then
             ;;{{{ print the best neighbor
             ;; (format t "Best value: ~a~%" (cost best-solution-found))
             (format t "------------------~%Cumulative neighbor:~%")
             (setf wc2 (basic-working-copy cumulative-solution-found))
             (prepare-solution-for-neighborhood-exploration wc2)
             (pp-solution wc2 t) (terpri)


             (format t "with cumulative cost: ~a (~a)~%"
                     (cost wc2)
                     (cond ((> cumulative-delta-cost 0) "worse")
                           ((< cumulative-delta-cost 0) "better")
                           (t "equal")))

             (format t "------------------~%")
             ;;}}}

             ;; ;;{{{ using yoel approach
             ;; (format t "Cost of original solution: ~a~%"
             ;;         (solution-cost s1 p1 cvrp-action))
             ;; (format t "Cost of best-neighbor: ~a~%"
             ;;         (solution-cost best-solution-found
             ;;                        p1 cvrp-action))
             ;; ;;}}}
             )
           (else
             (format t "No better solution found in neighborhood.~%")))

       (if best-better-solution
           (format t "Found ~a better solution, the best one with cost ~a~%"
                   how-many-better (cost best-better-solution))
           ;; else
           (format t "All neighbors were worse.~%"))

       )
     #+END_SRC
*** create a return-last-neighbor-rab (return the last-neighbor)
**** description

     In this section I want to create a function that explores a neighborhood and returns the last visited neighbor.

**** code
     #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-tests.lisp 
     (defun return-last-neighbor-rab
         (solution problem action repetitions)
       (let* (;; first the standard initializations
             (*vrp-stop-neighborhood-search* nil)
             (ops-list nil)
             (wc (basic-working-copy solution))
             (current-delta-cost 0)
             (best-delta-cost 0)
             (best-neighbor nil)
             (best-neighbor-as-solution nil)
             )

         (loop for i from 1 to repetitions
               while (not *vrp-stop-neighborhood-search*)
               do (prepare-solution-for-neighborhood-exploration wc)
               do (random-select-route (r1 wc)
                    (random-select-client (c1 r1 wc)
                      (random-insert-client (c1 r1 wc)
                        ;; let's compute the delta-cost
                        (setf current-delta-cost
                              (delta-cost (reverse ops-list)
                                          wc problem action))
                        ;; let's inconditionally set the
                        ;; current neighbor as the best-neighbor
                        (setf best-neighbor (clone (reverse ops-list)))
                        (setf best-delta-cost current-delta-cost)
                        (format t "current ~a, best: ~a~%"
                                current-delta-cost
                                best-delta-cost)
                        ))))

         ;; after we leave the loop we return the best neighbor
         (if best-neighbor
             (then
               (apply-set-of-operations best-neighbor wc)
               (setf best-neighbor-as-solution
                     (solution wc))
               (setf (cost best-neighbor-as-solution)
                     (+ (cost solution)
                        best-delta-cost))
               ;; return best-neighbor-as-solution
               (values best-neighbor-as-solution
                       best-delta-cost)))))
     #+END_SRC
**** tests with a-n33-k6
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n33-k6-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (last-solution nil)
            (last-cost 0)

            (wc0 (basic-working-copy s1))
            ;; (wc2 nil)
            (action (delta-cvrp-action))
            (cvrp-action (basic-cvrp-action)))



       (bformat t "Testing jump-around rab")

       ;; let's evaluate the solution

       (simulate-solution s1 p1 cvrp-action)
       (setf (cost s1) (+ (total-distance cvrp-action)
                          (total-penalty cvrp-action)))

       (format t "Distance: ~a, penalty: ~a, cost: ~a~%"
               (total-distance cvrp-action)
               (total-penalty cvrp-action)
               (cost s1))

       (prepare-solution-for-neighborhood-exploration wc0)

       ;; (format t "~%Testing jump-around rab with solution...~%")
       ;; (pp-solution wc0 t)
       (format t "-----------------~2%")

       ;;{{{ let's explore the neighborhood rarb
       (setf (values last-solution
                     last-cost)
             (return-last-neighbor-rab s1 p1 action 10))
       ;;}}}


       (if last-solution
           (then
             ;;{{{ print the last neighbor
             (format t "------------------~%Last neighbor:~%")
             (pp-solution last-solution t) (terpri)


             (format t "with delta-cost: ~a~%"
                     (cost last-solution))

             (format t "------------------~%")
             ;;}}}
             )
           (else
             (format t "No better solution found in neighborhood.~%"))))
     #+END_SRC
*** create a smart swap-clients (return the best-neighbor)
**** description

     In this section I want to create a function that explores the swap-clients neighborhood and does not repeat any neighbor :-o.  It will return the best-improvement.

**** code
     #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-tests.lisp 
     (defun smart-rarac (solution problem action)

       (declare (ignorable problem action))
       (let* (;; first the standard initializations
             (*vrp-stop-neighborhood-search* nil)
             (ops-list nil)
             (wc (basic-working-copy solution))
             ;; now the corresponding to the
             ;; best-improvement strategy
             (counter 1)
             ;; (current-delta-cost 0)
             ;; (best-delta-cost 0)
             ;; (best-neighbor nil)
             ;; (best-neighbor-as-solution nil)
             )

         (prepare-solution-for-neighborhood-exploration wc)

         (doselect-route (r1 wc)
           (doselect-client2 (c1 r1 wc)
             (doselect-route (r2 wc :ge r1)
               (doselect-client2 (c2 r2 wc :ge (list r1 c1.select.position))
                 (doswap-clients (c1 c2 wc)
                   ;; for now let's just pp the solution
                   (format t "Solution #~a after swapping c~a (~a ~a) and c~a (~a ~a):~%"
                             counter
                             (id (client-selected-at-operation c1 wc))
                             c1.route c1.select.position
                             (id (client-selected-at-operation c2 wc))
                             c2.route c2.select.position)
                   (pp-solution wc t) (terpri)
                   (incf counter)
                   )))))))
     #+END_SRC
**** tests with small problem
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                                         :demands '(10 10 15 40 20)
                                         :capacity 40)
       (with-basic-solution (s1 ((2 4 5) (3 1 6)))
         (let* ((best-solution-exhaustive nil)
                (action (delta-cvrp-action))
                (results nil)
                (cvrp-action (basic-cvrp-action 
                              :penalty-factor 1000))
                (wc (basic-working-copy s1))
                )

           (declare (ignore results
                            cvrp-action best-solution-exhaustive))

           (prepare-solution-for-neighborhood-exploration wc)

           (bformat t "Testing smart rarac")


           (format t "Original solution:~%")
           (pp-solution s1 t)

           (funcall 'smart-rarac s1 p1 action)


               )))
     #+END_SRC
     
**** tests with a-n33-k6
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (let* ((p1 a-n33-k6-problem)
            (s1 (make-initial-solution-for-cvrp-deterministic p1))
            (last-solution nil)
            (last-cost 0)

            (wc0 (basic-working-copy s1))
            ;; (wc2 nil)
            (action (delta-cvrp-action))
            (cvrp-action (basic-cvrp-action)))



       (bformat t "Testing jump-around rab")

       ;; let's evaluate the solution

       (simulate-solution s1 p1 cvrp-action)
       (setf (cost s1) (+ (total-distance cvrp-action)
                          (total-penalty cvrp-action)))

       (format t "Distance: ~a, penalty: ~a, cost: ~a~%"
               (total-distance cvrp-action)
               (total-penalty cvrp-action)
               (cost s1))

       (prepare-solution-for-neighborhood-exploration wc0)

       ;; (format t "~%Testing jump-around rab with solution...~%")
       ;; (pp-solution wc0 t)
       (format t "-----------------~2%")

       ;;{{{ let's explore the neighborhood rarb
       (setf (values last-solution
                     last-cost)
             (return-last-neighbor-rab s1 p1 action 10))
       ;;}}}


       (if last-solution
           (then
             ;;{{{ print the last neighbor
             (format t "------------------~%Last neighbor:~%")
             (pp-solution last-solution t) (terpri)


             (format t "with delta-cost: ~a~%"
                     (cost last-solution))

             (format t "------------------~%")
             ;;}}}
             )
           (else
             (format t "No better solution found in neighborhood.~%"))))
     #+END_SRC
*** using the macros*
**** description
     In this section I want to explore the neighborhood =rab= using the macros* (these macros* are the ones that after each op-simulation, they update the delta-cost).  I also want to use a best-improvement strategy.

     As a first approach I'm going to handwrite it.

     All right, I did it.  Let's analyze what happened.

     After all the call to the macros we need to add a finish-delta-cost-computation and after everything else, we need to add an undo-delta-cost-computation.  Besides, we need to bind current-delta-cost to the result of a call to get-delta-cost-from-action, and then do everything else that we want.

     After checking what every class do, I believe that the idea is to add two more classes: one for the computation of the delta-cost with the "old style" call to =delta-cost=, and another to use the * version of the macros.  These two classes should inherit from =search-with-delta-cost-computation= because this is the one that adds the current-delta-cost to the let-initializations and I don't want to duplicate that code.

     I just discovered that probably we'll need another search-strategy class that inherits from exhaustive-search and maps the name of the * macros to the corresponding name.  I'll add that class now.
     
**** code
***** smart*-rab
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-tests.lisp 
      (defun smart*-rab (solution problem action)

        ;; (declare (ignorable problem action))
        (let* (;; first the standard initializations
              (*vrp-stop-neighborhood-search* nil)
              (ops-list nil)
              (wc (basic-working-copy solution))
              ;; now the corresponding to the
              ;; best-improvement strategy
              ;; (counter 1)
              (current-delta-cost 0)
              (best-delta-cost most-positive-fixnum)
              (best-neighbor nil)
              (best-neighbor-as-solution nil)
              )

          (prepare-solution-for-neighborhood-exploration wc)
          (initialize-action-for-delta-cost-computation wc problem action)

          (doselect-route* (r1 wc)
            (doselect-client* (c1 r1 wc)
              (doinsert-client* (c1 r1 wc)

                ;; here we only need to finish the delta-cost
                ;; computation because each step where made in the
                ;; corresponding macros*

                (finish-delta-cost-computation wc problem action)

                ;; now we need to store the delta-cost of the
                ;; current neighbor and store it current-delta-cost.

                (setf current-delta-cost
                      (get-delta-cost-from-action action))


                ;; here we need to undo the finish-delta-cost-computation
                ;; so we can keep going with the exploration

                (undo-finish-delta-cost-computation wc problem action)

                ;; from here on we repeat what we have
                ;; in the standard best-improvement strategy
                ;; let's see if it is better
                (if (< current-delta-cost best-delta-cost)
                    ;; if it is
                    (then
                      ;; let's save the ops that make it
                      (setf best-neighbor (clone ops-list))
                      ;; let's update the best-cost
                      (setf best-delta-cost current-delta-cost)))


                ;; (incf counter)
                ;; (format t "#~a: ~a ~10t~%"
                ;;         counter current-delta-cost)
                ;; (pp-route 1 wc t) (terpri)

                )))

          ;; here we are outside the macros,
          ;; so we just need to build and return
          ;; the best neighbor
          ;; here we check if we found a neighbor better than solution
          ;; if so, we apply the operations in best-neighbor to solution
          ;; and return the best-neighbor
          ;; otherwise, we return nil
          ;; and that means that we didn't find a better neighbor

          (if best-neighbor
              (then
                (apply-set-of-operations (reverse best-neighbor) wc)
                (setf best-neighbor-as-solution
                      (solution wc))
                (setf (cost best-neighbor-as-solution)
                      (+ (cost solution)
                         best-delta-cost))
                ;; return best-neighbor-as-solution
                (values best-neighbor-as-solution
                        best-delta-cost)))

          ))
      #+END_SRC
     
***** just-rab
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-tests.lisp 
      (defun just-rab (solution problem action)

        ;; (declare (ignorable problem action))
        (let* (;; first the standard initializations
              (*vrp-stop-neighborhood-search* nil)
              (ops-list nil)
              (wc (basic-working-copy solution))
              ;; now the corresponding to the
              ;; best-improvement strategy
              ;; (counter 1)
              (current-delta-cost 0)
              (best-delta-cost most-positive-fixnum)
              (best-neighbor nil)
              (best-neighbor-as-solution nil)
              )

          (prepare-solution-for-neighborhood-exploration wc)
          ;; (initialize-action-for-delta-cost-computation wc problem action)

          (doselect-route (r1 wc)
            (doselect-client (c1 r1 wc)
              (doinsert-client (c1 r1 wc)

                ;; now we need to store the delta-cost of the
                ;; current neighbor and store it current-delta-cost.

                (setf current-delta-cost
                      (delta-cost (reverse ops-list) wc problem action))


                ;; from here on we repeat what we have
                ;; in the standard best-improvement strategy
                ;; let's see if it is better
                (if (< current-delta-cost best-delta-cost)
                    ;; if it is
                    (then
                      ;; let's save the ops that make it
                      (setf best-neighbor (clone ops-list))
                      ;; let's update the best-cost
                      (setf best-delta-cost current-delta-cost)))


                ;; (incf counter)
                ;; (format t "#~a: ~a ~10t~%"
                ;;         counter current-delta-cost)
                ;; (pp-route 1 wc t) (terpri)

                )))

          ;; here we are outside the macros,
          ;; so we just need to build and return
          ;; the best neighbor
          ;; here we check if we found a neighbor better than solution
          ;; if so, we apply the operations in best-neighbor to solution
          ;; and return the best-neighbor
          ;; otherwise, we return nil
          ;; and that means that we didn't find a better neighbor

          (if best-neighbor
              (then
                (apply-set-of-operations (reverse best-neighbor) wc)
                (setf best-neighbor-as-solution
                      (solution wc))
                (setf (cost best-neighbor-as-solution)
                      (+ (cost solution)
                         best-delta-cost))
                ;; return best-neighbor-as-solution
                (values best-neighbor-as-solution
                        best-delta-cost)))

          ))
      #+END_SRC
     
***** smart*-ref
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-tests.lisp 
      (defun smart*-ref (solution problem action)

        ;; (declare (ignorable problem action))
        (let* (;; first the standard initializations
              (*vrp-stop-neighborhood-search* nil)
              (ops-list nil)
              (wc (basic-working-copy solution))
              ;; now the corresponding to the
              ;; best-improvement strategy
              ;; (counter 1)
              (current-delta-cost 0)
              (best-delta-cost most-positive-fixnum)
              (best-neighbor nil)
              (best-neighbor-as-solution nil)
              )

          (prepare-solution-for-neighborhood-exploration wc)
          (initialize-action-for-delta-cost-computation wc problem action)

          (doselect-route* (r1 wc)
            (doselect-subroute* (c1 r1 wc)
              (doinsert-subroute* (c1 r1 wc)

                ;; here we only need to finish the delta-cost
                ;; computation because each step where made in the
                ;; corresponding macros*

                (finish-delta-cost-computation wc problem action)

                ;; now we need to store the delta-cost of the
                ;; current neighbor and store it current-delta-cost.

                (setf current-delta-cost
                      (get-delta-cost-from-action action))


                ;; here we need to undo the finish-delta-cost-computation
                ;; so we can keep going with the exploration

                (undo-finish-delta-cost-computation wc problem action)

                ;; from here on we repeat what we have
                ;; in the standard best-improvement strategy
                ;; let's see if it is better
                (if (< current-delta-cost best-delta-cost)
                    ;; if it is
                    (then
                      ;; let's save the ops that make it
                      (setf best-neighbor (clone ops-list))
                      ;; let's update the best-cost
                      (setf best-delta-cost current-delta-cost)))


                ;; (incf counter)
                ;; (format t "#~a: ~a ~10t~%"
                ;;         counter current-delta-cost)
                ;; (pp-route 1 wc t) (terpri)

                )))

          ;; here we are outside the macros,
          ;; so we just need to build and return
          ;; the best neighbor
          ;; here we check if we found a neighbor better than solution
          ;; if so, we apply the operations in best-neighbor to solution
          ;; and return the best-neighbor
          ;; otherwise, we return nil
          ;; and that means that we didn't find a better neighbor

          (if best-neighbor
              (then
                (apply-set-of-operations (reverse best-neighbor) wc)
                (setf best-neighbor-as-solution
                      (solution wc))
                (setf (cost best-neighbor-as-solution)
                      (+ (cost solution)
                         best-delta-cost))
                ;; return best-neighbor-as-solution
                (values best-neighbor-as-solution
                        best-delta-cost)))

          ))
      #+END_SRC
     
***** just-rab
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-tests.lisp 
      (defun just-ref (solution problem action)

        ;; (declare (ignorable problem action))
        (let* (;; first the standard initializations
              (*vrp-stop-neighborhood-search* nil)
              (ops-list nil)
              (wc (basic-working-copy solution))
              ;; now the corresponding to the
              ;; best-improvement strategy
              ;; (counter 1)
              (current-delta-cost 0)
              (best-delta-cost most-positive-fixnum)
              (best-neighbor nil)
              (best-neighbor-as-solution nil)
              )

          (prepare-solution-for-neighborhood-exploration wc)
          ;; (initialize-action-for-delta-cost-computation wc problem action)

          (doselect-route (r1 wc)
            (doselect-subroute (c1 r1 wc)
              (doinsert-subroute (c1 r1 wc)

                ;; now we need to store the delta-cost of the
                ;; current neighbor and store it current-delta-cost.

                (setf current-delta-cost
                      (delta-cost (reverse ops-list) wc problem action))


                ;; from here on we repeat what we have
                ;; in the standard best-improvement strategy
                ;; let's see if it is better
                (if (< current-delta-cost best-delta-cost)
                    ;; if it is
                    (then
                      ;; let's save the ops that make it
                      (setf best-neighbor (clone ops-list))
                      ;; let's update the best-cost
                      (setf best-delta-cost current-delta-cost)))


                ;; (incf counter)
                ;; (format t "#~a: ~a ~10t~%"
                ;;         counter current-delta-cost)
                ;; (pp-route 1 wc t) (terpri)

                )))

          ;; here we are outside the macros,
          ;; so we just need to build and return
          ;; the best neighbor
          ;; here we check if we found a neighbor better than solution
          ;; if so, we apply the operations in best-neighbor to solution
          ;; and return the best-neighbor
          ;; otherwise, we return nil
          ;; and that means that we didn't find a better neighbor

          (if best-neighbor
              (then
                (apply-set-of-operations (reverse best-neighbor) wc)
                (setf best-neighbor-as-solution
                      (solution wc))
                (setf (cost best-neighbor-as-solution)
                      (+ (cost solution)
                         best-delta-cost))
                ;; return best-neighbor-as-solution
                (values best-neighbor-as-solution
                        best-delta-cost)))

          ))
      #+END_SRC
     
**** tests
***** simple test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)   ;0
                                               (5 0 6 7 2 4 2 3 4)   ;1
                                               (1 8 0 3 9 1 2 4 5)   ;2
                                               (4 5 1 0 5 7 1 9 5)   ;3
                                               (4 5 1 5 0 6 2 8 2)   ;4
                                               (1 5 7 6 9 0 1 6 7)   ;5
                                               (4 5 1 3 5 7 0 9 5)   ;6
                                               (4 6 2 8 2 3 8 0 1)   ;7
                                               (4 5 3 4 1 6 2 8 0)   ;8
                                               )
                                               ;0 1 2 3 4 5 6 7 8
                                   :demands '(20 10 15 40 30 20 10 30)
                                   :capacity 30)
          (with-basic-cvrp-solution (s1 ((1 2 3 4) ;; (5 6)
                                         )
                                        problem)
            (let* ((action (delta-cvrp-action*))
                   (best-neighbor nil)
                   (best-delta-cost 0))


                (bformat t "Testing smart*-rab")


                (setf (values best-neighbor best-delta-cost)
                      (smart*-rab s1 problem action))

                (if best-neighbor
                    (then
                      (format t "Best delta cost: ~a~%"
                             best-delta-cost)
                      (pp-solution best-neighbor t) (terpri))
                    (else
                      (format t "No best neighbor found!~%")))

                (format t "total-penalty: ~a~%"
                        (delta-distance action)))))
      #+END_SRC

***** simple test with name
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (defun tests-profile ()
        (with-cvrp-problem (problem :distances `((0 2 3 4 5 6 7 8 9)   ;0
                                                 (5 0 6 7 2 4 2 3 4)   ;1
                                                 (1 8 0 3 9 1 2 4 5)   ;2
                                                 (4 5 1 0 5 7 1 9 5)   ;3
                                                 (4 5 1 5 0 6 2 8 2)   ;4
                                                 (1 5 7 6 9 0 1 6 7)   ;5
                                                 (4 5 1 3 5 7 0 9 5)   ;6
                                                 (4 6 2 8 2 3 8 0 1)   ;7
                                                 (4 5 3 4 1 6 2 8 0)   ;8
                                                 )
                                     ;0 1 2 3 4 5 6 7 8
                                     :demands '(20 10 15 40 30 20 10 30)
                                     :capacity 30)
          (with-basic-cvrp-solution (s1 ((1 2 3 4) ;; (5 6)
                                         )
                                        problem)
            (let* ((action (delta-cvrp-action*))
                   (best-neighbor nil)
                   (best-delta-cost 0))


              (bformat t "Testing smart*-rab")


              (setf (values best-neighbor best-delta-cost)
                    (smart*-rab s1 problem action))

              (if best-neighbor
                  (then
                    (format t "Best delta cost: ~a~%"
                            best-delta-cost)
                    (pp-solution best-neighbor t) (terpri))
                  (else
                    (format t "No best neighbor found!~%")))

              (format t "total-penalty: ~a~%"
                      (delta-distance action))
              ))))
      #+END_SRC

      #+RESULTS:

***** functions to make big cvrp instances and solutions
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-tests.lisp 
      (defun make-random-cvrp-instance (size &optional
                                               (distance-bound 20)
                                               (demand-bound 20)
                                               (capacity 100))
        (let* ((distance-list nil)
               (demand-list nil))
          (setf distance-list
                (loop for i from 1 to size
                      collect (loop for j from 1 to size
                                    if (= i j) collect 0
                                    else collect (random distance-bound 1))))
          (setf demand-list
                (loop for i from 1 below size
                      collect (random demand-bound 1)))
          (make-cvrp-from-lists distance-list demand-list capacity)))

      (defun make-deterministic-cvrp-instance
          (size &optional (capacity 100))
  
        (let* ((distance-list nil)
               (demand-list nil))
          (setf distance-list
                (loop for i from 1 to size
                      collect (loop for j from 1 to size
                                    if (= i j) collect 0
                                    else collect (* i j))))
          (setf demand-list
                (loop for i from 1 below size
                      collect i))
          (make-cvrp-from-lists distance-list demand-list capacity)))
      #+END_SRC
***** tests to find out why undo-delta-cost-computation is slow
      #+BEGIN_SRC lisp +n -r :results none :exports both :tangle ../src/vrp-tests.lisp 
      (defun test-undo-delta-cost-computation (size
                                               &key
                                                 (fun 'smart*-rab)
                                                 ;; (demand 20)
                                                 ;; (distance 20)
                                                 (capacity 400))
        (let* ((problem (make-deterministic-cvrp-instance size capacity))
               (s1 (make-initial-solution-for-cvrp-deterministic problem))
               (action (delta-cvrp-action*)))

          (funcall fun s1 problem action)
    
          ;; (pp-solution (smart*-rab s1 problem action) t)
          ;; (terpri)
          (values)
          ))
      #+END_SRC
*** exhaustive-search/best-improvement for rab with delta-cost*
**** description

     In this section we want to create a function that explores the neighborhood of a solution with an exhaustive/best-improvement strategy using the delta-cost* function.  The criterion will be =rab= that means move the client inside its route.

     The description of the criterion is:
     #+BEGIN_EXAMPLE
     (select-route r1)
     (select-client c1 from r1)
     (insert-client c1 into r1)
     #+END_EXAMPLE
     
     To create use the delta-cost* function we need to create an extra working-copy that will be passed to the delta-cost* function, and an action.  These two objects should be initialized at the beginning of the search.
     
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defun rab-exhaustive-best-with-delta-cost* (solution problem action)
       "Returns the best neighbor of the solution in wc, using an exhaustive search and best-improvment strategy."
       (let* ( ;; first the standard initializations
              (*vrp-stop-neighborhood-search* nil)
              (wc (basic-working-copy solution))
              (ops-list nil)
              ;; the following line is what we need
              ;; to use the function delta-cost*
              (wc-for-delta-cost (clone wc)) ;; the 2nd wc we'll need
              ;; now what corresponds to the
              ;; best-improvement strategy
              (current-delta-cost 0)
              (best-delta-cost 0)
              (best-neighbor nil)
              (best-neighbor-as-solution nil)
              )


         (prepare-solution-for-neighborhood-exploration wc)

         ;; let's clone the initialized wc to wc-for-delta-cost
         ;; (setf wc-for-delta-cost (clone wc))
         (prepare-solution-for-neighborhood-exploration wc-for-delta-cost)

         ;; this is the for the computation of the delta-cost
         ;; this action should be of the *-type
         (initialize-action-for-delta-cost-computation wc problem action)


         ;; here starts the exploration of the neighborhood
         (doselect-route (r1 wc)
           (doselect-client (c1 r1 wc)
             (doinsert-client (c1 r1 wc)

               ;; let's get the cost of the current neighbor
               (setf current-delta-cost
                     (delta-cost* (reverse ops-list)
                                  wc-for-delta-cost
                                  problem
                                  action))
               (format t "~%With delta-cost: ~a~%" current-delta-cost)
               (pp-solution wc t) (terpri)

               ;; let's see if it is better
               (if (< current-delta-cost best-delta-cost)
                   ;; if it is
                   (then
                     ;; let's save the ops that make it
                     (setf best-neighbor (clone ops-list))
                     ;; let's update the best-cost
                     (setf best-delta-cost current-delta-cost))))))

         ;; here we check if we found a neighbor better than solution
         ;; if so, we apply the operations in best-neighbor to solution
         ;; and return the best-neighbor
         ;; otherwise, we return nil
         ;; and that means that we didn't find a better neighbor

         (if best-neighbor
             (then
               (apply-set-of-operations (reverse best-neighbor) wc)
               (setf best-neighbor-as-solution
                     (solution wc))
               (setf (cost best-neighbor-as-solution)
                     (+ (cost solution)
                        best-delta-cost))
               ;; return best-neighbor-as-solution
               (values best-neighbor-as-solution
                       best-delta-cost)))))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                            :demands '(10 10 15 40 20)
                            :capacity 40)
       (with-basic-cvrp-solution (s1 ((3 2 4) (1 5)) p1)
         (let* ((best-solution-found nil)
                (wc0 (basic-working-copy s1))
                (wc2 nil)
                (action (delta-cvrp-action*))
                (cvrp-action (basic-cvrp-action)))



           (bformat t "Testing exhaustive/best-improvement rab with delta-cost*")

           ;; let's evaluate the solution

           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Distance: ~a, penalty: ~a, cost: ~a~%"
                   (total-distance cvrp-action)
                   (total-penalty cvrp-action)
                   (cost s1))

           (prepare-solution-for-neighborhood-exploration wc0)

           (format t "~%Testing exhaustive rab...~%")
           (pp-solution wc0 t)

           ;;{{{ let's explore the neighborhood rarb
           (setf best-solution-found
                 (rab-exhaustive-best-with-delta-cost* s1 p1 action))
           ;;}}}


           (if best-solution-found
               (then
                 ;;{{{ print the best neighbor
                 ;; (format t "Best value: ~a~%" (cost best-solution-found))
                 (format t "------------------~%Best neighbor:~%")
                 (setf wc2 (basic-working-copy best-solution-found))
                 (prepare-solution-for-neighborhood-exploration wc2)
                 (pp-solution wc2 t) (terpri)


                 (format t "with cost: ~a~%" (cost wc2))
                 (format t "------------------~%")
                 ;;}}}

                 ;; ;;{{{ using yoel approach
                 ;; (format t "Cost of original solution: ~a~%"
                 ;;         (solution-cost s1 p1 cvrp-action))
                 ;; (format t "Cost of best-neighbor: ~a~%"
                 ;;         (solution-cost best-solution-found
                 ;;                        p1 cvrp-action))
                 ;; ;;}}}
                 )
               (else
                 (format t "No better solution found in neighbor.~%")))

           )))
     #+END_SRC


*** exhaustive/best-improvement for rab with delta-cost* and Hector's
**** description

     In this section we want to create a function that explores the neighborhood of a solution with an exhaustive/best-improvement strategy using the delta-cost* function, and the code generators created by Hector.  The criterion will be =rab= that means move the client inside its route.

     The description of the criterion is:
     #+BEGIN_EXAMPLE
     (select-route r1)
     (select-client c1 from r1)
     (insert-client c1 into r1)
     #+END_EXAMPLE
     
     To create use the delta-cost* function we need to create an extra working-copy that will be passed to the delta-cost* function, and an action.  These two objects should be initialized at the beginning of the search.  We also need to create the generator.
     
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code
	      (defun rab-exhaustive-best-with-generator (solution problem graph)
		"Returns the best neighbor of the solution in wc, using an exhaustive search and best-improvement strategy."
		(let* (;; first the standard initializations
		       (*vrp-stop-neighborhood-search* nil)
		       (code `((select-route r1)
			       (select-client c1 from r1)
			       (insert-client c1 into r1)))

		       ;; the next lines are for the generation
		       ;; let's create the neighborhood tree
		       (neigh-tree (build-neighborhood-tree code solution))
		       ;; here we crete the exahustive generator from the tree
		       (sol-generator (exhaustive-exploration neigh-tree))
		       ;; the current neighbor-solution
		       (current-solution (funcall sol-generator))

		       ;; eval-graph-stuff
		       (ops nil)

		       ;; what follows is the required elements
		       ;; for the exhaustive search
		       (best-delta-cost (output-value (output graph)))
		       (best-neighbor nil)
		       (best-neighbor-as-solution nil)
		       )


		  ;; here starts the exploration of the neighborhood
		  (loop while current-solution
			do 
			   (setf ops (from-coordinates-to-operations current-solution))

			   ;; let's get the cost of the current neighbor
			   (do-suite-operations graph ops)
			   (setf current-delta-cost (output-value (output graph)))
			   (format t "~%With cost ~a:~% ~a"
				   current-delta-cost
				   (solution-track graph))
			   (format t "operations: ~a ~%~%" ops)
			   (undo-suite-operations graph ops)

			   ;; let's see if it is better
			   (if (< current-delta-cost best-delta-cost)
			       ;; if it is
			       (then
				 ;; let's save the ops that make it
				 (format t "----> found better cost <---- ~%~%")
				 (setf best-neighbor (clone ops))
				 ;; let's update the best-cost
				 (setf best-delta-cost current-delta-cost)))
			   ;; now let's create the next solution
			   (setf current-solution (funcall sol-generator)))

		  ;; here we check if we found a neighbor better than solution
		  ;; if so, we apply the operations in best-neighbor to solution
		  ;; and return the best-neighbor
		  ;; otherwise, we return nil
		  ;; and that means that we didn't find a better neighbor

		  (if best-neighbor
		      (then
			(setf ops best-neighbor)
			(do-suite-operations graph ops)		 
			(values best-neighbor best-delta-cost)
			))))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
     (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                            :demands '(10 10 15 40 20)
                            :capacity 40)
       (with-basic-cvrp-solution (s1 ((3 2 4) (1 5)) p1)
         (let* ((best-solution-found nil)
                (wc0 (basic-working-copy s1))
                (action (delta-cvrp-action*))
                (cvrp-action (basic-cvrp-action)))



           (bformat t "Testing exhaustive/best-improvement rab with delta-cost* and generator.")

           ;; let's evaluate the solution

           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "Distance: ~a, penalty: ~a, cost: ~a~%"
                   (total-distance cvrp-action)
                   (total-penalty cvrp-action)
                   (cost s1))

           (prepare-solution-for-neighborhood-exploration wc0)

           (format t "~%Testing exhaustive rab...~%")
           (pp-solution wc0 t)

           ;;{{{ let's explore the neighborhood rarb
           (setf best-solution-found
                 (rab-exhaustive-best-with-generator s1 p1 action))
           ;;}}}


           (if best-solution-found
               (then
                 ;;{{{ print the best neighbor
                 ;; (format t "Best value: ~a~%" (cost best-solution-found))
                 (format t "------------------~%Best neighbor:~%")
                 (setf wc2 (basic-working-copy best-solution-found))
                 (prepare-solution-for-neighborhood-exploration wc2)
                 (pp-solution wc2 t) (terpri)


                 (format t "with cost: ~a~%" (cost wc2))
                 (format t "------------------~%")
                 ;;}}}

                 ;; ;;{{{ using yoel approach
                 ;; (format t "Cost of original solution: ~a~%"
                 ;;         (solution-cost s1 p1 cvrp-action))
                 ;; (format t "Cost of best-neighbor: ~a~%"
                 ;;         (solution-cost best-solution-found
                 ;;                        p1 cvrp-action))
                 ;; ;;}}}
                 )
               (else
                 (format t "No better solution found in neighbor.~%")))

           )))
     #+END_SRC

     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn (defparameter c1 (basic-cvrp-client 1 1))
	      (defparameter c2 (basic-cvrp-client 2 1))
	      (defparameter c3 (basic-cvrp-client 3 4))
	      (defparameter c4 (basic-cvrp-client 4 3))
	      (defparameter c5 (basic-cvrp-client 5 2))
	      (defparameter c6 (basic-cvrp-client 6 1))

	      (defparameter v1 (cvrp-vehicle 1 20))
	      (defparameter v2 (cvrp-vehicle 2 20))

	      (defparameter d0 (basic-depot))

	      ;; Solution for the eval-graph
	      ;; remember to start and end all the routes with depot
	      ;; the starting depot is placed in the previous-client slot
	      (defparameter r1 (route-for-simulation :id 1 :vehicle v1 :depot d0
						     :clients (list c1 c2 c3 (clone d0)) :previous-client (clone d0)))
	      (defparameter r2 (route-for-simulation :id 2 :vehicle v2 :depot d0
						     :clients (list c4 c5 c6 (clone d0)) :previous-client (clone d0)))

	      (defparameter s1 (basic-solution :id 1 :routes (list r1 r2)))

	      ;; Solution for the neighborhood-tree
	      ;; In this case we use normal routes without depots
	      (defparameter r1-t (basic-route :id 1 :vehicle v1 :depot d0
					      :clients (list c1 c2 c3)))
	      (defparameter r2-t (basic-route :id 2 :vehicle v2 :depot d0
					      :clients (list c4 c5 c6)))

	      (defparameter s1-t (basic-solution :id 1 :routes (list r1-t r2-t)))


	      (defparameter dist-mat #2A((0 1 2 3 4 5 6)
					 (1 0 20 2 1 3 2)
					 (2 20 0 2 2 2 2)
					 (3 2 2 0 1 2 1)
					 (4 1 2 1 0 2 3)
					 (5 3 2 2 2 0 1)
					 (6 2 2 1 3 1 0)))
	      (defparameter problem (finite-fleet-cvrp-problem :id 1 :clients (list c1 c2 c3 c4 c5 c6)
							       :depot d0 :distance-matrix dist-mat :fleet (list v1 v2) ))

	      (defparameter graph (init-graph s1)))

       (let* ((best-solution-found nil))

	 (bformat t "Testing exhaustive/best-improvement rab with delta-cost* and generator.")

	 ;; let's evaluate the solution

	 (progn
	   (def-var total-distance 0 graph)
	   (loop for r in (routes s1) do 
	     (progn
	       (def-var route-distance 0 graph)
	       (def-var route-demand (capacity (vehicle r)) graph) 
	       (loop for c in (clients r) do 
		 (progn
		   (increment-distance (previous-client r) c route-distance dist-mat graph)
		   (decrement-demand c route-demand graph) 
		   (setf (previous-client r) c)))
	       (increment-value total-distance route-distance graph)
	       (apply-penalty route-demand total-distance 10 graph)) 
	     (return-value total-distance graph)))

	 (format t "initial cost: ~a~%" (output-value (output graph)))
	 (format t "initial solution: ~a~%" (solution-track graph))


	 (format t "~%Testing exhaustive rab...~%")

	 ;;{{{ let's explore the neighborhood rarb
	 (setf best-solution-found
	       (rab-exhaustive-best-with-generator s1-t problem graph))
	 ;;}}}


	 (if best-solution-found
	     (then
	       (format t "------------------~%Best neighbor:~%")
	       (format t "~a" (solution-track graph))
	       (format t "with cost ~a ~%" (output-value (output graph)))
	       (format t "------------------~%")
	       )
	     (else
	       (format t "No better solution found in neighbor.~%")))))
#+END_SRC

#+RESULTS:
#+begin_example
=========================================================================
 Testing exhaustive/best-improvement rab with delta-cost* and generator.
=========================================================================

initial cost: 39
initial solution: S1: (0)
routes:
  <r1: <cv:1. 0/20> (<d:0>: (<c1: 1> <c2: 1> <c3: 4> <d:0>))>
  <r2: <cv:2. 0/20> (<d:0>: (<c4: 3> <c5: 2> <c6: 1> <d:0>))>


Testing exhaustive rab...

With cost 39:
 S1: (0)
routes:
  <r1: <cv:1. 0/20> (<d:0>: (<c1: 1> <c2: 1> <c3: 4> <d:0>))>
  <r2: <cv:2. 0/20> (<d:0>: (<c4: 3> <c5: 2> <c6: 1> <d:0>))>
operations: (<op:a 1 2 0> <op:b 1 2 0>) 


With cost 40:
 S1: (0)
routes:
  <r1: <cv:1. 0/20> (<d:0>: (<c2: 1> <c1: 1> <c3: 4> <d:0>))>
  <r2: <cv:2. 0/20> (<d:0>: (<c4: 3> <c5: 2> <c6: 1> <d:0>))>
operations: (<op:a 1 1 0> <op:b 1 2 0>) 


With cost 39:
 S1: (0)
routes:
  <r1: <cv:1. 0/20> (<d:0>: (<c1: 1> <c2: 1> <c3: 4> <d:0>))>
  <r2: <cv:2. 0/20> (<d:0>: (<c4: 3> <c5: 2> <c6: 1> <d:0>))>
operations: (<op:a 1 2 0> <op:b 1 2 0>) 


With cost 40:
 S1: (0)
routes:
  <r1: <cv:1. 0/20> (<d:0>: (<c2: 1> <c1: 1> <c3: 4> <d:0>))>
  <r2: <cv:2. 0/20> (<d:0>: (<c4: 3> <c5: 2> <c6: 1> <d:0>))>
operations: (<op:a 1 2 0> <op:b 1 1 0>) 


With cost 39:
 S1: (0)
routes:
  <r1: <cv:1. 0/20> (<d:0>: (<c1: 1> <c2: 1> <c3: 4> <d:0>))>
  <r2: <cv:2. 0/20> (<d:0>: (<c4: 3> <c5: 2> <c6: 1> <d:0>))>
operations: (<op:a 1 2 0> <op:b 1 2 0>) 

No better solution found in neighbor.
#+end_example


*** random/best-improvement for rab with delta-cost* and Hector's
**** description

     In this section we want to create a function that explores the neighborhood of a solution with an exhaustive/best-improvement strategy using the delta-cost* function, and the code generators created by Hector.  The criterion will be =rab= that means move the client inside its route.

     The description of the criterion is:
     #+BEGIN_EXAMPLE
     (select-route r1)
     (select-client c1 from r1)
     (insert-client c1 into r1)
     #+END_EXAMPLE
     
     To create use the delta-cost* function we need to create an extra working-copy that will be passed to the delta-cost* function, and an action.  These two objects should be initialized at the beginning of the search.  We also need to create the generator.
     
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code
	      (defun rab-random-best-with-generator (solution problem graph)
		"Returns the best neighbor of the solution in wc, using an random search and best-improvement strategy."
		(let* (;; first the standard initializations
		       (*vrp-stop-neighborhood-search* nil)
		       (code `((select-route r1)
			       (select-client c1 from r1)
			       (insert-client c1 into r1)))
		       ;; the next lines are for the generation
		       ;; let's create the neighborhood tree
		       (neigh-tree (build-neighborhood-tree code solution))
		       ;; here we crete the exahustive generator from the tree
		       (sol-generator (random-exploration neigh-tree 5))
		       ;; the current neighbor-solution
		       (current-solution (funcall sol-generator))

		       ;; eval-graph-stuff
		       (ops nil)

		       ;; what follows is the required elements
		       ;; for the random search
		       (best-delta-cost (output-value (output graph)))
		       (best-neighbor nil)
		       (best-neighbor-as-solution nil)
		       )


		  ;; here starts the exploration of the neighborhood
		  (loop while current-solution
			do 
			   (setf ops (from-coordinates-to-operations current-solution))

			   ;; let's get the cost of the current neighbor
			   (do-suite-operations graph ops)
			   (setf current-delta-cost (output-value (output graph)))
			   (format t "~%With cost ~a:~% ~a"
				   current-delta-cost
				   (solution-track graph))
			   (format t "operations: ~a ~%~%" ops)
			   (undo-suite-operations graph ops)

			   ;; let's see if it is better
			   (if (< current-delta-cost best-delta-cost)
			       ;; if it is
			       (then
				 ;; let's save the ops that make it
				 (format t "----> found better cost <---- ~%~%")
				 (setf best-neighbor (clone ops))
				 ;; let's update the best-cost
				 (setf best-delta-cost current-delta-cost)))
			   ;; now let's create the next solution
			   (setf current-solution (funcall sol-generator)))

		  ;; here we check if we found a neighbor better than solution
		  ;; if so, we apply the operations in best-neighbor to solution
		  ;; and return the best-neighbor
		  ;; otherwise, we return nil
		  ;; and that means that we didn't find a better neighbor

		  (if best-neighbor
		      (then
			(setf ops best-neighbor)
			(do-suite-operations graph ops)		 
			(values best-neighbor best-delta-cost)
			))))
     #+END_SRC
**** tests
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
       (progn (defparameter c1 (basic-cvrp-client 1 1))
	      (defparameter c2 (basic-cvrp-client 2 1))
	      (defparameter c3 (basic-cvrp-client 3 4))
	      (defparameter c4 (basic-cvrp-client 4 3))
	      (defparameter c5 (basic-cvrp-client 5 2))
	      (defparameter c6 (basic-cvrp-client 6 1))

	      (defparameter v1 (cvrp-vehicle 1 20))
	      (defparameter v2 (cvrp-vehicle 2 20))

	      (defparameter d0 (basic-depot))

	      ;; Solution for the eval-graph
	      ;; remember to start and end all the routes with depot
	      ;; the starting depot is placed in the previous-client slot
	      (defparameter r1 (route-for-simulation :id 1 :vehicle v1 :depot d0
						     :clients (list c1 c2 c3 (clone d0)) :previous-client (clone d0)))
	      (defparameter r2 (route-for-simulation :id 2 :vehicle v2 :depot d0
						     :clients (list c4 c5 c6 (clone d0)) :previous-client (clone d0)))

	      (defparameter s1 (basic-solution :id 1 :routes (list r1 r2)))

	      ;; Solution for the neighborhood-tree
	      ;; In this case we use normal routes without depots
	      (defparameter r1-t (basic-route :id 1 :vehicle v1 :depot d0
					      :clients (list c1 c2 c3)))
	      (defparameter r2-t (basic-route :id 2 :vehicle v2 :depot d0
					      :clients (list c4 c5 c6)))

	      (defparameter s1-t (basic-solution :id 1 :routes (list r1-t r2-t)))


	      (defparameter dist-mat #2A((0 1 2 3 4 5 6)
					 (1 0 20 2 1 3 2)
					 (2 20 0 2 2 2 2)
					 (3 2 2 0 1 2 1)
					 (4 1 2 1 0 2 3)
					 (5 3 2 2 2 0 1)
					 (6 2 2 1 3 1 0)))
	      (defparameter problem (finite-fleet-cvrp-problem :id 1 :clients (list c1 c2 c3 c4 c5 c6)
							       :depot d0 :distance-matrix dist-mat :fleet (list v1 v2) ))

	      (defparameter graph (init-graph s1)))

       (let* ((best-solution-found nil))

	 (bformat t "Testing exhaustive/best-improvement rab with delta-cost* and generator.")

	 ;; let's evaluate the solution

	 (progn
	   (def-var total-distance 0 graph)
	   (loop for r in (routes s1) do 
	     (progn
	       (def-var route-distance 0 graph)
	       (def-var route-demand (capacity (vehicle r)) graph) 
	       (loop for c in (clients r) do 
		 (progn
		   (increment-distance (previous-client r) c route-distance dist-mat graph)
		   (decrement-demand c route-demand graph) 
		   (setf (previous-client r) c)))
	       (increment-value total-distance route-distance graph)
	       (apply-penalty route-demand total-distance 10 graph)) 
	     (return-value total-distance graph)))

	 (format t "initial cost: ~a~%" (output-value (output graph)))
	 (format t "initial solution: ~a~%" (solution-track graph))


	 (format t "~%Testing exhaustive rab...~%")

	 ;;{{{ let's explore the neighborhood rarb
	 (setf best-solution-found
	       (rab-random-best-with-generator s1-t problem graph))
	 ;;}}}


	 (if best-solution-found
	     (then
	       (format t "------------------~%Best neighbor:~%")
	       (format t "~a" (solution-track graph))
	       (format t "with cost ~a ~%" (output-value (output graph)))
	       (format t "------------------~%")
	       )
	     (else
	       (format t "No better solution found in neighbor.~%")))))
#+END_SRC

#+RESULTS:
#+begin_example
=========================================================================
 Testing exhaustive/best-improvement rab with delta-cost* and generator.
=========================================================================

initial cost: 39
initial solution: S1: (0)
routes:
  <r1: <cv:1. 0/20> (<d:0>: (<c1: 1> <c2: 1> <c3: 4> <d:0>))>
  <r2: <cv:2. 0/20> (<d:0>: (<c4: 3> <c5: 2> <c6: 1> <d:0>))>


Testing exhaustive rab...

With cost 39:
 S1: (0)
routes:
  <r1: <cv:1. 0/20> (<d:0>: (<c1: 1> <c2: 1> <c3: 4> <d:0>))>
  <r2: <cv:2. 0/20> (<d:0>: (<c4: 3> <c5: 2> <c6: 1> <d:0>))>
operations: (<op:a 1 2 0> <op:b 1 2 0>) 


With cost 40:
 S1: (0)
routes:
  <r1: <cv:1. 0/20> (<d:0>: (<c2: 1> <c1: 1> <c3: 4> <d:0>))>
  <r2: <cv:2. 0/20> (<d:0>: (<c4: 3> <c5: 2> <c6: 1> <d:0>))>
operations: (<op:a 1 1 0> <op:b 1 2 0>) 


With cost 39:
 S1: (0)
routes:
  <r1: <cv:1. 0/20> (<d:0>: (<c1: 1> <c2: 1> <c3: 4> <d:0>))>
  <r2: <cv:2. 0/20> (<d:0>: (<c4: 3> <c5: 2> <c6: 1> <d:0>))>
operations: (<op:a 1 2 0> <op:b 1 2 0>) 


With cost 40:
 S1: (0)
routes:
  <r1: <cv:1. 0/20> (<d:0>: (<c2: 1> <c1: 1> <c3: 4> <d:0>))>
  <r2: <cv:2. 0/20> (<d:0>: (<c4: 3> <c5: 2> <c6: 1> <d:0>))>
operations: (<op:a 1 2 0> <op:b 1 1 0>) 


With cost 39:
 S1: (0)
routes:
  <r1: <cv:1. 0/20> (<d:0>: (<c1: 1> <c2: 1> <c3: 4> <d:0>))>
  <r2: <cv:2. 0/20> (<d:0>: (<c4: 3> <c5: 2> <c6: 1> <d:0>))>
operations: (<op:a 1 2 0> <op:b 1 2 0>) 

No better solution found in neighbor.
#+end_example


** general idea
   The idea is to have several classes (one for each of the different situations) and then add a generic method to write the neighborhood exploration code according to the classes passed as arguments.

   So far we'll have two class hierarchies, one for the type of search (exhaustive, random, other) and another for the remaining aspects (how to select the best neighbor, what to return, etc).

   First, we'll add the classes, and then the generic functions.


* Classes
  
** classes for the generation of the neighborhood
*** documentation

    In this section we create classes to define how to generate the neighbors.  Up to this point (2020-12-28) we only had the option to generate the code using the do-operation-macros, but now we can also use the solution generators created by Hector on this thesis.  As we now have two choices, I am creating these classes here, so we can choose.

    So far I'll only create the new class, to use the generators, and I'm going to assume that if we don't use this class, then we want to use the do-operations-macros

*** search-with-a-solution-generator
**** description
     This class indicates that we should generate the neighbors using a neighborhood-generator.

     The idea is that this generation stores in the slot =macro-headings= the elements that should be placed in conditions of the while loop.

**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class use-a-neighborhood-generator ()
       ()
         :documentation "An instance of this class indicates that we should generate the neighbors using a neighborhood-generator."
         :constructor (use-a-neighborhood-generator ())
         :print-object-string ("<use-a-neighborhood-generator>")
         :slots-for-obj= ()
         :slots-for-clone ())
     #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((st1 (use-a-neighborhood-generator))
            (*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-output* nil))
       (bformat t "Testing use-a-neighborhood-generator...")
       (format t "use-a-neighborhood-generator: ~a~%" st1))
     #+END_SRC

    

** mixed (auxiliary) classes
*** description
    In this section I'll add the classes that I'm not too sure about where to add =:-(=.


*** search-with-a-basic-wc
**** description
     This class indicates that we should explore the neighborhood with an instance of basic-working-copy.  This is important for the moment when we want to initialize =wc= inside the let in a neighborhood-search.

**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class search-with-a-basic-wc ()
       ()
         :documentation "An instance of this class indicates that we should explore the neighborhood with an instance of a basic-working-copy."
         :constructor (search-with-a-basic-wc ())
         :print-object-string ("<search-with-basic-wc>")
         :slots-for-obj= ()
         :slots-for-clone ())
     #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((st1 (search-with-a-basic-wc))
            (*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-output* nil))
       (bformat t "Testing search-with-a-basic-wc...")
       (format t "search-with-a-basic-wc: ~a~%" st1))
     #+END_SRC

**** constant
     Here we create a constant (variable?) with an instance of this class.
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defparameter +search-with-a-basic-wc+
       (search-with-a-basic-wc))
     #+END_SRC
*** search-with-delta-cost-computation (abstract, functional)
**** description
     This class indicates that in this neighborhood exploration we want to compute the delta-cost of each neighbor.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class search-with-delta-cost-computation ()
         ()
         :documentation "A class to represent a search strategy where we need to compute the delta-cost of each neighbor.")
     #+END_SRC
**** no tests because this should be an abstract class
*** compute-delta-cost-inefficiently (abstract, functional)
**** description
     This class indicates that in this neighborhood exploration we want to compute the delta-cost of each neighbor, but we do it using the function =delta-cost= and this in inefficient because we repeat a lot of computations.  However it was useful for earlf (and dirty) hacks ;-).
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class compute-delta-cost-inefficiently
         (search-with-delta-cost-computation)
         ()
         :documentation "A class to represent a search strategy where we compute the delta-cost of each neighbor using the function delta-cost.")
     #+END_SRC
**** no tests because this should be an abstract class
*** compute-delta-cost-with-smart-macros (abstract, functional)
**** description
     This class indicates that in this neighborhood exploration we want to compute the delta-cost of each neighbor, and we do it using the * macros.

     What this class should add to the blueprint is the the finish-delta-cost-computation, and the binding of the current-delta-cost through the function get-delta-cost-from-action, AND the undo-finish-delta-cost-computation AT THE END OF THE INSIDE-MACRO SLOT :-o.

     It should also change the name of the macros it should use.

     We also need to add the =initialize-action-for-delta-cost-computation= to the outside-let initializations.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class compute-delta-cost-with-smart-macros
         (search-with-delta-cost-computation)
         ()
         :documentation "A class to represent a search strategy where we compute the delta-cost of each neighbor using the the * macros.")
     #+END_SRC
**** no tests because this should be an abstract class


*** use-neigh-generator (abstract, functional)
**** description
     This class indicates that we use a neighboor tree to generate solutions
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class use-neigh-tree()
         ()
         :documentation "A class to represent a search strategy where we use the neghborhood tree to generate solutions")
     #+END_SRC
**** no tests because this should be an abstract class

*** use-eval-graph (abstract, functional)
**** description
     This class indicates that we use an eval-graph to evaluate solutions
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class use-eval-graph()
         (use-neigh-generator)
         :documentation "A class to represent a search strategy where we use the eval graph to evaluate solutions")
     #+END_SRC
**** no tests because this should be an abstract class



*** there-is-a-best-solution (abstract functional)
**** description
     This class represents search strategies where we have a best-solution that should be returned.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class there-is-a-best-solution ()
         ()
         :documentation "A class to represent a search strategy where we have a best-solution value that we update during the search.")
     #+END_SRC
**** no tests because this should be an abstract class
*** return-best-solution (abstract functional)
**** description
     This class represents search strategies where we return the best solution found.  
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class return-best-solution
         (there-is-a-best-solution)
         ()
         :documentation "A class to represent a search strategy where we always return the value of best-solution.  If there isn't a best-solution, we return nil.")
     #+END_SRC
**** no tests because this should be an abstract class
*** return-best-delta-cost (abstract functional)
**** description
     This class represents search strategies where we also return the delta-cost of the best-solution found.  
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class return-best-delta-cost
         (there-is-a-best-solution)
         ()
         :documentation "A class to represent a selection strategy where we always return the delta-cost of the best-neighbor found.  If there is not a best neighbor we return 0.")
     #+END_SRC
**** no tests because this should be an abstract class
*** has-candidates-for-best-neighbor (abstract functional)
**** description
     This class represents search strategies where we collect a set of candidates for the best-neighbor.  An example of this is the standard random-improvement class.

     This is a class that computes delta-cost, has a best-neighbor, has candidates for best-neighbor, and returns a best-neighbor.  Hopefully, by appropriately inheriting from these classes we don't need to add any other code.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class has-candidates-for-best-neighbor
         ()
         () ;; no slots
         :documentation "A class to represent a search strategy where we collect a set of neighbors as candidates for the best-neighbor.")
     #+END_SRC
**** no tests because this should be an abstract class
     
*** looking-for-bug (debugger functional)
**** description
     This is a class that can be used to...  guess!  To look for bugs!
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class looking-for-bug
         (search-with-delta-cost-computation
          search-with-a-basic-wc)
         () ;; no slots
         :documentation "A class used to appropriately print debug messages.")
     #+END_SRC
**** constant
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defparameter +looking-for-bug+
       (make-instance 'looking-for-bug))
     #+END_SRC
     

** search strategies
*** exhaustive-search-strategy
**** description
     This class represents an exhaustive search of the neighborhood.  This means, for instance, that when we have a select-route operation, we iterate through all the possible routes in the solution, and so on.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
   (def-vrp-class exhaustive-neighborhood-search-strategy ()
       ()
       :documentation "A class to represent an exhaustive search of a neighborhood."
       :constructor (exhaustive-neighborhood-search-strategy ())
       :print-object-string ("<exhaustive-search>")
       :slots-for-obj= ()
       :slots-for-clone ())
     #+END_SRC

**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((st1 (exhaustive-neighborhood-search-strategy)))
       (bformat t "Testing exhaustive-neighborhood-search-strategy...")
       (format t "exhaustive-neighborhood-search-strategy: ~a~%" st1))
     #+END_SRC

**** constant
     Here we create a constant (variable?) with an instance of this class.
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defparameter +exhaustive-search-strategy+
       (exhaustive-neighborhood-search-strategy))
     #+END_SRC
*** random-search-strategy
**** description
     This class represents a random search of the neighborhood.  This means, for instance, that when we have a select-route operation, instead of iterate through all the possible routes in the solution (as in an exhaustive search), we just select a random route.

**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class random-neighborhood-search-strategy ()
         ((neighborhood-size
           :documentation "The number of neighbors that should be explored."))
         :documentation "A class to represent an exhaustive search of a neighborhood."
         :constructor (random-neighborhood-search-strategy
                       (&optional (neighborhood-size 100)))
         :print-object-string ("<random-search: ~a>" neighborhood-size)
         :slots-for-obj= (neighborhood-size)
         :slots-for-clone (neighborhood-size))
     #+END_SRC

**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((st1 (random-neighborhood-search-strategy))
            (st2 (random-neighborhood-search-strategy 100))
            (st3 (random-neighborhood-search-strategy 200))
            (st4 (clone st1)))
       (bformat t "Testing random-neighborhood-search-strategy...")
       ;; printing the strategies
       (loop for s in (list st1 st2 st3)
             doing (format t "exhaustive-neighborhood-search-strategy: ~a~%" s))

       (check-t (obj= st1 st1))
       (check-t (obj= st1 st2))
       (check-t (obj= st1 st4))

       (check-nil (obj= st1 st3))
       (check-nil (obj= st2 st3))

       )
     #+END_SRC

**** constant
     Here we create a constant (variable?) with an instance of this class.
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defparameter +random-search-strategy+
       (random-neighborhood-search-strategy 500))
     #+END_SRC
*** jump-around-search-strategy
**** description
     This class represents a `jump-around' search of the neighborhood.  This means to create a random-neighbor, unconditionally accept it and repeat the process several times.

     This strategy will inherit from =random-neighborhood-search-strategy= to use the random-neighborhood-operations.

     In this case, the =neighborhood-search= slot will be used as the maximum number of times that we should `jump'.

**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class jump-around-search-strategy
         (random-neighborhood-search-strategy)
         ()
         :documentation "A class to represent a `jump-around' search of a neighborhood."
         :constructor (jump-around-search-strategy
                       (&optional (neighborhood-size 100)))
         :print-object-string ("<jump-around-search: ~a>" neighborhood-size)
         :slots-for-obj= (neighborhood-size)
         :slots-for-clone (neighborhood-size))
     #+END_SRC

**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((st1 (jump-around-search-strategy))
            (st2 (jump-around-search-strategy 100))
            (st3 (jump-around-search-strategy 200))
            (st4 (clone st1)))
       (bformat t "Testing jump-around-strategy...")
       ;; printing the strategies
       (loop for s in (list st1 st2 st3)
             doing (format t "exhaustive-neighborhood-search-strategy: ~a~%" s))

       (check-t (obj= st1 st1))
       (check-t (obj= st1 st2))
       (check-t (obj= st1 st4))

       (check-nil (obj= st1 st3))
       (check-nil (obj= st2 st3))

       )
     #+END_SRC
**** constant
     Here we create a constant (variable?) with an instance of this class.
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defparameter +jump-around-strategy+
       (jump-around-search-strategy 10))
     #+END_SRC
*** random-bug-search-strategy
**** description
     This class represents a random search of the neighborhood.  This means, for instance, that when we have a select-route operation, instead of iterate through all the possible routes in the solution (as in an exhaustive search), we just select a random route.

**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class random-bug-search-strategy
         (random-neighborhood-search-strategy
          looking-for-bug)
         ()
         :documentation "A class to look for a bug in a random search a neighborhood."
         :constructor (random-bug-search-strategy
                       (&optional (neighborhood-size 10)))
         :print-object-string ("<random-bug-search: ~a>" neighborhood-size)
         :slots-for-obj= (neighborhood-size)
         :slots-for-clone (neighborhood-size))
     #+END_SRC

**** constant
     Here we create a constant (variable?) with an instance of this class.
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defparameter +random-bug-search+
       (random-bug-search-strategy 10))
     #+END_SRC


** selection strategies
*** best-improvement
***** description
      In this selection strategy, we explore all the neighborhood and then return the best neighbor.  To do that, we need to add initializations to the let, and to code-inside the macro.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (def-vrp-class best-improvement-search-strategy
          (
           return-best-solution
           use-eval-graph)

          ()
          :documentation "A class to represent a best-improvement strategy in the search of a neighborhood."
          :constructor (best-improvement-search-strategy ())
          :print-object-string ("<best-improvement-strategy>")
          :slots-for-obj= ()
          :slots-for-clone ())
      #+END_SRC
*** first-improvement
***** description
      In this selection strategy, we explore all the neighborhood and as soon as we find a neighbor better than the current solution, we return it.  To do this, we need to add a =(stop-neighborhood-search)= call to the `if' in inside-macro code.

***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (def-vrp-class first-improvement-search-strategy
          (
           return-best-solution
           use-eval-graph)

          ()
          :documentation "A class to represent a first-improvement strategy in the search of a neighborhood."
          :constructor (first-improvement-search-strategy ())
          :print-object-string ("<first-improvement-strategy>")
          :slots-for-obj= ()
          :slots-for-clone ())
      #+END_SRC
*** random-improvement-with-candidates
***** description
      In this selection strategy, we explore all the neighborhood and collect all the neighbors that are better than the current solution.  Finally, we return one of these better neighbors.

***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (def-vrp-class random-improvement-with-candidates-selection-strategy
          (
           return-best-solution
           has-candidates-for-best-neighbor
           use-eval-graph)

          ()
          :documentation "A class to represent a random-improvement strategy in the search of a neighborhood."
          :constructor (random-improvement-selection-strategy ())
          :print-object-string ("<random-improvement-strategy>")
          :slots-for-obj= ()
          :slots-for-clone ())
      #+END_SRC
*** random-improvement (without candidates)
***** description
      In this selection strategy, when we find a better neighbor we return it according to a probability.  In this case there is no need to have a list of candidates.

***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (def-vrp-class random-improvement-selection-strategy
          (
           return-best-solution
           use-eval-graph)

          ((acceptance-ratio
            :initform 0.5
            :documentation "The acceptance probability."))
          :documentation "A class to represent a random-improvement strategy in the search of a neighborhood."
          :constructor (random-improvement-selection-strategy
                        (&optional (acceptance-ratio 0.8)))
          :print-object-string ("<random-improvement-strategy>")
          :slots-for-obj= (acceptance-ratio)
          :slots-for-clone (acceptance-ratio))
      #+END_SRC
*** jump-around-return-last-neighbor
***** description
      In this selection strategy (that should be used in conjunction with a jump-around-search-strategy) we always return the last-neighbor. 
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (def-vrp-class jump-around-return-last-neighbor
          (use-eval-graph)

          ()
          :documentation "A class to represent the simplest jump-around selection strategy."
          :constructor (jump-around-return-last-neighbor ())
          :print-object-string ("<jump-around-last-neighbor>")
          :slots-for-obj= ()
          :slots-for-clone ())
      #+END_SRC
***** constant
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defparameter +jump-around-return-last-neighbor+
        (make-instance 'jump-around-return-last-neighbor))
      #+END_SRC
*** return-last-neighbor
***** description
      This class represents a selection strategy where we always return some neighbor, for instance the last one we built.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (def-vrp-class return-last-neighbor-selection-strategy
          (return-best-delta-cost
           return-best-solution
           use-eval-graph)
          () ;; no slots
          :documentation "A class to represent a search strategy where we return the last neighbor independently of its cost.")
      #+END_SRC
***** constant
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defparameter +return-last-neighbor+
        (make-instance 'return-last-neighbor-selection-strategy))
      #+END_SRC


** blueprints
*** neighborhood-strategy-blueprint
**** description

     A neighborhood-strategy-blueprint is a description of a neighborhood-strategy.  This will be helpful in the generation of the code for the neighborhood exploration.  Using instances of this class, we can describe a neighborhood-exploration criteria.  For instance, we can have how to initialize things in the let*, what to do as the body of the macros, what to return, and things like that.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class basic-neighborhood-strategy-blueprint ()
         ((initializations-inside-the-let
           :documentation "What we should initialize inside the let.")
          (initializations-outside-the-let
           :documentation "What we should initialize outside the let.")
          (macro-headings
           :documentation "A list with the heading of the macro calls.")
          (code-inside-the-macros
           :documentation "What we should do with the current neigborh.")
          (code-outside-the-macros
           :documentation "What we should do after the iteration through all the neigborhs is over.")
          (return-code
           :documentation "What we should return from the exploration."))
         :documentation "A class to represent a description of a neigborhood strategy.  It is used in the automatic generation of neigborhood search algorithms."
         :constructor (basic-strategy-blueprint
                       (&key (initializations-inside-the-let nil)
                             (initializations-outside-the-let nil)
                             (code-inside-the-macros nil)
                             (macro-headings nil)
                             (code-outside-the-macros nil)
                             (return-code nil)))

         :print-object-string ("<basic-strategy-blueprint>")
         :slots-for-obj= (initializations-inside-the-let
                          initializations-outside-the-let
                          macro-headings
                          code-inside-the-macros
                          code-outside-the-macros
                          return-code)
         :slots-for-clone (initializations-inside-the-let
                          initializations-outside-the-let
                          macro-headings
                          code-inside-the-macros
                          code-outside-the-macros
                          return-code))
     #+END_SRC

**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* t)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (bp2 (basic-strategy-blueprint
                  :initializations-inside-the-let
                  `((wc (basic-working-copy s1)))))
            (bp3 (basic-strategy-blueprint
                  :initializations-outside-the-let
                  `((prepare-solution-for-neighborhood-exploration wc))))
            (bp4 (basic-strategy-blueprint
                  :code-inside-the-macros
                  `((pp-solution wc t))))
            (bp5 (basic-strategy-blueprint
                  :code-outside-the-macros
                  `((format t "Hess"))))
            (bp6 (basic-strategy-blueprint
                  :return-code
                  `(wc)))
            (bp8 (basic-strategy-blueprint
                  :macro-headings `((doselect-route (r1 wc)))))
            (bp7 (clone bp1)))


       (bformat t "Testing basic-blueprint...")

       (check-t  (obj= bp1 bp1))
       (check-t  (obj= bp1 bp7))

       (check-nil (obj= bp1 bp2))
       (check-nil (obj= bp1 bp3))
       (check-nil (obj= bp1 bp4))
       (check-nil (obj= bp1 bp5))
       (check-nil (obj= bp1 bp6))
       (check-nil (obj= bp1 bp8))

       )
     #+END_SRC

     
* Generic-functions for the blueprint-updates
** description
   In this section we'll add the generic functions that will be used to generate the code for a specific neighborhood criterion.

   All these functions will receive the following arguments:

   - neighborhood-description
     This is a list with the pseudo-natural description of the neighborhood.
   - search-strategy
     This is an instance of a class that represents a search strategy.  Some examples can be exhausitve, random, smart-search, optimal-search, etc.
   - other-strategies
     These other strategies include
     - how to select the best-neighbor
       - best-improvement,
       - random-improvement,
       - first-improvement, etc.
     - what to return
       - better or nil,
       - the best, even if it is worse.
       - a list with candidates, etc
   - blueprint
     An instance of neighborhood-strategy-blueprint.  If we use an instance of a class to store the partial results, then we can use auxiliary methods in the generation of the neighborhood.
** generate-macro-headings (OBSOLETE)
*** description
    This function returns the heading of the macro calls that should be nested for the neighborhood criterion.

    For instance, if we have the criterion:

    #+BEGIN_EXAMPLE
    (select-route r1)
    (select-client c1 from r1)
    (insert-client c1 into r1)
    #+END_EXAMPLE

    we need to generate the following code:

    #+BEGIN_EXAMPLE
    (doselect-route (r1 wc)
      (doselect-client (c1 r1 wc)
        (doinsert-client (c1 r1 wc)
          ...do whatever we want here
        )))
    #+END_EXAMPLE

    In this case, the headings of the macro calls are:
    #+BEGIN_EXAMPLE
    (doselect-route (r1 wc))
    (doselect-client (c1 r1 wc))
    (doinsert-client (c1 r1 wc))
    #+END_EXAMPLE


    In a near future, when we can specify other arguments to those macros, those extra arguments should be added to this function too.

    For instance, when we can avoid repeating elements in the neighborhood, the code for the neighborhood could be something like:

    #+BEGIN_EXAMPLE
    (doselect-route (r1 wc)
      (doselect-client (c1 r1 wc)
        (doinsert-client (c1 r1 wc :dt (r1 c1.select.position))
          ...do whatever we want here
        )))
    #+END_EXAMPLE

    and then the headings for the macro calls would be:
    #+BEGIN_EXAMPLE
    (doselect-route (r1 wc))
    (doselect-client (c1 r1 wc))
    (doinsert-client (c1 r1 wc :dt (r1 c1.select.position)))
    #+END_EXAMPLE
    
    So, what this function returns is a list where each element is a list with the heading of the corresponding macro.
    This function does not return anything.  Instead, it stores the result in a blueprint that should be passed as argument to the generic function.

    When we want to pass some constraints to macro heading we add them at the end of pseudo-natural description.  For instance, we could have something like:

    #+BEGIN_EXAMPLE
    (select-route r1)
    (select-client c1 from r1)
    (select-client c2 from r1 :ge c1.select.position)
    (swap-clients c1 c2)
    #+END_EXAMPLE
*** generic-function
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
    (defgeneric generate-macro-calls (neighborhood-description
                                      search-strategy
                                      other-strategies
                                      where-to-store-it)
      (:documentation "This function receives a description of a neighborhood (in a human readable form) and returns a list where each element is the heading of the macro call derived from the corresponding neighborhood-instruction."))
    #+END_SRC
*** method (list t t t)
**** description
     In this case, we only need to map from the pseudo-natural neighborhood descprition to the do-neighborhood macros.  I'm going to do that with a global list.  This way, when we add new operations, we only need to update that list.

     We can use the following conventions:

       - the do-neighborhood macros will have the same name as the operation in the pseudo-natural description prepended with a do.
       - we can always know in what position of the pseudo-natural description are the name of the parameters that we are interested in

         For instance in a select-client we have:

         =(select-client c1 from r1)=

         In this case, the parameters we are interested in are =c1= and =r1=, and they are at positions 2 and 4, or in the positions 1 and 3, if we start counting from the first argument.


    That's precisely what we'll record in a list as the following:

    #+BEGIN_EXAMPLE
    (select-client 1 3)
    (swap 1 2)
    (reverse-subroute 1)
    #+END_EXAMPLE

    This means that in the =select-client= operation we want the first and third parameters, in the =swap=, the first and second, in the =reverse-subroute= we are just interested in the first, and so on.

    From a list as the previous one, we can compile a function that does something like this:

    #+BEGIN_EXAMPLE
    (cond
      ((eq 'select-client (first op))
       `(doselect-client (,(nth (1+ 1) op) ,(nth (1+ 3) op) wc)))
      ((eq 'swap (first op))
       `(doswap (,(second op) ,(third op) wc)))
      ((eq 'reverse-subroute (first op))
       `(doreverse-subroute (,(nth (1+ 1) op) wc))))
    #+END_EXAMPLE

    In this case op is each of the elements in the pseudo-natural description of the neighborhood criterion.

    In the next sections, I'm going to create a special variable with that info, and a function that translates the list in that variable to a function that can be used by the method.
**** help functions and variables
***** global variable *exhaustive-search-macro-heading-mapping*
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp
       (defparameter *exhaustive-search-macro-heading-mapping*
         `((select-route     1)
           (select-client    1 3)
           (insert-client    1 3)
           (swap-clients     1 2)
           (select-subroute  1 3)
           (insert-subroute  1 3)
           (reverse-subroute 1)
           (swap-subroutes   1 2)
           (add-route        1))
         "This list describe what are the relevant parameters in the pseudo-natural description of a neighborhood operation.  The car of each element is the pseudo-natural name of the neighborhood operation.  The rest of each element are (1-) of the position of the arguments we are interested in.")
       #+END_SRC
***** get-macro-name-for-operation
****** description
       This function receives a symbol (with the name of a neighborhood operation) and a search-strategy, and returns the name of the corresponding neighborhood-operation macro for that operation with the given strategy.

       For instance, in the case of the exhaustive-search, all the operations get the prefix `do' and so =select-route= becomes =doselect-route=, =select-client= =doselect-client= and so on.  In the case of a random search the symbols are prefixed with `random-': =select-client= becomes =random-select-client=, =insert-subroute= =random-insert-subroute= and so on.
****** generic-function
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defgeneric get-macro-name-for-operation
          (operation strategy)
        (:documentation "Returns the name of the corresponding neighborhood-operation macro for an operation and a given strategy."))
      #+END_SRC

****** method (t exhaustive-neighborhood-search-strategy)
******* code
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
       (defmethod get-macro-name-for-operation
           (operation (strategy exhaustive-neighborhood-search-strategy))
         (symb 'do operation))
       #+END_SRC

******* tests
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (let* ((*vrp-unit-testing-display-output* nil))
          (bformat t "Testing get-macro-name-for-operation")

          (format t "select-client: ")
          (check-eq 'doselect-client
                    (get-macro-name-for-operation
                     'select-client +exhaustive-search-strategy+))

          (format t "select-subroute: ")
          (check-eq 'doselect-subroute
                    (get-macro-name-for-operation
                     'select-subroute +exhaustive-search-strategy+))

          (format t "swap-clients: ")
          (check-eq 'doswap-clients
                    (get-macro-name-for-operation
                     'swap-clients +exhaustive-search-strategy+)))
                     #+END_SRC)

****** method (t exhaustive/efficient-neighborhood-search-strategy)
******* code
       #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
       (defmethod get-macro-name-for-operation
           (operation
            (strategy exhaustive/efficient-neighborhood-search-strategy))
         (symb 'do operation '*))
       #+END_SRC

******* tests
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (let* ((*vrp-unit-testing-display-output* nil))
          (bformat t "Testing get-macro-name-for-operation")

          (format t "select-client: ")
          (check-eq 'doselect-client*
                    (get-macro-name-for-operation
                     'select-client +exhaustive*-search-strategy+))

          (format t "select-subroute: ")
          (check-eq 'doselect-subroute*
                    (get-macro-name-for-operation
                     'select-subroute +exhaustive*-search-strategy+))

          (format t "swap-clients: ")
          (check-eq 'doswap-clients*
                    (get-macro-name-for-operation
                     'swap-clients +exhaustive*-search-strategy+)))
        #+END_SRC

***** function map-pseudo-natural-op-to-do-neigborhood-heading
****** description
       This function receives a pseudo-natural description of a single neighborhood-operation and returns a do-neighborhood macro heading.
****** generic-function
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defgeneric map-pseudo-natural-op-to-do-neigborhood-heading
          (description strategy)
       (:documentation "Describes how to map a neighborhood-operation description in pseudo-natural language to the heading of the macro call."))
      #+END_SRC

****** method (t t)
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod map-pseudo-natural-op-to-do-neigborhood-heading
          (description strategy)

        (let* ((wanted-name (first description))
               (op-found nil)
               (macro-heading nil)
               (macro-args nil)
               (max-arg-position 0)
               (constraints nil))
          (loop for op in *exhaustive-search-macro-heading-mapping*
                for op-name = (first op)
                for op-args = (rest op)
                while (not op-found)
                when (eq op-name wanted-name)
                     do (progn
                          ;; push the do-neighborhood operation macro
                          (push (get-macro-name-for-operation
                                 op-name strategy)
                                macro-heading)
                          ;; op-was-found
                          (setf op-found t)
                          ;; store the greates arg pos
                          (setf max-arg-position
                                (reduce #'max op-args))
                          ;; now push the args
                          (loop for arg in op-args
                                do (push (nth arg description)
                                         macro-args)
                                finally (push `wc macro-args))))
          ;; After pushing the mandatory args
          ;; we need to push the constraints
          ;; By convention, everything after the
          ;; maximum positional arg should be a
          ;; constraint, so we need to check if
          ;; there is any of those
          (setf constraints (nthcdr (1+ max-arg-position) description))
          ;; if there are constraints we need
          ;; to push them into macro-heading.
          ;; we don't need to check if constraints
          ;; is non nil, because the loop will do it
          ;; for us.
          (loop for c in constraints
                doing (push c macro-args))
    
          ;; now, let's push the args
          (push (reverse macro-args) macro-heading)
          ;; return the macro-heading
          (reverse macro-heading)))
      #+END_SRC

****** tests

******* basic tests
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (let* ((*vrp-unit-testing-display-output* nil))
          (bformat t "Testing map-pseudo-natural-op-to-do-neigborhood-heading")

          (format t "select-client: ")
  
  
          (check-obj= `(doselect-client (c2 r1 wc))
                      (map-pseudo-natural-op-to-do-neigborhood-heading
                       `(select-client c2 from r1)
                       +exhaustive-search-strategy+))

          (format t "select-route: ")
          (check-obj= `(doselect-route (r3 wc))
                      (map-pseudo-natural-op-to-do-neigborhood-heading
                       `(select-route r3)
                       +exhaustive-search-strategy+))

          (format t "insert-client: ")
          (check-obj= `(doinsert-client (c1 r3 wc))
                      (map-pseudo-natural-op-to-do-neigborhood-heading
                       `(insert-client c1 from r3)
                       +exhaustive-search-strategy+))

          (format t "swap-clients: ")
          (check-obj= `(doswap-clients (c4 c8 wc))
                      (map-pseudo-natural-op-to-do-neigborhood-heading
                       `(swap-clients c4 c8)
                       +exhaustive-search-strategy+))

          (format t "select-subroute: ")
          (check-obj= `(doselect-subroute (z1 r2 wc))
                      (map-pseudo-natural-op-to-do-neigborhood-heading
                       `(select-subroute z1 from r2)
                       +exhaustive-search-strategy+))

          (format t "insert-subroute: ")
          (check-obj= `(doinsert-subroute (z1 r2 wc))
                      (map-pseudo-natural-op-to-do-neigborhood-heading
                       `(insert-subroute z1 into r2)
                       +exhaustive-search-strategy+))

          (format t "reverse-subroute: ")
          (check-obj= `(doreverse-subroute (z1 wc))
                      (map-pseudo-natural-op-to-do-neigborhood-heading
                       `(reverse-subroute z1)
                       +exhaustive-search-strategy+))

          )
        #+END_SRC

******* tests with constraints
        #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
        (let* ((*vrp-unit-testing-display-output* nil))
          (bformat t "Testing map-pseudo-natural-op-to-do-neigborhood-heading")

          (format t "select-client with constraints: ")

          (format t "~s~%"
                  (map-pseudo-natural-op-to-do-neigborhood-heading
                   `(select-client c2 from r1
                                   :ge (list r2 c1.select.position)
                                   :lt (list r3 c3.select.position))
                       +exhaustive-search-strategy+)))
        #+END_SRC

**** method generate-macro-calls (list t t basic-blueprint)
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-macro-calls
          ((description list)
           strategy
           other-strategies
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (loop for op in description
              do (push
                  (map-pseudo-natural-op-to-do-neigborhood-heading
                   op strategy)
                  (macro-headings where-to-store-it))))
      #+END_SRC
**** tests
***** simple test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (bp1 (basic-strategy-blueprint))
             )


        (bformat t "Testing generate-macro-calls...")

        (format t "with just one operation:")
        ;;generate the code
        (generate-macro-calls
         `((select-route r1))
         +exhaustive-search-strategy+ t   bp1)
        ;; check
        (check-obj= `((doselect-route (r1 wc))) (macro-headings bp1))


        (format t "with two operations:")
        ;; initialize the blueprint
        (setf bp1 (basic-strategy-blueprint))
        ;; generate the code
        (generate-macro-calls
         `((select-route r1)
           (select-client c1 from r1))
         +exhaustive-search-strategy+ t   bp1)
        ;; check
        (check-obj= `((doselect-client (c1 r1 wc))
                      (doselect-route (r1 wc)))
                    (macro-headings bp1))

        (format t "with four operations:")
        ;; initialize the blueprint
        (setf bp1 (basic-strategy-blueprint))
        ;; generate the code
        (generate-macro-calls
         `((select-route r1)
           (select-subroute z1 from r1)
           (reverse-subroute z1)
           (insert-subroute z1 into r1))
         +exhaustive-search-strategy+ t   bp1)
        ;; check
        ;; we need to check in the reversed
        ;; order, because of the pushes in the
        ;; map-pseudo-natural-op-to-do-neigborhood-heading.
        (check-obj= `((doinsert-subroute (z1 r1 wc))
                      (doreverse-subroute (z1 wc))
                      (doselect-subroute (z1 r1 wc))
                      (doselect-route (r1 wc)))
                    (macro-headings bp1))

        )
      #+END_SRC

***** test with constraints
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (bp1 (basic-strategy-blueprint))
             )


        (bformat t "Testing generate-macro-calls...")

        (format t "with just one operation:")
        ;;generate the code
        (generate-macro-calls
         `((select-route r1 :ge 2))
         +exhaustive-search-strategy+ t   bp1)
        ;; check
        (check-obj= `((doselect-route (r1 wc :ge 2))) (macro-headings bp1))


        (format t "with two operations:")
        ;; initialize the blueprint
        (setf bp1 (basic-strategy-blueprint))
        ;; generate the code
        (generate-macro-calls
         `((select-route r1)
           (select-client c1 from r1 :le `(2 4)))
         +exhaustive-search-strategy+ t   bp1)
        ;; check
        (check-obj= `((doselect-client (c1 r1 wc :le `(2 4)))
                      (doselect-route (r1 wc)))
                    (macro-headings bp1))

        (setf bp1 (basic-strategy-blueprint))
        ;; generate the code
        (generate-macro-calls
         `((select-route r1)
           (select-client c1 from r1)
           (insert-client c1 into r1 :dt (1 2)))
         +exhaustive-search-strategy+ t   bp1)

        (format t "macro-headings: ~s~%" (macro-headings bp1))

        (generate-macro-calls
         `((select-route r1)
           (select-client c1 from r1 :le `(2 4)))
         +random-search-strategy+ t   bp1)

        (format t "macro headings: ~a~%"
                (macro-headings bp1))

        )
      #+END_SRC

*** method (list random-search-strategy t t)
**** description
     We have two differences in the macro-headings between the exhaustive-search-strategy and the random-search-strategy.

     The first one is the name of the macros: in one case they are named doOPERATION-NAME and in the random case we have random-OPERATION-NAME.

     The second difference is that we need to add a new loop with the number of times we want to do the random-search.  This is a slot in the class =random-neighborhood-search-strategy=.

     First, we specialize the the function =get-macro-name-for-operation= and then we modify the generate-macro-calls method.

**** get-macro-name-for-operation (t random-search)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
       (defmethod get-macro-name-for-operation
           (operation
            (strategy random-neighborhood-search-strategy))

         (symb "random-" operation))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((*vrp-unit-testing-display-output* nil))
        (bformat t "Testing get-macro-name-for-operation")

        (format t "select-client: ")
        (check-eq 'random-select-client
                  (get-macro-name-for-operation
                   'select-client +random-search-strategy+))

        (format t "select-subroute: ")
        (check-eq 'random-select-subroute
                  (get-macro-name-for-operation
                   'select-subroute +random-search-strategy+))

        (format t "swap-clients: ")
        (check-eq 'random-swap-clients
                  (get-macro-name-for-operation
                   'swap-clients +random-search-strategy+))))
      #+END_SRC
**** method generate-macro-calls (list t t basic-blueprint)
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-macro-calls
          ((description list)
           (strategy random-neighborhood-search-strategy)
           other-strategies
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        ;; first we add the loop with the number of repetitions
        (push `(loop for random-search-repetition-counter
                     from 1 to ,(neighborhood-size strategy)
                     while (not *vrp-stop-neighborhood-search*) do)
              (macro-headings where-to-store-it))

        ;; and then we do the same is in the exhaustive-search.
        (loop for op in description
              do (push
                  (map-pseudo-natural-op-to-do-neigborhood-heading
                   op strategy)
                  (macro-headings where-to-store-it))))
      #+END_SRC
**** tests for generate-macro-headings
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            )


       (bformat t "Testing generate-macro-calls...")

       (format t "with just one operation:")
       ;;generate the code
       (generate-macro-calls
        `((select-route r1))
        +random-search-strategy+ t   bp1)

       (format t "macro-headings: ~a~%"
               (macro-headings bp1))
       ;; check
       ;; (check-obj= `((random-select-route (r1 wc))) (macro-headings bp1))


       ;; (format t "with two operations:")
       ;; ;; initialize the blueprint
       ;; (setf bp1 (basic-strategy-blueprint))
       ;; ;; generate the code
       ;; (generate-macro-calls
       ;;  `((select-route r1)
       ;;    (select-client c1 from r1))
       ;;  +random-search-strategy+ t   bp1)
       ;; ;; check
       ;; (check-obj= `((random-select-client (c1 r1 wc))
       ;;               (random-select-route (r1 wc)))
       ;;             (macro-headings bp1))

       ;; (format t "with four operations:")
       ;; ;; initialize the blueprint
       ;; (setf bp1 (basic-strategy-blueprint))
       ;; ;; generate the code
       ;; (generate-macro-calls
       ;;  `((select-route r1)
       ;;    (select-subroute z1 from r1)
       ;;    (reverse-subroute z1)
       ;;    (insert-subroute z1 into r1))
       ;;  +random-search-strategy+ t   bp1)
       ;; ;; check
       ;; ;; we need to check in the reversed
       ;; ;; order, because of the pushes in the
       ;; ;; map-pseudo-natural-op-to-do-neigborhood-heading.
       ;; (check-obj= `((random-insert-subroute (z1 r1 wc))
       ;;               (random-reverse-subroute (z1 wc))
       ;;               (random-select-subroute (z1 r1 wc))
       ;;               (random-select-route (r1 wc)))
       ;;             (macro-headings bp1))

       )
     #+END_SRC
*** method (list jump-around-search-strategy t t)
**** description
     We have several differences in the macro-headings between the jump-around-search-strategy and the random-search-strategy.

     The name of the macros is the same, so this is not a problem, but,

      - we need to initialize the working-copy as a loop clause.

**** method generate-macro-calls (list jump-around t basic-blueprint)
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-macro-calls
          ((description list)
           (strategy jump-around-search-strategy)
           other-strategies
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        ;; first we add the loop with the number of repetitions
        (push `(loop for jump-around-repetition-counter
                     from 1 to ,(neighborhood-size strategy)
                     while (not *vrp-stop-neighborhood-search*)
                     ;; we need to prepare the wc for the exploration
                     do (prepare-solution-for-neighborhood-exploration wc)
                     ;; this is the last do to add the do-neig macros
                     do)

              (macro-headings where-to-store-it))

        ;; and then we do the same as in the exhaustive-search.
        (loop for op in description
              do (push
                  (map-pseudo-natural-op-to-do-neigborhood-heading
                   op strategy)
                  (macro-headings where-to-store-it))))
      #+END_SRC
**** tests for generate-macro-headings
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            )


       (bformat t "Testing generate-macro-calls...")

       (format t "with just one operation:")
       ;;generate the code
       (generate-macro-calls
        `((select-route r1))
        +jump-around-strategy+ t  bp1)

       (format t "macro-headings: ~a~%"
               (macro-headings bp1))
       ;; ;; check
       ;; (check-obj= `((random-select-route (r1 wc))) (macro-headings bp1))


       ;; (format t "with two operations:")
       ;; ;; initialize the blueprint
       ;; (setf bp1 (basic-strategy-blueprint))
       ;; ;; generate the code
       ;; (generate-macro-calls
       ;;  `((select-route r1)
       ;;    (select-client c1 from r1))
       ;;  +random-search-strategy+ t   bp1)
       ;; ;; check
       ;; (check-obj= `((random-select-client (c1 r1 wc))
       ;;               (random-select-route (r1 wc)))
       ;;             (macro-headings bp1))

       ;; (format t "with four operations:")
       ;; ;; initialize the blueprint
       ;; (setf bp1 (basic-strategy-blueprint))
       ;; ;; generate the code
       ;; (generate-macro-calls
       ;;  `((select-route r1)
       ;;    (select-subroute z1 from r1)
       ;;    (reverse-subroute z1)
       ;;    (insert-subroute z1 into r1))
       ;;  +random-search-strategy+ t   bp1)
       ;; ;; check
       ;; ;; we need to check in the reversed
       ;; ;; order, because of the pushes in the
       ;; ;; map-pseudo-natural-op-to-do-neigborhood-heading.
       ;; (check-obj= `((random-insert-subroute (z1 r1 wc))
       ;;               (random-reverse-subroute (z1 wc))
       ;;               (random-select-subroute (z1 r1 wc))
       ;;               (random-select-route (r1 wc)))
       ;;             (macro-headings bp1))

       )
     #+END_SRC
*** method (list looking-for-bug t t)
**** description
     When we want to debug something
**** map-pseudo-natural-op-to-do-neigborhood-heading
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod map-pseudo-natural-op-to-do-neigborhood-heading
          (description (strategy looking-for-bug))

        (let* ((wanted-name (first description))
               (op-found nil)
               (macro-heading nil)
               (macro-args nil))
          (loop for op in *exhaustive-search-macro-heading-mapping*
                for op-name = (first op)
                for op-args = (rest op)
                while (not op-found)
                when (eq op-name wanted-name)
                     do (progn
                          ;; push the do-neighborhood operation macro
                          (push (get-macro-name-for-operation
                                 op-name strategy)
                                macro-heading)
                          ;; op-was-found
                          (setf op-found t)
                          ;; now push the args
                          (loop for arg in op-args
                                do (push (nth arg description)
                                         macro-args)
                                finally (push `wc macro-args))))
          ;; let's push the args
          (push (reverse macro-args) macro-heading)
          ;; now let's push the debug info:
          (push `(format t "debug: inside (~a ~a)~%"
                         ',(second macro-heading)
                         ',(first macro-heading))
                macro-heading)
          ;; return the macro-heading
          (reverse macro-heading)))
      #+END_SRC
**** get-macro-name-for-operation (t random-search)
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
       (defmethod get-macro-name-for-operation
           (operation
            (strategy looking-for-bug))

         (symb "random-" operation))
      #+END_SRC
***** tests
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((*vrp-unit-testing-display-output* nil))
        (bformat t "Testing get-macro-name-for-operation")

        (format t "select-client: ")
        (check-eq 'random-select-client
                  (get-macro-name-for-operation
                   'select-client +random-search-strategy+))

        (format t "select-subroute: ")
        (check-eq 'random-select-subroute
                  (get-macro-name-for-operation
                   'select-subroute +random-search-strategy+))

        (format t "swap-clients: ")
        (check-eq 'random-swap-clients
                  (get-macro-name-for-operation
                   'swap-clients +random-search-strategy+))))
      #+END_SRC
**** method generate-macro-calls (list bug t basic-blueprint)
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-macro-calls
          ((description list)
           (strategy looking-for-bug)
           other-strategies
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        ;; first we add the loop with the number of repetitions
        (push `(loop for random-search-repetition-counter
                     from 1 to 10
                     while (not *vrp-stop-neighborhood-search*) do)
              (macro-headings where-to-store-it))

        ;; and then we do the same is in the exhaustive-search.
        (loop for op in description
              do (push
                  (map-pseudo-natural-op-to-do-neigborhood-heading
                   op strategy)
                  (macro-headings where-to-store-it))))
      #+END_SRC
**** tests for generate-macro-headings
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            )


       (bformat t "Testing generate-macro-calls...")

       (format t "with just one operation:")
       ;;generate the code
       (generate-macro-calls
        `((select-route r1))
        +looking-for-bug+ t   bp1)

       (format t "macro-headings: ~a~%"
               (macro-headings bp1))
       ;; check
       ;; (check-obj= `((random-select-route (r1 wc))) (macro-headings bp1))


       ;; (format t "with two operations:")
       ;; ;; initialize the blueprint
       ;; (setf bp1 (basic-strategy-blueprint))
       ;; ;; generate the code
       ;; (generate-macro-calls
       ;;  `((select-route r1)
       ;;    (select-client c1 from r1))
       ;;  +random-search-strategy+ t   bp1)
       ;; ;; check
       ;; (check-obj= `((random-select-client (c1 r1 wc))
       ;;               (random-select-route (r1 wc)))
       ;;             (macro-headings bp1))

       ;; (format t "with four operations:")
       ;; ;; initialize the blueprint
       ;; (setf bp1 (basic-strategy-blueprint))
       ;; ;; generate the code
       ;; (generate-macro-calls
       ;;  `((select-route r1)
       ;;    (select-subroute z1 from r1)
       ;;    (reverse-subroute z1)
       ;;    (insert-subroute z1 into r1))
       ;;  +random-search-strategy+ t   bp1)
       ;; ;; check
       ;; ;; we need to check in the reversed
       ;; ;; order, because of the pushes in the
       ;; ;; map-pseudo-natural-op-to-do-neigborhood-heading.
       ;; (check-obj= `((random-insert-subroute (z1 r1 wc))
       ;;               (random-reverse-subroute (z1 wc))
       ;;               (random-select-subroute (z1 r1 wc))
       ;;               (random-select-route (r1 wc)))
       ;;             (macro-headings bp1))

       )
     #+END_SRC
** generate-inside-let-initializations
*** description
    In this generic function we create the initializations that should go inside the let in the neighborhood search function.

    In a very basic neighborhood exploration, we need to initialize the variable =ops-list= to nil.  This a variable that is used to store all the simpler-operations needed to create the current neighbor.

    So, the very basic method will just add the =ops-list= initialization.

*** generic-function
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
    (defgeneric generate-inside-let-initializations
        (neighborhood-description
         search-strategy
         other-strategies
         where-to-store-it)
      (:documentation "This function receives a description of a neighborhood (in a human readable form) updates the argument where-to-store-it with the initializations that should be made inside the let."))
    #+END_SRC
*** method (t t t t) (add ops-list and stop-neighborhood)
**** description
     In this case, we'll only add the =ops-list= initialization to nil.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-inside-let-initializations
          (description
           strategy
           other-strategies
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(*vrp-stop-neighborhood-search* nil)
              (initializations-inside-the-let where-to-store-it))
        (push `(ops-list nil)
              (initializations-inside-the-let where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            )


       (bformat t "Testing generate-inside-let-initializations...")

       ;;generate the code
       (generate-inside-let-initializations t t t bp1)
       ;; check
       (format t "Added ops-list and stop-neighborhood-search? ")
       (check-obj= `((ops-list nil)
                     (*vrp-stop-neighborhood-search* nil))
                   (initializations-inside-the-let bp1))
       )
     #+END_SRC

*** method :after(t t use-eval-graph t)
**** description
     In this :after method, we'll initialize the current-cost.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-inside-let-initializations :after
          (description
           strategy
           (other-strategies use-eval-graph)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(current-cost 0)
              (initializations-inside-the-let where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (dcost-class (make-instance
                          'search-with-delta-cost-computation))
            )


       (bformat t "Testing generate-inside-let-initializations...")

       ;;generate the code
       (generate-inside-let-initializations
        t t dcost-class bp1)

       (format t "let-initializations: ~a~%"
               (initializations-inside-the-let bp1))
       ;; check
       (format t "Added ops-list and stop-neighborhood-search? ")
       (check-obj= `((current-delta-cost 0)
                     (ops-list nil)
                     (*vrp-stop-neighborhood-search* nil))
                   (initializations-inside-the-let bp1))
       )
     #+END_SRC

*** method :after(t t use-neigh-tree t)
**** description
     In this :after method, we'll build the neigh-tree, initialize the solution generator and generate the first (current) solution.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
	(defmethod generate-inside-let-initializations :after
	    (description
	     strategy
	     (other-strategies use-neigh-tree)
	     (where-to-store-it basic-neighborhood-strategy-blueprint))

	  (push `(neigh-tree (build-neighborhood-tree code solution))
		(initializations-inside-the-let where-to-store-it))
	  (push `(sol-generator (exhaustive-exploration neigh-tree))
		(initializations-inside-the-let where-to-store-it))
	  (push `(current-solution (funcall sol-generator))
		(initializations-inside-the-let where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (dcost-class (make-instance
                          'search-with-delta-cost-computation))
            )


       (bformat t "Testing generate-inside-let-initializations...")

       ;;generate the code
       (generate-inside-let-initializations
        t t dcost-class bp1)

       (format t "let-initializations: ~a~%"
               (initializations-inside-the-let bp1))
       ;; check
       (format t "Added ops-list and stop-neighborhood-search? ")
       (check-obj= `((current-delta-cost 0)
                     (ops-list nil)
                     (*vrp-stop-neighborhood-search* nil))
                   (initializations-inside-the-let bp1))
       )
     #+END_SRC




*** method :after(t t there-is-a-best-solution t)
**** description
     In this :after method, we'll initialize the variable best-neighbor.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-inside-let-initializations :after
          (description
           strategy
           (other-strategies there-is-a-best-solution)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(best-neighbor nil)
              (initializations-inside-the-let where-to-store-it))
        (push `(best-delta-cost initial-best-delta-cost)
              (initializations-inside-the-let where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (dcost-class (make-instance
                          'there-is-a-best-solution))
            )


       (bformat t "Testing generate-inside-let-initializations...")

       ;;generate the code
       (generate-inside-let-initializations
        t t dcost-class bp1)

       (format t "let-initializations: ~a~%"
               (initializations-inside-the-let bp1))
       ;; check
       (format t "Added (best-neighbor nil)? ")
       (check-obj= `((best-cost 0)
                     (best-neighbor nil)
                     (ops-list nil)
                     (*vrp-stop-neighborhood-search* nil))
                   (initializations-inside-the-let bp1)))
     #+END_SRC
*** method :after(t t return-best-solution t)
**** description
     In this :after method, we'll initialize the variable best-neighbor.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-inside-let-initializations :after
          (description
           strategy
           (other-strategies return-best-solution)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(best-neighbor-as-solution nil)
              (initializations-inside-the-let where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (dcost-class (make-instance
                          'return-best-solution))
            )


       (bformat t "Testing generate-inside-let-initializations...")

       ;;generate the code
       (generate-inside-let-initializations
        t t dcost-class bp1)

       (format t "let-initializations: ~a~%"
               (initializations-inside-the-let bp1))
       ;; check
       (format t "Added (best-neighbor nil)? ")
       (check-obj= `((best-neighbor-as-solution nil)
                     (best-cost 0)
                     (best-neighbor nil)
                     (ops-list nil)
                     (*vrp-stop-neighborhood-search* nil))
                   (initializations-inside-the-let bp1)))
     #+END_SRC
*** method :after(t t has-candidates-for-best-neighbor t)
**** description
     In this :after method, we'll initialize the variable candidates-for-best-neighbor
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-inside-let-initializations :after
          (description
           strategy
           (other-strategies has-candidates-for-best-neighbor)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(candidates-for-best-neighbor nil)
              (initializations-inside-the-let where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (dcost-class (make-instance
                          'has-candidates-for-best-neighbor))
            )


       (bformat t "Testing generate-inside-let-initializations...")

       ;;generate the code
       (generate-inside-let-initializations
        t t dcost-class bp1)

       (format t "let-initializations: ~a~%"
               (initializations-inside-the-let bp1))
       ;; check
       (format t "Added (best-neighbor nil)? ")
       (check-obj= `((candidates-for-best-neighbor nil)
                     (ops-list nil)
                     (*vrp-stop-neighborhood-search* nil))
                   (initializations-inside-the-let bp1)))
     #+END_SRC
*** method :after(t jump-around-search-strategy t t)
**** description
     In this :after method, we'll initialize the variable cumulative-delta-cost.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-inside-let-initializations :after
          (description
           (strategy jump-around-search-strategy)
           other-strategies
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(cumulative-cost 0)
              (initializations-inside-the-let where-to-store-it))

        (push `(best-jump-cost 0)
              (initializations-inside-the-let where-to-store-it))

        (push `(best-jump-cost-to-return 0)
              (initializations-inside-the-let where-to-store-it))

        (push `(best-jump-solution nil)
              (initializations-inside-the-let where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (dcost-class (make-instance
                          'has-a-cumulative-delta-cost))
            )


       (bformat t "Testing generate-inside-let-initializations...")

       ;;generate the code
       (generate-inside-let-initializations
        t dcost-class t bp1)

       (format t "let-initializations: ~a~%"
               (initializations-inside-the-let bp1))
       ;; check
       (format t "Added (cumulative-delta-cost 0)? ")
       (check-obj= `((cumulative-delta-cost 0)
                     (ops-list nil)
                     (*vrp-stop-neighborhood-search* nil))
                   (initializations-inside-the-let bp1))
       )
     #+END_SRC
*** method :around (t jump-around-search-strategy return-last t)
**** description
     In this :around method, we'll initialize the variable cumulative-delta-cost for the jump-around and we won't call any auxiliary methods.  This is probably an ugly hack and should be improved.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-inside-let-initializations :around
          (description
           (strategy jump-around-search-strategy)
           (other-strategies jump-around-return-last-neighbor)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(*vrp-stop-neighborhood-search* nil)
              (initializations-inside-the-let where-to-store-it))
        (push `(ops-list nil)
              (initializations-inside-the-let where-to-store-it))
        (push `(wc (basic-working-copy (clone solution)))
              (initializations-inside-the-let where-to-store-it))
        (push `(current-cost 0)
              (initializations-inside-the-let where-to-store-it))

        (push `(cumulative-cost 0)
              (initializations-inside-the-let where-to-store-it))

        (push `(best-jump-cost 0)
              (initializations-inside-the-let where-to-store-it))

        (push `(best-jump-cost-to-return 0)
              (initializations-inside-the-let where-to-store-it))

        (push `(best-jump-solution nil)
              (initializations-inside-the-let where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (dcost-class (make-instance
                          'has-a-cumulative-delta-cost))
            )


       (bformat t "Testing generate-inside-let-initializations...")

       ;;generate the code
       (generate-inside-let-initializations
        t dcost-class t bp1)

       (format t "let-initializations: ~a~%"
               (initializations-inside-the-let bp1))
       ;; check
       (format t "Added (cumulative-delta-cost 0)? ")
       (check-obj= `((cumulative-delta-cost 0)
                     (ops-list nil)
                     (*vrp-stop-neighborhood-search* nil))
                   (initializations-inside-the-let bp1))
       )
     #+END_SRC
** generate-outside-let-initializations
*** description
    In this generic function we create the initializations that should go outside the let in the neighborhood search function.

    In a very basic neighborhood exploration, we need to prepare the working-copy for the simulation of the neighborhood.
*** generic-function
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
    (defgeneric generate-outside-let-initializations
        (neighborhood-description
         search-strategy
         other-strategies
         where-to-store-it)
      (:documentation "This function receives a description of a neighborhood (in a human readable form) updates the argument where-to-store-it with the initializations that should be made outside the let."))
    #+END_SRC
*** method (t t t t) (prepare-for-neighborhood-exploration)
**** description
     In this base case, we'll add the prepare-solution-for-neighborhood-exploration instruction.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-outside-let-initializations
          (description
           strategy
           other-strategies
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(prepare-solution-for-neighborhood-exploration wc)
              (initializations-outside-the-let where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            )


       (bformat t "Testing generate-inside-let-initializations...")

       ;;generate the code
       (generate-outside-let-initializations t t t bp1)
       ;; check
       (format t "Added prepare wc for exploration? ")
       (check-obj= `((prepare-solution-for-neighborhood-exploration wc))
                   (initializations-outside-the-let bp1))
       )
     #+END_SRC
*** method (t macros t t) (initialize-action-for-computation)
**** description
     In this base case, we'll add the prepare-solution-for-neighborhood-exploration instruction.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-outside-let-initializations :after
          (description
           (strategy exhaustive/efficient-neighborhood-search-strategy)
           other-strategies
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(initialize-action-for-delta-cost-computation wc problem action)
              (initializations-outside-the-let where-to-store-it)))


      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            )


       (bformat t "Testing generate-inside-let-initializations...")

       ;;generate the code
       (generate-outside-let-initializations t t t bp1)
       ;; check
       (format t "Added prepare wc for exploration? ")
       (check-obj= `((prepare-solution-for-neighborhood-exploration wc))
                   (initializations-outside-the-let bp1))
       )
     #+END_SRC
*** method (t jump-around-search-strategy t t) 
**** description
     In this base case, we don't add the prepare-solution-for-neighborhood-exploration instruction because we do it inside the loop.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-outside-let-initializations
          (description
           (strategy jump-around-search-strategy)
           other-strategies
           (where-to-store-it basic-neighborhood-strategy-blueprint))
        "Don't do anything.  Wait for the auxiliary methods"
        nil)
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            )


       (bformat t "Testing generate-inside-let-initializations...")

       ;;generate the code
       (generate-outside-let-initializations
        t +jump-around-strategy+ t bp1)

       (format t "(initializations-outside-the-let bp1): ~a~%"
               (initializations-outside-the-let bp1))
       ;; check
       (format t "Added prepare wc for exploration? ")
       (check-nil (initializations-outside-the-let bp1))
       )
     #+END_SRC
** generate-code-inside-macros
*** description
    In this generic function we create the code that we should run inside the do-neighborhood macros.  According to the selection-strategy we are using, here we should do several things.

    If we are computing delta-cost, then maybe the first thing we should do here is to compute that delta cost, and with that value each selection strategy should behave differently.
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defgeneric generate-code-inside-macros
         (neighborhood-description
          search-strategy
          other-strategies
          where-to-store-it)
       (:documentation "This function receives a description of a neighborhood (in a human readable form) updates the argument where-to-store-it with the code that we should run inside the macros."))
     #+END_SRC
*** method (t t t t)
**** description
     Here, we won't do anything, just wait for the auxiliary methods.
**** code (don't do anything)
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-code-inside-macros
          (description
           strategy
           other-strategies
           where-to-store-it)
        "Don't do anything, just wait for the auxiliary methods."
        nil)
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (search-with-cost (make-instance
                               'search-with-delta-cost-computation))
            )


       (bformat t "Testing generate-inside-let-initializations...")

       ;;generate the code
       (generate-code-inside-macros t t search-with-cost bp1)
       ;; check
       (format t "Added prepare wc for exploration? ")
       (check-obj= `((setf current-delta-cost
                           (delta-cost (reverse ops-list) wc problem action)))
                   (code-inside-the-macros bp1))
       )
     #+END_SRC
*** method :after (t t compute-delta-cost-inefficiently t)
**** description
     In this case, the first thing we need to do inside the macros is to compute the current delta cost.  This means that we also need to add it to the inside-let-initializations.
**** code (compute delta-cost using =delta-cost=)
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-code-inside-macros :after
          (description
           strategy
           (other-strategies compute-delta-cost-inefficiently)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(setf current-delta-cost
                     (delta-cost (reverse ops-list) wc problem action))
              (code-inside-the-macros where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (search-with-cost (make-instance
                               'compute-delta-cost-inefficiently))
            )


       (bformat t "Testing generate-code-inside-macros")

       ;;generate the code
       (generate-code-inside-macros t t search-with-cost bp1)
       ;; check
       (format t "Added prepare wc for exploration? ")
       (check-obj= `((setf current-delta-cost
                           (delta-cost (reverse ops-list) wc problem action)))
                   (code-inside-the-macros bp1))
       )
     #+END_SRC
*** method :after (t t compute-delta-cost-with-smart-macros t)
**** description
     In this case we need to do several things:
      - finish-delta-cost-computation
      - bind current-delta-cost through get-delta-cost-from-action
      - undo-finish-delta-cost-computation

     I have just realized that we can do that right one after another, and not undo-finish-delta-cost-computation after everything else was done.  That could make things really easy :-o.  I'll test it in the handmade example.  OK.  It works!!! \o/.  This is going to be really easy.  I just need to check the order in which I should add the instructions.  Eureka!!!  I'll add them inside a =progn= and that should solve that issue :-D.
**** code (compute delta-cost using * macros)
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-code-inside-macros :after
          (description
           strategy
           (other-strategies compute-delta-cost-with-smart-macros)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(progn

                 (finish-delta-cost-computation wc problem action)
                 (setf current-delta-cost
                       (get-delta-cost-from-action action))

                 (undo-finish-delta-cost-computation wc problem action))

              (code-inside-the-macros where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (search-with-cost (make-instance
                               'compute-delta-cost-with-smart-macros))
            )


       (bformat t "Testing generate-code-inside-macros")

       ;;generate the code
       (generate-code-inside-macros t t search-with-cost bp1)

       (format t "Code inside the macros: ~a~%"
               (code-inside-the-macros bp1))
       ;; check


       (format t "Added prepare wc for exploration? ")
       (check-obj= `((progn
                       (finish-delta-cost-computation
                        wc problem action)
                       (setf current-delta-cost
                             (get-delta-cost-from-action action))
                       (undo-finish-delta-cost-computation wc problem action)))
                   (code-inside-the-macros bp1)))
     #+END_SRC
*** method :after (t t best-improvement t)
**** description
     In this case, we need to update the values of the best-neighbor.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-code-inside-macros :after
          (description
           strategy
           (other-strategies best-improvement-search-strategy)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(if (< current-delta-cost best-delta-cost)
                   ;; if it is
                   (then
                     ;; let's save the ops that make it
                     (setf best-neighbor (clone ops-list))
                     ;; let's update the best-cost
                     (setf best-delta-cost current-delta-cost)))
              (code-inside-the-macros where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (search-with-cost (best-improvement-search-strategy))
            )


       (bformat t "Testing generate-code-inside-macros")

       ;;generate the code
       (generate-code-inside-macros t t search-with-cost bp1)

       (format t "code-inside-the-macros:~%~a~%"
               (code-inside-the-macros bp1))
       ;; check
       (format t "Added best-neighbor update? ")
       (check-obj= `((if (< current-delta-cost best-delta-cost)
                         (then
                           (setf best-neighbor (clone ops-list))
                           (setf best-delta-cost current-delta-cost)))
                     (setf current-delta-cost
                           (delta-cost (reverse ops-list) wc problem action)))
                   (code-inside-the-macros bp1))
       )
     #+END_SRC
*** method :after (t t first-improvement t)
**** description
     In this case, we need to update the values of the best-neighbor and stop the iteration if we find a better neighbor.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-code-inside-macros :after
          (description
           strategy
           (other-strategies first-improvement-search-strategy)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(if (< current-delta-cost best-delta-cost)
                   ;; if it is
                   (then
                     ;; let's save the ops that make it
                     (setf best-neighbor (clone ops-list))
                     ;; let's update the best-cost
                     (setf best-delta-cost current-delta-cost)
                     ;; stop the search
                     (stop-neighborhood-search)))
              (code-inside-the-macros where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (search-with-cost (first-improvement-search-strategy))
            )


       (bformat t "Testing generate-code-inside-macros")

       ;;generate the code
       (generate-code-inside-macros t t search-with-cost bp1)

       (format t "code-inside-the-macros:~%~a~%"
               (code-inside-the-macros bp1))
       ;; check
       ;; (format t "Added best-neighbor update? ")
       ;; (check-obj= `((if (< current-delta-cost best-delta-cost)
       ;;                   (then
       ;;                     (setf best-neighbor (clone ops-list))
       ;;                     (setf best-delta-cost current-delta-cost)))
       ;;               (setf current-delta-cost
       ;;                     (delta-cost (reverse ops-list) wc problem action)))
       ;;             (code-inside-the-macros bp1))
       )
     #+END_SRC
*** method :after (t t has-candidates-for-best-neighbor t)
**** description
     In this case, when we find a neighbor better than the current one, we push it into the =candidates-for-best-neighbor= list.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-code-inside-macros :after
          (description
           strategy
           (other-strategies has-candidates-for-best-neighbor)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(if (< current-delta-cost best-delta-cost)
                   ;; if it is
                   (then
                     ;; let's push the neighbor into the
                     ;; list of candidates
                     (push (list (clone ops-list) current-delta-cost)
                           candidates-for-best-neighbor)))
              (code-inside-the-macros where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (search-with-cost (make-instance
                               'has-candidates-for-best-neighbor))
            )


       (bformat t "Testing generate-code-inside-macros")

       ;;generate the code
       (generate-code-inside-macros t t search-with-cost bp1)

       (format t "code-inside-the-macros:~%~a~%"
               (code-inside-the-macros bp1))
       ;; check
       ;; (format t "Added best-neighbor update? ")
       ;; (check-obj= `((if (< current-delta-cost best-delta-cost)
       ;;                   (then
       ;;                     (setf best-neighbor (clone ops-list))
       ;;                     (setf best-delta-cost current-delta-cost)))
       ;;               (setf current-delta-cost
       ;;                     (delta-cost (reverse ops-list) wc problem action)))
       ;;             (code-inside-the-macros bp1))
       )
     #+END_SRC
*** method :after (t t random-improvement (without candidates) t)
**** description
     In this case, when we find a neighbor better than the current one, we make a probability check and if if successes, we return it.  If it fails and best-solution is not bound yet, we bind it to this solution.  (In case all checks fail, we still return the best-solution found).
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-code-inside-macros :after
          (description
           strategy
           (other-strategies random-improvement-selection-strategy)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(if (< current-delta-cost best-delta-cost)
                   ;; if it is
                   (then
                     ;; let's make a random check:
                     (let* ((r (random 1.0)))
                       (if (<= r ,(acceptance-ratio other-strategies))
                           ;; let's set the best-neighbor
                           ;; and stop the search
                           (then
                             (setf best-neighbor (clone ops-list))
                             (setf best-delta-cost current-delta-cost)
                             (stop-neighborhood-search))
                           (else ;; let's check if
                             ;; best-neighbor is bound
                             ;; if it isn't bind it to
                             ;; this neighbor
                             ;; [this would be a first-improvement]
                             (unless best-neighbor
                               (setf best-neighbor (clone ops-list))
                               (setf best-delta-cost current-delta-cost)))))))
              (code-inside-the-macros where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (search-with-cost (make-instance
                               'random-improvement-selection-strategy))
            )


       (bformat t "Testing generate-code-inside-macros")

       ;;generate the code
       (generate-code-inside-macros t t search-with-cost bp1)

       (format t "code-inside-the-macros:~%~a~%"
               (code-inside-the-macros bp1))
       ;; check
       ;; (format t "Added best-neighbor update? ")
       ;; (check-obj= `((if (< current-delta-cost best-delta-cost)
       ;;                   (then
       ;;                     (setf best-neighbor (clone ops-list))
       ;;                     (setf best-delta-cost current-delta-cost)))
       ;;               (setf current-delta-cost
       ;;                     (delta-cost (reverse ops-list) wc problem action)))
       ;;             (code-inside-the-macros bp1))
       )
     #+END_SRC
*** method :after (t jump-around-search-strategy t t)
**** description
     Here we apply the operations and set the new cost of the working-copy.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-code-inside-macros :after
          (description
           (strategy jump-around-search-strategy)
           other-strategies
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(progn
                 ;; as we have a cumulative-delta-cost
                 ;; we need to update-it
                 (incf cumulative-delta-cost current-delta-cost)

                 ;; let's apply the operations
                 (apply-set-of-operations
                  (reverse ops-list) wc)

                 ;; let's update the solution cost
                 (setf (cost wc) 
                       (+ (cost wc)
                          (+ (delta-distance action)
                             (total-penalty action)))))
              (code-inside-the-macros where-to-store-it))

        (push
         ;; let's check for the best better solution
         `(if (< current-delta-cost best-jump-delta-cost)
              (then ;; we found a best-better-solution

                (setf best-jump-solution
                      (clone (solution wc)))
                ;; we don't need to update the cost
                ;; of the best solution
                ;; because it was already done before.


                ;; the best-delta-cost is now 0
                ;; because the current-neighbor
                ;; is also updated.
                (setf best-jump-delta-cost 0)

                ;; here we set the best-jump-delta-cost-to-return
                ;; to the current-delta-cost
                ;; because that's the actual difference
                ;; from the initial solution
                (setf best-jump-delta-cost-to-return
                      cumulative-delta-cost)
                )
              (else ;; if the current-cost is not better,
                ;; we need to update the best-delta-cost
                (incf best-jump-delta-cost (- current-delta-cost))))

              (code-inside-the-macros where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (search-with-cost (jump-around-search-strategy))

            )


       (bformat t "Testing generate-code-inside-macros")


       ;; (format t "applicable-methods: ~a~%"
       ;;         (compute-applicable-methods
       ;;          #'generate-code-inside-macros
       ;;          (list t +jump-around-strategy+ t bp1)))
  
       ;;generate the code
       (generate-code-inside-macros
        t
        +jump-around-strategy+
        (make-instance 'search-with-delta-cost-computation)
        bp1)
  

       (format t "code-inside-the-macros:~%~a~%"
               (code-inside-the-macros bp1))


       ;; check
       ;; (format t "Added best-neighbor update? ")
       ;; (check-obj= `((if (< current-delta-cost best-delta-cost)
       ;;                   (then
       ;;                     (setf best-neighbor (clone ops-list))
       ;;                     (setf best-delta-cost current-delta-cost)))
       ;;               (setf current-delta-cost
       ;;                     (delta-cost (reverse ops-list) wc problem action)))
       ;;             (code-inside-the-macros bp1))
       )
     #+END_SRC
*** method :after (t t return-last-neighbor t)
**** description
     In this case, we unconditionally set the value of the best-neighbor and the best-cost.  This way, the strategy =return-best-solution= always returns the last-neighbor.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-code-inside-macros :after
          (description
           strategy
           (other-strategies return-last-neighbor-selection-strategy)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(progn
                 ;; let's set the best-neighbor
                 (setf best-neighbor (clone ops-list))
                 ;; let's update the best-cost
                 (setf best-delta-cost current-delta-cost))
              (code-inside-the-macros where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (search-with-cost (make-instance
                               'return-last-neighbor-selection-strategy))
            )


       (bformat t "Testing generate-code-inside-macros")

       ;;generate the code
       (generate-code-inside-macros t t search-with-cost bp1)

       (format t "code-inside-the-macros:~%~a~%"
               (code-inside-the-macros bp1))
       ;; check
       (format t "Added best-neighbor update? ")
       (check-obj= `((progn
                       (setf best-neighbor (clone ops-list))
                       (setf best-delta-cost current-delta-cost))
                     (setf current-delta-cost
                           (delta-cost (reverse ops-list) wc problem action)))
                   (code-inside-the-macros bp1))
       )
     #+END_SRC
** generate-code-outside-macros
*** description
    In this generic function we generate the code that we should run after the neighborhood was explored. This is the place to create the best-neighbor-as-solution if we have to.
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defgeneric generate-code-outside-macros
         (neighborhood-description
          search-strategy
          other-strategies
          where-to-store-it)
       (:documentation "This function receives a description of a neighborhood (in a human readable form) and updates the argument where-to-store-it with the code that we should run after the macros finished the exploration of the neighborhood."))
     #+END_SRC
*** method (t t t t)
**** description
     In this case, we don't do anything.  We just wait for the auxiliary methods.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-code-outside-macros
          (description
           strategy
           other-strategies
           where-to-store-it)
       "Don't do anything.  Wait for the auxiliary methods."
        nil)
      #+END_SRC
*** method :after (t t return-best-solution t)
**** description
     In this case, we need to check whether or not there is a best-neighbor and if so, create the best-neighbor-as-solution.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-code-outside-macros :after
          (description
           strategy
           (other-strategies return-best-solution )
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(if best-neighbor
                   (then
                     (apply-set-of-operations (reverse best-neighbor) wc)
                     (setf best-neighbor-as-solution
                           (solution wc))
                     (setf (cost best-neighbor-as-solution)
                           (+ (cost solution)
                              best-delta-cost))))
              (code-outside-the-macros where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (search-with-cost (make-instance 'return-best-solution))
            )


       (bformat t "Testing generate-code-outside-macros")

       ;;generate the code
       (generate-code-outside-macros t t search-with-cost bp1)

       (format t "code-outside-the-macros:~%~a~%"
               (code-outside-the-macros bp1))
       ;; check
       ;; (format t "Added best-neighbor update? ")
       ;; (check-obj= `((if (< current-delta-cost best-delta-cost)
       ;;                   (then
       ;;                     (setf best-neighbor (clone ops-list))
       ;;                     (setf best-delta-cost current-delta-cost)))
       ;;               (setf current-delta-cost
       ;;                     (delta-cost (reverse ops-list) wc problem action)))
       ;;             (code-inside-the-macros bp1))
       )
     #+END_SRC
*** method *primary* (t jump-around return-last-solution t)
**** description
     In this case, we need to check whether or not there is a best-neighbor and if so, create the best-neighbor-as-solution.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-code-outside-macros
          (description
           (strategy jump-around-search-strategy)
           (other-strategies return-last-neighbor-selection-strategy )
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(setf best-neighbor-as-solution
                 (clone (solution wc)))
              (code-outside-the-macros where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (search-with-cost
             (make-instance 'return-last-neighbor-selection-strategy))
            )


       (bformat t "Testing generate-code-outside-macros")

       ;;generate the code
       (generate-code-outside-macros t t search-with-cost bp1)

       (format t "code-outside-the-macros:~%~a~%"
               (code-outside-the-macros bp1))
       ;; check
       ;; (format t "Added best-neighbor update? ")
       ;; (check-obj= `((if (< current-delta-cost best-delta-cost)
       ;;                   (then
       ;;                     (setf best-neighbor (clone ops-list))
       ;;                     (setf best-delta-cost current-delta-cost)))
       ;;               (setf current-delta-cost
       ;;                     (delta-cost (reverse ops-list) wc problem action)))
       ;;             (code-inside-the-macros bp1))
       )
     #+END_SRC
*** method :after (t t has-candidates-for-best-neighbor t)
**** description
     In this case, we set the best-neighbor as a random neighbor selected from the list of candidates.  We have to execute this before the code that return-best-solution inserts, because here is where we set the value of best-neighbor, so we have to be careful in the order of the parents when we define the class.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-code-outside-macros :after
          (description
           strategy
           (other-strategies has-candidates-for-best-neighbor )
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(if candidates-for-best-neighbor
                   (then
                     (let* ((selected-position
                             (random (length candidates-for-best-neighbor)))
                            (selected-info
                             (nth selected-position
                                  candidates-for-best-neighbor)))
                       (setf best-neighbor
                             (first selected-info)
                             best-delta-cost
                             (second selected-info)))))
              (code-outside-the-macros where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (search-with-cost
             (make-instance 'has-candidates-for-best-neighbor))
            )


       (bformat t "Testing generate-code-outside-macros")

       ;;generate the code
       (generate-code-outside-macros t t search-with-cost bp1)

       (format t "code-outside-the-macros:~%~a~%"
               (code-outside-the-macros bp1))

       ;; ;; ;; check
       (format t "Added best-neighbor update? ")
       (check-obj= 
        `((if candidates-for-best-neighbor
          (then
            (let* ((selected-position
                    (random (length candidates-for-best-neighbor)))
                   (selected-info
                    (nth selected-position candidates-for-best-neighbor)))
              (setf best-neighbor (first selected-info)
                    best-delta-cost (second selected-info))))))
                   (code-outside-the-macros bp1)))
     #+END_SRC
** generate-return-code
*** description
    In this generic function we generate the code with what to return from the neighborhood-search.
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defgeneric generate-return-code
         (neighborhood-description
          search-strategy
          other-strategies
          where-to-store-it)
       (:documentation "This function receives a description of a neighborhood (in a human readable form) and updates the argument where-to-store-it with the code that we should run to return the result of the neighborhood exploration."))
     #+END_SRC

*** method (t t t t)
**** description
     In this case, we don't do anything.  We just wait for the auxiliary methods.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-return-code
          (description
           strategy
           other-strategies
           where-to-store-it)
       "Don't do anything.  Wait for the auxiliary methods."
        nil)
      #+END_SRC
     
*** method :after (t t return-best-solution t)
**** description
     In this case, we return the best-neighbor.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-return-code :after
          (description
           strategy
           (other-strategies return-best-solution)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

          (push 'best-neighbor-as-solution
           (return-code where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (search-with-cost (best-improvement-search-strategy))
            )


       (bformat t "Testing generate-return-code")

       ;;generate the code
       (generate-code-outside-macros t t search-with-cost bp1)

       (format t "return-code:~%~a~%"
               (return-code bp1))
       ;; check
       (format t "Added best-neighbor update? ")
       (check-obj= `(best-neighbor-as-solution)
                   (return-code bp1)))
     #+END_SRC
*** method :after (t t return-best-delta-cost t)
**** description
     In this case, we return the best-neighbor.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-return-code :after
          (description
           strategy
           (other-strategies return-best-delta-cost)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push 'best-delta-cost
              (return-code where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (search-with-cost
             (make-instance 'return-best-delta-cost))
            )


       (bformat t "Testing generate-return-code")

       ;;generate the code
       (generate-return-code t t search-with-cost bp1)

       (format t "return-code:~%~a~%"
               (return-code bp1))
       ;; check
       (format t "Added best-neighbor update? ")
       (check-obj= `(best-delta-cost)
                   (return-code bp1)))
     #+END_SRC
*** tests for return-last-solution
**** description
     Here we just test the return-code for return-last-solution
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (search-with-cost
             (make-instance 'return-last-neighbor-selection-strategy))
            )


       (bformat t "Testing generate-return-code")

       ;;generate the code
       (generate-return-code t t search-with-cost bp1)

       (format t "return-code:~%~a~%"
               (return-code bp1))
       ;; check
       (format t "Added best-neighbor update? ")
       (check-obj= `(best-delta-cost best-neighbor-as-solution)
                   (return-code bp1)))
     #+END_SRC
*** method :after (t jump-around-search-strategy t t)
**** description
     In this case we return the last cumulative-neighbor, and the cumulative-delta-cost.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-return-code :after
          (description
           (strategy jump-around-search-strategy)
           other-strategies
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push '(clone (solution wc))
              (return-code where-to-store-it))
        (push 'cumulative-delta-cost
              (return-code where-to-store-it))
        (push 'best-jump-solution
              (return-code where-to-store-it))
        (push 'best-jump-delta-cost-to-return
              (return-code where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (search-with-cost (make-instance
                               'jump-around-search-strategy)))


       (bformat t "Testing generate-return-code")

       ;;generate the code
       (generate-return-code t search-with-cost +best-improvement+ bp1)

       (format t "return-code:~%~a~%"
               (return-code bp1))
       ;; check
       ;; (format t "Added best-neighbor update? ")
       ;; (check-obj= `(best-neighbor-as-solution)
       ;;             (return-code bp1))
       )
     #+END_SRC



** prepare-blueprint-for-code-generation
*** description
    This function receives a list with the description of the neighborhood criterion, the wanted behavior (as instances of classes) and a blueprint and setups the blueprint with all the info required to write the actual code.
*** generic-function
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defgeneric prepare-blueprint-for-code-generation
         (neighborhood-description
          search-strategy
          other-strategies
          where-to-store-it)
       (:documentation "This function receives a list with the description of the neighborhood criterion, the wanted behavior (as instances of classes) and a blueprint and setups the blueprint with all the info required to write the actual code."))
     #+END_SRC
*** method (list t t basic-blueprint)
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod prepare-blueprint-for-code-generation
          ((description list)
           strategy
           other-strategies
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        ;; first we generate the macro calls
        (generate-macro-calls
         description strategy other-strategies where-to-store-it)
        ;; then the inside-let
        (generate-inside-let-initializations
         description strategy other-strategies where-to-store-it)
        ;; next, the outside-let.
        (generate-outside-let-initializations
         description strategy other-strategies where-to-store-it)
        ;; Now what's inside the macros
        (generate-code-inside-macros
         description strategy other-strategies where-to-store-it)
        ;; and then what's outside them
        (generate-code-outside-macros
         description strategy other-strategies where-to-store-it)
        ;; finally, we set the return code
        (generate-return-code
         description strategy other-strategies where-to-store-it))
      #+END_SRC
*** tests
    #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
    (let* ((bp1 (basic-strategy-blueprint))
           (code `((select-route r1)
                   (select-client c1 from r1)
                   (insert-client c1 into r1))))

      (bformat t "Testing prepare-bluprint...")
  
      (prepare-blueprint-for-code-generation
       code +exhaustive-search-strategy+ +best-improvement+ bp1)

      (format t "inside let:~%~{     ~a~%~}~%"
              (initializations-inside-the-let bp1))
      (format t "outside let:~%~{     ~a~%~}~%"
              (initializations-outside-the-let bp1))
      (format t "macro headings:~%~{     ~a~%~}~%"
              (macro-headings bp1))
      (format t "code-inside macros:~%~{     ~a~%~}~%"
              (code-inside-the-macros bp1))
      (format t "code-outside the macros:~%~{     ~a~%~}~%"
              (code-outside-the-macros bp1))
      (format t "return code:~%~{     ~a~%~}~%"
              (return-code bp1))
      )
    #+END_SRC
    
    

* Generic-functions for the creation of the functions
** description
   In this section we create the functions that will create the code for the actual neighborhood search functions from the blueprints.
** write-neighborhood-exploration-code
*** description
    This function receives a blueprint and returns a list with the code of a neighborhood exploration function.  We should take into acount that all the code-snippets in the blueprint were pushed, so we need to reverse them.

    This function can receive as named parameters extra code that can be inserted at several places in the function.  For instance, it can be inserted at the end of the let, at the end of the initializations outside the let, etc.
*** generic-function
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
    (defgeneric write-neighborhood-exploration-code
        (blueprint
         &key
           inside-let
           outside-let
           inside-macro
           outside-macro)
  
      (:documentation "A function to generate the actual code from a blueprint."))
    #+END_SRC
    
*** method (basic-neighborhood-strategy-blueprint)
**** description
     In this method we just add the header of the function, and insert the slots of the blueprints appropriately.
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod write-neighborhood-exploration-code 
          ((blueprint basic-neighborhood-strategy-blueprint)
           &key
           inside-let
           outside-let
           inside-macro
           outside-macro)

        (declare (ignorable inside-let
                            outside-let
                            inside-macro
                            outside-macro))

        (let* (;; first, let's compose the body
               ;; inside the macros
               ;; let's get the code-inside-the-macros
               (inner-code (reverse
                            (append
                            inside-macro
                            (code-inside-the-macros blueprint))))
               (headings (macro-headings blueprint))
               (macro-code nil)
               (let-code
                `(let* ,(reverse
                         (initializations-inside-the-let blueprint))))
               (result)
               )
          ;; let's create the code inside the first
          ;; of the macros
          (setf macro-code `(,@(first headings) ,@inner-code))
          ;; let's create the code inside the rest of the macros
          (loop for macro in (rest (macro-headings blueprint))
                doing (setf macro-code
                            `(,@macro ,macro-code)))

          ;; next we should write the code outside the macros
          (setf result `(,macro-code
                        ;; this is the code outside the macros
                        ,@(reverse (code-outside-the-macros blueprint))
                        ;; and this is the return code
                        (values ,@ (reverse (return-code blueprint)))))

          ;; now let's add the let and
          ;; the initializations outside the let
          (setf result (append
                        let-code
                        (reverse (initializations-outside-the-let blueprint))
                        result))

          ;; finally, the function heading:
          (setf result
                `(lambda (solution problem action graph
                          &optional (initial-best-delta-cost 0))
                   (declare (ignorable initial-best-delta-cost
                                       solution problem action graph))

                          ,result))
          ;; and now, let's return result
          result))
      #+END_SRC
**** test
***** basic-test
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (bp1 (basic-strategy-blueprint))
             (code `((select-route r1)
                     (select-client c1 from r1)
                     (insert-client c1 into r1)))
             )


        (bformat t "Testing write-search-code")

        ;; let's populate the blueprint
        (prepare-blueprint-for-code-generation
         code +exhaustive-search-strategy+ +best-improvement+ bp1)

        (format t "the generated code:~%~a~%"
                (write-neighborhood-exploration-code bp1)))
      #+END_SRC

***** testing :inside-macro
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (bp1 (basic-strategy-blueprint))
             (code `((select-route r1)
                     (select-client c1 from r1)
                     (insert-client c1 into r1)))
             )


        (bformat t "Testing write-search-code")

        ;; let's populate the blueprint
        (prepare-blueprint-for-code-generation
         code +exhaustive-search-strategy+ +best-improvement+ bp1)

        (format t "the generated code:~%~a~%"
                (write-neighborhood-exploration-code
                 bp1 :inside-macro `((progn
                                       (pp-solution wc t) (terpri))))))
      #+END_SRC

***** testing :inside-macro with empty strategy
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (bp1 (basic-strategy-blueprint))
             (code `((select-route r1)
                     (select-client c1 from r1)
                     (insert-client c1 into r1)))
             )


        (bformat t "Testing write-search-code")

        ;; let's populate the blueprint
        (prepare-blueprint-for-code-generation
         code +exhaustive-search-strategy+ t bp1)

        (format t "the generated code:~%~a~%"
                (write-neighborhood-exploration-code
                 bp1 :inside-macro `((progn
                                       (pp-solution wc t) (terpri))))))
      #+END_SRC

***** testing :inside-macro first-improvement
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (bp1 (basic-strategy-blueprint))
             (code `((select-route r1)
                     (select-client c1 from r1)
                     (insert-client c1 into r1)))
             )


        (bformat t "Testing write-search-code")

        ;; let's populate the blueprint
        (prepare-blueprint-for-code-generation
         code +exhaustive-search-strategy+ +best-improvement+ bp1)

        ;; (format t "what-happens: ~a~%"
        ;;         (compute-applicable-methods
        ;;          'generate-code-outside-macros
        ;;          (list code
        ;;                +exhaustive-search-strategy+
        ;;                +first-improvement+
        ;;                bp1)))

        (format t "code-outside macro: ~a~%"
                (code-outside-the-macros bp1))

        (format t "the generated code:~%~a~%"
                (write-neighborhood-exploration-code
                 bp1 ;; :inside-macro `((progn
                     ;;                   (pp-solution wc t) (terpri)))
                 )))
      #+END_SRC

***** testing :inside-macro random-improvement
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (bp1 (basic-strategy-blueprint))
             (code `((select-route r1)
                     (select-client c1 from r1)
                     (insert-client c1 into r1)))
             )


        (bformat t "Testing write-search-code")

        ;; let's populate the blueprint
        (prepare-blueprint-for-code-generation
         code
         +exhaustive-search-strategy+
         +random-improvement+
         bp1)

        ;; (format t "what-happens: ~a~%"
        ;;         (compute-applicable-methods
        ;;          'generate-code-outside-macros
        ;;          (list code
        ;;                +exhaustive-search-strategy+
        ;;                +first-improvement+
        ;;                bp1)))

        (format t "code-outside macro: ~a~%"
                (code-outside-the-macros bp1))

        (format t "the generated code:~%~a~%"
                (write-neighborhood-exploration-code
                 bp1 ;; :inside-macro `((progn
                     ;;                   (pp-solution wc t) (terpri)))
                 )))
      #+END_SRC

*** testing random-search
**** basic-test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            ;; (code1 `((select-route r1)
            ;;         (select-client c1 from r1)
            ;;         (insert-client c1 into r1)))
            (code2 `((select-route r1)
                    (select-subroute z1 from r1)
                    (insert-subroute z1 into r1)))
            )


       (bformat t "Testing write-search-code")

       ;; let's populate the blueprint
       (prepare-blueprint-for-code-generation
        code2
        ;; (random-neighborhood-search-strategy 100)
        +exhaustive-search-strategy+
        +best-improvement+ bp1)

       (format t "the generated code:~%~a~%"
               (write-neighborhood-exploration-code bp1)))
     #+END_SRC

*** testing jump-around-search-strategy
**** basic-test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            ;; (code1 `((select-route r1)
            ;;         (select-client c1 from r1)
            ;;         (insert-client c1 into r1)))
            (code2 `((select-route r1)
                    (select-subroute z1 from r1)
                    (insert-subroute z1 into r1)))
            )


       (bformat t "Testing write-search-code")

       ;; let's populate the blueprint
       (prepare-blueprint-for-code-generation
        code2
        +jump-around-strategy+
        +jump-around-last-neighbor+
        bp1)

       (format t "the generated code:~%~a~%"
               (write-neighborhood-exploration-code bp1)))
     #+END_SRC

*** testing jump-around-with-best-search-strategy
**** basic-test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            ;; (code1 `((select-route r1)
            ;;         (select-client c1 from r1)
            ;;         (insert-client c1 into r1)))
            (code2 `((select-route r1)
                    (select-subroute z1 from r1)
                    (insert-subroute z1 into r1)))
            )


       (bformat t "Testing write-search-code")

       ;; let's populate the blueprint
       (prepare-blueprint-for-code-generation
        code2
        +jump-around-strategy+
        +jump-around-best-neighbor+
        bp1)

       (format t "the generated code:~%~a~%"
               (write-neighborhood-exploration-code bp1)))
     #+END_SRC

*** testing return-last-neighbor-selection-strategy
**** basic-test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            ;; (code1 `((select-route r1)
            ;;         (select-client c1 from r1)
            ;;         (insert-client c1 into r1)))
            (code2 `((select-route r1)
                    (select-subroute z1 from r1)
                    (insert-subroute z1 into r1)))
            )


       (bformat t "Testing write-search-code")

       ;; (format t "applicable-methods:~%~a~%"
       ;;         (compute-applicable-methods
       ;;          #'generate-code-outside-macros
       ;;          (list code2 +random-search-strategy+
       ;;                +random-improvement+ bp1)))

       ;; let's populate the blueprint
       (prepare-blueprint-for-code-generation
        code2
        (jump-around-search-strategy 10)
        ;; +random-search-strategy+
        ;; +return-last-neighbor+
        (make-instance 'jump-around-return-last-neighbor)
        ;; +best-improvement+
        ;; +random-improvement+

        bp1)



       (format t "the generated code:~%~a~%"
               (write-neighborhood-exploration-code bp1))

       ;; (format t "code-outside-the-macros:~%~a~%"
       ;;         (code-outside-the-macros bp1))
       )
     #+END_SRC

*** testing macros* strategy
**** basic-test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            ;; (code1 `((select-route r1)
            ;;         (select-client c1 from r1)
            ;;         (insert-client c1 into r1)))
            (code2 `((select-route r1)
                     (select-client c1 from r1)
                     (insert-client c1 into r1)))
            )


       (bformat t "Testing write-search-code")

       ;; (format t "applicable-methods:~%~a~%"
       ;;         (compute-applicable-methods
       ;;          #'generate-code-outside-macros
       ;;          (list code2 +exhaustive-search-strategy+
       ;;                +best-improvement+ bp1)))

       ;; let's populate the blueprint
       (prepare-blueprint-for-code-generation
        code2
        ,*exhaustive-search-strategy*
        ;; +random-search-strategy+
        ;; +return-last-neighbor+
        ,*random-improvement*
        ;; +best-improvement+
        ;; +random-improvement+

        bp1)



       (format t "the generated code:~%~a~%"
               (write-neighborhood-exploration-code bp1))

       ;; (format t "code-outside-the-macros:~%~a~%"
       ;;         (code-outside-the-macros bp1))
       )
     #+END_SRC

*** testing random-search with candidates
**** basic-test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            ;; (code1 `((select-route r1)
            ;;         (select-client c1 from r1)
            ;;         (insert-client c1 into r1)))
            (code2 `((select-route r1)
                    (select-subroute z1 from r1)
                    (insert-subroute z1 into r1)))
            )


       (bformat t "Testing write-search-code")

       ;; let's populate the blueprint
       (prepare-blueprint-for-code-generation
        code2
        ;; (random-neighborhood-search-strategy 100)
        +exhaustive-search-strategy+
        +random-improvement-with-candidates+
        bp1)

       (format t "the generated code:~%~a~%"
               (write-neighborhood-exploration-code bp1)))
     #+END_SRC

*** testing random-search without candidates
**** basic-test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            ;; (code1 `((select-route r1)
            ;;         (select-client c1 from r1)
            ;;         (insert-client c1 into r1)))
            (code2 `((select-route r1)
                    (select-subroute z1 from r1)
                    (insert-subroute z1 into r1)))
            )


       (bformat t "Testing write-search-code")

       ;; let's populate the blueprint
       (prepare-blueprint-for-code-generation
        code2
        ;; (random-neighborhood-search-strategy 100)
        ,*exhaustive-search-strategy*
        ,*best-improvement*
        bp1)

       (format t "the generated code:~%~a~%"
               (write-neighborhood-exploration-code bp1)))
     #+END_SRC

*** testing search for repeated elements
**** basic-test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (code1 `((select-route r1)
                    (select-client c1 from r1)
                    (insert-client c1 into r1)))
            )


       (bformat t "Testing write-search-code")

       ;; let's populate the blueprint
       (prepare-blueprint-for-code-generation
        code1
        ;; (random-neighborhood-search-strategy 100)
        ,*exhaustive-search-strategy*
        ,*best-improvement*
        bp1)

       (format t "the generated code:~%~a~%"
               (write-neighborhood-exploration-code bp1)))
     #+END_SRC

** make-neighborhood-exploration-function
*** description
    This function receives a blueprint and returns a lambda that explores the neighborhood according to the strategies in the blueprint
*** generic-function
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
    (defgeneric make-neighborhood-exploration-function
        (blueprint
         &key
           inside-let
           outside-let
           inside-macro
           outside-macro)

      (:documentation "A function to create the functions that actually explore the neighborhood."))
    #+END_SRC
    
*** method (basic-neighborhood-strategy-blueprint)
**** description
     In this method we just call eval (:-o) on the code returned by =write-neighborhood-exploration-code=.  There must be better ways to do this, but I haven't found them :-(.

**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod make-neighborhood-exploration-function 
          ((blueprint basic-neighborhood-strategy-blueprint)
           &key
           inside-let
           outside-let
           inside-macro
           outside-macro)


        (eval (write-neighborhood-exploration-code
               blueprint
               :inside-let inside-let
               :outside-let outside-let
               :inside-macro inside-macro
               :outside-macro outside-macro)))
      #+END_SRC
**** test
***** testing the function
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (bp1 (basic-strategy-blueprint))
             (code `((select-route r1)
                     (select-client c1 from r1)
                     (insert-client c1 into r1)))
             )


        (bformat t "Testing make-neighborhood-exploration-function")

        ;; let's populate the blueprint
        (prepare-blueprint-for-code-generation
         code +exhaustive-search-strategy+ +best-improvement+ bp1)

        (format t "the generated code:~%~a~%"
                (make-neighborhood-exploration-function bp1)))
      #+END_SRC
***** testing the keywords
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
            (let* ((*vrp-unit-testing-display-output* nil)
                   (*vrp-unit-testing-display-results* t)
                   (bp1 (basic-strategy-blueprint))
                   (code `((select-route r1)
                           (select-client c1 from r1)
                           (insert-client c1 into r1))))


              (bformat t "Testing make-neighborhood-exploration-function")

              ;; let's populate the blueprint
              (prepare-blueprint-for-code-generation
               code +exhaustive-search-strategy+ +best-improvement+ bp1)

              (format t "the generated code:~%~a~%"
                      (make-neighborhood-exploration-function
                       bp1 :inside-macro
                       `((progn
                           (format t "debug: with c1 ~a, r1 ~a"
                                   (client-selected-at-operation c1 wc)
                                   r1))))))
      #+END_SRC
***** testing an exploration
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                            (5 0 6 7 2 4)  ;1
                                            (1 8 0 3 9 1)  ;2
                                            (4 5 1 0 5 7)  ;3
                                            (4 5 1 5 0 6)  ;4
                                            (1 5 7 6 9 0)) ;5
                                            ;0 1 2 3 4 5 
                                :demands '(20 10 15 40 30)
                                :capacity 40)
          (with-basic-cvrp-solution (s1 ((1) (3 4) (5) (2)) p1)
            (let* ((action (delta-cvrp-action))
                   (cvrp-action (basic-cvrp-action))
                   (bp (basic-strategy-blueprint))
                   (bp1 (basic-strategy-blueprint))
                   rarb rarabb 
                   best-neighbor)




              (bformat t "Testing delta-cost")

              ;; let's simulate the solution
              (simulate-solution s1 p1 cvrp-action)
              (setf (cost s1) (+ (total-distance cvrp-action)
                                 (total-penalty cvrp-action)))

              (format t "With cost: ~a~%"
                      (cost s1))
              (pp-solution s1 t) (terpri)

              ;; (progn ;; for rarb

              ;;   (prepare-blueprint-for-code-generation
              ;;   `((select-route r1)
              ;;     (select-client c1 from r1)
              ;;     (select-route r2)
              ;;     (insert-client c1 into r2))
              ;;   +exhaustive-search-strategy+
              ;;   +best-improvement+ 
              ;;   bp)

              ;;  (setf rarb (make-neighborhood-exploration-function bp))
              ;;  ;; let's get the best neighbor
              ;;  (setf best-neighbor (funcall rarb s1 p1 action))

              ;;  (if best-neighbor
              ;;      (then
              ;;        (format t "After rarb we found...~%")
              ;;        (format t "With cost ~a...~%" (cost best-neighbor))
              ;;        (pp-solution best-neighbor t))
              ;;      (else
              ;;        (format t "No best neighbor found :-[."))))

              ;; (progn ;; for rarabb

              ;;   (prepare-blueprint-for-code-generation
              ;;   `((select-route r1)
              ;;     (select-client c1 from r1)
              ;;     (select-route r2)
              ;;     (select-client c2 from r2)
              ;;     (insert-client c1 into r2)
              ;;     (insert-client c2 into r1))
              ;;   +exhaustive-search-strategy+
              ;;   +best-improvement+ 
              ;;   bp1)

              ;;   (format t "After rarb s1 is~%")
              ;;   (pp-solution s1 t) (terpri)

              ;;   ;; (format t "code is:~%~a~%"
              ;;   ;;         (write-neighborhood-exploration-code bp1))

              ;;  (setf rararbrb (make-neighborhood-exploration-function bp1))
              ;;  ;; ;; let's get the best neighbor
              ;;  (setf best-neighbor (funcall rararbrb s1 p1 action))

              ;;  (if best-neighbor
              ;;      (then
              ;;        (format t "After rararbrb we found...~%")
              ;;        (format t "With cost ~a...~%" (cost best-neighbor))
              ;;        (pp-solution best-neighbor t))
              ;;      (else
              ;;        (format t "No best neighbor found :-[.")))
              ;;  )


              (progn ;; for rarabb

                (prepare-blueprint-for-code-generation
                `((select-route r1)
                  (select-client c1 from r1)
                  (select-route r2)
                  (select-client c2 from r2)
                  (select-route r3)
                  (insert-client c1 into r3)
                  (select-route r4)
                  (insert-client c2 into r4))
                +exhaustive-search-strategy+
                +best-improvement+ 
                bp1)

                ;; (format t "code is:~%~a~%"
                ;;         (write-neighborhood-exploration-code bp1))

                (setf rararbrb
                      (make-neighborhood-exploration-function
                       bp1))
               ;; ;; let's get the best neighbor
               (setf best-neighbor (funcall rararbrb s1 p1 action))

               (if best-neighbor
                   (then
                     (format t "After rararbrb we found...~%")
                     (format t "With cost ~a...~%" (cost best-neighbor))
                     (pp-solution best-neighbor t))
                   (else
                     (format t "No best neighbor found :-[.")))
               )

              (progn
                (format t "testing Yoel~%")
                (with-basic-cvrp-solution (s2 ((1 3) (4) () (2 5)) p1 2)
                  (pp-solution s2 t) (terpri)
                  (simulate-solution s2 p1 cvrp-action)
                  (setf (cost s2) (+ (total-distance cvrp-action)
                                     (total-penalty cvrp-action)))
                  (format t "Cost: ~a~%" (cost s2))))

              )))
      #+END_SRC
*** tests
**** test for random-search-strategy
***** testing the function
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (bp1 (basic-strategy-blueprint))
             (code `((select-route r1)
                     (select-client c1 from r1)
                     (insert-client c1 into r1)))
             )


        (bformat t "Testing make-neighborhood-exploration-function")

        ;; let's populate the blueprint
        (prepare-blueprint-for-code-generation
         code +random-search-strategy+ +random-improvement+ bp1)

        (format t "the generated code:~%~a~%"
                (write-neighborhood-exploration-code bp1))
  
        ;; (format t "the generated code:~%~a~%"
        ;;         (make-neighborhood-exploration-function bp1))
        )
      #+END_SRC
***** testing the keywords
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
            (let* ((*vrp-unit-testing-display-output* nil)
                   (*vrp-unit-testing-display-results* t)
                   (bp1 (basic-strategy-blueprint))
                   (code `((select-route r1)
                           (select-client c1 from r1)
                           (insert-client c1 into r1))))


              (bformat t "Testing make-neighborhood-exploration-function")

              ;; let's populate the blueprint
              (prepare-blueprint-for-code-generation
               code +exhaustive-search-strategy+ +best-improvement+ bp1)

              (format t "the generated code:~%~a~%"
                      (make-neighborhood-exploration-function
                       bp1 :inside-macro
                       `((progn
                           (format t "debug: with c1 ~a, r1 ~a"
                                   (client-selected-at-operation c1 wc)
                                   r1))))))
      #+END_SRC
***** testing an exploration
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                            (5 0 6 7 2 4)  ;1
                                            (1 8 0 3 9 1)  ;2
                                            (4 5 1 0 5 7)  ;3
                                            (4 5 1 5 0 6)  ;4
                                            (1 5 7 6 9 0)) ;5
                                            ;0 1 2 3 4 5 
                                :demands '(20 10 15 40 30)
                                :capacity 40)
          (with-basic-cvrp-solution (s1 ((1) (3 4) (5) (2)) p1)
            (let* ((action (delta-cvrp-action))
                   (cvrp-action (basic-cvrp-action))
                   (bp (basic-strategy-blueprint))
                   (bp1 (basic-strategy-blueprint))
                   rararbrb 
                   best-neighbor)




              (bformat t "Testing delta-cost")

              ;; let's simulate the solution
              (simulate-solution s1 p1 cvrp-action)
              (setf (cost s1) (+ (total-distance cvrp-action)
                                 (total-penalty cvrp-action)))

              (format t "With cost: ~a~%"
                      (cost s1))
              (pp-solution s1 t) (terpri)


              (progn ;; for rarabb

                (prepare-blueprint-for-code-generation
                `((select-route r1)
                  (select-client c1 from r1)
                  (select-route r2)
                  (select-client c2 from r2)
                  (select-route r3)
                  (insert-client c1 into r3)
                  (select-route r4)
                  (insert-client c2 into r4))
                +exhaustive-search-strategy+
                +best-improvement+ 
                bp1)

                (format t "code is:~%~a~%"
                        (write-neighborhood-exploration-code bp1))

                (setf rararbrb
                      (make-neighborhood-exploration-function
                       bp1))
               ;; ;; let's get the best neighbor
               (setf best-neighbor (funcall rararbrb s1 p1 action))

               (if best-neighbor
                   (then
                     (format t "After rararbrb we found...~%")
                     (format t "With cost ~a...~%" (cost best-neighbor))
                     (pp-solution best-neighbor t))
                   (else
                     (format t "No best neighbor found :-[.")))
               )

              (progn
                (format t "testing Yoel~%")
                (with-basic-cvrp-solution (s2 ((1 3) (4) () (2 5)) p1 2)
                  (pp-solution s2 t) (terpri)
                  (simulate-solution s2 p1 cvrp-action)
                  (setf (cost s2) (+ (total-distance cvrp-action)
                                     (total-penalty cvrp-action)))
                  (format t "Cost: ~a~%" (cost s2))))

              )))
      #+END_SRC

      #+RESULTS:
      #+begin_example
      ====================
       Testing delta-cost
      ====================

      With cost: 15031
      S1:
	  R1: (1)
	  R2: (3, 4)
	  R3: (5)
	  R4: (2)

      code is:
      (LAMBDA (SOLUTION PROBLEM ACTION &OPTIONAL (INITIAL-BEST-DELTA-COST 0))
	(DECLARE (IGNORABLE INITIAL-BEST-DELTA-COST SOLUTION PROBLEM ACTION))
	(LET* ((*VRP-STOP-NEIGHBORHOOD-SEARCH* NIL)
	       (OPS-LIST NIL)
	       (CURRENT-DELTA-COST 0)
	       (WC (MAKE-WORKING-COPY (CLONE SOLUTION)))
	       (BEST-NEIGHBOR NIL)
	       (BEST-DELTA-COST INITIAL-BEST-DELTA-COST)
	       (BEST-NEIGHBOR-AS-SOLUTION NIL))
	  (PREPARE-SOLUTION-FOR-NEIGHBORHOOD-EXPLORATION WC)
	  (DOSELECT-ROUTE (R1 WC)
	    (DOSELECT-CLIENT (C1 R1 WC)
	      (DOSELECT-ROUTE (R2 WC)
		(DOSELECT-CLIENT (C2 R2 WC)
		  (DOSELECT-ROUTE (R3 WC)
		    (DOINSERT-CLIENT (C1 R3 WC)
		      (DOSELECT-ROUTE (R4 WC)
			(DOINSERT-CLIENT (C2 R4 WC)
			  (SETF CURRENT-DELTA-COST
				  (DELTA-COST (REVERSE OPS-LIST) WC PROBLEM ACTION))
			  (IF (< CURRENT-DELTA-COST BEST-DELTA-COST)
			      (THEN
				(SETF BEST-NEIGHBOR (CLONE OPS-LIST))
				(SETF BEST-DELTA-COST CURRENT-DELTA-COST)))))))))))
	  (IF BEST-NEIGHBOR
	      (THEN
		(APPLY-SET-OF-OPERATIONS (REVERSE BEST-NEIGHBOR) WC)
		(SETF BEST-NEIGHBOR-AS-SOLUTION (SOLUTION WC))
		(SETF (COST BEST-NEIGHBOR-AS-SOLUTION)
			(+ (COST SOLUTION) BEST-DELTA-COST))))
	  (VALUES BEST-NEIGHBOR-AS-SOLUTION)))
      After rararbrb we found...
      With cost 27...
      S1:
	  R1: (1, 3)
	  R2: (4)
	  R3: (2, 5)
      testing Yoel
      S2:
	  R1: (1, 3)
	  R2: (4)
	  R3: ()
	  R4: (2, 5)

      Cost: 27
      #+end_example

**** test for jump-around-strategy
***** testing the function
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
      (let* ((*vrp-unit-testing-display-output* nil)
             (*vrp-unit-testing-display-results* t)
             (bp1 (basic-strategy-blueprint))
             (code `((select-route r1)
                     (select-client c1 from r1)
                     (insert-client c1 into r1)))
             )


        (bformat t "Testing make-neighborhood-exploration-function")

        ;; let's populate the blueprint
        (prepare-blueprint-for-code-generation
         code
         +jump-around-strategy+
         +jump-around-last-neighbor+
         bp1)

        (format t "the generated code:~%~a~%"
                (make-neighborhood-exploration-function bp1)))
      #+END_SRC
***** testing the keywords
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
            (let* ((*vrp-unit-testing-display-output* nil)
                   (*vrp-unit-testing-display-results* t)
                   (bp1 (basic-strategy-blueprint))
                   (code `((select-route r1)
                           (select-client c1 from r1)
                           (insert-client c1 into r1))))


              (bformat t "Testing make-neighborhood-exploration-function")

              ;; let's populate the blueprint
              (prepare-blueprint-for-code-generation
               code +exhaustive-search-strategy+ +best-improvement+ bp1)

              (format t "the generated code:~%~a~%"
                      (make-neighborhood-exploration-function
                       bp1 :inside-macro
                       `((progn
                           (format t "debug: with c1 ~a, r1 ~a"
                                   (client-selected-at-operation c1 wc)
                                   r1))))))
      #+END_SRC
***** testing an exploration
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                            (5 0 6 7 2 4)  ;1
                                            (1 8 0 3 9 1)  ;2
                                            (4 5 1 0 5 7)  ;3
                                            (4 5 1 5 0 6)  ;4
                                            (1 5 7 6 9 0)) ;5
                                            ;0 1 2 3 4 5 
                                :demands '(20 10 15 40 30)
                                :capacity 40)
          (with-basic-cvrp-solution (s1 ((1) (3 4) (5) (2)) p1)
            (let* ((action (delta-cvrp-action))
                   (cvrp-action (basic-cvrp-action))
                   (bp (basic-strategy-blueprint))
                   (bp1 (basic-strategy-blueprint))
                   rarb rarabb 
                   best-neighbor)




              (bformat t "Testing delta-cost")

              ;; let's simulate the solution
              (simulate-solution s1 p1 cvrp-action)
              (setf (cost s1) (+ (total-distance cvrp-action)
                                 (total-penalty cvrp-action)))

              (format t "With cost: ~a~%"
                      (cost s1))
              (pp-solution s1 t) (terpri)

              ;; (progn ;; for rarb

              ;;   (prepare-blueprint-for-code-generation
              ;;   `((select-route r1)
              ;;     (select-client c1 from r1)
              ;;     (select-route r2)
              ;;     (insert-client c1 into r2))
              ;;   +exhaustive-search-strategy+
              ;;   +best-improvement+ 
              ;;   bp)

              ;;  (setf rarb (make-neighborhood-exploration-function bp))
              ;;  ;; let's get the best neighbor
              ;;  (setf best-neighbor (funcall rarb s1 p1 action))

              ;;  (if best-neighbor
              ;;      (then
              ;;        (format t "After rarb we found...~%")
              ;;        (format t "With cost ~a...~%" (cost best-neighbor))
              ;;        (pp-solution best-neighbor t))
              ;;      (else
              ;;        (format t "No best neighbor found :-[."))))

              ;; (progn ;; for rarabb

              ;;   (prepare-blueprint-for-code-generation
              ;;   `((select-route r1)
              ;;     (select-client c1 from r1)
              ;;     (select-route r2)
              ;;     (select-client c2 from r2)
              ;;     (insert-client c1 into r2)
              ;;     (insert-client c2 into r1))
              ;;   +exhaustive-search-strategy+
              ;;   +best-improvement+ 
              ;;   bp1)

              ;;   (format t "After rarb s1 is~%")
              ;;   (pp-solution s1 t) (terpri)

              ;;   ;; (format t "code is:~%~a~%"
              ;;   ;;         (write-neighborhood-exploration-code bp1))

              ;;  (setf rararbrb (make-neighborhood-exploration-function bp1))
              ;;  ;; ;; let's get the best neighbor
              ;;  (setf best-neighbor (funcall rararbrb s1 p1 action))

              ;;  (if best-neighbor
              ;;      (then
              ;;        (format t "After rararbrb we found...~%")
              ;;        (format t "With cost ~a...~%" (cost best-neighbor))
              ;;        (pp-solution best-neighbor t))
              ;;      (else
              ;;        (format t "No best neighbor found :-[.")))
              ;;  )


              (progn ;; for rarabb

                (prepare-blueprint-for-code-generation
                `((select-route r1)
                  (select-client c1 from r1)
                  (select-route r2)
                  (select-client c2 from r2)
                  (select-route r3)
                  (insert-client c1 into r3)
                  (select-route r4)
                  (insert-client c2 into r4))
                ;; +jump-around-strategy+
                ;; +jump-around-last-neighbor+
                +exhaustive-search-strategy+
                +random-improvement+
                bp1)

                ;; (format t "code is:~%~a~%"
                ;;         (write-neighborhood-exploration-code bp1))

                (setf rararbrb
                      (make-neighborhood-exploration-function
                       bp1))
               ;; ;; let's get the best neighbor
               (setf best-neighbor (funcall rararbrb s1 p1 action))

               (if best-neighbor
                   (then
                     (format t "After rararbrb we found...~%")
                     (format t "With cost ~a...~%" (cost best-neighbor))
                     (pp-solution best-neighbor t))
                   (else
                     (format t "No best neighbor found :-[.")))
               )

              ;; (progn
              ;;   (format t "testing Yoel~%")
              ;;   (with-basic-cvrp-solution (s2 ((1 3) (4) () (2 5)) p1 2)
              ;;     (pp-solution s2 t) (terpri)
              ;;     (simulate-solution s2 p1 cvrp-action)
              ;;     (setf (cost s2) (+ (total-distance cvrp-action)
              ;;                        (total-penalty cvrp-action)))
              ;;     (format t "Cost: ~a~%" (cost s2))))

              )))
      #+END_SRC
**** looking for bug.  Bug found and removed
***** testing an exploration
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                            (5 0 6 7 2 4)  ;1
                                            (1 8 0 3 9 1)  ;2
                                            (4 5 1 0 5 7)  ;3
                                            (4 5 1 5 0 6)  ;4
                                            (1 5 7 6 9 0)) ;5
                                            ;0 1 2 3 4 5 
                                :demands '(20 10 15 40 30)
                                :capacity 40)
          (with-basic-cvrp-solution (s1 ((1) (3 4) () (5) () (2)) p1)
            (let* ((action (delta-cvrp-action))
                   (cvrp-action (basic-cvrp-action))
      ;;             (bp (basic-strategy-blueprint))
                   (bp1 (basic-strategy-blueprint))
                   ;; rarb rarabb
                   rararbrb
             
                   best-neighbor)




              (bformat t "Testing delta-cost")

              ;; let's simulate the solution
              (simulate-solution s1 p1 cvrp-action)
              (setf (cost s1) (+ (total-distance cvrp-action)
                                 (total-penalty cvrp-action)))

              (format t "With cost: ~a~%"
                      (cost s1))
              (pp-solution s1 t) (terpri)


              (progn ;; for rarabb

                (prepare-blueprint-for-code-generation
                `((select-route r1)
                  (select-client c1 from r1)
                  (select-route r2)
                  (select-client c2 from r2)
                  (select-route r3)
                  (insert-client c1 into r3)
                  (select-route r4)
                  (insert-client c2 into r4))
                +jump-around-strategy+
                +jump-around-last-neighbor+
                bp1)

                ;; (format t "code is:~%~a~%"
                ;;         (write-neighborhood-exploration-code
                ;;          bp1
                ;;          :inside-macro
                ;;          `((progn
                ;;              (format t "Current solution:~%")
                ;;              (pp-solution wc t) (terpri)
                ;;              (format t "========================~%")))))

                (setf rararbrb
                      (make-neighborhood-exploration-function
                       bp1
                       ;; :inside-macro
                       ;; `((progn
                       ;;     (let* ((wc3 (basic-working-copy (solution wc))))
                       ;;       (prepare-solution-for-neighborhood-exploration wc3)
                       ;;       (format t "Current solution:~%")
                       ;;      (pp-solution wc3 t) (terpri)
                       ;;      (format t "========================~%"))))
                       ))

                (format t "Let's jump-around~%")
               ;; ;; let's get the best neighbor
               (setf best-neighbor (funcall rararbrb s1 p1 action))

               (if best-neighbor
                   (then
                     (format t "After rararbrb we found...~%")
                     (format t "With cost ~a...~%" (cost best-neighbor))
                     (pp-solution best-neighbor t))
                   (else
                     (format t "No best neighbor found :-[.")))
               )

              ;; (progn
              ;;   (format t "testing Yoel~%")
              ;;   (with-basic-cvrp-solution (s2 ((1 3) (4) () (2 5)) p1 2)
              ;;     (pp-solution s2 t) (terpri)
              ;;     (simulate-solution s2 p1 cvrp-action)
              ;;     (setf (cost s2) (+ (total-distance cvrp-action)
              ;;                        (total-penalty cvrp-action)))
              ;;     (format t "Cost: ~a~%" (cost s2))))

              )))
      #+END_SRC
**** test for jump-around-strategy
***** testing an exploration
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                            (5 0 6 7 2 4)  ;1
                                            (1 8 0 3 9 1)  ;2
                                            (4 5 1 0 5 7)  ;3
                                            (4 5 1 5 0 6)  ;4
                                            (1 5 7 6 9 0)) ;5
                                            ;0 1 2 3 4 5 
                                :demands '(20 10 15 40 30)
                                :capacity 40)
          (with-basic-cvrp-solution (s1 ((1) (3 4) (5) (2)) p1)
            (let* ((action (delta-cvrp-action))
                   (cvrp-action (basic-cvrp-action))
                   (bp1 (basic-strategy-blueprint))
                   ;; rarb rarabb
                   rararbrb 
                   best-neighbor
                   last-neighbor
                   cumulative-delta
                   best-jump-delta-cost)




              (bformat t "Testing delta-cost")

              ;; let's simulate the solution
              (simulate-solution s1 p1 cvrp-action)
              (setf (cost s1) (+ (total-distance cvrp-action)
                                 (total-penalty cvrp-action)))

              (format t "With cost: ~a~%"
                      (cost s1))
              (pp-solution s1 t) (terpri)


              (progn ;; for rarabb

                (prepare-blueprint-for-code-generation
                `((select-route r1)
                  (select-client c1 from r1)
                  (select-route r2)
                  (select-client c2 from r2)
                  (select-route r3)
                  (insert-client c1 into r3)
                  (select-route r4)
                  (insert-client c2 into r4))
                +jump-around-strategy+
                +jump-around-best-neighbor+
                bp1)

                ;; (format t "code is:~%~a~%"
                ;;         (write-neighborhood-exploration-code bp1))

                (setf rararbrb
                      (make-neighborhood-exploration-function
                       bp1
                       :inside-macro
                       `((progn
                           (format t "current ~a, cumul ~a, best ~a~%"
                                   current-delta-cost
                                   cumulative-delta-cost
                                   best-jump-delta-cost)))))


                ;; ;; let's get the best neighbor

                (setf (values last-neighbor
                              cumulative-delta
                              best-neighbor
                              best-jump-delta-cost)
                      (funcall rararbrb s1 p1 action))

                (format t "===============~%")

                (if last-neighbor
                    (then
                      (format t "The last neighbor, with delta ~a, was~%"
                              cumulative-delta)
                      (pp-solution last-neighbor t) (terpri)))

                (if best-neighbor
                   (then
                     (format t "The best found, ")
                     (format t "with cost ~a, and delta-cost ~a was~%"
                             (cost best-neighbor)
                             best-jump-delta-cost)
                     (pp-solution best-neighbor t))
                   (else
                     (format t "No best neighbor found :-[.~%")))
               )

              ;; (progn
              ;;   (format t "testing Yoel~%")
              ;;   (with-basic-cvrp-solution (s2 ((1 3) (4) () (2 5)) p1 2)
              ;;     (pp-solution s2 t) (terpri)
              ;;     (simulate-solution s2 p1 cvrp-action)
              ;;     (setf (cost s2) (+ (total-distance cvrp-action)
              ;;                        (total-penalty cvrp-action)))
              ;;     (format t "Cost: ~a~%" (cost s2))))

              )))
      #+END_SRC
***** testing with a-n33-k6-problem
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((p1 a-n33-k6-problem)
             (s1 (make-initial-solution-for-cvrp-deterministic p1))
             (action (delta-cvrp-action))
             (cvrp-action (basic-cvrp-action))
             (bp1 (basic-strategy-blueprint))
             ;; rarb rarabb
             rararbrb 
             best-neighbor
             last-neighbor
             cumulative-delta
             best-jump-delta-cost)



        (format t "|~%|~%|~%|~%|~%")
        (bformat t "Testing jumping-around-strategy")

        ;; let's simulate the solution
        (simulate-solution s1 p1 cvrp-action)
        (setf (cost s1) (+ (total-distance cvrp-action)
                           (total-penalty cvrp-action)))

        (format t "With cost: ~a~%"
                (cost s1))
        (pp-solution s1 t) (terpri)


        (progn ;; for rarabb

          (prepare-blueprint-for-code-generation
           `((select-route r1)
             (select-client c1 from r1)
             (select-route r2)
             (select-client c2 from r2)
             (select-route r3)
             (insert-client c1 into r3)
             (select-route r4)
             (insert-client c2 into r4))
           (jump-around-search-strategy 10)
           +jump-around-last-neighbor+
           bp1)

          ;; (format t "code is:~%~a~%"
          ;;         (write-neighborhood-exploration-code bp1))

          (setf rararbrb
                (make-neighborhood-exploration-function
                 bp1
                 :inside-macro
                 `((progn
                     (format t "current ~a, cumul ~a, best ~a~%"
                             current-delta-cost
                             cumulative-delta-cost
                             best-jump-delta-cost)))))


          ;; ;; let's get the best neighbor

          (setf (values last-neighbor
                        cumulative-delta
                        best-neighbor
                        best-jump-delta-cost)
                (funcall rararbrb s1 p1 action))

          (format t "===============~%")

          (if last-neighbor
              (then
                (format t "The last neighbor, with delta ~a, was~%"
                        cumulative-delta)
                (pp-solution last-neighbor t) (terpri)))

          (if best-neighbor
              (then
                (format t "The best found, ")
                (format t "with cost ~a, and delta-cost ~a was~%"
                        (cost best-neighbor)
                        best-jump-delta-cost)
                (pp-solution best-neighbor t))
              (else
                (format t "No best neighbor found :-[.~%")))
          )

        ;; (progn
        ;;   (format t "testing Yoel~%")
        ;;   (with-basic-cvrp-solution (s2 ((1 3) (4) () (2 5)) p1 2)
        ;;     (pp-solution s2 t) (terpri)
        ;;     (simulate-solution s2 p1 cvrp-action)
        ;;     (setf (cost s2) (+ (total-distance cvrp-action)
        ;;                        (total-penalty cvrp-action)))
        ;;     (format t "Cost: ~a~%" (cost s2))))

        )
      #+END_SRC
**** test for return-last-neighbor-selection-strategy
***** testing an exploration
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                            (5 0 6 7 2 4)  ;1
                                            (1 8 0 3 9 1)  ;2
                                            (4 5 1 0 5 7)  ;3
                                            (4 5 1 5 0 6)  ;4
                                            (1 5 7 6 9 0)) ;5
                                            ;0 1 2 3 4 5 
                                :demands '(20 10 15 40 30)
                                :capacity 40)
          (with-basic-cvrp-solution (s1 ((1) (3 4) (5) (2)) p1)
            (let* ((action (delta-cvrp-action))
                   (cvrp-action (basic-cvrp-action))
                   (bp1 (basic-strategy-blueprint))
                   ;; rarb rarabb
                   rararbrb 
                   last-delta
                   last-neighbor)




              (bformat t "Testing delta-cost")

              ;; let's simulate the solution
              (simulate-solution s1 p1 cvrp-action)
              (setf (cost s1) (+ (total-distance cvrp-action)
                                 (total-penalty cvrp-action)))

              (format t "With cost: ~a~%"
                      (cost s1))
              (pp-solution s1 t) (terpri)


              (progn ;; for rarabb

                (prepare-blueprint-for-code-generation
                `((select-route r1)
                  (select-client c1 from r1)
                  (select-route r2)
                  (select-client c2 from r2)
                  (select-route r3)
                  (insert-client c1 into r3)
                  (select-route r4)
                  (insert-client c2 into r4))
                (random-neighborhood-search-strategy 10)
                +return-last-neighbor+
                bp1)

                ;; (format t "code is:~%~a~%"
                ;;         (write-neighborhood-exploration-code bp1))

                (setf rararbrb
                      (make-neighborhood-exploration-function
                       bp1
                       :inside-macro
                       `((progn
                           (format t "current ~a, best ~a~%"
                                   current-delta-cost
                                   best-delta-cost)))))


                ;; ;; let's get the best neighbor

                (setf (values last-neighbor
                              last-delta)
                      (funcall rararbrb s1 p1 action))

                (format t "===============~%")

                (if last-neighbor
                    (then
                      (format t "The last neighbor, with delta ~a, was~%"
                              last-delta)
                      (pp-solution last-neighbor t) (terpri))))

              (progn
                (format t "testing Yoel~%")
                (simulate-solution last-neighbor p1 cvrp-action)
                (setf (cost last-neighbor) (+ (total-distance cvrp-action)
                                              (total-penalty cvrp-action)))
                (format t "Cost: ~a~%" (cost last-neighbor))

              ))))
      #+END_SRC


***** testing with a-n33-k6-problem
      #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
      (let* ((p1 a-n33-k6-problem)
             (s1 (make-initial-solution-for-cvrp-deterministic p1))
             (action (delta-cvrp-action))
             (cvrp-action (basic-cvrp-action))
             (bp1 (basic-strategy-blueprint))
             ;; rarb rarabb
             rararbrb 
             best-neighbor
             last-neighbor
             cumulative-delta
             best-jump-delta-cost)



        (format t "|~%|~%|~%|~%|~%")
        (bformat t "Testing jumping-around-strategy")

        ;; let's simulate the solution
        (simulate-solution s1 p1 cvrp-action)
        (setf (cost s1) (+ (total-distance cvrp-action)
                           (total-penalty cvrp-action)))

        (format t "With cost: ~a~%"
                (cost s1))
        (pp-solution s1 t) (terpri)


        (progn ;; for rarabb

          (prepare-blueprint-for-code-generation
           `((select-route r1)
             (select-client c1 from r1)
             (select-route r2)
             (select-client c2 from r2)
             (select-route r3)
             (insert-client c1 into r3)
             (select-route r4)
             (insert-client c2 into r4))
           (jump-around-search-strategy 10)
           +jump-around-last-neighbor+
           bp1)

          ;; (format t "code is:~%~a~%"
          ;;         (write-neighborhood-exploration-code bp1))

          (setf rararbrb
                (make-neighborhood-exploration-function
                 bp1
                 :inside-macro
                 `((progn
                     (format t "current ~a, cumul ~a, best ~a~%"
                             current-delta-cost
                             cumulative-delta-cost
                             best-jump-delta-cost)))))


          ;; ;; let's get the best neighbor

          (setf (values last-neighbor
                        cumulative-delta
                        best-neighbor
                        best-jump-delta-cost)
                (funcall rararbrb s1 p1 action))

          (format t "===============~%")

          (if last-neighbor
              (then
                (format t "The last neighbor, with delta ~a, was~%"
                        cumulative-delta)
                (pp-solution last-neighbor t) (terpri)))

          (if best-neighbor
              (then
                (format t "The best found, ")
                (format t "with cost ~a, and delta-cost ~a was~%"
                        (cost best-neighbor)
                        best-jump-delta-cost)
                (pp-solution best-neighbor t))
              (else
                (format t "No best neighbor found :-[.~%")))
          )

        ;; (progn
        ;;   (format t "testing Yoel~%")
        ;;   (with-basic-cvrp-solution (s2 ((1 3) (4) () (2 5)) p1 2)
        ;;     (pp-solution s2 t) (terpri)
        ;;     (simulate-solution s2 p1 cvrp-action)
        ;;     (setf (cost s2) (+ (total-distance cvrp-action)
        ;;                        (total-penalty cvrp-action)))
        ;;     (format t "Cost: ~a~%" (cost s2))))

        )
      #+END_SRC


* function make-neighborhood-criterion (ordinary)
** description
   This function receives a list with the pseudo-natural description of a neighborhood criterion, the strategies, and code to add to the criterion, and returns a function.  This does not require the user to know anything about blueprints or anything like that.
   
** code
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
    (defun make-neighborhood-criterion
        (description
         search-strategy
         select-strategy
         &key
           inside-let
           outside-let
           inside-macro
           outside-macro)

      "This function receives a list with the pseudo-natural description of a neighborhood criterion, the strategies, and code to add to the criterion, and returns a function that explores the neighborhood using the given strategies."

      (let* ((blueprint (basic-strategy-blueprint)))

        (prepare-blueprint-for-code-generation
                         description
                         search-strategy
                         select-strategy
                         blueprint)

        (make-neighborhood-exploration-function
         blueprint
         :inside-let inside-let
         :outside-let outside-let
         :inside-macro inside-macro
         :outside-macro outside-macro)))
    #+END_SRC
   
** test constraints by exploration (just printing the solution)
   #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
   (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                       (5 0 6 7 2 4)  ;1
                                       (1 8 0 3 9 1)  ;2
                                       (4 5 1 0 5 7)  ;3
                                       (4 5 1 5 0 6)  ;4
                                       (1 5 7 6 9 0)) ;5
                                       ;0 1 2 3 4 5 
                             :demands '(20 10 15 40 30)
                             :capacity 40)
     (with-basic-solution (s1 ((1 2 3) (4 5)))
       (let* ((action (delta-cvrp-action))
              (cvrp-action (basic-cvrp-action))
              (rarb-code `((select-route r1)
                           (select-client c1 from r1)
                           (select-route r2 :ge r1)
                           (select-client c2 from r2
                                          :ge (list r1 c1.select.position))
                           (swap-clients c1 c2)))
              (bp (basic-strategy-blueprint))
              best-neighbor)

         (declare (ignore cvrp-action best-neighbor))

         (bformat t "Testing make-neighborhood-criterion")

         (progn ;; for rarac

           (prepare-blueprint-for-code-generation 
            rarbs
            +exhaustive-search-strategy+ 
            +search-with-a-basic-wc+
            bp)

           (format t "code: ~s~%"
                   (write-neighborhood-exploration-code
                    bp
                    :inside-macro `((terpri) (pp-solution wc t))
                    ))

           (setf rarbf (make-neighborhood-criterion 
                       rarb-code
                       +exhaustive-search-strategy+ 
                       +search-with-a-basic-wc+
                       :inside-macro `((terpri)
                                       (pp-solution wc t))))

           (funcall rarbf s1 p1 action)))))
   #+END_SRC

** test constraints by exploration (just printing the solution)
   #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
   (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                       (5 0 6 7 2 4)  ;1
                                       (1 8 0 3 9 1)  ;2
                                       (4 5 1 0 5 7)  ;3
                                       (4 5 1 5 0 6)  ;4
                                       (1 5 7 6 9 0)) ;5
                                       ;0 1 2 3 4 5 
                             :demands '(20 10 15 40 30)
                             :capacity 40)
     (with-basic-solution (s1 ((1 2 3 4 5)))
       (let* ((action (delta-cvrp-action))
              (cvrp-action (basic-cvrp-action))
              (rarb-code `((select-route r1)
                           (select-client c1 from r1)
                           (insert-client c1 into r1
                                          :dt (list r1 c1.select.position))))
              (bp (basic-strategy-blueprint))
              best-neighbor)

         (declare (ignore cvrp-action best-neighbor))

         (bformat t "Testing make-neighborhood-criterion")

         (progn ;; for rarac

           (prepare-blueprint-for-code-generation 
            rarb-code
            +exhaustive-search-strategy+ 
            +search-with-a-basic-wc+
            bp)

           (format t "code: ~s~%"
                   (write-neighborhood-exploration-code
                    bp
                    :inside-macro `((terpri) (pp-solution wc t))
                    ))

           (setf rarb (make-neighborhood-criterion 
                       rarb-code
                       +exhaustive-search-strategy+ 
                       +search-with-a-basic-wc+
                       :inside-macro `((terpri)
                                       (pp-solution wc t)
                                       (format t "inserting ~a in ~a (selected from ~a)~%"
                                               c1.client c1.insert.position c1.select.position))))

           (format t "original solution:~%")
           (pp-solution s1 t) (terpri)

           (funcall rarb s1 p1 action)

           )



         )))
   #+END_SRC

** test exploration (best-improvement)
   #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
   (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                             :demands '(20 10 15 40 30)
                             :capacity 40)
       (with-basic-cvrp-solution (s1 ((1) (3 4) (5) (2)) p1)
         (let* ((action (delta-cvrp-action))
                (cvrp-action (basic-cvrp-action))
                rarb
                best-neighbor)


           (bformat t "Testing make-neighborhood-criterion")

           ;; let's simulate the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "With cost: ~a~%"
                   (cost s1))
           (pp-solution s1 t) (terpri)

           ;; (progn ;; for rarb

           ;;   (setf rarb (make-neighborhood-criterion 
           ;;               `((select-route r1)
           ;;                 (select-client c1 from r1)
           ;;                 (select-route r2)
           ;;                 (insert-client c1 into r2))
           ;;               +exhaustive-search-strategy+ 
           ;;               +best-improvement+))

           ;;  ;; (setf rarb (make-neighborhood-exploration-function bp))
           ;;  ;; let's get the best neighbor
           ;;  (setf best-neighbor (funcall rarb s1 p1 action))

           ;;  (if best-neighbor
           ;;      (then
           ;;        (format t "After rarb we found...~%")
           ;;        (format t "With cost ~a...~%" (cost best-neighbor))
           ;;        (pp-solution best-neighbor t))
           ;;      (else
           ;;        (format t "No best neighbor found :-[."))))

           (progn ;; for rarac

             (setf rarb (make-neighborhood-criterion 
                         `((select-route r1)
                           (select-client c1 from r1)
                           (select-route r2)
                           (select-client c2 from r2)
                           (swap-clients c1 c2))
                         +exhaustive-search-strategy+ 
                         +best-improvement+))

            ;; (setf rarb (make-neighborhood-exploration-function bp))
            ;; let's get the best neighbor
            (setf best-neighbor (funcall rarb s1 p1 action))

            (if best-neighbor
                (then
                  (format t "After rarb we found...~%")
                  (format t "With cost ~a...~%" (cost best-neighbor))
                  (pp-solution best-neighbor t))
                (else
                  (format t "No best neighbor found :-[."))))



           )))
   #+END_SRC

   #+RESULTS:
** test exploration (best-improvement )
   #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
   (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                             :demands '(20 10 15 40 30)
                             :capacity 40)
       (with-basic-cvrp-solution (s1 ((3 2 4) (1 5)) p1)
         (let* ((action (delta-cvrp-action))
                (cvrp-action (basic-cvrp-action))
                rarb
                best-neighbor)


           (bformat t "Testing make-neighborhood-criterion")

           ;; let's simulate the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "With cost: ~a~%"
                   (cost s1))
           (pp-solution s1 t) (terpri)

           ;; (progn ;; for rarb

           ;;   (setf rarb (make-neighborhood-criterion 
           ;;               `((select-route r1)
           ;;                 (select-client c1 from r1)
           ;;                 (select-route r2)
           ;;                 (insert-client c1 into r2))
           ;;               +exhaustive-search-strategy+ 
           ;;               +best-improvement+))

           ;;  ;; (setf rarb (make-neighborhood-exploration-function bp))
           ;;  ;; let's get the best neighbor
           ;;  (setf best-neighbor (funcall rarb s1 p1 action))

           ;;  (if best-neighbor
           ;;      (then
           ;;        (format t "After rarb we found...~%")
           ;;        (format t "With cost ~a...~%" (cost best-neighbor))
           ;;        (pp-solution best-neighbor t))
           ;;      (else
           ;;        (format t "No best neighbor found :-[."))))

           (progn ;; for rarac

             (setf rarb (make-neighborhood-criterion 
                         `((select-route r1)
                           (select-client c1 from r1)
                           (select-route r2)
                           (select-client c2 from r2)
                           (swap-clients c1 c2))
                         +exhaustive-search-strategy+ 
                         +best-improvement+))

            ;; (setf rarb (make-neighborhood-exploration-function bp))
            ;; let's get the best neighbor
            (setf best-neighbor (funcall rarb s1 p1 action))

            (if best-neighbor
                (then
                  (format t "After rarb we found...~%")
                  (format t "With cost ~a...~%" (cost best-neighbor))
                  (pp-solution best-neighbor t))
                (else
                  (format t "No best neighbor found :-[."))))



           )))
   #+END_SRC

** test exploration (first-improvement-search-strategy)
   #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
   (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                             :demands '(20 10 15 40 30)
                             :capacity 40)
       (with-basic-cvrp-solution (s1 ((1) (3 4) (5) (2)) p1)
         (let* ((action (delta-cvrp-action))
                (cvrp-action (basic-cvrp-action))
                rarb
                best-neighbor)


           (bformat t "Testing make-neighborhood-criterion")

           ;; let's simulate the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "With cost: ~a~%"
                   (cost s1))
           (pp-solution s1 t) (terpri)

           ;; (progn ;; debug

           ;;   (prepare-blueprint-for-code-generation
           ;;    `((select-route r1)
           ;;      (select-client c1 from r1)
           ;;      (select-route r2)
           ;;      (select-client c2 from r2)
           ;;      (swap-clients c1 c2))
           ;;    +exhaustive-search-strategy+ 
           ;;    +first-improvement+
           ;;    bp)

           ;;   (format t "debug: code: ~a~%"
           ;;          (write-neighborhood-exploration-code
           ;;           bp
           ;;           :inside-macro `((progn
           ;;                             (format t "cost: ~a~%"
           ;;                                     current-delta-cost)
           ;;                             (pp-solution wc t) (terpri)
           ;;                             ))))
           ;;   )

           (progn ;; for rarac



             (setf rarb (make-neighborhood-criterion 
                         `((select-route r1)
                           (select-client c1 from r1)
                           (select-route r2)
                           (select-client c2 from r2)
                           (swap-clients c1 c2))
                         +exhaustive-search-strategy+ 
                         +first-improvement+
                         :inside-macro `((progn
                                           (format t "cost: ~a~%"
                                                   current-delta-cost)
                                           (pp-solution wc t) (terpri)
                                           ))))

            ;; (setf rarb (make-neighborhood-exploration-function bp))
            ;; let's get the best neighbor
            (setf best-neighbor (funcall rarb s1 p1 action))

            (if best-neighbor
                (then
                  (format t "After rarb we found...~%")
                  (format t "With cost ~a...~%" (cost best-neighbor))
                  (pp-solution best-neighbor t))
                (else
                  (format t "No best neighbor found :-[."))))



           )))
   #+END_SRC

** test exploration (random-improvement-search-strategy)
   #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp 
   (with-cvrp-problem (p1 :distances `((0 2 3 4 5 6)  ;0
                                         (5 0 6 7 2 4)  ;1
                                         (1 8 0 3 9 1)  ;2
                                         (4 5 1 0 5 7)  ;3
                                         (4 5 1 5 0 6)  ;4
                                         (1 5 7 6 9 0)) ;5
                                         ;0 1 2 3 4 5 
                             :demands '(20 10 15 40 30)
                             :capacity 40)
       (with-basic-cvrp-solution (s1 ((1) (3 4) (5) (2)) p1)
         (let* ((action (delta-cvrp-action))
                (cvrp-action (basic-cvrp-action))
                (bp (basic-strategy-blueprint))
                rarb
                best-neighbor)


           (bformat t "Testing make-neighborhood-criterion")

           ;; let's simulate the solution
           (simulate-solution s1 p1 cvrp-action)
           (setf (cost s1) (+ (total-distance cvrp-action)
                              (total-penalty cvrp-action)))

           (format t "With cost: ~a~%"
                   (cost s1))
           (pp-solution s1 t) (terpri)

           ;; (progn ;; debug

           ;;   (prepare-blueprint-for-code-generation
           ;;    `((select-route r1)
           ;;      (select-client c1 from r1)
           ;;      (select-route r2)
           ;;      (select-client c2 from r2)
           ;;      (swap-clients c1 c2))
           ;;    +exhaustive-search-strategy+ 
           ;;    +random-improvement+
           ;;    bp)

           ;;   (format t "debug: code: ~a~%"
           ;;          (write-neighborhood-exploration-code
           ;;           bp
           ;;           :inside-macro `((progn
           ;;                             (format t "cost: ~a~%"
           ;;                                     current-delta-cost)
           ;;                             (pp-solution wc t) (terpri)
           ;;                             ))))
           ;;   )

           (progn ;; for rarac

             (setf rarb (make-neighborhood-criterion 
                         `((select-route r1)
                           (select-client c1 from r1)
                           (select-route r2)
                           (select-client c2 from r2)
                           (swap-clients c1 c2))
                         +exhaustive-search-strategy+ 
                         +random-improvement+
                         ;; :inside-macro
                         ;; `((progn
                         ;;     (format t "cost: ~a~%"
                         ;;             current-delta-cost)
                         ;;     (pp-solution wc t) (terpri)
                         ;;     (format t "candidates: ~a~%"
                         ;;             candidates-for-best-neighbor)
                         ;;     ))
                         ))

            ;; (setf rarb (make-neighborhood-exploration-function bp))
            ;; let's get the best neighbor
            (setf best-neighbor (funcall rarb s1 p1 action))

            (if best-neighbor
                (then
                  (format t "After rarb we found...~%")
                  (format t "With cost ~a...~%" (cost best-neighbor))
                  (pp-solution best-neighbor t))
                (else
                  (format t "No best neighbor found :-[."))))



           )))
   #+END_SRC


* find repeated elements in neighborhood
** functions to detect repeated elements in a neigborhood using a trie
*** description
    In this section, I'm going to add the code written by Heidy to detect the repeated elements in a neighborhood. She did that using a trie and then adding all the strategies elements. First, I'm going to add the trie functions. In the trie, each solution is represented as a list of list of numbers, where each number is the id of a client. The operations list should be reversed (as it usually is inside the criteria).
*** converting a solution to a list of clients
**** description
     In this section we write the functions to convert a solution to a representation that can be used on the trie. That solution is described as a list of operations and a working-copy. The idea is to be able to store a neighbor solution described by the list of operations and an "actual solution".
**** generic funtion
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
    (defgeneric ops-list-to-list-of-clients (ops-list wc)
      (:documentation
        "A function to return a list of list of clients from an ops-list and a solution (or working copy)."))
    #+END_SRC   
**** method for a list of operations and a basic-working-copy
***** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defmethod ops-list-to-list-of-clients ((ops-list list)
                                             (wc basic-working-copy))
         (let* ((original-solution (clone (solution wc)))
                (wc* (basic-working-copy original-solution))
                (solution nil))

           (prepare-solution-for-neighborhood-exploration wc*)
           (apply-set-of-operations (reverse ops-list) wc*)
           (setf solution (solution wc*))
    
           (loop for route in (routes solution)
                 collecting (loop for c in (clients route)
                                  collecting (id c)))))
     #+END_SRC   
      
***** test
      #+begin_src lisp +n -r :results output :exports code
      (with-basic-solution (s1 ((1 2 3) (4 5)))
        (let* ((wc (basic-working-copy s1))
               (ops-list (list
                          (op-insert-client 2 3 0)
                          (op-select-client 1 1 0)))

               (ops-list2 (list
                          (op-insert-client 1 4 0)
                          (op-select-client 2 1 0)))
               (sol nil)
               )



          (bformat t "ops-list-to-list-of-clients")
          (prepare-solution-for-neighborhood-exploration wc)

          ;; let's print the solution
          (format t "The solution is:~%")
          (pp-solution wc t)


          (format t "The first operations are: ~a and ~a~%"
                  (second ops-list) (first ops-list))
          ;; let's get the clients list
          (setf sol (ops-list-to-list-of-clients ops-list wc))

          (format t "List with clients: ~a~%" sol)

          (format t "Now trying ~a~%"
                  (reverse ops-list2))
          (setf sol (ops-list-to-list-of-clients ops-list2 wc))

          (format t "List with clients: ~a~%" sol)

          ))
      #+end_src
**** method for an empty list of operations and a basic-working-copy
***** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defmethod ops-list-to-list-of-clients ((ops-list (eql nil))
                                             (wc basic-working-copy))
         (let* ((original-solution (clone (solution wc))))

           (loop for route in (routes original-solution)
                 collecting (loop for c in (clients route)
                                  collecting (id c)))))
     #+END_SRC   
***** test
      #+begin_src lisp +n -r :results output :exports code
      (with-basic-solution (s1 ((1 2 3) (4 5)))
        (let* ((wc (basic-working-copy s1))
               (ops-list nil)
               (sol nil)
               )



          (bformat t "ops-list-to-list-of-clients")
          (prepare-solution-for-neighborhood-exploration wc)

          ;; let's print the solution
          (format t "The solution is:~%")
          (pp-solution wc t)


          (format t "The operations list is ~a~%"
                  ops-list)
          ;; let's get the clients list
          (setf sol (ops-list-to-list-of-clients ops-list wc))

          (format t "List with clients: ~a~%" sol)

          ))
      #+end_src
*** trie implementation
**** description
     In this section we write a trie implementation, that will be useful to determine whether or not a solution has already been visited.
     First we create the node class and it's constructor
**** class trie-node
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defclass node ()
       ((value :accessor .value
                :initarg :value
                :initform :-1)
        (children-nodes :accessor .children-nodes
                         :initarg :children-nodes
                         :initform :nil)
        (parent :accessor .parent
                 :initarg :parent
                 :initform :nil)))

      (defun new-node (value &key children-nodes parent)
        (make-instance 'node
                       :value value
                       :children-nodes children-nodes
                       :parent parent))
     #+END_SRC   
**** function new-trie
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defun new-trie ()
       (new-node "r1"))
     #+END_SRC   
**** function insert-in-the-children-list
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defun insert-in-the-children-list (r node)
       (let ((flag 0))
         (loop for child in (.children-nodes r) do
               (if (eql (.value child) (.value node))
                   (progn 
                     (setf flag 1)
                     (setf node child)
                     (return child))))
         (if (eql flag 0)
             (push node (.children-nodes r)) )       
         node))
      #+END_SRC   
**** function insert-in-trie
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defun insert-in-trie (solution root)
       (let* ((node nil)
              (leaf nil)               
              (visit 0))

         (loop for route in solution do 
               (loop for client in route do 
                     (setf node (new-node client))
                     (setf (.parent node) root)
                     (setf root (insert-in-the-children-list root node)))
               (setf leaf root)
               (setf root
                     (insert-in-the-children-list
                      root (new-node "r" :parent leaf))))


         (if (> (length (.children-nodes leaf)) 1)
             (setf visit 1))
         (if (not (> (length (.children-nodes leaf)) 1))
             (setf (.value root) -1))

         (loop while (> 1 0) do
               (if (eql (.parent root) nil)
                   (progn
                     ;; (format t "~a" (.value root))
                     (return root)))
               ;; (format t "~a" (.value root))
               (setf root (.parent root)))
         visit))
     #+END_SRC   
**** tests
      #+begin_src lisp +n -r :results output :exports code
      (let* ((sol1 '((1 2 3) (4 5 6)))
             (sol2 '((1 2 4) (3 5 6)))
             (sol3 '((1 2 3) (4 5 6)))
             (trie (new-trie))
             )

             (bformat t "Testing the trie")

             (format t "Let's add the solution ~a: ~a (expect 0)~%"
                     sol1 (insert-in-trie sol1 trie))
             (format t "Let's add the solution ~a: ~a (expect 0)~%"
                     sol1 (insert-in-trie sol2 trie))
             (format t "Let's add the solution ~a: ~a (expect 1)~%"
                     sol1 (insert-in-trie sol3 trie))
             (format t "Let's add the solution ~a: ~a (expect 1)~%"
                     sol1 (insert-in-trie sol1 trie))

          )
      #+end_src
** class definitions for the strategy
*** repeated-solutions-search-strategy (functional)
**** description
     This class represents a search where we compute the repeated neighbors in the neighborhood. To do that, we store the visited clients in a trie.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (def-vrp-class repeated-solutions-search-strategy
      (search-with-a-basic-wc)
       ()
      :documentation "A class to represent a search where we store the repetead elements in a neighborhood."
      :constructor (repeated-solutions-search-strategy ())
      :print-object-string ("<repeated-solutions-search-strategy>")
      :slots-for-obj= ()
      :slots-for-clone ())
     #+END_SRC

**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((st1 (repeated-solutions-search-strategy)))
       (bformat t "Testing repeated-solutions-search-strategy...")
       (format t "repeated-solutions-search-strategy: ~a~%" st1))
     #+END_SRC

**** constant
     Here we create a constant (variable?) with an instance of this class.
     #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
     (defparameter +repeated-neighbors-search-strategy+
       (repeated-solutions-search-strategy))
     #+END_SRC
** generate-inside-let-initializations
*** description
    When using the repeated-solutions-search-strategy, we need to initialize the trie, the current solution, and the list with repeated elements.
*** method :after(t t repeated-solutions-search-strategy t)
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-inside-let-initializations :after
          (description
           strategy
           (other-strategies repeated-solutions-search-strategy)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push `(solutions-repeated nil) ;; a list with the repeated elements
              (initializations-inside-the-let where-to-store-it))
        (push `(current-trie (new-trie)) ;; the trie to store the visited clients
              (initializations-inside-the-let where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (instance (make-instance
                       'repeated-solutions-search-strategy))
            )

       (bformat t "Testing generate-inside-let-initializations...")

       ;;generate the code
       (generate-inside-let-initializations
        t t instance bp1)

       (format t "let-initializations: ~a~%"
               (initializations-inside-the-let bp1))

       )
     #+END_SRC
** generate-outside-let-initializations
*** description
    After the let initializations and before the macros, we need to insert the current solution into the trie.
*** method :after(t t repeated-solutions-search-strategy t)
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-outside-let-initializations :after
          (description
           strategy
           (other-strategies repeated-solutions-search-strategy)
           (where-to-store-it basic-neighborhood-strategy-blueprint))


          (push `(insert-in-trie (ops-list-to-list-of-clients nil wc)
                                  current-trie)
           (initializations-outside-the-let where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (instance (make-instance
                       'repeated-solutions-search-strategy))
            )

       (bformat t "Testing generate-outside-let-initializations...")

       ;;generate the code
       (generate-outside-let-initializations
        t t instance bp1)

       (format t "let-initializations: ~a~%"
               (initializations-outside-the-let bp1))

       )
     #+END_SRC

     #+RESULTS:
     : =================================================
     :  Testing generate-outside-let-initializations...
     : =================================================
     : 
     : let-initializations: NIL
** generate-code-inside-macros
*** description
    Inside the macros we need to decide what to do. In this case is to check if we have already visited the current solution, an if so, store it in the list.
*** method :after(t t repeated-solutions-search-strategy t)
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-code-inside-macros :after
          (description
           strategy
           (other-strategies repeated-solutions-search-strategy)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

          (push `(progn
                   (if (= (insert-in-trie
                           (ops-list-to-list-of-clients
                            ops-list wc)
                           current-trie)
                          1)
                       (then
                         (push (list
                                (clone (ops-list-to-list-of-clients
                                        ops-list wc))
                                (clone (reverse ops-list)))
                               solutions-repeated))))

           (code-inside-the-macros where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (instance (make-instance
                       'repeated-solutions-search-strategy))
            )

       (bformat t "Testing generate-code-inside-the-macros...")

       ;;generate the code
       (generate-code-inside-macros t t instance bp1)

       (format t "code-inside-the-macro:~%~a~%"
               (code-inside-the-macros bp1))

       )
     #+END_SRC

     #+RESULTS:
     : =================================================
     :  Testing generate-outside-let-initializations...
     : =================================================
     : 
     : let-initializations: NIL
** generate-return-code
*** description
    In this case, we just return the list with the repeated clients.
*** method :after(t t repeated-solutions-search-strategy t)
**** code
      #+BEGIN_SRC lisp +n -r :results none :exports code :tangle ../src/vrp-search-strategies.lisp 
      (defmethod generate-return-code :after
          (description
           strategy
           (other-strategies repeated-solutions-search-strategy)
           (where-to-store-it basic-neighborhood-strategy-blueprint))

        (push 'solutions-repeated
              (return-code where-to-store-it)))
      #+END_SRC
**** test
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (instance (make-instance
                       'repeated-solutions-search-strategy))
            )

       (bformat t "Testing generate-code-inside-the-macros...")

       ;;generate the code
       (generate-return-code t t instance bp1)

       (format t "return-code:~%~a~%"
               (return-code bp1))

       )
     #+END_SRC

** testing it all
*** description
    Here, we'll test that everything works the way it should.
*** testing the generated code
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (let* ((*vrp-unit-testing-display-output* nil)
            (*vrp-unit-testing-display-results* t)
            (bp1 (basic-strategy-blueprint))
            (code1 `((select-route r1)
                     (select-client c1 from r1)
                     (insert-client c1 into r1)))
            )


       (bformat t "Testing write-search-code")

       ;; let's populate the blueprint
       (prepare-blueprint-for-code-generation
        code1
        ;; (random-neighborhood-search-strategy 100)
        +exhaustive-search-strategy+
        (make-instance 'repeated-solutions-search-strategy)
        bp1)

       (format t "the generated code:~%~a~%"
               (write-neighborhood-exploration-code bp1)))
     #+END_SRC

     #+RESULTS:
     #+begin_example
     ===========================
      Testing write-search-code
     ===========================

     the generated code:
     (LAMBDA (SOLUTION PROBLEM ACTION &OPTIONAL (INITIAL-BEST-DELTA-COST 0))
       (DECLARE (IGNORABLE INITIAL-BEST-DELTA-COST SOLUTION PROBLEM ACTION))
       (LET* ((*VRP-STOP-NEIGHBORHOOD-SEARCH* NIL)
	      (OPS-LIST NIL)
	      (WC (MAKE-WORKING-COPY (CLONE SOLUTION)))
	      (SOLUTIONS-REPEATED NIL)
	      (CURRENT-TRIE (NEW-TRIE)))
	 (PREPARE-SOLUTION-FOR-NEIGHBORHOOD-EXPLORATION WC)
	 (INSERT-IN-TRIE (OPS-LIST-TO-LIST-OF-CLIENTS NIL WC) CURRENT-TRIE)
	 (DOSELECT-ROUTE (R1 WC)
	   (DOSELECT-CLIENT (C1 R1 WC)
	     (DOINSERT-CLIENT (C1 R1 WC)
	       (PROGN
		(IF (=
		     (INSERT-IN-TRIE (OPS-LIST-TO-LIST-OF-CLIENTS OPS-LIST WC)
				     CURRENT-TRIE)
		     1)
		    (THEN
		      (PUSH
		       (LIST (CLONE (OPS-LIST-TO-LIST-OF-CLIENTS OPS-LIST WC))
			     (CLONE (REVERSE OPS-LIST)))
		       SOLUTIONS-REPEATED)))))))
	 (VALUES SOLUTIONS-REPEATED)))
     #+end_example

*** testing the execution
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (with-basic-solution (s1 ((1 2 3 4 5)))
       (let* ((bp1 (basic-strategy-blueprint))
              (wc (basic-working-copy s1))
              (spot-repeated-clients-strat
               (make-instance 'repeated-solutions-search-strategy))
              (code1 rab)
              (explore-function nil)
              (repeated-clients nil)
              ;; (actual-solutions nil)
              )

;;         (prepare-blueprint-for-code-generation
;;          code1
;;          +exhaustive-search-strategy+
;;          spot-repeated-clients-strat
;;          bp1)

         (prepare-solution-for-neighborhood-exploration wc)

         (setf explore-function (make-neighborhood-criterion
                                 code1
                                 +exhaustive-search-strategy+
                                 spot-repeated-clients-strat))

         (bformat t "testing repeated clients")

         (setf repeated-clients (funcall
                                 explore-function
                                 s1
                                 t
                                 t))

         ;; (setf actual-solutions
         ;;       (mapcar (lambda (x)
         ;;                 (let* ((wc* (basic-working-copy s1)))
         ;;                   (prepare-solution-for-neighborhood-exploration wc*)
         ;;                   ops-list-to-list-of-clients x wc*)))
         ;;               (reverse repeated-clients)))

         (format t "repeated-clients:~%~{~a~%~}~%"
                 (reverse repeated-clients))

         ))
     #+END_SRC

     #+RESULTS:
     : ==========================
     :  testing repeated clients
     : ==========================
     : 
     : repeated-clients:
     : 

*** testing the execution with Gabriela
     #+BEGIN_SRC lisp +n -r :results output :exports both :tangle ../src/vrp-tests.lisp
     (in-package :vrp)

     (with-basic-solution (s1 ((1 2 3 4 5) (6 7)))
       (let* ((bp1 (basic-strategy-blueprint))
              (wc (basic-working-copy s1))
              (spot-repeated-clients-strat
               (make-instance 'repeated-solutions-search-strategy))
              (code1 rerehg)
              (explore-function nil)
              (repeated-clients nil)
              ;; (actual-solutions nil)
              )

         (prepare-blueprint-for-code-generation
          code1
          +exhaustive-search-strategy+
          spot-repeated-clients-strat
          bp1)

         (prepare-solution-for-neighborhood-exploration wc)

         (setf explore-function (make-neighborhood-criterion
                                 code1
                                 +exhaustive-search-strategy+
                                 spot-repeated-clients-strat))

         (bformat t "testing repeated clients")

         (setf repeated-clients (funcall
                                 explore-function
                                 s1
                                 t
                                 t))
    
         (format t "repeated-clients:~%~{~a~%~}~%"
                 (reverse repeated-clients))

         (format t "number of repeated instances: ~a~%"
                 (length repeated-clients))

         ))
     #+END_SRC


